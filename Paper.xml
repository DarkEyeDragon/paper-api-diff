<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Fri Oct 23 20:16:22 CEST 2020 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Paper"
  jdversion="1.1.0">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath C:\Users\Martin\Downloads\jdiff-1.1.0\jdiff-1.1.0\jdiff.jar;C:\Users\Martin\Downloads\jdiff-1.1.0\jdiff-1.1.0\xerces.jar -d C:\Users\Martin\Downloads\jdiff-1.1.0\jdiff-1.1.0\myreport -classpath E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-launcher.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-antlr.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-apache-bcel.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-apache-bsf.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-apache-log4j.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-apache-oro.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-apache-regexp.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-apache-resolver.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-apache-xalan2.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-commons-logging.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-commons-net.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-jai.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-javamail.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-jdepend.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-jmf.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-jsch.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-junit.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-junit4.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-netrexx.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-swing.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant-testutil.jar;E:\Programme\AndroidWorks\apache-ant-1.8.2\lib\ant.jar;C:\Program Files\Amazon Corretto\jdk1.8.0_212\lib\tools.jar -sourcepath D:\IntellijProjects\Paper\Paper-API\src\main\java -doclet jdiff.JDiff -docletpath C:\Users\Martin\Downloads\jdiff-1.1.0\jdiff-1.1.0\jdiff.jar;C:\Users\Martin\Downloads\jdiff-1.1.0\jdiff-1.1.0\xerces.jar -apiname Paper -baseURI http://www.w3.org -apidir C:\Users\Martin\Downloads\jdiff-1.1.0\jdiff-1.1.0\myreport -source 1.8 -->
<package name="co.aikar.timings">
  <!-- start class co.aikar.timings.FullServerTickHandler -->
  <class name="FullServerTickHandler" extends="co.aikar.timings.TimingHandler"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="startTiming" return="co.aikar.timings.Timing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopTiming"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class co.aikar.timings.FullServerTickHandler -->
  <!-- start class co.aikar.timings.NullTimingHandler -->
  <class name="NullTimingHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="co.aikar.timings.Timing"/>
    <constructor name="NullTimingHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startTiming" return="co.aikar.timings.Timing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopTiming"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startTimingIfSync" return="co.aikar.timings.Timing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopTimingIfSync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="abort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTimingHandler" return="co.aikar.timings.TimingHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NULL" type="co.aikar.timings.Timing"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class co.aikar.timings.NullTimingHandler -->
  <!-- start class co.aikar.timings.TimedEventExecutor -->
  <class name="TimedEventExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.EventExecutor"/>
    <constructor name="TimedEventExecutor" type="org.bukkit.plugin.EventExecutor, org.bukkit.plugin.Plugin, java.lang.reflect.Method, java.lang.Class&lt;? extends org.bukkit.event.Event&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps an event executor and associates a timing handler to it.

 @param executor Executor to wrap
 @param plugin Owning plugin
 @param method EventHandler method
 @param eventClass Owning class]]>
      </doc>
    </constructor>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="event" type="org.bukkit.event.Event"/>
      <exception name="EventException" type="org.bukkit.event.EventException"/>
    </method>
  </class>
  <!-- end class co.aikar.timings.TimedEventExecutor -->
  <!-- start interface co.aikar.timings.Timing -->
  <interface name="Timing"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <method name="startTiming" return="co.aikar.timings.Timing"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts timing the execution until {@link #stopTiming()} is called.

 @return Timing]]>
      </doc>
    </method>
    <method name="stopTiming"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>Stops timing and records the data. Propagates the data up to group handlers.</p>

 Will automatically be called when this Timing is used with try-with-resources]]>
      </doc>
    </method>
    <method name="startTimingIfSync" return="co.aikar.timings.Timing"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts timing the execution until {@link #stopTiming()} is called.

 But only if we are on the primary thread.

 @return Timing]]>
      </doc>
    </method>
    <method name="stopTimingIfSync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>Stops timing and records the data. Propagates the data up to group handlers.</p>

 <p>Will automatically be called when this Timing is used with try-with-resources</p>

 But only if we are on the primary thread.]]>
      </doc>
    </method>
    <method name="abort"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Doesn't do anything - Removed">
      <doc>
      <![CDATA[@deprecated Doesn't do anything - Removed]]>
      </doc>
    </method>
    <method name="getTimingHandler" return="co.aikar.timings.TimingHandler"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used internally to get the actual backing Handler in the case of delegated Handlers

 @return TimingHandler]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Provides an ability to time sections of code within the Minecraft Server]]>
    </doc>
  </interface>
  <!-- end interface co.aikar.timings.Timing -->
  <!-- start class co.aikar.timings.TimingHistory -->
  <class name="TimingHistory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="lastMinuteTime" type="long"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="timedTicks" type="long"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="playerTicks" type="long"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="entityTicks" type="long"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="tileEntityTicks" type="long"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="activatedEntityTicks" type="long"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class co.aikar.timings.TimingHistory -->
  <!-- start class co.aikar.timings.Timings -->
  <class name="Timings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="co.aikar.timings.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a Timing for a plugin corresponding to a name.

 @param plugin Plugin to own the Timing
 @param name   Name of Timing
 @return Handler]]>
      </doc>
    </method>
    <method name="of" return="co.aikar.timings.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <param name="groupHandler" type="co.aikar.timings.Timing"/>
      <doc>
      <![CDATA[<p>Returns a handler that has a groupHandler timer handler. Parent timers should not have their
 start/stop methods called directly, as the children will call it for you.</p>

 Parent Timers are used to group multiple subsections together and get a summary of them combined
 Parent Handler can not be changed after first call

 @param plugin       Plugin to own the Timing
 @param name         Name of Timing
 @param groupHandler Parent handler to mirror .start/stop calls to
 @return Timing Handler]]>
      </doc>
    </method>
    <method name="ofStart" return="co.aikar.timings.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a Timing object after starting it, useful for Java7 try-with-resources.

 try (Timing ignored = Timings.ofStart(plugin, someName)) {
 // timed section
 }

 @param plugin Plugin to own the Timing
 @param name   Name of Timing
 @return Timing Handler]]>
      </doc>
    </method>
    <method name="ofStart" return="co.aikar.timings.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <param name="groupHandler" type="co.aikar.timings.Timing"/>
      <doc>
      <![CDATA[Returns a Timing object after starting it, useful for Java7 try-with-resources.

 try (Timing ignored = Timings.ofStart(plugin, someName, groupHandler)) {
 // timed section
 }

 @param plugin       Plugin to own the Timing
 @param name         Name of Timing
 @param groupHandler Parent handler to mirror .start/stop calls to
 @return Timing Handler]]>
      </doc>
    </method>
    <method name="isTimingsEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the Spigot Timings system is enabled

 @return Enabled or not]]>
      </doc>
    </method>
    <method name="setTimingsEnabled"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <doc>
      <![CDATA[<p>Sets whether or not the Spigot Timings system should be enabled</p>

 Calling this will reset timing data.

 @param enabled Should timings be reported]]>
      </doc>
    </method>
    <method name="isVerboseTimingsEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>Sets whether or not the Timings should monitor at Verbose level.</p>

 <p>When Verbose is disabled, high-frequency timings will not be available.</p>

 @return Enabled or not]]>
      </doc>
    </method>
    <method name="setVerboseTimingsEnabled"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <doc>
      <![CDATA[<p>Sets whether or not the Timings should monitor at Verbose level.</p>

 When Verbose is disabled, high-frequency timings will not be available.
 Calling this will reset timing data.

 @param enabled Should high-frequency timings be reported]]>
      </doc>
    </method>
    <method name="getHistoryInterval" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>Gets the interval between Timing History report generation.</p>

 Defaults to 5 minutes (6000 ticks)

 @return Interval in ticks]]>
      </doc>
    </method>
    <method name="setHistoryInterval"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interval" type="int"/>
      <doc>
      <![CDATA[<p>Sets the interval between Timing History report generations.</p>

 <p>Defaults to 5 minutes (6000 ticks)</p>

 This will recheck your history length, so lowering this value will lower your
 history length if you need more than 60 history windows.

 @param interval Interval in ticks]]>
      </doc>
    </method>
    <method name="getHistoryLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets how long in ticks Timings history is kept for the server.

 Defaults to 1 hour (72000 ticks)

 @return Duration in Ticks]]>
      </doc>
    </method>
    <method name="setHistoryLength"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Sets how long Timing History reports are kept for the server.

 Defaults to 1 hours(72000 ticks)

 This value is capped at a maximum of getHistoryInterval() * MAX_HISTORY_FRAMES (12)

 Will not reset Timing Data but may truncate old history if the new length is less than old length.

 @param length Duration in ticks]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets all Timing Data]]>
      </doc>
    </method>
    <method name="generateReport"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <doc>
      <![CDATA[Generates a report and sends it to the specified command sender.

 If sender is null, ConsoleCommandSender will be used.
 @param sender The sender to send to, or null to use the ConsoleCommandSender]]>
      </doc>
    </method>
    <method name="generateReport"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="co.aikar.timings.TimingsReportListener"/>
      <doc>
      <![CDATA[Generates a report and sends it to the specified listener.
 Use with {@link org.bukkit.command.BufferedCommandSender} to get full response when done!
 @param sender The listener to send responses too.]]>
      </doc>
    </method>
    <field name="NULL_HANDLER" type="co.aikar.timings.Timing"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class co.aikar.timings.Timings -->
  <!-- start class co.aikar.timings.TimingsCommand -->
  <class name="TimingsCommand" extends="org.bukkit.command.defaults.BukkitCommand"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimingsCommand" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="currentAlias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
  </class>
  <!-- end class co.aikar.timings.TimingsCommand -->
  <!-- start class co.aikar.timings.TimingsManager -->
  <class name="TimingsManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getCommandTiming" return="co.aikar.timings.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pluginName" type="java.lang.String"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <doc>
      <![CDATA[<p>Due to access restrictions, we need a helper method to get a Command TimingHandler with String group</p>

 Plugins should never call this

 @param pluginName Plugin this command is associated with
 @param command    Command to get timings for
 @return TimingHandler]]>
      </doc>
    </method>
    <method name="getPluginByClassloader" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Looks up the class loader for the specified class, and if it is a PluginClassLoader, return the
 Plugin that created this class.

 @param clazz Class to check
 @return Plugin if created by a plugin]]>
      </doc>
    </method>
    <field name="FULL_SERVER_TICK" type="co.aikar.timings.FullServerTickHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TIMINGS_TICK" type="co.aikar.timings.TimingHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PLUGIN_GROUP_HANDLER" type="co.aikar.timings.Timing"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="hiddenConfigs" type="java.util.List&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="privacy" type="boolean"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class co.aikar.timings.TimingsManager -->
  <!-- start class co.aikar.timings.TimingsReportListener -->
  <class name="TimingsReportListener" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.MessageCommandSender"/>
    <constructor name="TimingsReportListener" type="org.bukkit.command.CommandSender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimingsReportListener" type="org.bukkit.command.CommandSender, java.lang.Runnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimingsReportListener" type="java.util.List&lt;org.bukkit.command.CommandSender&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimingsReportListener" type="java.util.List&lt;org.bukkit.command.CommandSender&gt;, java.lang.Runnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTimingsURL" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
    </method>
    <method name="addConsoleIfNeeded"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class co.aikar.timings.TimingsReportListener -->
</package>
<package name="co.aikar.util">
  <!-- start class co.aikar.util.Counter -->
  <class name="Counter" extends="&lt;any&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Counter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="decrement" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="T"/>
    </method>
    <method name="increment" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="T"/>
    </method>
    <method name="decrement" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="T"/>
      <param name="amount" type="long"/>
    </method>
    <method name="increment" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="T"/>
      <param name="amount" type="long"/>
    </method>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="T"/>
    </method>
    <method name="delegate" return="java.util.Map&lt;T, java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class co.aikar.util.Counter -->
  <!-- start class co.aikar.util.JSONUtil -->
  <class name="JSONUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="pair" return="co.aikar.util.JSONUtil.JSONPair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Creates a key/value "JSONPair" object

 @param key Key to use
 @param obj Value to use
 @return JSONPair]]>
      </doc>
    </method>
    <method name="pair" return="co.aikar.util.JSONUtil.JSONPair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="long"/>
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="createObject" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="co.aikar.util.JSONUtil.JSONPair[]"/>
      <doc>
      <![CDATA[Creates a new JSON object from multiple JSONPair key/value pairs

 @param data JSONPairs
 @return Map]]>
      </doc>
    </method>
    <method name="appendObjectData" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="java.util.Map"/>
      <param name="data" type="co.aikar.util.JSONUtil.JSONPair[]"/>
      <doc>
      <![CDATA[This appends multiple key/value Obj pairs into a JSON Object

 @param parent Map to be appended to
 @param data Data to append
 @return Map]]>
      </doc>
    </method>
    <method name="toArray" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[This builds a JSON array from a set of data

 @param data Data to build JSON array from
 @return List]]>
      </doc>
    </method>
    <method name="toArrayMapper" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="E[]"/>
      <param name="mapper" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[These help build a single JSON array using a mapper function

 @param collection Collection to apply to
 @param mapper Mapper to apply
 @param <E> Element Type
 @return List]]>
      </doc>
    </method>
    <method name="toArrayMapper" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="mapper" type="&lt;any&gt;"/>
    </method>
    <method name="toObjectMapper" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="E[]"/>
      <param name="mapper" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[These help build a single JSON Object from a collection, using a mapper function

 @param collection Collection to apply to
 @param mapper Mapper to apply
 @param <E> Element Type
 @return Map]]>
      </doc>
    </method>
    <method name="toObjectMapper" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="mapper" type="&lt;any&gt;"/>
    </method>
    <doc>
    <![CDATA[Provides Utility methods that assist with generating JSON Objects]]>
    </doc>
  </class>
  <!-- end class co.aikar.util.JSONUtil -->
  <!-- start class co.aikar.util.JSONUtil.JSONPair -->
  <class name="JSONUtil.JSONPair" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Simply stores a key and a value, used internally by many methods below.]]>
    </doc>
  </class>
  <!-- end class co.aikar.util.JSONUtil.JSONPair -->
  <!-- start class co.aikar.util.LoadingIntMap -->
  <class name="LoadingIntMap" extends="&lt;any&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LoadingIntMap" type="&lt;any&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LoadingIntMap" type="int, &lt;any&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LoadingIntMap" type="int, float, &lt;any&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="int"/>
    </method>
    <doc>
    <![CDATA[Allows you to pass a Loader function that when a key is accessed that doesn't exist,
 automatically loads the entry into the map by calling the loader Function.

 .get() Will only return null if the Loader can return null.

 You may pass any backing Map to use.

 This class is not thread safe and should be wrapped with Collections.synchronizedMap on the OUTSIDE of the LoadingMap if needed.

 Do not wrap the backing map with Collections.synchronizedMap.

 @param <V> Value]]>
    </doc>
  </class>
  <!-- end class co.aikar.util.LoadingIntMap -->
  <!-- start class co.aikar.util.LoadingIntMap.Feeder -->
  <class name="LoadingIntMap.Feeder" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Feeder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
    </method>
    <method name="apply" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Due to java stuff, you will need to cast it to (Function) for some cases

 @param <T> Type]]>
    </doc>
  </class>
  <!-- end class co.aikar.util.LoadingIntMap.Feeder -->
  <!-- start class co.aikar.util.LoadingMap -->
  <class name="LoadingMap" extends="java.util.AbstractMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LoadingMap" type="java.util.Map&lt;K, V&gt;, java.util.function.Function&lt;K, V&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initializes an auto loading map using specified loader and backing map
 @param backingMap Map to wrap
 @param loader Loader]]>
      </doc>
    </constructor>
    <method name="of" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map&lt;K, V&gt;"/>
      <param name="loader" type="java.util.function.Function&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Creates a new LoadingMap with the specified map and loader

 @param backingMap Actual map being used.
 @param loader Loader to use
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map]]>
      </doc>
    </method>
    <method name="newAutoMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map&lt;K, V&gt;"/>
      <param name="keyClass" type="java.lang.Class&lt;? extends K&gt;"/>
      <param name="valueClass" type="java.lang.Class&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a LoadingMap with an auto instantiating loader.

 Will auto construct class of of Value when not found

 Since this uses Reflection, It is more effecient to define your own static loader
 than using this helper, but if performance is not critical, this is easier.

 @param backingMap Actual map being used.
 @param keyClass Class used for the K generic
 @param valueClass Class used for the V generic
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map that auto instantiates on .get()]]>
      </doc>
    </method>
    <method name="newAutoMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map&lt;K, V&gt;"/>
      <param name="valueClass" type="java.lang.Class&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a LoadingMap with an auto instantiating loader.

 Will auto construct class of of Value when not found

 Since this uses Reflection, It is more effecient to define your own static loader
 than using this helper, but if performance is not critical, this is easier.

 @param backingMap Actual map being used.
 @param valueClass Class used for the V generic
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map that auto instantiates on .get()]]>
      </doc>
    </method>
    <method name="newHashAutoMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyClass" type="java.lang.Class&lt;? extends K&gt;"/>
      <param name="valueClass" type="java.lang.Class&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[@see #newAutoMap

 new Auto initializing map using a HashMap.

 @param keyClass Class used for the K generic
 @param valueClass Class used for the V generic
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map that auto instantiates on .get()]]>
      </doc>
    </method>
    <method name="newHashAutoMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueClass" type="java.lang.Class&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[@see #newAutoMap

 new Auto initializing map using a HashMap.

 @param valueClass Class used for the V generic
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map that auto instantiates on .get()]]>
      </doc>
    </method>
    <method name="newHashAutoMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyClass" type="java.lang.Class&lt;? extends K&gt;"/>
      <param name="valueClass" type="java.lang.Class&lt;? extends V&gt;"/>
      <param name="initialCapacity" type="int"/>
      <param name="loadFactor" type="float"/>
      <doc>
      <![CDATA[@see #newAutoMap

 new Auto initializing map using a HashMap.

 @param keyClass Class used for the K generic
 @param valueClass Class used for the V generic
 @param initialCapacity Initial capacity to use
 @param loadFactor Load factor to use
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map that auto instantiates on .get()]]>
      </doc>
    </method>
    <method name="newHashAutoMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueClass" type="java.lang.Class&lt;? extends V&gt;"/>
      <param name="initialCapacity" type="int"/>
      <param name="loadFactor" type="float"/>
      <doc>
      <![CDATA[@see #newAutoMap

 new Auto initializing map using a HashMap.

 @param valueClass Class used for the V generic
 @param initialCapacity Initial capacity to use
 @param loadFactor Load factor to use
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return  Map that auto instantiates on .get()]]>
      </doc>
    </method>
    <method name="newHashMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="java.util.function.Function&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Initializes an auto loading map using a HashMap

 @param loader Loader to use
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map]]>
      </doc>
    </method>
    <method name="newHashMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="java.util.function.Function&lt;K, V&gt;"/>
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Initializes an auto loading map using a HashMap

 @param loader Loader to use
 @param initialCapacity Initial capacity to use
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map]]>
      </doc>
    </method>
    <method name="newHashMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="java.util.function.Function&lt;K, V&gt;"/>
      <param name="initialCapacity" type="int"/>
      <param name="loadFactor" type="float"/>
      <doc>
      <![CDATA[Initializes an auto loading map using a HashMap

 @param loader Loader to use
 @param initialCapacity Initial capacity to use
 @param loadFactor Load factor to use
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map]]>
      </doc>
    </method>
    <method name="newIdentityHashMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="java.util.function.Function&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Initializes an auto loading map using an Identity HashMap

 @param loader Loader to use
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map]]>
      </doc>
    </method>
    <method name="newIdentityHashMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="java.util.function.Function&lt;K, V&gt;"/>
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Initializes an auto loading map using an Identity HashMap

 @param loader Loader to use
 @param initialCapacity Initial capacity to use
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="co.aikar.util.LoadingMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Allows you to pass a Loader function that when a key is accessed that doesn't exists,
 automatically loads the entry into the map by calling the loader Function.

 .get() Will only return null if the Loader can return null.

 You may pass any backing Map to use.

 This class is not thread safe and should be wrapped with Collections.synchronizedMap on the OUTSIDE of the LoadingMap if needed.

 Do not wrap the backing map with Collections.synchronizedMap.

 @param <K> Key
 @param <V> Value]]>
    </doc>
  </class>
  <!-- end class co.aikar.util.LoadingMap -->
  <!-- start class co.aikar.util.LoadingMap.Feeder -->
  <class name="LoadingMap.Feeder" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Function&lt;T, T&gt;"/>
    <constructor name="Feeder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
    </method>
    <method name="apply" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Due to java stuff, you will need to cast it to (Function) for some cases

 @param <T> Type]]>
    </doc>
  </class>
  <!-- end class co.aikar.util.LoadingMap.Feeder -->
  <!-- start class co.aikar.util.MRUMapCache -->
  <class name="MRUMapCache" extends="java.util.AbstractMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MRUMapCache" type="java.util.Map&lt;K, V&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="of" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Wraps the specified map with a most recently used cache

 @param map Map to be wrapped
 @param <K> Key Type of the Map
 @param <V> Value Type of the Map
 @return Map]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implements a Most Recently Used cache in front of a backing map, to quickly access the last accessed result.

 @param <K> Key Type of the Map
 @param <V> Value Type of the Map]]>
    </doc>
  </class>
  <!-- end class co.aikar.util.MRUMapCache -->
</package>
<package name="com.destroystokyo.paper">
  <!-- start class com.destroystokyo.paper.ClientOption -->
  <class name="ClientOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getType" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="SKIN_PARTS" type="com.destroystokyo.paper.ClientOption&lt;com.destroystokyo.paper.SkinParts&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CHAT_COLORS_ENABLED" type="com.destroystokyo.paper.ClientOption&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CHAT_VISIBILITY" type="com.destroystokyo.paper.ClientOption&lt;com.destroystokyo.paper.ClientOption.ChatVisibility&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOCALE" type="com.destroystokyo.paper.ClientOption&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAIN_HAND" type="com.destroystokyo.paper.ClientOption&lt;org.bukkit.inventory.MainHand&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VIEW_DISTANCE" type="com.destroystokyo.paper.ClientOption&lt;java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.destroystokyo.paper.ClientOption -->
  <!-- start class com.destroystokyo.paper.ClientOption.ChatVisibility -->
  <class name="ClientOption.ChatVisibility" extends="java.lang.Enum&lt;com.destroystokyo.paper.ClientOption.ChatVisibility&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.ClientOption.ChatVisibility[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.ClientOption.ChatVisibility"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.ClientOption.ChatVisibility -->
  <!-- start class com.destroystokyo.paper.HeightmapType -->
  <class name="HeightmapType" extends="java.lang.Enum&lt;com.destroystokyo.paper.HeightmapType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="Upstream has added their own API for using the game heightmaps. See {@link org.bukkit.HeightMap} and the
 non-deprecated getHighestBlock methods on World such as {@link org.bukkit.World#getHighestBlockAt(Location, HeightMap)}.">
    <method name="values" return="com.destroystokyo.paper.HeightmapType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.HeightmapType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Enumeration of different heightmap types maintained by the server. Generally using these maps is much faster
 than using an iterative search for a block in a given x, z coordinate.

 @deprecated Upstream has added their own API for using the game heightmaps. See {@link org.bukkit.HeightMap} and the
 non-deprecated getHighestBlock methods on World such as {@link org.bukkit.World#getHighestBlockAt(Location, HeightMap)}.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.HeightmapType -->
  <!-- start class com.destroystokyo.paper.MaterialSetTag -->
  <class name="MaterialSetTag" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Tag&lt;org.bukkit.Material&gt;"/>
    <constructor name="MaterialSetTag" type="java.util.function.Predicate&lt;org.bukkit.Material&gt;"
      static="false" final="false" visibility="public"
      deprecated="Use NamespacedKey version of constructor">
      <doc>
      <![CDATA[@deprecated Use NamespacedKey version of constructor]]>
      </doc>
    </constructor>
    <constructor name="MaterialSetTag" type="java.util.Collection&lt;org.bukkit.Material&gt;"
      static="false" final="false" visibility="public"
      deprecated="Use NamespacedKey version of constructor">
      <doc>
      <![CDATA[@deprecated Use NamespacedKey version of constructor]]>
      </doc>
    </constructor>
    <constructor name="MaterialSetTag" type="org.bukkit.Material[]"
      static="false" final="false" visibility="public"
      deprecated="Use NamespacedKey version of constructor">
      <doc>
      <![CDATA[@deprecated Use NamespacedKey version of constructor]]>
      </doc>
    </constructor>
    <constructor name="MaterialSetTag" type="org.bukkit.NamespacedKey, java.util.function.Predicate&lt;org.bukkit.Material&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MaterialSetTag" type="org.bukkit.NamespacedKey, org.bukkit.Material[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MaterialSetTag" type="org.bukkit.NamespacedKey, java.util.Collection&lt;org.bukkit.Material&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tags" type="org.bukkit.Tag[]"/>
    </method>
    <method name="add" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tags" type="com.destroystokyo.paper.MaterialSetTag[]"/>
    </method>
    <method name="add" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material[]"/>
    </method>
    <method name="add" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="materials" type="java.util.Collection&lt;org.bukkit.Material&gt;"/>
    </method>
    <method name="contains" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="with" type="java.lang.String"/>
    </method>
    <method name="endsWith" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="with" type="java.lang.String"/>
    </method>
    <method name="startsWith" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="with" type="java.lang.String"/>
    </method>
    <method name="add" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="java.util.function.Predicate&lt;org.bukkit.Material&gt;"/>
    </method>
    <method name="not" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tags" type="com.destroystokyo.paper.MaterialSetTag"/>
    </method>
    <method name="not" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material[]"/>
    </method>
    <method name="not" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="materials" type="java.util.Collection&lt;org.bukkit.Material&gt;"/>
    </method>
    <method name="not" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="java.util.function.Predicate&lt;org.bukkit.Material&gt;"/>
    </method>
    <method name="notEndsWith" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="with" type="java.lang.String"/>
    </method>
    <method name="notStartsWith" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="with" type="java.lang.String"/>
    </method>
    <method name="getValues" return="java.util.Set&lt;org.bukkit.Material&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTagged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.data.BlockData"/>
    </method>
    <method name="isTagged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.BlockState"/>
    </method>
    <method name="isTagged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
    </method>
    <method name="isTagged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="isTagged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
    </method>
    <method name="ensureSize" return="com.destroystokyo.paper.MaterialSetTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <param name="size" type="int"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.MaterialSetTag -->
  <!-- start class com.destroystokyo.paper.MaterialTags -->
  <class name="MaterialTags" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MaterialTags"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="ARROWS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEDS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all colors of beds.]]>
      </doc>
    </field>
    <field name="BUCKETS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all bucket items.]]>
      </doc>
    </field>
    <field name="COALS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers coal and charcoal.]]>
      </doc>
    </field>
    <field name="COBBLESTONE_WALLS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers both cobblestone wall variants.]]>
      </doc>
    </field>
    <field name="COBBLESTONES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers both cobblestone and mossy Cobblestone.]]>
      </doc>
    </field>
    <field name="CONCRETES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all colors of concrete.]]>
      </doc>
    </field>
    <field name="CONCRETE_POWDER" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all colors of concrete powder.]]>
      </doc>
    </field>
    <field name="COOKED_FISH" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the two types of cooked fish.]]>
      </doc>
    </field>
    <field name="DYES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all dyes.]]>
      </doc>
    </field>
    <field name="FENCE_GATES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all variants of gates.]]>
      </doc>
    </field>
    <field name="FENCES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all variants of fences.]]>
      </doc>
    </field>
    <field name="FISH_BUCKETS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all variants of fish buckets.]]>
      </doc>
    </field>
    <field name="GLASS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the non-colored glass and 16 stained glass (not panes).]]>
      </doc>
    </field>
    <field name="GLASS_PANES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the non-colored glass panes and stained glass panes (panes only).]]>
      </doc>
    </field>
    <field name="GLAZED_TERRACOTTA" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all glazed terracotta blocks.]]>
      </doc>
    </field>
    <field name="STAINED_TERRACOTTA" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the colors of stained terracotta.]]>
      </doc>
    </field>
    <field name="TERRACOTTA" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers terracotta along with the stained variants.]]>
      </doc>
    </field>
    <field name="GOLDEN_APPLES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers both golden apples.]]>
      </doc>
    </field>
    <field name="HORSE_ARMORS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of horse armor.]]>
      </doc>
    </field>
    <field name="INFESTED_BLOCKS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of infested blocks.]]>
      </doc>
    </field>
    <field name="MUSHROOM_BLOCKS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of mushroom blocks.]]>
      </doc>
    </field>
    <field name="MUSHROOMS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all mushrooms.]]>
      </doc>
    </field>
    <field name="MUSIC_DISCS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all music disc items.]]>
      </doc>
    </field>
    <field name="ORES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all ores.]]>
      </doc>
    </field>
    <field name="PISTONS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all piston typed items and blocks including the piston head and moving piston.]]>
      </doc>
    </field>
    <field name="POTATOES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all potato items.]]>
      </doc>
    </field>
    <field name="PRESSURE_PLATES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all wooden pressure plates and the weighted pressure plates and the stone pressure plate.]]>
      </doc>
    </field>
    <field name="PRISMARINE" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of prismarine blocks.]]>
      </doc>
    </field>
    <field name="PRISMARINE_SLABS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of prismarine slabs.]]>
      </doc>
    </field>
    <field name="PRISMARINE_STAIRS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of prismarine stairs.]]>
      </doc>
    </field>
    <field name="PUMPKINS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of pumpkins.]]>
      </doc>
    </field>
    <field name="QUARTZ_BLOCKS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of quartz blocks.]]>
      </doc>
    </field>
    <field name="RAW_FISH" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all uncooked fish items.]]>
      </doc>
    </field>
    <field name="RED_SANDSTONES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of red sandstone blocks.]]>
      </doc>
    </field>
    <field name="SANDSTONES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of sandstone blocks.]]>
      </doc>
    </field>
    <field name="SPONGES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers sponge and wet sponge.]]>
      </doc>
    </field>
    <field name="SHULKER_BOXES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the non-colored and colored shulker boxes.]]>
      </doc>
    </field>
    <field name="SKULLS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers zombie, creeper, skeleton, dragon, and player heads.]]>
      </doc>
    </field>
    <field name="SPAWN_EGGS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all spawn egg items.]]>
      </doc>
    </field>
    <field name="STAINED_GLASS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all colors of stained glass.]]>
      </doc>
    </field>
    <field name="STAINED_GLASS_PANES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all colors of stained glass panes.]]>
      </doc>
    </field>
    <field name="TRAPDOORS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all variants of trapdoors.]]>
      </doc>
    </field>
    <field name="WOODEN_FENCES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all wood variants of fences.]]>
      </doc>
    </field>
    <field name="WOODEN_TRAPDOORS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers all wood variants of trapdoors.]]>
      </doc>
    </field>
    <field name="WOODEN_GATES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the wood variants of gates.]]>
      </doc>
    </field>
    <field name="PURPUR" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of purpur.]]>
      </doc>
    </field>
    <field name="SIGNS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of signs.]]>
      </doc>
    </field>
    <field name="TORCH" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of a regular torch.]]>
      </doc>
    </field>
    <field name="REDSTONE_TORCH" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of a redstone torch.]]>
      </doc>
    </field>
    <field name="SOUL_TORCH" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of a soul torch.]]>
      </doc>
    </field>
    <field name="TORCHES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of torches.]]>
      </doc>
    </field>
    <field name="LANTERNS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of lanterns.]]>
      </doc>
    </field>
    <field name="RAILS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of rails.]]>
      </doc>
    </field>
    <field name="SWORDS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of swords.]]>
      </doc>
    </field>
    <field name="SHOVELS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of shovels.]]>
      </doc>
    </field>
    <field name="PICKAXES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of pickaxes.]]>
      </doc>
    </field>
    <field name="AXES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of axes.]]>
      </doc>
    </field>
    <field name="HOES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of hoes.]]>
      </doc>
    </field>
    <field name="HELMETS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of helmets.]]>
      </doc>
    </field>
    <field name="HEAD_EQUIPPABLE" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of items that can be equipped in the helmet slot.]]>
      </doc>
    </field>
    <field name="CHESTPLATES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of chestplate.]]>
      </doc>
    </field>
    <field name="CHEST_EQUIPPABLE" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of items that can be equipped in the chest slot.]]>
      </doc>
    </field>
    <field name="LEGGINGS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of leggings.]]>
      </doc>
    </field>
    <field name="BOOTS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of boots.]]>
      </doc>
    </field>
    <field name="BOWS" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of bows.]]>
      </doc>
    </field>
    <field name="THROWABLE_PROJECTILES" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Covers the variants of player-throwable projectiles (not requiring a bow or any other "assistance").]]>
      </doc>
    </field>
    <field name="COLORABLE" type="com.destroystokyo.paper.MaterialSetTag"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a collection tags to identify materials that share common properties.
 Will map to minecraft for missing tags, as well as custom ones that may be useful.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.MaterialTags -->
  <!-- start interface com.destroystokyo.paper.Namespaced -->
  <interface name="Namespaced"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getNamespace" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the namespace this resource is a part of
 <p>
 This is contractually obligated to only contain lowercase alphanumeric characters,
 periods, underscores, and hyphens.

 @return resource namespace]]>
      </doc>
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key corresponding to this resource
 <p>
 This is contractually obligated to only contain lowercase alphanumeric characters,
 periods, underscores, hyphens, and forward slashes.

 @return resource key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a namespaced resource, see {@link org.bukkit.NamespacedKey} for single elements
 or {@link com.destroystokyo.paper.NamespacedTag} for a collection of elements

 Namespaces may only contain lowercase alphanumeric characters, periods,
 underscores, and hyphens.
 <p>
 Keys may only contain lowercase alphanumeric characters, periods,
 underscores, hyphens, and forward slashes.
 <p>
 You should not be implementing this interface yourself, use {@link org.bukkit.NamespacedKey}
 or {@link com.destroystokyo.paper.NamespacedTag} as needed instead.]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.Namespaced -->
  <!-- start class com.destroystokyo.paper.NamespacedTag -->
  <class name="NamespacedTag" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.destroystokyo.paper.Namespaced"/>
    <constructor name="NamespacedTag" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="should never be used by plugins, for internal use only!!">
      <doc>
      <![CDATA[Create a key in a specific namespace.

 @param namespace String representing a grouping of keys
 @param key Name for this specific key
 @deprecated should never be used by plugins, for internal use only!!]]>
      </doc>
    </constructor>
    <constructor name="NamespacedTag" type="org.bukkit.plugin.Plugin, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a key in the plugin's namespace.
 <p>
 Namespaces may only contain lowercase alphanumeric characters, periods,
 underscores, and hyphens.
 <p>
 Keys may only contain lowercase alphanumeric characters, periods,
 underscores, hyphens, and forward slashes.

 @param plugin the plugin to use for the namespace
 @param key the key to create]]>
      </doc>
    </constructor>
    <method name="getNamespace" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="randomKey" return="com.destroystokyo.paper.NamespacedTag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="should never be used by plugins, for internal use only!!">
      <doc>
      <![CDATA[Return a new random key in the {@link #BUKKIT} namespace.

 @return new key
 @deprecated should never be used by plugins, for internal use only!!]]>
      </doc>
    </method>
    <method name="minecraft" return="com.destroystokyo.paper.NamespacedTag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a key in the Minecraft namespace.

 @param key the key to use
 @return new key in the Minecraft namespace]]>
      </doc>
    </method>
    <field name="MINECRAFT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The namespace representing all inbuilt keys.]]>
      </doc>
    </field>
    <field name="BUKKIT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The namespace representing all keys generated by Bukkit for backwards
 compatibility measures.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents a String based key pertaining to a tagged entry. Consists of two components - a namespace
 and a key.
 <p>
 Namespaces may only contain lowercase alphanumeric characters, periods,
 underscores, and hyphens.
 <p>
 Keys may only contain lowercase alphanumeric characters, periods,
 underscores, hyphens, and forward slashes.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.NamespacedTag -->
  <!-- start class com.destroystokyo.paper.ParticleBuilder -->
  <class name="ParticleBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ParticleBuilder" type="org.bukkit.Particle"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="spawn" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sends the particle to all receiving players (or all). This method is safe to use
 Asynchronously

 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="particle" return="org.bukkit.Particle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The particle going to be sent]]>
      </doc>
    </method>
    <method name="particle" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <doc>
      <![CDATA[Changes what particle will be sent

 @param particle The particle
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="java.util.List&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return List of players who will receive the particle, or null for all in world]]>
      </doc>
    </method>
    <method name="hasReceivers" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Example use:

 builder.receivers(16); if (builder.hasReceivers()) { sendParticleAsync(builder); }

 @return If this particle is going to be sent to someone]]>
      </doc>
    </method>
    <method name="allPlayers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sends this particle to all players in the world. This is rather silly and you should likely not
 be doing this.

 Just be a logical person and use receivers by radius or collection.

 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="receivers" type="java.util.List&lt;org.bukkit.entity.Player&gt;"/>
      <doc>
      <![CDATA[@param receivers List of players to receive this particle, or null for all players in the
 world
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="receivers" type="java.util.Collection&lt;org.bukkit.entity.Player&gt;"/>
      <doc>
      <![CDATA[@param receivers List of players to receive this particle, or null for all players in the
 world
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="receivers" type="org.bukkit.entity.Player[]"/>
      <doc>
      <![CDATA[@param receivers List of players to be receive this particle, or null for all players in the
 world
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="int"/>
      <doc>
      <![CDATA[Selects all players within a cuboid selection around the particle location, within the
 specified bounding box. If you want a more spherical check, see {@link #receivers(int,
 boolean)}

 @param radius amount to add on all axis
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="int"/>
      <param name="byDistance" type="boolean"/>
      <doc>
      <![CDATA[Selects all players within the specified radius around the particle location. If byDistance is
 false, behavior uses cuboid selection the same as {@link #receivers(int, int)} If byDistance is
 true, radius is tested by distance in a spherical shape

 @param radius amount to add on each axis
 @param byDistance true to use a spherical radius, false to use a cuboid
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xzRadius" type="int"/>
      <param name="yRadius" type="int"/>
      <doc>
      <![CDATA[Selects all players within a cuboid selection around the particle location, within the
 specified bounding box. Allows specifying a different Y size than X and Z If you want a more
 cylinder check, see {@link #receivers(int, int, boolean)} If you want a more spherical check,
 see {@link #receivers(int, boolean)}

 @param xzRadius amount to add on the x/z axis
 @param yRadius amount to add on the y axis
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xzRadius" type="int"/>
      <param name="yRadius" type="int"/>
      <param name="byDistance" type="boolean"/>
      <doc>
      <![CDATA[Selects all players within the specified radius around the particle location. If byDistance is
 false, behavior uses cuboid selection the same as {@link #receivers(int, int)} If byDistance is
 true, radius is tested by distance on the y plane and on the x/z plane, in a cylinder shape.

 @param xzRadius amount to add on the x/z axis
 @param yRadius amount to add on the y axis
 @param byDistance true to use a cylinder shape, false to use cuboid
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="receivers" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xRadius" type="int"/>
      <param name="yRadius" type="int"/>
      <param name="zRadius" type="int"/>
      <doc>
      <![CDATA[Selects all players within a cuboid selection around the particle location, within the
 specified bounding box. If you want a more cylinder check, see {@link #receivers(int, int,
 boolean)} If you want a more spherical check, see {@link #receivers(int, boolean)}

 @param xRadius amount to add on the x axis
 @param yRadius amount to add on the y axis
 @param zRadius amount to add on the z axis
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="source" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The player considered the source of this particle (for Visibility concerns), or null]]>
      </doc>
    </method>
    <method name="source" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Sets the source of this particle for visibility concerns (Vanish API)

 @param source The player who is considered the source
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="location" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Location of where the particle will spawn]]>
      </doc>
    </method>
    <method name="location" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the location of where to spawn the particle

 @param location The location of the particle
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="location" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Sets the location of where to spawn the particle

 @param world World to spawn particle in
 @param x X location
 @param y Y location
 @param z Z location
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Number of particles to spawn]]>
      </doc>
    </method>
    <method name="count" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Sets the number of particles to spawn

 @param count Number of particles
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="offsetX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Particle offset X. Varies by particle on how this is used

 @return Particle offset X.]]>
      </doc>
    </method>
    <method name="offsetY" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Particle offset Y. Varies by particle on how this is used

 @return Particle offset Y.]]>
      </doc>
    </method>
    <method name="offsetZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Particle offset Z. Varies by particle on how this is used

 @return Particle offset Z.]]>
      </doc>
    </method>
    <method name="offset" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <doc>
      <![CDATA[Sets the particle offset. Varies by particle on how this is used

 @param offsetX Particle offset X
 @param offsetY Particle offset Y
 @param offsetZ Particle offset Z
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="extra" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Particle extra data. Varies by particle on how this is used

 @return the extra particle data]]>
      </doc>
    </method>
    <method name="extra" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extra" type="double"/>
      <doc>
      <![CDATA[Sets the particle extra data. Varies by particle on how this is used

 @param extra the extra particle data
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="data" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the particle custom data. Varies by particle on how this is used

 @param <T> The Particle data type
 @return the ParticleData for this particle]]>
      </doc>
    </method>
    <method name="data" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Sets the particle custom data. Varies by particle on how this is used

 @param data The new particle data
 @param <T> The Particle data type
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="force" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the particle is forcefully shown to the player. If forced, the particle will show
 faraway, as far as the player's view distance allows. If false, the particle will show
 according to the client's particle settings.

 @param force true to force, false for normal
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="color" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Sets the particle Color. Only valid for REDSTONE.

 @param color the new particle color
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="color" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <param name="size" type="float"/>
      <doc>
      <![CDATA[Sets the particle Color and size. Only valid for REDSTONE.

 @param color the new particle color
 @param size the size of the particle
 @return a reference to this object.]]>
      </doc>
    </method>
    <method name="color" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="int"/>
      <param name="g" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Sets the particle Color.
 Only valid for REDSTONE.
 @param r red color component
 @param g green color component
 @param b blue color component
 @return a reference to this object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helps prepare a particle to be sent to players.

 Usage of the builder is preferred over the super long {@link World#spawnParticle(Particle, Location, int, double, double, double, double, Object)} API]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.ParticleBuilder -->
  <!-- start interface com.destroystokyo.paper.SkinParts -->
  <interface name="SkinParts"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hasCapeEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasJacketEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasLeftSleeveEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasRightSleeveEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasLeftPantsEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasRightPantsEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasHatsEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRaw" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface com.destroystokyo.paper.SkinParts -->
  <!-- start class com.destroystokyo.paper.Title -->
  <class name="Title" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Title" type="BaseComponent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a title with the default time values and no subtitle.

 <p>Times use default values.</p>

 @param title the main text of the title
 @throws NullPointerException if the title is null]]>
      </doc>
    </constructor>
    <constructor name="Title" type="BaseComponent[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a title with the default time values and no subtitle.

 <p>Times use default values.</p>

 @param title the main text of the title
 @throws NullPointerException if the title is null]]>
      </doc>
    </constructor>
    <constructor name="Title" type="BaseComponent, BaseComponent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a title with the default time values.

 <p>Times use default values.</p>

 @param title    the main text of the title
 @param subtitle the secondary text of the title]]>
      </doc>
    </constructor>
    <constructor name="Title" type="BaseComponent[], BaseComponent[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a title with the default time values.

 <p>Times use default values.</p>

 @param title    the main text of the title
 @param subtitle the secondary text of the title]]>
      </doc>
    </constructor>
    <constructor name="Title" type="BaseComponent, BaseComponent, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new title.

 @param title    the main text of the title
 @param subtitle the secondary text of the title
 @param fadeIn   the number of ticks for the title to fade in
 @param stay     the number of ticks for the title to stay on screen
 @param fadeOut  the number of ticks for the title to fade out
 @throws IllegalArgumentException if any of the times are negative]]>
      </doc>
    </constructor>
    <constructor name="Title" type="BaseComponent[], BaseComponent[], int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new title.

 @param title    the main text of the title
 @param subtitle the secondary text of the title
 @param fadeIn   the number of ticks for the title to fade in
 @param stay     the number of ticks for the title to stay on screen
 @param fadeOut  the number of ticks for the title to fade out
 @throws IllegalArgumentException if any of the times are negative]]>
      </doc>
    </constructor>
    <method name="getTitle" return="BaseComponent[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the text of this title

 @return the text]]>
      </doc>
    </method>
    <method name="getSubtitle" return="BaseComponent[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the text of this title's subtitle

 @return the text]]>
      </doc>
    </method>
    <method name="getFadeIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of ticks to fade in.

 <p>The returned value is never negative.</p>

 @return the number of ticks to fade in]]>
      </doc>
    </method>
    <method name="getStay" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of ticks to stay.

 <p>The returned value is never negative.</p>

 @return the number of ticks to stay]]>
      </doc>
    </method>
    <method name="getFadeOut" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of ticks to fade out.

 <p>The returned value is never negative.</p>

 @return the number of ticks to fade out]]>
      </doc>
    </method>
    <method name="builder" return="com.destroystokyo.paper.Title.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_FADE_IN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default number of ticks for the title to fade in.]]>
      </doc>
    </field>
    <field name="DEFAULT_STAY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default number of ticks for the title to stay.]]>
      </doc>
    </field>
    <field name="DEFAULT_FADE_OUT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default number of ticks for the title to fade out.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents a title to may be sent to a {@link Player}.

 <p>A title can be sent without subtitle text.</p>]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.Title -->
  <!-- start class com.destroystokyo.paper.Title.Builder -->
  <class name="Title.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="title" return="com.destroystokyo.paper.Title.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="BaseComponent"/>
      <doc>
      <![CDATA[Sets the title to the given text.

 @param title the title text
 @return this builder instance
 @throws NullPointerException if the title is null]]>
      </doc>
    </method>
    <method name="title" return="com.destroystokyo.paper.Title.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="BaseComponent[]"/>
      <doc>
      <![CDATA[Sets the title to the given text.

 @param title the title text
 @return this builder instance
 @throws NullPointerException if the title is null]]>
      </doc>
    </method>
    <method name="subtitle" return="com.destroystokyo.paper.Title.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subtitle" type="BaseComponent"/>
      <doc>
      <![CDATA[Sets the subtitle to the given text.

 @param subtitle the title text
 @return this builder instance]]>
      </doc>
    </method>
    <method name="subtitle" return="com.destroystokyo.paper.Title.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subtitle" type="BaseComponent[]"/>
      <doc>
      <![CDATA[Sets the subtitle to the given text.

 @param subtitle the title text
 @return this builder instance]]>
      </doc>
    </method>
    <method name="fadeIn" return="com.destroystokyo.paper.Title.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fadeIn" type="int"/>
      <doc>
      <![CDATA[Sets the number of ticks for the title to fade in

 @param fadeIn the number of ticks to fade in
 @return this builder instance
 @throws IllegalArgumentException if it is negative]]>
      </doc>
    </method>
    <method name="stay" return="com.destroystokyo.paper.Title.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stay" type="int"/>
      <doc>
      <![CDATA[Sets the number of ticks for the title to stay.

 @param stay the number of ticks to stay
 @return this builder instance
 @throws IllegalArgumentException if it is negative]]>
      </doc>
    </method>
    <method name="fadeOut" return="com.destroystokyo.paper.Title.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fadeOut" type="int"/>
      <doc>
      <![CDATA[Sets the number of ticks for the title to fade out.

 @param fadeOut the number of ticks to fade out
 @return this builder instance
 @throws IllegalArgumentException if it is negative]]>
      </doc>
    </method>
    <method name="build" return="com.destroystokyo.paper.Title"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a title based on the values in the builder.

 @return a title from the values in this builder
 @throws IllegalStateException if title isn't specified]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating titles]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.Title.Builder -->
</package>
<package name="com.destroystokyo.paper.block">
  <!-- start interface com.destroystokyo.paper.block.BlockSoundGroup -->
  <interface name="BlockSoundGroup"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getBreakSound" return="org.bukkit.Sound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the sound that plays when breaking this block

 @return The break sound]]>
      </doc>
    </method>
    <method name="getStepSound" return="org.bukkit.Sound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the sound that plays when stepping on this block

 @return The step sound]]>
      </doc>
    </method>
    <method name="getPlaceSound" return="org.bukkit.Sound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the sound that plays when placing this block

 @return The place sound]]>
      </doc>
    </method>
    <method name="getHitSound" return="org.bukkit.Sound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the sound that plays when hitting this block

 @return The hit sound]]>
      </doc>
    </method>
    <method name="getFallSound" return="org.bukkit.Sound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the sound that plays when this block falls

 @return The fall sound]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the sounds that a {@link Block} makes in certain situations
 <p>
 The sound group includes break, step, place, hit, and fall sounds.]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.block.BlockSoundGroup -->
  <!-- start class com.destroystokyo.paper.block.TargetBlockInfo -->
  <class name="TargetBlockInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TargetBlockInfo" type="org.bukkit.block.Block, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the block that is targeted

 @return Targeted block]]>
      </doc>
    </method>
    <method name="getBlockFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the targeted BlockFace

 @return Targeted blockface]]>
      </doc>
    </method>
    <method name="getRelativeBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the relative Block to the targeted block on the side it is targeted at

 @return Block relative to targeted block]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents information about a targeted block]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.block.TargetBlockInfo -->
  <!-- start class com.destroystokyo.paper.block.TargetBlockInfo.FluidMode -->
  <class name="TargetBlockInfo.FluidMode" extends="java.lang.Enum&lt;com.destroystokyo.paper.block.TargetBlockInfo.FluidMode&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.block.TargetBlockInfo.FluidMode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.block.TargetBlockInfo.FluidMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.block.TargetBlockInfo.FluidMode -->
</package>
<package name="com.destroystokyo.paper.entity">
  <!-- start interface com.destroystokyo.paper.entity.Pathfinder -->
  <interface name="Pathfinder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEntity" return="org.bukkit.entity.Mob"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The entity that is controlled by this pathfinder]]>
      </doc>
    </method>
    <method name="stopPathfinding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the Entity to stop trying to navigate to its current desired location]]>
      </doc>
    </method>
    <method name="hasPath" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the entity is currently trying to navigate to a destination, this will return true
 @return true if the entity is navigating to a destination]]>
      </doc>
    </method>
    <method name="getCurrentPath" return="com.destroystokyo.paper.entity.Pathfinder.PathResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The location the entity is trying to navigate to, or null if there is no destination]]>
      </doc>
    </method>
    <method name="findPath" return="com.destroystokyo.paper.entity.Pathfinder.PathResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Calculates a destination for the Entity to navigate to, but does not set it
 as the current target. Useful for calculating what would happen before setting it.
 @param loc Location to navigate to
 @return The closest Location the Entity can get to for this navigation, or null if no path could be calculated]]>
      </doc>
    </method>
    <method name="findPath" return="com.destroystokyo.paper.entity.Pathfinder.PathResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.LivingEntity"/>
      <doc>
      <![CDATA[Calculates a destination for the Entity to navigate to to reach the target entity,
 but does not set it as the current target.
 Useful for calculating what would happen before setting it.

 The behavior of this PathResult is subject to the games pathfinding rules, and may
 result in the pathfinding automatically updating to follow the target Entity.

 However, this behavior is not guaranteed, and is subject to the games behavior.

 @param target the Entity to navigate to
 @return The closest Location the Entity can get to for this navigation, or null if no path could be calculated]]>
      </doc>
    </method>
    <method name="moveTo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Calculates a destination for the Entity to navigate to, and sets it with default speed
 as the current target.
 @param loc Location to navigate to
 @return If the pathfinding was successfully started]]>
      </doc>
    </method>
    <method name="moveTo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="speed" type="double"/>
      <doc>
      <![CDATA[Calculates a destination for the Entity to navigate to, with desired speed
 as the current target.
 @param loc Location to navigate to
 @param speed Speed multiplier to navigate at, where 1 is 'normal'
 @return If the pathfinding was successfully started]]>
      </doc>
    </method>
    <method name="moveTo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.LivingEntity"/>
      <doc>
      <![CDATA[Calculates a destination for the Entity to navigate to to reach the target entity,
 and sets it with default speed.

 The behavior of this PathResult is subject to the games pathfinding rules, and may
 result in the pathfinding automatically updating to follow the target Entity.

 However, this behavior is not guaranteed, and is subject to the games behavior.

 @param target the Entity to navigate to
 @return If the pathfinding was successfully started]]>
      </doc>
    </method>
    <method name="moveTo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.LivingEntity"/>
      <param name="speed" type="double"/>
      <doc>
      <![CDATA[Calculates a destination for the Entity to navigate to to reach the target entity,
 and sets it with specified speed.

 The behavior of this PathResult is subject to the games pathfinding rules, and may
 result in the pathfinding automatically updating to follow the target Entity.

 However, this behavior is not guaranteed, and is subject to the games behavior.

 @param target the Entity to navigate to
 @param speed Speed multiplier to navigate at, where 1 is 'normal'
 @return If the pathfinding was successfully started]]>
      </doc>
    </method>
    <method name="moveTo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="com.destroystokyo.paper.entity.Pathfinder.PathResult"/>
      <doc>
      <![CDATA[Takes the result of a previous pathfinding calculation and sets it
 as the active pathfinding with default speed.

 @param path The Path to start following
 @return If the pathfinding was successfully started]]>
      </doc>
    </method>
    <method name="moveTo" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="com.destroystokyo.paper.entity.Pathfinder.PathResult"/>
      <param name="speed" type="double"/>
      <doc>
      <![CDATA[Takes the result of a previous pathfinding calculation and sets it
 as the active pathfinding,

 @param path The Path to start following
 @param speed Speed multiplier to navigate at, where 1 is 'normal'
 @return If the pathfinding was successfully started]]>
      </doc>
    </method>
    <method name="canOpenDoors" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this pathfinder allows passing through closed doors.

 @return if this pathfinder allows passing through closed doors]]>
      </doc>
    </method>
    <method name="setCanOpenDoors"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canOpenDoors" type="boolean"/>
      <doc>
      <![CDATA[Allows this pathfinder to pass through closed doors, or not

 @param canOpenDoors if the mob can pass through closed doors, or not]]>
      </doc>
    </method>
    <method name="canPassDoors" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this pathfinder allows passing through open doors.

 @return if this pathfinder allows passing through open doors]]>
      </doc>
    </method>
    <method name="setCanPassDoors"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canPassDoors" type="boolean"/>
      <doc>
      <![CDATA[Allows this pathfinder to pass through open doors, or not

 @param canPassDoors if the mob can pass through open doors, or not]]>
      </doc>
    </method>
    <method name="canFloat" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this pathfinder assumes that the mob can float

 @return if this pathfinder assumes that the mob can float]]>
      </doc>
    </method>
    <method name="setCanFloat"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canFloat" type="boolean"/>
      <doc>
      <![CDATA[Makes this pathfinder assume that the mob can float, or not

 @param canFloat if the mob can float, or not]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Handles pathfinding operations for an Entity]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.entity.Pathfinder -->
  <!-- start interface com.destroystokyo.paper.entity.Pathfinder.PathResult -->
  <interface name="Pathfinder.PathResult"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPoints" return="java.util.List&lt;org.bukkit.Location&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All currently calculated points to follow along the path to reach the destination location

 Will return points the entity has already moved past, see {@link #getNextPointIndex()}
 @return List of points]]>
      </doc>
    </method>
    <method name="getNextPointIndex" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the index of the current point along the points returned in {@link #getPoints()} the entity
 is trying to reach, or null if we are done with this pathfinding.]]>
      </doc>
    </method>
    <method name="getNextPoint" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The next location in the path points the entity is trying to reach, or null if there is no next point]]>
      </doc>
    </method>
    <method name="getFinalPoint" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The closest point the path can get to the target location]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the result of a pathfinding calculation]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.entity.Pathfinder.PathResult -->
  <!-- start interface com.destroystokyo.paper.entity.RangedEntity -->
  <interface name="RangedEntity"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Mob"/>
    <method name="rangedAttack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.LivingEntity"/>
      <param name="charge" type="float"/>
      <doc>
      <![CDATA[Attack the specified entity using a ranged attack.

 @param target the entity to target
 @param charge How "charged" the attack is (how far back the bow was pulled for Bow attacks).
               This should be a value between 0 and 1, represented as targetDistance/maxDistance.]]>
      </doc>
    </method>
    <method name="setChargingAttack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="raiseHands" type="boolean"/>
      <doc>
      <![CDATA[Sets that the Entity is "charging" up an attack, by raising its hands

 @param raiseHands Whether the entities hands are raised to charge attack]]>
      </doc>
    </method>
    <method name="isChargingAttack" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Alias to {@link LivingEntity#isHandRaised()}, if the entity is charging an attack
 @return If entities hands are raised]]>
      </doc>
    </method>
  </interface>
  <!-- end interface com.destroystokyo.paper.entity.RangedEntity -->
  <!-- start class com.destroystokyo.paper.entity.TargetEntityInfo -->
  <class name="TargetEntityInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TargetEntityInfo" type="org.bukkit.entity.Entity, org.bukkit.util.Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the entity that is targeted

 @return Targeted entity]]>
      </doc>
    </method>
    <method name="getHitVector" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the position the entity is targeted at

 @return Targeted position]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents information about a targeted entity]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.entity.TargetEntityInfo -->
</package>
<package name="com.destroystokyo.paper.entity.ai">
  <!-- start interface com.destroystokyo.paper.entity.ai.Goal -->
  <interface name="Goal"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="shouldActivate" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this goal should be activated

 @return if this goal should be activated]]>
      </doc>
    </method>
    <method name="shouldStayActive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this goal should stay active, defaults to {@link Goal#shouldActivate()}

 @return if this goal should stay active]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when this goal gets activated]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when this goal gets stopped]]>
      </doc>
    </method>
    <method name="tick"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called each tick the goal is activated]]>
      </doc>
    </method>
    <method name="getKey" return="com.destroystokyo.paper.entity.ai.GoalKey&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A unique key that identifies this type of goal. Plugins should use their own namespace, not the minecraft
 namespace. Additionally, this key also specifies to what mobs this goal can be applied to

 @return the goal key]]>
      </doc>
    </method>
    <method name="getTypes" return="java.util.EnumSet&lt;com.destroystokyo.paper.entity.ai.GoalType&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of all applicable flags for this goal.<br>

 This method is only called on construction.

 @return the subtypes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an AI goal of an entity]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.entity.ai.Goal -->
  <!-- start class com.destroystokyo.paper.entity.ai.GoalKey -->
  <class name="GoalKey" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEntityClass" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNamespacedKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="of" return="com.destroystokyo.paper.entity.ai.GoalKey&lt;A&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entityClass" type="java.lang.Class&lt;A&gt;"/>
      <param name="namespacedKey" type="org.bukkit.NamespacedKey"/>
    </method>
    <doc>
    <![CDATA[Used to identify a Goal. Consists of a {@link NamespacedKey} and the type of mob the goal can be applied to

 @param <T> the type of mob the goal can be applied to]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.entity.ai.GoalKey -->
  <!-- start class com.destroystokyo.paper.entity.ai.GoalType -->
  <class name="GoalType" extends="java.lang.Enum&lt;com.destroystokyo.paper.entity.ai.GoalType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.entity.ai.GoalType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.entity.ai.GoalType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the subtype of a goal. Used by minecraft to disable certain types of goals if needed.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.entity.ai.GoalType -->
  <!-- start interface com.destroystokyo.paper.entity.ai.MobGoals -->
  <interface name="MobGoals"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addGoal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="priority" type="int"/>
      <param name="goal" type="com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;"/>
    </method>
    <method name="removeGoal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="goal" type="com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;"/>
    </method>
    <method name="removeAllGoals"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
    </method>
    <method name="removeAllGoals"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="type" type="com.destroystokyo.paper.entity.ai.GoalType"/>
    </method>
    <method name="removeGoal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="key" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;T&gt;"/>
    </method>
    <method name="hasGoal" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="key" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;T&gt;"/>
    </method>
    <method name="getGoal" return="com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="key" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;T&gt;"/>
    </method>
    <method name="getGoals" return="java.util.Collection&lt;com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="key" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;T&gt;"/>
    </method>
    <method name="getAllGoals" return="java.util.Collection&lt;com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
    </method>
    <method name="getAllGoals" return="java.util.Collection&lt;com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="type" type="com.destroystokyo.paper.entity.ai.GoalType"/>
    </method>
    <method name="getAllGoalsWithout" return="java.util.Collection&lt;com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="type" type="com.destroystokyo.paper.entity.ai.GoalType"/>
    </method>
    <method name="getRunningGoals" return="java.util.Collection&lt;com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
    </method>
    <method name="getRunningGoals" return="java.util.Collection&lt;com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="type" type="com.destroystokyo.paper.entity.ai.GoalType"/>
    </method>
    <method name="getRunningGoalsWithout" return="java.util.Collection&lt;com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mob" type="T extends org.bukkit.entity.Mob"/>
      <param name="type" type="com.destroystokyo.paper.entity.ai.GoalType"/>
    </method>
    <doc>
    <![CDATA[Represents a part of the "brain" of a mob. It tracks all tasks (running or not), allows adding and removing goals]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.entity.ai.MobGoals -->
  <!-- start interface com.destroystokyo.paper.entity.ai.VanillaGoal -->
  <interface name="VanillaGoal"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.destroystokyo.paper.entity.ai.Goal&lt;T&gt;"/>
    <field name="BEE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_BECOME_ANGRY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_ENTER_HIVE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_GO_TO_HIVE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_GO_TO_KNOWN_FLOWER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_GROW_CROP" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_HURT_BY_OTHER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_LOCATE_HIVE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_POLLINATE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEE_WANDER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Bee&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BLAZE_FIREBALL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Blaze&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TEMPT_CHANCE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Cat&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CAT_AVOID_ENTITY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Cat&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CAT_RELAX_ON_OWNER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Cat&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOLPHIN_SWIM_TO_TREASURE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Dolphin&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOLPHIN_SWIM_WITH_PLAYER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Dolphin&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOLPHIN_PLAY_WITH_ITEMS" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Dolphin&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DROWNED_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Drowned&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DROWNED_GOTO_BEACH" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Drowned&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DROWNED_GOTO_WATER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DROWNED_SWIM_UP" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Drowned&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DROWNED_TRIDENT_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;com.destroystokyo.paper.entity.RangedEntity&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENDERMAN_PICKUP_BLOCK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Enderman&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENDERMAN_PLACE_BLOCK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Enderman&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PLAYER_WHO_LOOKED_AT_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Enderman&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENDERMAN_FREEZE_WHEN_LOOKED_AT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Enderman&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EVOKER_ATTACK_SPELL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Evoker&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EVOKER_CAST_SPELL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Evoker&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EVOKER_SUMMON_SPELL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Evoker&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EVOKER_WOLOLO_SPELL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Evoker&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FISH_SWIM" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fish&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_DEFEND_TRUSTED" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_FACEPLANT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_BREED" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_EAT_BERRIES" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_FLOAT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_FOLLOW_PARENT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_LOOK_AT_PLAYER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_MELEE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_PANIC" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_PERCH_AND_SEARCH" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_POUNCE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_SEARCH_FOR_ITEMS" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_SLEEP" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_STROLL_THROUGH_VILLAGE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_SEEK_SHELTER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOX_STALK_PREY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fox&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GHAST_ATTACK_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Ghast&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GHAST_IDLE_MOVE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Ghast&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GHAST_MOVE_TOWARDS_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Ghast&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GUARDIAN_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Guardian&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RAIDER_OPEN_DOOR" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Illager&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ILLUSIONER_BLINDNESS_SPELL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Illusioner&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ILLUSIONER_MIRROR_SPELL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Illusioner&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SPELLCASTER_CAST_SPELL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Spellcaster&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LLAMA_ATTACK_WOLF" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Llama&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LLAMA_HURT_BY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Llama&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LLAMATRADER_DEFENDED_WANDERING_TRADER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.TraderLlama&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG_DISTANCE_PATROL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Monster&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OCELOT_AVOID_ENTITY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Ocelot&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OCELOT_TEMPT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Ocelot&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_AVOID" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_BREED" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_HURT_BY_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_LIE_ON_BACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_LOOK_AT_PLAYER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_PANIC" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_ROLL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_SIT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANDA_SNEEZE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Panda&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PHANTOM_ATTACK_PLAYER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Phantom&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PHANTOM_ATTACK_STRATEGY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Phantom&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PHANTOM_CIRCLE_AROUND_ANCHOR" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Phantom&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PHANTOM_SWEEP_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Phantom&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANGER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.PigZombie&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="removed in 1.16">
      <doc>
      <![CDATA[@deprecated removed in 1.16]]>
      </doc>
    </field>
    <field name="ANGER_OTHER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.PigZombie&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="removed in 1.16">
      <doc>
      <![CDATA[@deprecated removed in 1.16]]>
      </doc>
    </field>
    <field name="POLARBEAR_ATTACK_PLAYERS" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.PolarBear&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="POLARBEAR_HURT_BY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.PolarBear&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="POLARBEAR_MELEE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.PolarBear&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="POLARBEAR_PANIC" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.PolarBear&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PUFFERFISH_PUFF" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.PufferFish&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EAT_CARROTS" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Rabbit&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KILLER_RABBIT_MELEE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Rabbit&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RABBIT_AVOID_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Rabbit&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RABBIT_PANIC" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Rabbit&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RAIDER_HOLD_GROUND" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Raider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RAIDER_OBTAIN_BANNER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Raider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RAIDER_CELEBRATION" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Raider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RAIDER_MOVE_THROUGH_VILLAGE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Raider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RAVAGER_MELEE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Ravager&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SHULKER_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Shulker&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SHULKER_DEFENSE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Shulker&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SHULKER_NEAREST" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Shulker&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SHULKER_PEEK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Shulker&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SILVERFISH_HIDE_IN_BLOCK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Silverfish&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SILVERFISH_WAKE_OTHERS" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Silverfish&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SKELETON_MELEE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Skeleton&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SLIME_IDLE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Slime&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SLIME_NEAREST_PLAYER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Slime&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SLIME_RANDOM_DIRECTION" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Slime&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SLIME_RANDOM_JUMP" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Slime&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SPIDER_MELEE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Spider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SPIDER_NEAREST_ATTACKABLE_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Spider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRIDER_GO_TO_LAVA" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Strider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SQUID" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Squid&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SQUID_FLEE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Squid&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TURTLE_BREED" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Turtle&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TURTLE_GO_HOME" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Turtle&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TURTLE_GOTO_WATER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Turtle&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TURTLE_LAY_EGG" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Turtle&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TURTLE_PANIC" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Turtle&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TURTLE_RANDOM_STROLL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Turtle&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TURTLE_TEMPT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Turtle&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TURTLE_TRAVEL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Turtle&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VEX_CHARGE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Vex&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VEX_COPY_TARGET_OF_OWNER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Vex&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VEX_RANDOM_MOVE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Vex&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VILLAGERTRADER_WANDER_TO_POSITION" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.WanderingTrader&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VINDICATOR_BREAK_DOOR" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VINDICATOR_JOHNNY_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Vindicator&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VINDICATOR_MELEE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Vindicator&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WITHER_DO_NOTHING" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Wither&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WOLF_AVOID_ENTITY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Wolf&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ZOMBIE_ATTACK_TURTLE_EGG" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Zombie&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ARROW_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;com.destroystokyo.paper.entity.RangedEntity&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AVOID_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BEG" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Wolf&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BOW_SHOOT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Monster&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BREAK_DOOR" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BREATH" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BREED" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Animals&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CAT_SIT_ON_BED" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Cat&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CROSSBOW_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Monster&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFEND_VILLAGE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.IronGolem&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOOR_OPEN" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EAT_TILE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FISH_SCHOOL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Fish&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLEE_SUN" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOAT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOLLOW_BOAT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOLLOW_ENTITY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOLLOW_OWNER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Tameable&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOLLOW_PARENT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Animals&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HORSE_TRAP" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.SkeletonHorse&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HURT_BY_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INTERACT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JUMP_ON_BLOCK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Cat&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LEAP_AT_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LLAMA_FOLLOW" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Llama&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOOK_AT_PLAYER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOOK_AT_TRADING_PLAYER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.AbstractVillager&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MELEE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MOVE_THROUGH_VILLAGE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MOVE_TOWARDS_RESTRICTION" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MOVE_TOWARDS_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NEAREST_ATTACKABLE_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NEAREST_ATTACKABLE_TARGET_WITCH" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Raider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NEAREST_HEALABLE_RAIDER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Raider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NEAREST_VILLAGE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OCELOT_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OFFER_FLOWER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.IronGolem&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OWNER_HURT_BY_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Tameable&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OWNER_HURT_TARGET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Tameable&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PANIC" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PERCH" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Parrot&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RAID" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Raider&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RANDOM_FLY" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RANDOM_LOOKAROUND" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RANDOM_STROLL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RANDOM_STROLL_LAND" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RANDOM_SWIM" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RANDOM_TARGET_NON_TAMED" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Tameable&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="REMOVE_BLOCK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RESTRICT_SUN" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SIT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Tameable&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STROLL_VILLAGE" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SWELL" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creeper&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TAME" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.AbstractHorse&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TEMPT" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TRADE_WITH_PLAYER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.AbstractVillager&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USE_ITEM" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WATER" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WATER_JUMP" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Dolphin&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ZOMBIE_ATTACK" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Zombie&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STROLL_VILLAGE_GOLEM" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Creature&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNIVERSAL_ANGER_RESET" type="com.destroystokyo.paper.entity.ai.GoalKey&lt;org.bukkit.entity.Mob&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a vanilla goal. Plugins should never implement this.<br>
 Generated by VanillaPathfinderTest in paper-server]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.entity.ai.VanillaGoal -->
</package>
<package name="com.destroystokyo.paper.entity.villager">
  <!-- start class com.destroystokyo.paper.entity.villager.Reputation -->
  <class name="Reputation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Reputation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Reputation" type="java.util.Map&lt;com.destroystokyo.paper.entity.villager.ReputationType, java.lang.Integer&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getReputation" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.destroystokyo.paper.entity.villager.ReputationType"/>
      <doc>
      <![CDATA[Gets the reputation value for a specific {@link ReputationType}.

 @param type The {@link ReputationType type} of reputation to get.
 @return The value of the {@link ReputationType type}.]]>
      </doc>
    </method>
    <method name="setReputation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.destroystokyo.paper.entity.villager.ReputationType"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the reputation value for a specific {@link ReputationType}.

 @param type The {@link ReputationType type} of reputation to set.
 @param value The value of the {@link ReputationType type}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A reputation score for a player on a villager.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.entity.villager.Reputation -->
  <!-- start class com.destroystokyo.paper.entity.villager.ReputationType -->
  <class name="ReputationType" extends="java.lang.Enum&lt;com.destroystokyo.paper.entity.villager.ReputationType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.entity.villager.ReputationType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.entity.villager.ReputationType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A type of reputation gained with a {@link org.bukkit.entity.Villager Villager}.
 <p>
 All types but {@link #MAJOR_POSITIVE} are shared to other villagers.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.entity.villager.ReputationType -->
</package>
<package name="com.destroystokyo.paper.event.block">
  <!-- start class com.destroystokyo.paper.event.block.AnvilDamagedEvent -->
  <class name="AnvilDamagedEvent" extends="org.bukkit.event.inventory.InventoryEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="AnvilDamagedEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.block.data.BlockData"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInventory" return="org.bukkit.inventory.AnvilInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDamageState" return="com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new state of damage on the anvil

 @return Damage state]]>
      </doc>
    </method>
    <method name="setDamageState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damageState" type="com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState"/>
      <doc>
      <![CDATA[Sets the new state of damage on the anvil

 @param damageState Damage state]]>
      </doc>
    </method>
    <method name="isBreaking" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if anvil is breaking on this use

 @return True if breaking]]>
      </doc>
    </method>
    <method name="setBreaking"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="breaking" type="boolean"/>
      <doc>
      <![CDATA[Sets if anvil is breaking on this use

 @param breaking True if breaking]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an anvil is damaged from being used]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.block.AnvilDamagedEvent -->
  <!-- start class com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState -->
  <class name="AnvilDamagedEvent.DamageState" extends="java.lang.Enum&lt;com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get block material of this state

 @return Material]]>
      </doc>
    </method>
    <method name="getState" return="com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blockData" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Get damaged state by block data

 @param blockData Block data
 @return DamageState
 @throws IllegalArgumentException If non anvil block data is given]]>
      </doc>
    </method>
    <method name="getState" return="com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Get damaged state by block material

 @param material Block material
 @return DamageState
 @throws IllegalArgumentException If non anvil material is given]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the amount of damage on an anvil block]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState -->
  <!-- start class com.destroystokyo.paper.event.block.BeaconEffectEvent -->
  <class name="BeaconEffectEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BeaconEffectEvent" type="org.bukkit.block.Block, org.bukkit.potion.PotionEffect, org.bukkit.entity.Player, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getEffect" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the potion effect being applied.

 @return Potion effect]]>
      </doc>
    </method>
    <method name="setEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.potion.PotionEffect"/>
      <doc>
      <![CDATA[Sets the potion effect that will be applied.

 @param effect Potion effect]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player who the potion effect is being applied to.

 @return Affected player]]>
      </doc>
    </method>
    <method name="isPrimary" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the effect is a primary beacon effect.

 @return true if this event represents a primary effect]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a beacon effect is being applied to a player.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.block.BeaconEffectEvent -->
  <!-- start class com.destroystokyo.paper.event.block.BlockDestroyEvent -->
  <class name="BlockDestroyEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockDestroyEvent" type="org.bukkit.block.Block, org.bukkit.block.data.BlockData, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewState" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The new state of this block (Air, or a Fluid type)]]>
      </doc>
    </method>
    <method name="willDrop" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If the server is going to drop the block in question with this destroy event]]>
      </doc>
    </method>
    <method name="playEffect" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If the server is going to play the sound effect for this destruction]]>
      </doc>
    </method>
    <method name="setPlayEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="playEffect" type="boolean"/>
      <doc>
      <![CDATA[@param playEffect If the server should play the sound effect for this destruction]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If the event is cancelled, meaning the block will not be destroyed]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[If the event is cancelled, the block will remain in its previous state.
 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired anytime the server intends to 'destroy' a block through some triggering reason.
 This does not fire anytime a block is set to air, but only with more direct triggers such
 as physics updates, pistons, Entities changing blocks, commands set to "Destroy".

 This event is associated with the game playing a sound effect at the block in question, when
 something can be described as "intend to destroy what is there",

 Events such as leaves decaying, pistons retracting (where the block is moving), does NOT fire this event.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.block.BlockDestroyEvent -->
  <!-- start class com.destroystokyo.paper.event.block.TNTPrimeEvent -->
  <class name="TNTPrimeEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="TNTPrimeEvent" type="org.bukkit.block.Block, com.destroystokyo.paper.event.block.TNTPrimeEvent.PrimeReason, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getReason" return="com.destroystokyo.paper.event.block.TNTPrimeEvent.PrimeReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the TNT prime reason

 @return Prime reason]]>
      </doc>
    </method>
    <method name="getPrimerEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the TNT primer {@link Entity}.

 It's null if {@link #getReason()} is {@link PrimeReason#REDSTONE} or {@link PrimeReason#FIRE}.
 It's not null if {@link #getReason()} is {@link PrimeReason#ITEM} or {@link PrimeReason#PROJECTILE}
 It might be null if {@link #getReason()} is {@link PrimeReason#EXPLOSION}

 @return The {@link Entity} who primed the TNT]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether spawning {@link org.bukkit.entity.TNTPrimed} should be cancelled or not

 @return Whether spawning {@link org.bukkit.entity.TNTPrimed} should be cancelled or not]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Sets whether to cancel spawning {@link org.bukkit.entity.TNTPrimed} or not

 @param cancel whether spawning {@link org.bukkit.entity.TNTPrimed} should be cancelled or not]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when TNT block is about to turn into {@link org.bukkit.entity.TNTPrimed}
 <p>
 Cancelling it won't turn TNT into {@link org.bukkit.entity.TNTPrimed} and leaves
 the TNT block as-is

 @author Mark Vainomaa]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.block.TNTPrimeEvent -->
  <!-- start class com.destroystokyo.paper.event.block.TNTPrimeEvent.PrimeReason -->
  <class name="TNTPrimeEvent.PrimeReason" extends="java.lang.Enum&lt;com.destroystokyo.paper.event.block.TNTPrimeEvent.PrimeReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.event.block.TNTPrimeEvent.PrimeReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.event.block.TNTPrimeEvent.PrimeReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.block.TNTPrimeEvent.PrimeReason -->
</package>
<package name="com.destroystokyo.paper.event.entity">
  <!-- start class com.destroystokyo.paper.event.entity.CreeperIgniteEvent -->
  <class name="CreeperIgniteEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="CreeperIgniteEvent" type="org.bukkit.entity.Creeper, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Creeper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isIgnited" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setIgnited"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignited" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a Creeper is ignite flag is changed (armed/disarmed to explode).]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.CreeperIgniteEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EnderDragonFireballHitEvent -->
  <class name="EnderDragonFireballHitEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EnderDragonFireballHitEvent" type="org.bukkit.entity.DragonFireball, java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;, org.bukkit.entity.AreaEffectCloud"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.DragonFireball"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The fireball involved in this event]]>
      </doc>
    </method>
    <method name="getTargets" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The living entities hit by fireball

 May be null if no entities were hit

 @return the targets]]>
      </doc>
    </method>
    <method name="getAreaEffectCloud" return="org.bukkit.entity.AreaEffectCloud"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The area effect cloud spawned in this collision]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when a DragonFireball collides with a block/entity and spawns an AreaEffectCloud]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EnderDragonFireballHitEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EnderDragonFlameEvent -->
  <class name="EnderDragonFlameEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EnderDragonFlameEvent" type="org.bukkit.entity.EnderDragon, org.bukkit.entity.AreaEffectCloud"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.EnderDragon"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The enderdragon involved in this event]]>
      </doc>
    </method>
    <method name="getAreaEffectCloud" return="org.bukkit.entity.AreaEffectCloud"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The area effect cloud spawned in this collision]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when an EnderDragon spawns an AreaEffectCloud by shooting flames]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EnderDragonFlameEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EnderDragonShootFireballEvent -->
  <class name="EnderDragonShootFireballEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EnderDragonShootFireballEvent" type="org.bukkit.entity.EnderDragon, org.bukkit.entity.DragonFireball"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.EnderDragon"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The enderdragon shooting the fireball]]>
      </doc>
    </method>
    <method name="getFireball" return="org.bukkit.entity.DragonFireball"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The fireball being shot]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when an EnderDragon shoots a fireball]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EnderDragonShootFireballEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EndermanAttackPlayerEvent -->
  <class name="EndermanAttackPlayerEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EndermanAttackPlayerEvent" type="org.bukkit.entity.Enderman, org.bukkit.entity.Player"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Enderman"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The enderman considering attacking

 @return The enderman considering attacking]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The player the Enderman is considering attacking

 @return The player the Enderman is considering attacking]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If cancelled, the enderman will not attack]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Cancels if the Enderman will attack this player
 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired when an Enderman determines if it should attack a player or not.
 Starts off cancelled if the player is wearing a pumpkin head or is not looking
 at the Enderman, according to Vanilla rules.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EndermanAttackPlayerEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EndermanEscapeEvent -->
  <class name="EndermanEscapeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EndermanEscapeEvent" type="org.bukkit.entity.Enderman, com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Enderman"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReason" return="com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The reason the enderman is trying to escape]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Cancels the escape.

 If this escape normally would of resulted in damage avoidance such as indirect,
 the enderman will now take damage.

 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EndermanEscapeEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason -->
  <class name="EndermanEscapeEvent.Reason" extends="java.lang.Enum&lt;com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityAddToWorldEvent -->
  <class name="EntityAddToWorldEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityAddToWorldEvent" type="org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired any time an entity is being added to the world for any reason.

 Not to be confused with {@link org.bukkit.event.entity.CreatureSpawnEvent}
 This will fire anytime a chunk is reloaded too.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityAddToWorldEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityJumpEvent -->
  <class name="EntityJumpEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityJumpEvent" type="org.bukkit.entity.LivingEntity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity jumps
 <p>
 Cancelling the event will stop the entity from jumping]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityJumpEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityKnockbackByEntityEvent -->
  <class name="EntityKnockbackByEntityEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityKnockbackByEntityEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.entity.Entity, float, org.bukkit.util.Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the entity which was knocked back]]>
      </doc>
    </method>
    <method name="getKnockbackStrength" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the original knockback strength.]]>
      </doc>
    </method>
    <method name="getHitBy" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the Entity which hit]]>
      </doc>
    </method>
    <method name="getAcceleration" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the acceleration that will be applied]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired when an Entity is knocked back by the hit of another Entity. The acceleration
 vector can be modified. If this event is cancelled, the entity is not knocked back.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityKnockbackByEntityEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityPathfindEvent -->
  <class name="EntityPathfindEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityPathfindEvent" type="org.bukkit.entity.Entity, org.bukkit.Location, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Entity that is pathfinding.
 @return The Entity that is pathfinding.]]>
      </doc>
    </method>
    <method name="getTargetEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the Entity is trying to pathfind to an entity, this is the entity in relation.

 Otherwise this will return null.

 @return The entity target or null]]>
      </doc>
    </method>
    <method name="getLoc" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Location of where the entity is about to move to.

 Note that if the target happened to of been an entity
 @return Location of where the entity is trying to pathfind to.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when an Entity decides to start moving towards a location.

 This event does not fire for the entities actual movement. Only when it
 is choosing to start moving to a location.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityPathfindEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent -->
  <class name="EntityRemoveFromWorldEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityRemoveFromWorldEvent" type="org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired any time an entity is being removed from a world for any reason]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityTeleportEndGatewayEvent -->
  <class name="EntityTeleportEndGatewayEvent" extends="org.bukkit.event.entity.EntityTeleportEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityTeleportEndGatewayEvent" type="org.bukkit.entity.Entity, org.bukkit.Location, org.bukkit.Location, org.bukkit.block.EndGateway"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getGateway" return="org.bukkit.block.EndGateway"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The gateway triggering the teleport

 @return EndGateway used]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired any time an entity attempts to teleport in an end gateway]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityTeleportEndGatewayEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityTransformedEvent -->
  <class name="EntityTransformedEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Bukkit has added {@link EntityTransformEvent}, you should start using that">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityTransformedEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity, com.destroystokyo.paper.event.entity.EntityTransformedEvent.TransformedReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTransformed" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link EntityTransformEvent#getTransformedEntity()}">
      <doc>
      <![CDATA[The entity after it has transformed

 @return Transformed entity
 @deprecated see {@link EntityTransformEvent#getTransformedEntity()}]]>
      </doc>
    </method>
    <method name="getReason" return="com.destroystokyo.paper.event.entity.EntityTransformedEvent.TransformedReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link EntityTransformEvent#getTransformReason()}">
      <doc>
      <![CDATA[@return The reason for the transformation
 @deprecated see {@link EntityTransformEvent#getTransformReason()}]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when an entity transforms into another entity
 <p>
 If the event is cancelled, the entity will not transform
 @deprecated Bukkit has added {@link EntityTransformEvent}, you should start using that]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityTransformedEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityTransformedEvent.TransformedReason -->
  <class name="EntityTransformedEvent.TransformedReason" extends="java.lang.Enum&lt;com.destroystokyo.paper.event.entity.EntityTransformedEvent.TransformedReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.event.entity.EntityTransformedEvent.TransformedReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.event.entity.EntityTransformedEvent.TransformedReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityTransformedEvent.TransformedReason -->
  <!-- start class com.destroystokyo.paper.event.entity.EntityZapEvent -->
  <class name="EntityZapEvent" extends="org.bukkit.event.entity.EntityTransformEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityZapEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.LightningStrike, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getBolt" return="org.bukkit.entity.LightningStrike"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the lightning bolt that is striking the entity.
 @return The lightning bolt responsible for this event]]>
      </doc>
    </method>
    <method name="getReplacementEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that will replace the struck entity.
 @return The entity that will replace the struck entity]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired when lightning strikes an entity]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.EntityZapEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.ExperienceOrbMergeEvent -->
  <class name="ExperienceOrbMergeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ExperienceOrbMergeEvent" type="org.bukkit.entity.ExperienceOrb, org.bukkit.entity.ExperienceOrb"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMergeTarget" return="org.bukkit.entity.ExperienceOrb"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The orb that will absorb the other experience orb]]>
      </doc>
    </method>
    <method name="getMergeSource" return="org.bukkit.entity.ExperienceOrb"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The orb that is subject to being removed and merged into the target orb]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[@param cancel true if you wish to cancel this event, and prevent the orbs from merging]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired anytime the server is about to merge 2 experience orbs into one]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.ExperienceOrbMergeEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.PhantomPreSpawnEvent -->
  <class name="PhantomPreSpawnEvent" extends="com.destroystokyo.paper.event.entity.PreCreatureSpawnEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PhantomPreSpawnEvent" type="org.bukkit.Location, org.bukkit.entity.Entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSpawningEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the entity this phantom is spawning for

 @return Entity]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when a phantom is spawned for an exhausted player]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.PhantomPreSpawnEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent -->
  <class name="PlayerNaturallySpawnCreaturesEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerNaturallySpawnCreaturesEvent" type="org.bukkit.entity.Player, byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSpawnRadius" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The radius of chunks around this player to be included in natural spawn selection]]>
      </doc>
    </method>
    <method name="setSpawnRadius"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="byte"/>
      <doc>
      <![CDATA[@param radius The radius of chunks around this player to be included in natural spawn selection]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If this players chunks will be excluded from natural spawns]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[@param cancel true if you wish to cancel this event, and not include this players chunks for natural spawning]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired when the server is calculating what chunks to try to spawn monsters in every Monster Spawn Tick event]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.PreCreatureSpawnEvent -->
  <class name="PreCreatureSpawnEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PreCreatureSpawnEvent" type="org.bukkit.Location, org.bukkit.entity.EntityType, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSpawnLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The location this creature is being spawned at]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The type of creature being spawned]]>
      </doc>
    </method>
    <method name="getReason" return="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Reason this creature is spawning (ie, NATURAL vs SPAWNER)]]>
      </doc>
    </method>
    <method name="shouldAbortSpawn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If the spawn process should be aborted vs trying more attempts]]>
      </doc>
    </method>
    <method name="setShouldAbortSpawn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shouldAbortSpawn" type="boolean"/>
      <doc>
      <![CDATA[Set this if you are more blanket blocking all types of these spawns, and wish to abort the spawn process from
 trying more attempts after this cancellation.

 @param shouldAbortSpawn Set if the spawn process should be aborted vs trying more attempts]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If the spawn of this creature is cancelled or not]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Cancelling this event is more effecient than cancelling CreatureSpawnEvent
 @param cancel true if you wish to cancel this event, and abort the spawn of this creature]]>
      </doc>
    </method>
    <doc>
    <![CDATA[WARNING: This event only fires for a limited number of cases, and not for every case that CreatureSpawnEvent does.

 You should still listen to CreatureSpawnEvent as a backup, and only use this event as an "enhancement".
 The intent of this event is to improve server performance, so limited use cases.
 
 Currently: NATURAL and SPAWNER based reasons. Please submit a Pull Request for future additions.
 Also, Plugins that replace Entity Registrations with their own custom entities might not fire this event.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.PreCreatureSpawnEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.PreSpawnerSpawnEvent -->
  <class name="PreSpawnerSpawnEvent" extends="com.destroystokyo.paper.event.entity.PreCreatureSpawnEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PreSpawnerSpawnEvent" type="org.bukkit.Location, org.bukkit.entity.EntityType, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSpawnerLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called before an entity is spawned into a world by a spawner.

 This only includes the spawner's location and not the full BlockState snapshot for performance reasons.
 If you really need it you have to get the spawner yourself.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.PreSpawnerSpawnEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.ProjectileCollideEvent -->
  <class name="ProjectileCollideEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ProjectileCollideEvent" type="org.bukkit.entity.Projectile, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCollidedWith" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the entity the projectile collided with

 @return the entity collided with]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Projectile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the projectile that collided

 @return the projectile that collided]]>
      </doc>
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Called when an projectile collides with an entity
 <p>
 This event is called <b>before</b> {@link org.bukkit.event.entity.EntityDamageByEntityEvent}, and cancelling it will allow the projectile to continue flying]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.ProjectileCollideEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.SkeletonHorseTrapEvent -->
  <class name="SkeletonHorseTrapEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SkeletonHorseTrapEvent" type="org.bukkit.entity.SkeletonHorse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.SkeletonHorse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Event called when a player gets close to a skeleton horse and triggers the lightning trap]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.SkeletonHorseTrapEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.SlimeChangeDirectionEvent -->
  <class name="SlimeChangeDirectionEvent" extends="com.destroystokyo.paper.event.entity.SlimePathfindEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SlimeChangeDirectionEvent" type="org.bukkit.entity.Slime, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewYaw" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the new chosen yaw

 @return Chosen yaw]]>
      </doc>
    </method>
    <method name="setNewYaw"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="yaw" type="float"/>
      <doc>
      <![CDATA[Set the new chosen yaw

 @param yaw Chosen yaw]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired when a Slime decides to change it's facing direction.
 <p>
 This event does not fire for the entity's actual movement. Only when it
 is choosing to change direction.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.SlimeChangeDirectionEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.SlimePathfindEvent -->
  <class name="SlimePathfindEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SlimePathfindEvent" type="org.bukkit.entity.Slime"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Slime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Slime that is pathfinding.

 @return The Slime that is pathfinding.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when a Slime decides to start pathfinding.
 <p>
 This event does not fire for the entity's actual movement. Only when it
 is choosing to start moving.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.SlimePathfindEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.SlimeSwimEvent -->
  <class name="SlimeSwimEvent" extends="com.destroystokyo.paper.event.entity.SlimeWanderEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SlimeSwimEvent" type="org.bukkit.entity.Slime"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Fired when a Slime decides to start jumping while swimming in water/lava.
 <p>
 This event does not fire for the entity's actual movement. Only when it
 is choosing to start jumping.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.SlimeSwimEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.SlimeTargetLivingEntityEvent -->
  <class name="SlimeTargetLivingEntityEvent" extends="com.destroystokyo.paper.event.entity.SlimePathfindEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SlimeTargetLivingEntityEvent" type="org.bukkit.entity.Slime, org.bukkit.entity.LivingEntity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTarget" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the targeted entity

 @return Targeted entity]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired when a Slime decides to change direction to target a LivingEntity.
 <p>
 This event does not fire for the entity's actual movement. Only when it
 is choosing to start moving.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.SlimeTargetLivingEntityEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.SlimeWanderEvent -->
  <class name="SlimeWanderEvent" extends="com.destroystokyo.paper.event.entity.SlimePathfindEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SlimeWanderEvent" type="org.bukkit.entity.Slime"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Fired when a Slime decides to start wandering.
 <p>
 This event does not fire for the entity's actual movement. Only when it
 is choosing to start moving.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.SlimeWanderEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.ThrownEggHatchEvent -->
  <class name="ThrownEggHatchEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ThrownEggHatchEvent" type="org.bukkit.entity.Egg, boolean, byte, org.bukkit.entity.EntityType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEgg" return="org.bukkit.entity.Egg"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the egg involved in this event.

 @return the egg involved in this event]]>
      </doc>
    </method>
    <method name="isHatching" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the egg is hatching or not. Will be what the server
 would've done without interaction.

 @return boolean Whether the egg is going to hatch or not]]>
      </doc>
    </method>
    <method name="setHatching"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hatching" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the egg will hatch or not.

 @param hatching true if you want the egg to hatch, false if you want it
     not to]]>
      </doc>
    </method>
    <method name="getHatchingType" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of the mob being hatched (EntityType.CHICKEN by default)

 @return The type of the mob being hatched by the egg]]>
      </doc>
    </method>
    <method name="setHatchingType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hatchType" type="org.bukkit.entity.EntityType"/>
      <doc>
      <![CDATA[Change the type of mob being hatched by the egg

 @param hatchType The type of the mob being hatched by the egg]]>
      </doc>
    </method>
    <method name="getNumHatches" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of mob hatches from the egg. By default the number will
 be the number the server would've done
 <ul>
 <li>7/8 chance of being 0
 <li>31/256 ~= 1/8 chance to be 1
 <li>1/256 chance to be 4
 </ul>

 @return The number of mobs going to be hatched by the egg]]>
      </doc>
    </method>
    <method name="setNumHatches"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numHatches" type="byte"/>
      <doc>
      <![CDATA[Change the number of mobs coming out of the hatched egg
 <p>
 The boolean hatching will override this number. Ie. If hatching =
 false, this number will not matter

 @param numHatches The number of mobs coming out of the egg]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a thrown egg might hatch.
 <p>
 This event fires for all thrown eggs that may hatch, players, dispensers, etc.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.ThrownEggHatchEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.TurtleGoHomeEvent -->
  <class name="TurtleGoHomeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="TurtleGoHomeEvent" type="org.bukkit.entity.Turtle"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Turtle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The turtle going home

 @return The turtle]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired when a Turtle decides to go home]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.TurtleGoHomeEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.TurtleLayEggEvent -->
  <class name="TurtleLayEggEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="TurtleLayEggEvent" type="org.bukkit.entity.Turtle, org.bukkit.Location, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Turtle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The turtle laying the eggs

 @return The turtle]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the location where the eggs are being laid

 @return Location of eggs]]>
      </doc>
    </method>
    <method name="getEggCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of eggs being laid

 @return Number of eggs]]>
      </doc>
    </method>
    <method name="setEggCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eggCount" type="int"/>
      <doc>
      <![CDATA[Set the number of eggs being laid

 @param eggCount Number of eggs]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired when a Turtle lays eggs]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.TurtleLayEggEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.TurtleStartDiggingEvent -->
  <class name="TurtleStartDiggingEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="TurtleStartDiggingEvent" type="org.bukkit.entity.Turtle, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Turtle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The turtle digging

 @return The turtle]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the location where the turtle is digging

 @return Location where digging]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired when a Turtle starts digging to lay eggs]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.TurtleStartDiggingEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.WitchConsumePotionEvent -->
  <class name="WitchConsumePotionEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="WitchConsumePotionEvent" type="org.bukkit.entity.Witch, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Witch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPotion" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the potion the witch will consume and have the effects applied.]]>
      </doc>
    </method>
    <method name="setPotion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="potion" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the potion to be consumed and applied to the witch.
 @param potion The potion]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Event was cancelled or potion was null]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when a witch consumes the potion in their hand to buff themselves.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.WitchConsumePotionEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.WitchReadyPotionEvent -->
  <class name="WitchReadyPotionEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="WitchReadyPotionEvent" type="org.bukkit.entity.Witch, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="process" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="witch" type="org.bukkit.entity.Witch"/>
      <param name="potion" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Fires thee event, returning the desired potion, or air of cancelled
 @param witch the witch whom is readying to use a potion
 @param potion the potion to be used
 @return The ItemStack to be used]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Witch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPotion" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the potion the witch is readying to use]]>
      </doc>
    </method>
    <method name="setPotion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="potion" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the potion the which is going to hold and use
 @param potion The potion]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.WitchReadyPotionEvent -->
  <!-- start class com.destroystokyo.paper.event.entity.WitchThrowPotionEvent -->
  <class name="WitchThrowPotionEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="WitchThrowPotionEvent" type="org.bukkit.entity.Witch, org.bukkit.entity.LivingEntity, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Witch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTarget" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The target of the potion]]>
      </doc>
    </method>
    <method name="getPotion" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The potion the witch will throw at a player]]>
      </doc>
    </method>
    <method name="setPotion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="potion" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the potion to be thrown at a player
 @param potion The potion]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Event was cancelled or potion was null]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when a witch throws a potion at a player]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.entity.WitchThrowPotionEvent -->
</package>
<package name="com.destroystokyo.paper.event.executor">
  <!-- start class com.destroystokyo.paper.event.executor.MethodHandleEventExecutor -->
  <class name="MethodHandleEventExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.EventExecutor"/>
    <constructor name="MethodHandleEventExecutor" type="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;, java.lang.invoke.MethodHandle"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MethodHandleEventExecutor" type="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;, java.lang.reflect.Method"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="event" type="org.bukkit.event.Event"/>
      <exception name="EventException" type="org.bukkit.event.EventException"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.executor.MethodHandleEventExecutor -->
  <!-- start class com.destroystokyo.paper.event.executor.StaticMethodHandleEventExecutor -->
  <class name="StaticMethodHandleEventExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.EventExecutor"/>
    <constructor name="StaticMethodHandleEventExecutor" type="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;, java.lang.reflect.Method"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="event" type="org.bukkit.event.Event"/>
      <exception name="EventException" type="org.bukkit.event.EventException"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.executor.StaticMethodHandleEventExecutor -->
</package>
<package name="com.destroystokyo.paper.event.executor.asm">
  <!-- start class com.destroystokyo.paper.event.executor.asm.ASMEventExecutorGenerator -->
  <class name="ASMEventExecutorGenerator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ASMEventExecutorGenerator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="generateEventExecutor" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.reflect.Method"/>
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="generateName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NEXT_ID" type="java.util.concurrent.atomic.AtomicInteger"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.destroystokyo.paper.event.executor.asm.ASMEventExecutorGenerator -->
  <!-- start interface com.destroystokyo.paper.event.executor.asm.ClassDefiner -->
  <interface name="ClassDefiner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isBypassAccessChecks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if the defined classes can bypass access checks

 @return if classes bypass access checks]]>
      </doc>
    </method>
    <method name="defineClass" return="java.lang.Class&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentLoader" type="java.lang.ClassLoader"/>
      <param name="name" type="java.lang.String"/>
      <param name="data" type="byte[]"/>
      <doc>
      <![CDATA[Define a class

 @param parentLoader the parent classloader
 @param name         the name of the class
 @param data         the class data to load
 @return the defined class
 @throws ClassFormatError     if the class data is invalid
 @throws NullPointerException if any of the arguments are null]]>
      </doc>
    </method>
    <method name="getInstance" return="com.destroystokyo.paper.event.executor.asm.ClassDefiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface com.destroystokyo.paper.event.executor.asm.ClassDefiner -->
  <!-- start class com.destroystokyo.paper.event.executor.asm.SafeClassDefiner -->
  <class name="SafeClassDefiner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.destroystokyo.paper.event.executor.asm.ClassDefiner"/>
    <method name="defineClass" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentLoader" type="java.lang.ClassLoader"/>
      <param name="name" type="java.lang.String"/>
      <param name="data" type="byte[]"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.executor.asm.SafeClassDefiner -->
</package>
<package name="com.destroystokyo.paper.event.inventory">
  <!-- start class com.destroystokyo.paper.event.inventory.PrepareGrindstoneEvent -->
  <class name="PrepareGrindstoneEvent" extends="com.destroystokyo.paper.event.inventory.PrepareResultEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PrepareGrindstoneEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInventory" return="org.bukkit.inventory.GrindstoneInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an item is put in a slot for grinding in a Grindstone
 @see com.destroystokyo.paper.event.inventory.PrepareResultEvent]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.inventory.PrepareGrindstoneEvent -->
  <!-- start class com.destroystokyo.paper.event.inventory.PrepareResultEvent -->
  <class name="PrepareResultEvent" extends="org.bukkit.event.inventory.InventoryEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PrepareResultEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get result item, may be null.

 @return result item]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an item is put in an inventory containing a result slot]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.inventory.PrepareResultEvent -->
</package>
<package name="com.destroystokyo.paper.event.player">
  <!-- start class com.destroystokyo.paper.event.player.IllegalPacketEvent -->
  <class name="IllegalPacketEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IllegalPacketEvent" type="org.bukkit.entity.Player, java.lang.String, java.lang.String, java.lang.Exception"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isShouldKick" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setShouldKick"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shouldKick" type="boolean"/>
    </method>
    <method name="getKickMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setKickMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kickMessage" type="java.lang.String"/>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExceptionMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="process"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <param name="type" type="java.lang.String"/>
      <param name="kickMessage" type="java.lang.String"/>
      <param name="exception" type="java.lang.Exception"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.IllegalPacketEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerAdvancementCriterionGrantEvent -->
  <class name="PlayerAdvancementCriterionGrantEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerAdvancementCriterionGrantEvent" type="org.bukkit.entity.Player, org.bukkit.advancement.Advancement, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAdvancement" return="org.bukkit.advancement.Advancement"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the advancement which has been affected.

 @return affected advancement]]>
      </doc>
    </method>
    <method name="getCriterion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the criterion which has been granted.

 @return granted criterion]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player is granted a criteria in an advancement.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerAdvancementCriterionGrantEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerArmorChangeEvent -->
  <class name="PlayerArmorChangeEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerArmorChangeEvent" type="org.bukkit.entity.Player, com.destroystokyo.paper.event.player.PlayerArmorChangeEvent.SlotType, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSlotType" return="com.destroystokyo.paper.event.player.PlayerArmorChangeEvent.SlotType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of slot being altered.

 @return type of slot being altered]]>
      </doc>
    </method>
    <method name="getOldItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the existing item that's being replaced

 @return old item]]>
      </doc>
    </method>
    <method name="getNewItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new item that's replacing the old

 @return new item]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the player themselves change their armor items
 <p>
 Not currently called for environmental factors though it <strong>MAY BE IN THE FUTURE</strong>]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerArmorChangeEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerArmorChangeEvent.SlotType -->
  <class name="PlayerArmorChangeEvent.SlotType" extends="java.lang.Enum&lt;com.destroystokyo.paper.event.player.PlayerArmorChangeEvent.SlotType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.event.player.PlayerArmorChangeEvent.SlotType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.event.player.PlayerArmorChangeEvent.SlotType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getTypes" return="java.util.Set&lt;org.bukkit.Material&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an immutable set of all allowed material types that can be placed in an
 armor slot.

 @return immutable set of material types]]>
      </doc>
    </method>
    <method name="getByMaterial" return="com.destroystokyo.paper.event.player.PlayerArmorChangeEvent.SlotType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Gets the type of slot via the specified material

 @param material material to get slot by
 @return slot type the material will go in, or null if it won't]]>
      </doc>
    </method>
    <method name="isEquipable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Gets whether or not this material can be equipped to a slot

 @param material material to check
 @return whether or not this material can be equipped]]>
      </doc>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerArmorChangeEvent.SlotType -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerAttackEntityCooldownResetEvent -->
  <class name="PlayerAttackEntityCooldownResetEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerAttackEntityCooldownResetEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins
 <p>
 If an attack cooldown event is cancelled, the players attack strength will remain at the same value instead of being reset.

 @return true if this event is cancelled]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Cancelling this event will prevent the target player from having their cooldown reset from attacking this entity

 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <method name="getCooledAttackStrength" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the value of the players cooldown attack strength when they initiated the attack

 @return returns the original player cooldown value]]>
      </doc>
    </method>
    <method name="getAttackedEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entity attacked by the player

 @return the entity attacked by the player]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when processing a player's attack on an entity when the player's attack strength cooldown is reset]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerAttackEntityCooldownResetEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerClientOptionsChangeEvent -->
  <class name="PlayerClientOptionsChangeEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerClientOptionsChangeEvent" type="org.bukkit.entity.Player, java.lang.String, int, com.destroystokyo.paper.ClientOption.ChatVisibility, boolean, com.destroystokyo.paper.SkinParts, org.bukkit.inventory.MainHand"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLocale" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasLocaleChanged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getViewDistance" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasViewDistanceChanged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChatVisibility" return="com.destroystokyo.paper.ClientOption.ChatVisibility"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasChatVisibilityChanged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasChatColorsEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasChatColorsEnabledChanged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSkinParts" return="com.destroystokyo.paper.SkinParts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasSkinPartsChanged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMainHand" return="org.bukkit.inventory.MainHand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasMainHandChanged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the player changes his client settings]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerClientOptionsChangeEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerConnectionCloseEvent -->
  <class name="PlayerConnectionCloseEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerConnectionCloseEvent" type="java.util.UUID, java.lang.String, java.net.InetAddress, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayerUniqueId" return="java.util.UUID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code UUID} of the player disconnecting.]]>
      </doc>
    </method>
    <method name="getPlayerName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the player disconnecting.]]>
      </doc>
    </method>
    <method name="getIpAddress" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player's IP address.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 This event is invoked when a player has disconnected. It is guaranteed that,
 if the server is in online-mode, that the provided uuid and username have been
 validated.
 </p>

 <p>
 The event is invoked for players who have not yet logged into the world, whereas
 {@link org.bukkit.event.player.PlayerQuitEvent} is only invoked on players who have logged into the world.
 </p>

 <p>
 The event is invoked for players who have already logged into the world,
 although whether or not the player exists in the world at the time of
 firing is undefined. (That is, whether the plugin can retrieve a Player object
 using the event parameters is undefined). However, it is guaranteed that this
 event is invoked AFTER {@link org.bukkit.event.player.PlayerQuitEvent}, if the player has already logged into the world.
 </p>

 <p>
 This event is guaranteed to never fire unless {@link org.bukkit.event.player.AsyncPlayerPreLoginEvent} has
 been fired beforehand, and this event may not be called in parallel with
 {@link org.bukkit.event.player.AsyncPlayerPreLoginEvent} for the same connection.
 </p>

 <p>
 Cancelling the {@link org.bukkit.event.player.AsyncPlayerPreLoginEvent} guarantees the corresponding
 {@code PlayerConnectionCloseEvent} is never called.
 </p>

 <p>
 The event may be invoked asynchronously or synchronously. Plugins should check
 {@link Event#isAsynchronous()} and handle accordingly.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerConnectionCloseEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerElytraBoostEvent -->
  <class name="PlayerElytraBoostEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerElytraBoostEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack, org.bukkit.entity.Firework"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the firework itemstack used

 @return ItemStack of firework]]>
      </doc>
    </method>
    <method name="getFirework" return="org.bukkit.entity.Firework"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the firework entity that was spawned

 @return Firework entity]]>
      </doc>
    </method>
    <method name="shouldConsume" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether to consume the firework or not

 @return True to consume]]>
      </doc>
    </method>
    <method name="setShouldConsume"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consume" type="boolean"/>
      <doc>
      <![CDATA[Set whether to consume the firework or not

 @param consume True to consume]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Fired when a player boosts elytra flight with a firework]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerElytraBoostEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerHandshakeEvent -->
  <class name="PlayerHandshakeEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerHandshakeEvent" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link PlayerHandshakeEvent}.

 @param originalHandshake the original handshake string
 @param cancelled if this event is enabled]]>
      </doc>
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines if this event is cancelled.

 <p>When this event is cancelled, custom handshake logic will not
 be processed.</p>

 @return {@code true} if this event is cancelled, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
      <doc>
      <![CDATA[Sets if this event is cancelled.

 <p>When this event is cancelled, custom handshake logic will not
 be processed.</p>

 @param cancelled {@code true} if this event is cancelled, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="getOriginalHandshake" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the original handshake string.

 @return the original handshake string]]>
      </doc>
    </method>
    <method name="getServerHostname" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the server hostname string.

 <p>This should not include the port.</p>

 @return the server hostname string]]>
      </doc>
    </method>
    <method name="setServerHostname"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverHostname" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the server hostname string.

 <p>This should not include the port.</p>

 @param serverHostname the server hostname string]]>
      </doc>
    </method>
    <method name="getSocketAddressHostname" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the socket address hostname string.

 <p>This should not include the port.</p>

 @return the socket address hostname string]]>
      </doc>
    </method>
    <method name="setSocketAddressHostname"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="socketAddressHostname" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the socket address hostname string.

 <p>This should not include the port.</p>

 @param socketAddressHostname the socket address hostname string]]>
      </doc>
    </method>
    <method name="getUniqueId" return="java.util.UUID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the unique id.

 @return the unique id]]>
      </doc>
    </method>
    <method name="setUniqueId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uniqueId" type="java.util.UUID"/>
      <doc>
      <![CDATA[Sets the unique id.

 @param uniqueId the unique id]]>
      </doc>
    </method>
    <method name="getPropertiesJson" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the profile properties.

 <p>This should be a valid JSON string.</p>

 @return the profile properties, as JSON]]>
      </doc>
    </method>
    <method name="isFailed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines if authentication failed.

 <p>When {@code true}, the client connecting will be disconnected
 with the {@link #getFailMessage() fail message}.</p>

 @return {@code true} if authentication failed, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="setFailed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="failed" type="boolean"/>
      <doc>
      <![CDATA[Sets if authentication failed and the client should be disconnected.

 <p>When {@code true}, the client connecting will be disconnected
 with the {@link #getFailMessage() fail message}.</p>

 @param failed {@code true} if authentication failed, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="setPropertiesJson"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertiesJson" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the profile properties.

 <p>This should be a valid JSON string.</p>

 @param propertiesJson the profile properties, as JSON]]>
      </doc>
    </method>
    <method name="getFailMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the message to display to the client when authentication fails.

 @return the message to display to the client]]>
      </doc>
    </method>
    <method name="setFailMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="failMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the message to display to the client when authentication fails.

 @param failMessage the message to display to the client]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is fired during a player handshake.

 <p>If there are no listeners listening to this event, the logic default
 to your server platform will be ran.</p>

 <p>WARNING: TAMPERING WITH THIS EVENT CAN BE DANGEROUS</p>]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerHandshakeEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerInitialSpawnEvent -->
  <class name="PlayerInitialSpawnEvent" extends="org.spigotmc.event.player.PlayerSpawnLocationEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use {@link PlayerSpawnLocationEvent}, Duplicate API">
    <constructor name="PlayerInitialSpawnEvent" type="org.bukkit.entity.Player, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@deprecated Use {@link PlayerSpawnLocationEvent}, Duplicate API]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerInitialSpawnEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerJumpEvent -->
  <class name="PlayerJumpEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerJumpEvent" type="org.bukkit.entity.Player, org.bukkit.Location, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins
 <p>
 If a jump event is cancelled, the player will be moved or
 teleported back to the Location as defined by getFrom(). This will not
 fire an event

 @return true if this event is cancelled]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Sets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins
 <p>
 If a jump event is cancelled, the player will be moved or
 teleported back to the Location as defined by getFrom(). This will not
 fire an event

 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <method name="getFrom" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location this player jumped from

 @return Location the player jumped from]]>
      </doc>
    </method>
    <method name="setFrom"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the location to mark as where the player jumped from

 @param from New location to mark as the players previous location]]>
      </doc>
    </method>
    <method name="getTo" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location this player jumped to

 This information is based on what the client sends, it typically
 has little relation to the arc of the jump at any given point.

 @return Location the player jumped to]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the server detects the player is jumping.
 <p>
 Added to avoid the overhead and special case logic that many plugins use
 when checking for jumps via PlayerMoveEvent, this event is fired whenever
 the server detects that the player is jumping.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerJumpEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent -->
  <class name="PlayerLaunchProjectileEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerLaunchProjectileEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack, org.bukkit.entity.Projectile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getProjectile" return="org.bukkit.entity.Projectile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the projectile which will be launched by this event

 @return the launched projectile]]>
      </doc>
    </method>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the ItemStack used to fire the projectile

 @return The ItemStack used]]>
      </doc>
    </method>
    <method name="shouldConsume" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether to consume the ItemStack or not

 @return True to consume]]>
      </doc>
    </method>
    <method name="setShouldConsume"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumeItem" type="boolean"/>
      <doc>
      <![CDATA[Set whether to consume the ItemStack or not

 @param consumeItem True to consume]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player shoots a projectile]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerLocaleChangeEvent -->
  <class name="PlayerLocaleChangeEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by {@link org.bukkit.event.player.PlayerLocaleChangeEvent} upstream">
    <constructor name="PlayerLocaleChangeEvent" type="org.bukkit.entity.Player, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getOldLocale" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the locale the player switched from.

 @return player's old locale]]>
      </doc>
    </method>
    <method name="getNewLocale" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the locale the player is changed to.

 @return player's new locale]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the locale of the player is changed.

 @deprecated Replaced by {@link org.bukkit.event.player.PlayerLocaleChangeEvent} upstream]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerLocaleChangeEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerPickupExperienceEvent -->
  <class name="PlayerPickupExperienceEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerPickupExperienceEvent" type="org.bukkit.entity.Player, org.bukkit.entity.ExperienceOrb"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExperienceOrb" return="org.bukkit.entity.ExperienceOrb"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the Orb that the player is picking up]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[If true, Cancels picking up the experience orb, leaving it in the world
 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired when a player is attempting to pick up an experience orb]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerPickupExperienceEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerPostRespawnEvent -->
  <class name="PlayerPostRespawnEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerPostRespawnEvent" type="org.bukkit.entity.Player, org.bukkit.Location, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRespawnedLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the location of the respawned player

 @return location of the respawned player]]>
      </doc>
    </method>
    <method name="isBedSpawn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the player respawned to their bed

 @return whether the player respawned to their bed]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired after a player has respawned]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerPostRespawnEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerReadyArrowEvent -->
  <class name="PlayerReadyArrowEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerReadyArrowEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBow" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the player is using to fire the arrow]]>
      </doc>
    </method>
    <method name="getArrow" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the arrow that is attempting to be used]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether or not use of this arrow is cancelled. On cancel, the server will try the next arrow available and fire another event.]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Cancel use of this arrow. On cancel, the server will try the next arrow available and fire another event.
 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when a player is firing a bow and the server is choosing an arrow to use.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerReadyArrowEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerRecipeBookClickEvent -->
  <class name="PlayerRecipeBookClickEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerRecipeBookClickEvent" type="org.bukkit.entity.Player, org.bukkit.NamespacedKey, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRecipe" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the namespaced key of the recipe that was clicked by the player

 @return The namespaced key of the recipe]]>
      </doc>
    </method>
    <method name="setRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipe" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Changes what recipe is requested. This sets the requested recipe to the recipe with the given key

 @param recipe The key of the recipe that should be requested]]>
      </doc>
    </method>
    <method name="isMakeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a boolean which indicates whether or not the player requested to make the maximum amount of results. This is
 true if shift is pressed while the recipe is clicked in the recipe book

 @return {@code true} if shift is pressed while the recipe is clicked]]>
      </doc>
    </method>
    <method name="setMakeAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="makeAll" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not the maximum amount of results should be made. If this is true, the request is handled as if
 the player had pressed shift while clicking on the recipe

 @param makeAll {@code true} if the request should attempt to make the maximum amount of results]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player clicks a recipe in the recipe book]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerRecipeBookClickEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerStartSpectatingEntityEvent -->
  <class name="PlayerStartSpectatingEntityEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerStartSpectatingEntityEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCurrentSpectatorTarget" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that the player is currently spectating or themselves if they weren't spectating anything

 @return The entity the player is currently spectating (before they start spectating the new target).]]>
      </doc>
    </method>
    <method name="getNewSpectatorTarget" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new entity that the player will now be spectating

 @return The entity the player is now going to be spectating.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Triggered when a player starts spectating an entity in spectator mode.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerStartSpectatingEntityEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerStopSpectatingEntityEvent -->
  <class name="PlayerStopSpectatingEntityEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerStopSpectatingEntityEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSpectatorTarget" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that the player is spectating

 @return The entity the player is currently spectating (before they will stop).]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Triggered when a player stops spectating an entity in spectator mode.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerStopSpectatingEntityEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerTeleportEndGatewayEvent -->
  <class name="PlayerTeleportEndGatewayEvent" extends="org.bukkit.event.player.PlayerTeleportEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerTeleportEndGatewayEvent" type="org.bukkit.entity.Player, org.bukkit.Location, org.bukkit.Location, org.bukkit.block.EndGateway"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getGateway" return="org.bukkit.block.EndGateway"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The gateway triggering the teleport

 @return EndGateway used]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired when a teleport is triggered for an End Gateway]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerTeleportEndGatewayEvent -->
  <!-- start class com.destroystokyo.paper.event.player.PlayerUseUnknownEntityEvent -->
  <class name="PlayerUseUnknownEntityEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerUseUnknownEntityEvent" type="org.bukkit.entity.Player, int, boolean, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntityId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isAttack" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHand" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.player.PlayerUseUnknownEntityEvent -->
</package>
<package name="com.destroystokyo.paper.event.profile">
  <!-- start class com.destroystokyo.paper.event.profile.FillProfileEvent -->
  <class name="FillProfileEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FillProfileEvent" type="com.destroystokyo.paper.profile.PlayerProfile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayerProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The Profile that had properties filled]]>
      </doc>
    </method>
    <method name="getProperties" return="java.util.Set&lt;com.destroystokyo.paper.profile.ProfileProperty&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as .getPlayerProfile().getProperties()

 @see PlayerProfile#getProperties()
 @return The new properties on the profile.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired once a profiles additional properties (such as textures) has been filled]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.profile.FillProfileEvent -->
  <!-- start class com.destroystokyo.paper.event.profile.LookupProfileEvent -->
  <class name="LookupProfileEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LookupProfileEvent" type="com.destroystokyo.paper.profile.PlayerProfile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayerProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The profile that was recently looked up. This profile can be mutated]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Allows a plugin to be notified anytime AFTER a Profile has been looked up from the Mojang API
 This is an opportunity to view the response and potentially cache things.

 No guarantees are made about thread execution context for this event. If you need to know, check
 event.isAsync()]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.profile.LookupProfileEvent -->
  <!-- start class com.destroystokyo.paper.event.profile.PreFillProfileEvent -->
  <class name="PreFillProfileEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PreFillProfileEvent" type="com.destroystokyo.paper.profile.PlayerProfile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayerProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The profile that needs its properties filled]]>
      </doc>
    </method>
    <method name="setProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Collection&lt;com.destroystokyo.paper.profile.ProfileProperty&gt;"/>
      <doc>
      <![CDATA[Sets the properties on the profile, avoiding the call to the Mojang API
 Same as .getPlayerProfile().setProperties(properties);
 
 @see PlayerProfile#setProperties(Collection)
 @param properties The properties to set/append]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired when the server is requesting to fill in properties of an incomplete profile, such as textures.

 Allows plugins to pre populate cached properties and avoid a call to the Mojang API]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.profile.PreFillProfileEvent -->
  <!-- start class com.destroystokyo.paper.event.profile.PreLookupProfileEvent -->
  <class name="PreLookupProfileEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PreLookupProfileEvent" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Name of the profile]]>
      </doc>
    </method>
    <method name="getUUID" return="java.util.UUID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this value is left null by the completion of the event call, then the server will
 trigger a call to the Mojang API to look up the UUID (Network Request), and subsequently, fire a
 {@link LookupProfileEvent}

 @return The UUID of the profile if it has already been provided by a plugin]]>
      </doc>
    </method>
    <method name="setUUID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Sets the UUID for this player name. This will skip the initial API call to find the players UUID.

 However, if Profile Properties are needed by the server, you must also set them or else an API call might still be made.

 @param uuid the UUID to set for the profile or null to reset]]>
      </doc>
    </method>
    <method name="getProfileProperties" return="java.util.Set&lt;com.destroystokyo.paper.profile.ProfileProperty&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The currently pending prepopulated properties.
 Any property in this Set will be automatically prefilled on this Profile]]>
      </doc>
    </method>
    <method name="setProfileProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Set&lt;com.destroystokyo.paper.profile.ProfileProperty&gt;"/>
      <doc>
      <![CDATA[Clears any existing prepopulated properties and uses the supplied properties
 Any property in this Set will be automatically prefilled on this Profile
 @param properties The properties to add]]>
      </doc>
    </method>
    <method name="addProfileProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Set&lt;com.destroystokyo.paper.profile.ProfileProperty&gt;"/>
      <doc>
      <![CDATA[Adds any properties currently missing to the prepopulated properties set, replacing any that already were set.
 Any property in this Set will be automatically prefilled on this Profile
 @param properties The properties to add]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Allows a plugin to intercept a Profile Lookup for a Profile by name

 At the point of event fire, the UUID and properties are unset.

 If a plugin sets the UUID, and optionally the properties, the API call to look up the profile may be skipped.

 No guarantees are made about thread execution context for this event. If you need to know, check
 event.isAsync()]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.profile.PreLookupProfileEvent -->
  <!-- start class com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent -->
  <class name="ProfileWhitelistVerifyEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProfileWhitelistVerifyEvent" type="com.destroystokyo.paper.profile.PlayerProfile, boolean, boolean, boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKickMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the currently planned message to send to the user if they are not whitelisted]]>
      </doc>
    </method>
    <method name="setKickMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kickMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[@param kickMessage The message to send to the player on kick if not whitelisted. May set to null to use the server configured default]]>
      </doc>
    </method>
    <method name="getPlayerProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The profile of the player trying to connect]]>
      </doc>
    </method>
    <method name="isWhitelisted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Whether the player is whitelisted to play on this server (whitelist may be off is why its true)]]>
      </doc>
    </method>
    <method name="setWhitelisted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="whitelisted" type="boolean"/>
      <doc>
      <![CDATA[Changes the players whitelisted state. false will deny the login
 @param whitelisted The new whitelisted state]]>
      </doc>
    </method>
    <method name="isOp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return if the player obtained whitelist status by having op]]>
      </doc>
    </method>
    <method name="isWhitelistEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return if the server even has whitelist on]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fires when the server needs to verify if a player is whitelisted.

 Plugins may override/control the servers whitelist with this event,
 and dynamically change the kick message.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent -->
</package>
<package name="com.destroystokyo.paper.event.server">
  <!-- start class com.destroystokyo.paper.event.server.AsyncTabCompleteEvent -->
  <class name="AsyncTabCompleteEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="AsyncTabCompleteEvent" type="org.bukkit.command.CommandSender, java.util.List&lt;java.lang.String&gt;, java.lang.String, boolean, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSender" return="org.bukkit.command.CommandSender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the sender completing this command.

 @return the {@link CommandSender} instance]]>
      </doc>
    </method>
    <method name="getCompletions" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The list of completions which will be offered to the sender, in order.
 This list is mutable and reflects what will be offered.

 If this collection is not empty after the event is fired, then
 the standard process of calling {@link Command#tabComplete(CommandSender, String, String[])}
 or current player names will not be called.

 @return a list of offered completions]]>
      </doc>
    </method>
    <method name="setCompletions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="completions" type="java.util.List&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Set the completions offered, overriding any already set.
 If this collection is not empty after the event is fired, then
 the standard process of calling {@link Command#tabComplete(CommandSender, String, String[])}
 or current player names will not be called.

 The passed collection will be cloned to a new List. You must call {{@link #getCompletions()}} to mutate from here

 @param completions the new completions]]>
      </doc>
    </method>
    <method name="getBuffer" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the entire buffer which formed the basis of this completion.

 @return command buffer, as entered]]>
      </doc>
    </method>
    <method name="isCommand" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return True if it is a command being tab completed, false if it is a chat message.]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The position looked at by the sender, or null if none]]>
      </doc>
    </method>
    <method name="isHandled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If true, the standard process of calling {@link Command#tabComplete(CommandSender, String, String[])}
 or current player names will not be called.

 @return Is completions considered handled. Always true if completions is not empty.]]>
      </doc>
    </method>
    <method name="setHandled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handled" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not to consider the completion request handled.
 If true, the standard process of calling {@link Command#tabComplete(CommandSender, String, String[])}
 or current player names will not be called.

 @param handled if this completion should be marked as being handled]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
      <doc>
      <![CDATA[Will provide no completions, and will not fire the synchronous process
 @param cancelled true if you wish to cancel this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Allows plugins to compute tab completion results asynchronously. If this event provides completions, then the standard synchronous process will not be fired to populate the results. However, the synchronous TabCompleteEvent will fire with the Async results.

 Only 1 process will be allowed to provide completions, the Async Event, or the standard process.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.AsyncTabCompleteEvent -->
  <!-- start class com.destroystokyo.paper.event.server.GS4QueryEvent -->
  <class name="GS4QueryEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GS4QueryEvent" type="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType, java.net.InetAddress, com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getQueryType" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get query type
 @return query type]]>
      </doc>
    </method>
    <method name="getQuerierAddress" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get querier address
 @return querier address]]>
      </doc>
    </method>
    <method name="getResponse" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get query response
 @return query response]]>
      </doc>
    </method>
    <method name="setResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse"/>
      <doc>
      <![CDATA[Set query response
 @param response query response]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is fired if server is getting queried over GS4 Query protocol

 Adapted from Velocity's ProxyQueryEvent

 @author Mark Vainomaa]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.GS4QueryEvent -->
  <!-- start class com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse -->
  <class name="GS4QueryEvent.QueryResponse" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMotd" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get motd which will be used to reply to the query. By default it is {@link org.bukkit.Server#getMotd()}.
 @return motd]]>
      </doc>
    </method>
    <method name="getGameVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get game version which will be used to reply to the query. By default supported Minecraft versions range is sent.
 @return game version]]>
      </doc>
    </method>
    <method name="getMap" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get map name which will be used to reply to the query. By default {@code world} is sent.
 @return map name]]>
      </doc>
    </method>
    <method name="getCurrentPlayers" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current online player count which will be used to reply to the query.
 @return online player count]]>
      </doc>
    </method>
    <method name="getMaxPlayers" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get max player count which will be used to reply to the query.
 @return max player count]]>
      </doc>
    </method>
    <method name="getHostname" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get server (public facing) hostname
 @return server hostname]]>
      </doc>
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get server (public facing) port
 @return server port]]>
      </doc>
    </method>
    <method name="getPlayers" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get collection of players which will be used to reply to the query.
 @return collection of players]]>
      </doc>
    </method>
    <method name="getServerVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get server software (name and version) which will be used to reply to the query.
 @return server software]]>
      </doc>
    </method>
    <method name="getPlugins" return="java.util.Collection&lt;com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get list of plugins which will be used to reply to the query.
 @return collection of plugins]]>
      </doc>
    </method>
    <method name="toBuilder" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link Builder} instance from data represented by this response
 @return {@link QueryResponse} builder]]>
      </doc>
    </method>
    <method name="builder" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link Builder} instance
 @return {@link QueryResponse} builder]]>
      </doc>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse -->
  <!-- start class com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder -->
  <class name="GS4QueryEvent.QueryResponse.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="motd" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="motd" type="java.lang.String"/>
    </method>
    <method name="gameVersion" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gameVersion" type="java.lang.String"/>
    </method>
    <method name="map" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.lang.String"/>
    </method>
    <method name="currentPlayers" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="currentPlayers" type="int"/>
    </method>
    <method name="maxPlayers" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxPlayers" type="int"/>
    </method>
    <method name="hostname" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostname" type="java.lang.String"/>
    </method>
    <method name="port" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="port" type="int"/>
    </method>
    <method name="players" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="players" type="java.util.Collection&lt;java.lang.String&gt;"/>
    </method>
    <method name="players" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="players" type="java.lang.String[]"/>
    </method>
    <method name="clearPlayers" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serverVersion" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverVersion" type="java.lang.String"/>
    </method>
    <method name="plugins" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugins" type="java.util.Collection&lt;com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation&gt;"/>
    </method>
    <method name="plugins" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugins" type="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation[]"/>
    </method>
    <method name="clearPlugins" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds new {@link QueryResponse} with supplied data
 @return response]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for {@link QueryResponse} objects.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.Builder -->
  <!-- start class com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation -->
  <class name="GS4QueryEvent.QueryResponse.PluginInformation" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginInformation" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="setVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="java.lang.String"/>
    </method>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="of" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="version" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Plugin information]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation -->
  <!-- start class com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType -->
  <class name="GS4QueryEvent.QueryType" extends="java.lang.Enum&lt;com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The type of query]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType -->
  <!-- start class com.destroystokyo.paper.event.server.PaperServerListPingEvent -->
  <class name="PaperServerListPingEvent" extends="org.bukkit.event.server.ServerListPingEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PaperServerListPingEvent" type="com.destroystokyo.paper.network.StatusClient, java.lang.String, int, int, java.lang.String, int, org.bukkit.util.CachedServerIcon"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getClient" return="com.destroystokyo.paper.network.StatusClient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link StatusClient} pinging the server.

 @return The client]]>
      </doc>
    </method>
    <method name="getNumPlayers" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Returns {@code -1} if players are hidden using
 {@link #shouldHidePlayers()}.</p>]]>
      </doc>
    </method>
    <method name="setNumPlayers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numPlayers" type="int"/>
      <doc>
      <![CDATA[Sets the number of players displayed in the server list.

 <p>Note that this won't have any effect if {@link #shouldHidePlayers()}
 is enabled.</p>

 @param numPlayers The number of online players]]>
      </doc>
    </method>
    <method name="getMaxPlayers" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Returns {@code -1} if players are hidden using
 {@link #shouldHidePlayers()}.</p>]]>
      </doc>
    </method>
    <method name="shouldHidePlayers" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether all player related information is hidden in the server
 list. This will cause {@link #getNumPlayers()}, {@link #getMaxPlayers()}
 and {@link #getPlayerSample()} to be skipped in the response.

 <p>The Vanilla Minecraft client will display the player count as {@code ???}
 when this option is enabled.</p>

 @return {@code true} if the player count is hidden]]>
      </doc>
    </method>
    <method name="setHidePlayers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hidePlayers" type="boolean"/>
      <doc>
      <![CDATA[Sets whether all player related information is hidden in the server
 list. This will cause {@link #getNumPlayers()}, {@link #getMaxPlayers()}
 and {@link #getPlayerSample()} to be skipped in the response.

 <p>The Vanilla Minecraft client will display the player count as {@code ???}
 when this option is enabled.</p>

 @param hidePlayers {@code true} if the player count should be hidden]]>
      </doc>
    </method>
    <method name="getPlayerSample" return="java.util.List&lt;com.destroystokyo.paper.profile.PlayerProfile&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a mutable list of {@link PlayerProfile} that will be displayed
 as online players on the client.

 <p>The Vanilla Minecraft client will display them when hovering the
 player count with the mouse.</p>

 @return The mutable player sample list]]>
      </doc>
    </method>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the version that will be sent as server version on the client.

 @return The server version]]>
      </doc>
    </method>
    <method name="setVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the version that will be sent as server version to the client.

 @param version The server version]]>
      </doc>
    </method>
    <method name="getProtocolVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the protocol version that will be sent as the protocol version
 of the server to the client.

 @return The protocol version of the server, or {@code -1} if the server
 has not finished initialization yet]]>
      </doc>
    </method>
    <method name="setProtocolVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocolVersion" type="int"/>
      <doc>
      <![CDATA[Sets the protocol version that will be sent as the protocol version
 of the server to the client.

 @param protocolVersion The protocol version of the server]]>
      </doc>
    </method>
    <method name="getServerIcon" return="org.bukkit.util.CachedServerIcon"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the server icon sent to the client.

 @return The icon to send to the client, or {@code null} for none]]>
      </doc>
    </method>
    <method name="setServerIcon"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="icon" type="org.bukkit.util.CachedServerIcon"/>
      <doc>
      <![CDATA[Sets the server icon sent to the client.

 @param icon The icon to send to the client, or {@code null} for none]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Cancelling this event will cause the connection to be closed immediately,
 without sending a response to the client.</p>]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Cancelling this event will cause the connection to be closed immediately,
 without sending a response to the client.</p>]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> For compatibility reasons, this method will return all
 online players, not just the ones referenced in {@link #getPlayerSample()}.
 Removing a player will:</p>

 <ul>
     <li>Decrement the online player count (if and only if) the player
     count wasn't changed by another plugin before.</li>
     <li>Remove all entries from {@link #getPlayerSample()} that refer to
     the removed player (based on their {@link UUID}).</li>
 </ul>]]>
      </doc>
    </method>
    <method name="getOnlinePlayers" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getBukkitPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="player" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Extended version of {@link ServerListPingEvent} that allows full control
 of the response sent to the client.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.PaperServerListPingEvent -->
  <!-- start class com.destroystokyo.paper.event.server.ServerExceptionEvent -->
  <class name="ServerExceptionEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerExceptionEvent" type="com.destroystokyo.paper.exception.ServerException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getException" return="com.destroystokyo.paper.exception.ServerException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the wrapped exception that was thrown.

 @return Exception thrown]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called whenever an exception is thrown in a recoverable section of the server.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.ServerExceptionEvent -->
  <!-- start class com.destroystokyo.paper.event.server.ServerTickEndEvent -->
  <class name="ServerTickEndEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerTickEndEvent" type="int, double, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTickNumber" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return What tick this was since start (first tick = 1)]]>
      </doc>
    </method>
    <method name="getTickDuration" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Time in milliseconds of how long this tick took]]>
      </doc>
    </method>
    <method name="getTimeRemaining" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Amount of nanoseconds remaining before the next tick should start.

 If this value is negative, then that means the server has exceeded the tick time limit and TPS has been lost.

 Method will continously return the updated time remaining value. (return value is not static)

 @return Amount of nanoseconds remaining before the next tick should start]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the server has finished ticking the main loop]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.ServerTickEndEvent -->
  <!-- start class com.destroystokyo.paper.event.server.ServerTickStartEvent -->
  <class name="ServerTickStartEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerTickStartEvent" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTickNumber" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return What tick this is going be since start (first tick = 1)]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.ServerTickStartEvent -->
  <!-- start class com.destroystokyo.paper.event.server.WhitelistToggleEvent -->
  <class name="WhitelistToggleEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WhitelistToggleEvent" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether whitelist is going to be enabled or not

 @return Whether whitelist is going to be enabled or not]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is fired when whitelist is toggled

 @author Mark Vainomaa]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.event.server.WhitelistToggleEvent -->
</package>
<package name="com.destroystokyo.paper.exception">
  <!-- start class com.destroystokyo.paper.exception.ServerCommandException -->
  <class name="ServerCommandException" extends="com.destroystokyo.paper.exception.ServerException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerCommandException" type="java.lang.String, java.lang.Throwable, org.bukkit.command.Command, org.bukkit.command.CommandSender, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerCommandException" type="java.lang.Throwable, org.bukkit.command.Command, org.bukkit.command.CommandSender, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerCommandException" type="java.lang.String, java.lang.Throwable, boolean, boolean, org.bukkit.command.Command, org.bukkit.command.CommandSender, java.lang.String[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getCommand" return="org.bukkit.command.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the command which threw the exception

 @return exception throwing command]]>
      </doc>
    </method>
    <method name="getCommandSender" return="org.bukkit.command.CommandSender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the command sender which executed the command request

 @return command sender of exception thrown command request]]>
      </doc>
    </method>
    <method name="getArguments" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the arguments which threw the exception for the command

 @return arguments of exception thrown command request]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown when a command throws an exception]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerCommandException -->
  <!-- start class com.destroystokyo.paper.exception.ServerEventException -->
  <class name="ServerEventException" extends="com.destroystokyo.paper.exception.ServerPluginException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerEventException" type="java.lang.String, java.lang.Throwable, org.bukkit.plugin.Plugin, org.bukkit.event.Listener, org.bukkit.event.Event"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerEventException" type="java.lang.Throwable, org.bukkit.plugin.Plugin, org.bukkit.event.Listener, org.bukkit.event.Event"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerEventException" type="java.lang.String, java.lang.Throwable, boolean, boolean, org.bukkit.plugin.Plugin, org.bukkit.event.Listener, org.bukkit.event.Event"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getListener" return="org.bukkit.event.Listener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the listener which threw the exception

 @return event listener]]>
      </doc>
    </method>
    <method name="getEvent" return="org.bukkit.event.Event"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the event which caused the exception

 @return event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exception thrown when a server event listener throws an exception]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerEventException -->
  <!-- start class com.destroystokyo.paper.exception.ServerException -->
  <class name="ServerException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerException" type="java.lang.String, java.lang.Throwable, boolean, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Wrapper exception for all exceptions that are thrown by the server.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerException -->
  <!-- start class com.destroystokyo.paper.exception.ServerInternalException -->
  <class name="ServerInternalException" extends="com.destroystokyo.paper.exception.ServerException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerInternalException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerInternalException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerInternalException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerInternalException" type="java.lang.String, java.lang.Throwable, boolean, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="reportInternalException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
    </method>
    <doc>
    <![CDATA[Thrown when the internal server throws a recoverable exception.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerInternalException -->
  <!-- start class com.destroystokyo.paper.exception.ServerPluginEnableDisableException -->
  <class name="ServerPluginEnableDisableException" extends="com.destroystokyo.paper.exception.ServerPluginException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerPluginEnableDisableException" type="java.lang.String, java.lang.Throwable, org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerPluginEnableDisableException" type="java.lang.Throwable, org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerPluginEnableDisableException" type="java.lang.String, java.lang.Throwable, boolean, boolean, org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown whenever there is an exception with any enabling or disabling of plugins.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerPluginEnableDisableException -->
  <!-- start class com.destroystokyo.paper.exception.ServerPluginException -->
  <class name="ServerPluginException" extends="com.destroystokyo.paper.exception.ServerException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerPluginException" type="java.lang.String, java.lang.Throwable, org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerPluginException" type="java.lang.Throwable, org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerPluginException" type="java.lang.String, java.lang.Throwable, boolean, boolean, org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getResponsiblePlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin which is directly responsible for the exception being thrown

 @return plugin which is responsible for the exception throw]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Wrapper exception for all cases to which a plugin can be immediately blamed for]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerPluginException -->
  <!-- start class com.destroystokyo.paper.exception.ServerPluginMessageException -->
  <class name="ServerPluginMessageException" extends="com.destroystokyo.paper.exception.ServerPluginException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerPluginMessageException" type="java.lang.String, java.lang.Throwable, org.bukkit.plugin.Plugin, org.bukkit.entity.Player, java.lang.String, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerPluginMessageException" type="java.lang.Throwable, org.bukkit.plugin.Plugin, org.bukkit.entity.Player, java.lang.String, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerPluginMessageException" type="java.lang.String, java.lang.Throwable, boolean, boolean, org.bukkit.plugin.Plugin, org.bukkit.entity.Player, java.lang.String, byte[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getChannel" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the channel to which the error occurred from recieving data from

 @return exception channel]]>
      </doc>
    </method>
    <method name="getData" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the data to which the error occurred from

 @return exception data]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player which the plugin message causing the exception originated from

 @return exception player]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown when an incoming plugin message channel throws an exception]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerPluginMessageException -->
  <!-- start class com.destroystokyo.paper.exception.ServerSchedulerException -->
  <class name="ServerSchedulerException" extends="com.destroystokyo.paper.exception.ServerPluginException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerSchedulerException" type="java.lang.String, java.lang.Throwable, org.bukkit.scheduler.BukkitTask"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerSchedulerException" type="java.lang.Throwable, org.bukkit.scheduler.BukkitTask"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerSchedulerException" type="java.lang.String, java.lang.Throwable, boolean, boolean, org.bukkit.scheduler.BukkitTask"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getTask" return="org.bukkit.scheduler.BukkitTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the task which threw the exception

 @return exception throwing task]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown when a plugin's scheduler fails with an exception]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerSchedulerException -->
  <!-- start class com.destroystokyo.paper.exception.ServerTabCompleteException -->
  <class name="ServerTabCompleteException" extends="com.destroystokyo.paper.exception.ServerCommandException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerTabCompleteException" type="java.lang.String, java.lang.Throwable, org.bukkit.command.Command, org.bukkit.command.CommandSender, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerTabCompleteException" type="java.lang.Throwable, org.bukkit.command.Command, org.bukkit.command.CommandSender, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerTabCompleteException" type="java.lang.String, java.lang.Throwable, boolean, boolean, org.bukkit.command.Command, org.bukkit.command.CommandSender, java.lang.String[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Called when a tab-complete request throws an exception]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.exception.ServerTabCompleteException -->
</package>
<package name="com.destroystokyo.paper.inventory">
  <!-- start class com.destroystokyo.paper.inventory.ItemStackRecipeChoice -->
  <class name="ItemStackRecipeChoice" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Draft API">
    <implements name="org.bukkit.inventory.RecipeChoice"/>
    <constructor name="ItemStackRecipeChoice" type="org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ItemStackRecipeChoice" type="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.inventory.RecipeChoice"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="test" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <field name="choices" type="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Allows crafting Items that require full matching itemstacks to complete the recipe for custom items
 @deprecated Draft API]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.inventory.ItemStackRecipeChoice -->
</package>
<package name="com.destroystokyo.paper.inventory.meta">
  <!-- start interface com.destroystokyo.paper.inventory.meta.ArmorStandMeta -->
  <interface name="ArmorStandMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="isInvisible" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the ArmorStand should be invisible when spawned

 @return true if this should be invisible]]>
      </doc>
    </method>
    <method name="hasNoBasePlate" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ArmorStand should have no base plate when spawned

 @return true if it will not have a base plate]]>
      </doc>
    </method>
    <method name="shouldShowArms" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ArmorStand should show arms when spawned

 @return true if it will show arms]]>
      </doc>
    </method>
    <method name="isSmall" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ArmorStand will be small when spawned

 @return true if it will be small]]>
      </doc>
    </method>
    <method name="isMarker" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ArmorStand will be a marker when spawned
 The exact details of this flag are an implementation detail

 @return true if it will be a marker]]>
      </doc>
    </method>
    <method name="setInvisible"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="invisible" type="boolean"/>
      <doc>
      <![CDATA[Sets that this ArmorStand should be invisible when spawned

 @param invisible true if set invisible]]>
      </doc>
    </method>
    <method name="setNoBasePlate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="noBasePlate" type="boolean"/>
      <doc>
      <![CDATA[Sets that this ArmorStand should have no base plate when spawned

 @param noBasePlate true if no base plate]]>
      </doc>
    </method>
    <method name="setShowArms"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="showArms" type="boolean"/>
      <doc>
      <![CDATA[Sets that this ArmorStand should show arms when spawned

 @param showArms true if show arms]]>
      </doc>
    </method>
    <method name="setSmall"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="small" type="boolean"/>
      <doc>
      <![CDATA[Sets that this ArmorStand should be small when spawned

 @param small true if small]]>
      </doc>
    </method>
    <method name="setMarker"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="boolean"/>
      <doc>
      <![CDATA[Sets that this ArmorStand should be a marker when spawned
 The exact details of this flag are an implementation detail

 @param marker true if a marker]]>
      </doc>
    </method>
  </interface>
  <!-- end interface com.destroystokyo.paper.inventory.meta.ArmorStandMeta -->
</package>
<package name="com.destroystokyo.paper.loottable">
  <!-- start interface com.destroystokyo.paper.loottable.LootableBlockInventory -->
  <interface name="LootableBlockInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.destroystokyo.paper.loottable.LootableInventory"/>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block that is lootable
 @return The Block]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Inventory that can generate loot, such as Chests inside of Fortresses and Mineshafts]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.loottable.LootableBlockInventory -->
  <!-- start interface com.destroystokyo.paper.loottable.LootableEntityInventory -->
  <interface name="LootableEntityInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.destroystokyo.paper.loottable.LootableInventory"/>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that is lootable
 @return The Entity]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Inventory that can generate loot, such as Minecarts inside of Mineshafts]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.loottable.LootableEntityInventory -->
  <!-- start interface com.destroystokyo.paper.loottable.LootableInventory -->
  <interface name="LootableInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.loot.Lootable"/>
    <method name="isRefillEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server owners have to enable whether or not an object in a world should refill

 @return If the world this inventory is currently in has Replenishable Lootables enabled]]>
      </doc>
    </method>
    <method name="hasBeenFilled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether or not this object has ever been filled
 @return Has ever been filled]]>
      </doc>
    </method>
    <method name="hasPlayerLooted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Has this player ever looted this block
 @param player The player to check
 @return Whether or not this player has looted this block]]>
      </doc>
    </method>
    <method name="hasPlayerLooted" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="java.util.UUID"/>
      <doc>
      <![CDATA[Has this player ever looted this block
 @param player The player to check
 @return Whether or not this player has looted this block]]>
      </doc>
    </method>
    <method name="getLastLooted" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Gets the timestamp, in milliseconds, of when the player last looted this object

 @param player The player to check
 @return Timestamp last looted, or null if player has not looted this object]]>
      </doc>
    </method>
    <method name="getLastLooted" return="java.lang.Long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets the timestamp, in milliseconds, of when the player last looted this object

 @param player The player to check
 @return Timestamp last looted, or null if player has not looted this object]]>
      </doc>
    </method>
    <method name="setHasPlayerLooted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <param name="looted" type="boolean"/>
      <doc>
      <![CDATA[Change the state of whether or not a player has looted this block
 @param player The player to change state for
 @param looted true to add player to looted list, false to remove
 @return The previous state of whether the player had looted this or not]]>
      </doc>
    </method>
    <method name="setHasPlayerLooted" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="java.util.UUID"/>
      <param name="looted" type="boolean"/>
      <doc>
      <![CDATA[Change the state of whether or not a player has looted this block
 @param player The player to change state for
 @param looted true to add player to looted list, false to remove
 @return The previous state of whether the player had looted this or not]]>
      </doc>
    </method>
    <method name="hasPendingRefill" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns Whether or not this object has been filled and now has a pending refill
 @return Has pending refill]]>
      </doc>
    </method>
    <method name="getLastFilled" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the timestamp in milliseconds that the Lootable object was last refilled

 @return -1 if it was never refilled, or timestamp in milliseconds]]>
      </doc>
    </method>
    <method name="getNextRefill" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the timestamp in milliseconds that the Lootable object will refill

 @return -1 if it is not scheduled for refill, or timestamp in milliseconds]]>
      </doc>
    </method>
    <method name="setNextRefill" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="refillAt" type="long"/>
      <doc>
      <![CDATA[Sets the timestamp in milliseconds of the next refill for this object

 @param refillAt timestamp in milliseconds. -1 to clear next refill
 @return The previous scheduled time to refill, or -1 if was not scheduled]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Inventory that contains a Loot Table associated to it that will
 automatically fill on first open.

 A new feature and API is provided to support automatically refreshing the contents
 of the inventory based on that Loot Table after a configurable amount of time has passed.

 The behavior of how the Inventory is filled based on the loot table may vary based
 on Minecraft versions and the Loot Table feature.]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.loottable.LootableInventory -->
  <!-- start class com.destroystokyo.paper.loottable.LootableInventoryReplenishEvent -->
  <class name="LootableInventoryReplenishEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="LootableInventoryReplenishEvent" type="org.bukkit.entity.Player, com.destroystokyo.paper.loottable.LootableInventory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInventory" return="com.destroystokyo.paper.loottable.LootableInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.loottable.LootableInventoryReplenishEvent -->
</package>
<package name="com.destroystokyo.paper.network">
  <!-- start interface com.destroystokyo.paper.network.NetworkClient -->
  <interface name="NetworkClient"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAddress" return="java.net.InetSocketAddress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the socket address of the client.

 @return The client's socket address]]>
      </doc>
    </method>
    <method name="getProtocolVersion" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the protocol version of the client.

 @return The client's protocol version, or {@code -1} if unknown
 @see <a href="http://wiki.vg/Protocol_version_numbers">List of protocol
     version numbers</a>]]>
      </doc>
    </method>
    <method name="getVirtualHost" return="java.net.InetSocketAddress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the virtual host the client is connected to.

 <p>The virtual host refers to the hostname/port the client used to
 connect to the server.</p>

 @return The client's virtual host, or {@code null} if unknown]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a client connected to the server.]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.network.NetworkClient -->
  <!-- start interface com.destroystokyo.paper.network.StatusClient -->
  <interface name="StatusClient"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.destroystokyo.paper.network.NetworkClient"/>
    <method name="isLegacy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the client is using an older version that doesn't
 support all of the features in {@link PaperServerListPingEvent}.

 <p>For Vanilla, this returns {@code true} for all clients older than 1.7.</p>

 @return {@code true} if the client is using legacy ping]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a client requesting the current status from the server (e.g. from
 the server list).

 @see PaperServerListPingEvent]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.network.StatusClient -->
</package>
<package name="com.destroystokyo.paper.profile">
  <!-- start interface com.destroystokyo.paper.profile.PlayerProfile -->
  <interface name="PlayerProfile"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The players name, if set]]>
      </doc>
    </method>
    <method name="setName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets this profiles Name

 @param name The new Name
 @return The previous Name]]>
      </doc>
    </method>
    <method name="getId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The players unique identifier, if set]]>
      </doc>
    </method>
    <method name="setId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Sets this profiles UUID

 @param uuid The new UUID
 @return The previous UUID]]>
      </doc>
    </method>
    <method name="getProperties" return="java.util.Set&lt;com.destroystokyo.paper.profile.ProfileProperty&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return A Mutable set of this players properties, such as textures.
 Values specified here are subject to implementation details.]]>
      </doc>
    </method>
    <method name="hasProperty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <doc>
      <![CDATA[Check if the Profile has the specified property
 @param property Property name to check
 @return If the property is set]]>
      </doc>
    </method>
    <method name="setProperty"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="com.destroystokyo.paper.profile.ProfileProperty"/>
      <doc>
      <![CDATA[Sets a property. If the property already exists, the previous one will be replaced
 @param property Property to set.]]>
      </doc>
    </method>
    <method name="setProperties"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Collection&lt;com.destroystokyo.paper.profile.ProfileProperty&gt;"/>
      <doc>
      <![CDATA[Sets multiple properties. If any of the set properties already exist, it will be replaced
 @param properties The properties to set]]>
      </doc>
    </method>
    <method name="removeProperty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes a specific property from this profile
 @param property The property to remove
 @return If a property was removed]]>
      </doc>
    </method>
    <method name="removeProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="com.destroystokyo.paper.profile.ProfileProperty"/>
      <doc>
      <![CDATA[Removes a specific property from this profile
 @param property The property to remove
 @return If a property was removed]]>
      </doc>
    </method>
    <method name="removeProperties" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Collection&lt;com.destroystokyo.paper.profile.ProfileProperty&gt;"/>
      <doc>
      <![CDATA[Removes all properties in the collection
 @param properties The properties to remove
 @return If any property was removed]]>
      </doc>
    </method>
    <method name="clearProperties"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all properties on this profile]]>
      </doc>
    </method>
    <method name="isComplete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If the profile is now complete (has UUID and Name)]]>
      </doc>
    </method>
    <method name="completeFromCache" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Like {@link #complete(boolean)} but will try only from cache, and not make network calls
 Does not account for textures.

 @return If the profile is now complete (has UUID and Name)]]>
      </doc>
    </method>
    <method name="completeFromCache" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="onlineMode" type="boolean"/>
      <doc>
      <![CDATA[Like {@link #complete(boolean)} but will try only from cache, and not make network calls
 Does not account for textures.

 @param onlineMode Treat this as online mode or not
 @return If the profile is now complete (has UUID and Name)]]>
      </doc>
    </method>
    <method name="completeFromCache" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookupUUID" type="boolean"/>
      <param name="onlineMode" type="boolean"/>
      <doc>
      <![CDATA[Like {@link #complete(boolean)} but will try only from cache, and not make network calls
 Does not account for textures.

 @param lookupUUID If only name is supplied, should we do a UUID lookup
 @param onlineMode Treat this as online mode or not
 @return If the profile is now complete (has UUID and Name)]]>
      </doc>
    </method>
    <method name="complete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this profile is not complete, then make the API call to complete it.
 This is a blocking operation and should be done asynchronously.

 This will also complete textures. If you do not want to load textures, use {{@link #complete(boolean)}}
 @return If the profile is now complete (has UUID and Name) (if you get rate limited, this operation may fail)]]>
      </doc>
    </method>
    <method name="complete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="textures" type="boolean"/>
      <doc>
      <![CDATA[If this profile is not complete, then make the API call to complete it.
 This is a blocking operation and should be done asynchronously.

 Optionally will also fill textures.

 Online mode will be automatically determined
 @param textures controls if we should fill the profile with texture properties
 @return If the profile is now complete (has UUID and Name) (if you get rate limited, this operation may fail)]]>
      </doc>
    </method>
    <method name="complete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="textures" type="boolean"/>
      <param name="onlineMode" type="boolean"/>
      <doc>
      <![CDATA[If this profile is not complete, then make the API call to complete it.
 This is a blocking operation and should be done asynchronously.

 Optionally will also fill textures.
 @param textures controls if we should fill the profile with texture properties
 @param onlineMode Treat this server as online mode or not
 @return If the profile is now complete (has UUID and Name) (if you get rate limited, this operation may fail)]]>
      </doc>
    </method>
    <method name="hasTextures" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether or not this Profile has textures associated to it
 @return If has a textures property]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a players profile for the game, such as UUID, Name, and textures.]]>
    </doc>
  </interface>
  <!-- end interface com.destroystokyo.paper.profile.PlayerProfile -->
  <!-- start class com.destroystokyo.paper.profile.ProfileProperty -->
  <class name="ProfileProperty" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProfileProperty" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProfileProperty" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The property name, ie "textures"]]>
      </doc>
    </method>
    <method name="getValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The property value, likely to be base64 encoded]]>
      </doc>
    </method>
    <method name="getSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return A signature from Mojang for signed properties]]>
      </doc>
    </method>
    <method name="isSigned" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If this property has a signature or not]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a property on a {@link PlayerProfile}]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.profile.ProfileProperty -->
</package>
<package name="com.destroystokyo.paper.util">
  <!-- start class com.destroystokyo.paper.util.SneakyThrow -->
  <class name="SneakyThrow" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SneakyThrow"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sneaky"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Throwable"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.util.SneakyThrow -->
  <!-- start interface com.destroystokyo.paper.util.VersionFetcher -->
  <interface name="VersionFetcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getCacheTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Amount of time to cache results for in milliseconds
 <p>
 Negative values will never cache.

 @return cache time]]>
      </doc>
    </method>
    <method name="getVersionMessage" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverVersion" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the version message to cache and show to command senders. Multiple messages can be sent using newlines (\n)
 in the string. The string will be split on these newlines and sent as individual messages.
 <p>
 NOTE: This is run in a new thread separate from that of the command processing thread

 @param serverVersion the current version of the server (will match {@link Bukkit#getVersion()})
 @return the message to show when requesting a version]]>
      </doc>
    </method>
  </interface>
  <!-- end interface com.destroystokyo.paper.util.VersionFetcher -->
  <!-- start class com.destroystokyo.paper.util.VersionFetcher.DummyVersionFetcher -->
  <class name="VersionFetcher.DummyVersionFetcher" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.destroystokyo.paper.util.VersionFetcher"/>
    <constructor name="DummyVersionFetcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCacheTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersionMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverVersion" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.util.VersionFetcher.DummyVersionFetcher -->
</package>
<package name="com.destroystokyo.paper.utils">
  <!-- start class com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue -->
  <class name="CachedSizeConcurrentLinkedQueue" extends="java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CachedSizeConcurrentLinkedQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue -->
  <!-- start class com.destroystokyo.paper.utils.PaperPluginLogger -->
  <class name="PaperPluginLogger" extends="java.util.logging.Logger"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getLogger" return="java.util.logging.Logger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="description" type="org.bukkit.plugin.PluginDescriptionFile"/>
    </method>
    <method name="setParent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="java.util.logging.Logger"/>
    </method>
    <doc>
    <![CDATA[Prevents plugins (e.g. Essentials) from changing the parent of the plugin logger.]]>
    </doc>
  </class>
  <!-- end class com.destroystokyo.paper.utils.PaperPluginLogger -->
  <!-- start class com.destroystokyo.paper.utils.UnsafeUtils -->
  <class name="UnsafeUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isUnsafeSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnsafe" return="sun.misc.Unsafe"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.destroystokyo.paper.utils.UnsafeUtils -->
</package>
<package name="io.papermc.paper.event.block">
  <!-- start class io.papermc.paper.event.block.BellRingEvent -->
  <class name="BellRingEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BellRingEvent" type="org.bukkit.block.Block, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that rang the bell.

 @return the ringer or null if none]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a bell is rung.]]>
    </doc>
  </class>
  <!-- end class io.papermc.paper.event.block.BellRingEvent -->
</package>
<package name="io.papermc.paper.world">
  <!-- start class io.papermc.paper.world.MoonPhase -->
  <class name="MoonPhase" extends="java.lang.Enum&lt;io.papermc.paper.world.MoonPhase&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="io.papermc.paper.world.MoonPhase[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="io.papermc.paper.world.MoonPhase"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getPhase" return="io.papermc.paper.world.MoonPhase"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="day" type="long"/>
    </method>
  </class>
  <!-- end class io.papermc.paper.world.MoonPhase -->
</package>
<package name="org.bukkit">
  <!-- start class org.bukkit.Art -->
  <class name="Art" extends="java.lang.Enum&lt;org.bukkit.Art&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.Art[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Art"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getBlockWidth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the width of the painting, in blocks

 @return The width of the painting, in blocks]]>
      </doc>
    </method>
    <method name="getBlockHeight" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the height of the painting, in blocks

 @return The height of the painting, in blocks]]>
      </doc>
    </method>
    <method name="getId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Get the ID of this painting.

 @return The ID of this painting
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getById" return="org.bukkit.Art"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Get a painting by its numeric ID

 @param id The ID
 @return The painting
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByName" return="org.bukkit.Art"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a painting by its unique name
 <p>
 This ignores underscores and capitalization

 @param name The name
 @return The painting]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the art on a painting]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Art -->
  <!-- start class org.bukkit.Axis -->
  <class name="Axis" extends="java.lang.Enum&lt;org.bukkit.Axis&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Axis[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Axis"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents a mutually perpendicular axis in 3D Cartesian coordinates. In
 Minecraft the x, z axes lie in the horizontal plane, whilst the y axis points
 upwards.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Axis -->
  <!-- start interface org.bukkit.BanEntry -->
  <interface name="BanEntry"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTarget" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the target involved. This may be in the form of an IP or a player
 name.

 @return the target name or IP address]]>
      </doc>
    </method>
    <method name="getCreated" return="java.util.Date"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the date this ban entry was created.

 @return the creation date]]>
      </doc>
    </method>
    <method name="setCreated"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="created" type="java.util.Date"/>
      <doc>
      <![CDATA[Sets the date this ban entry was created.

 @param created the new created date, cannot be null
 @see #save() saving changes]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source of this ban.
 <p>
 Note: A source is considered any String, although this is generally a
 player name.

 @return the source of the ban]]>
      </doc>
    </method>
    <method name="setSource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the source of this ban.
 <p>
 Note: A source is considered any String, although this is generally a
 player name.

 @param source the new source where null values become empty strings
 @see #save() saving changes]]>
      </doc>
    </method>
    <method name="getExpiration" return="java.util.Date"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the date this ban expires on, or null for no defined end date.

 @return the expiration date]]>
      </doc>
    </method>
    <method name="setExpiration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expiration" type="java.util.Date"/>
      <doc>
      <![CDATA[Sets the date this ban expires on. Null values are considered
 "infinite" bans.

 @param expiration the new expiration date, or null to indicate an
     eternity
 @see #save() saving changes]]>
      </doc>
    </method>
    <method name="getReason" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason for this ban.

 @return the ban reason, or null if not set]]>
      </doc>
    </method>
    <method name="setReason"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the reason for this ban. Reasons must not be null.

 @param reason the new reason, null values assume the implementation
     default
 @see #save() saving changes]]>
      </doc>
    </method>
    <method name="save"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Saves the ban entry, overwriting any previous data in the ban list.
 <p>
 Saving the ban entry of an unbanned player will cause the player to be
 banned once again.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A single entry from a ban list. This may represent either a player ban or
 an IP ban.
 <p>
 Ban entries include the following properties:
 <table border=1>
 <caption>Property information</caption>
 <tr>
     <th>Property</th>
     <th>Description</th>
 </tr><tr>
     <td>Target Name / IP Address</td>
     <td>The target name or IP address</td>
 </tr><tr>
     <td>Creation Date</td>
     <td>The creation date of the ban</td>
 </tr><tr>
     <td>Source</td>
     <td>The source of the ban, such as a player, console, plugin, etc</td>
 </tr><tr>
     <td>Expiration Date</td>
     <td>The expiration date of the ban</td>
 </tr><tr>
     <td>Reason</td>
     <td>The reason for the ban</td>
 </tr>
 </table>
 <p>
 Unsaved information is not automatically written to the implementation's
 ban list, instead, the {@link #save()} method must be called to write the
 changes to the ban list. If this ban entry has expired (such as from an
 unban) and is no longer found in the list, the {@link #save()} call will
 re-add it to the list, therefore banning the victim specified.
 <p>
 Likewise, changes to the associated {@link BanList} or other entries may or
 may not be reflected in this entry.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.BanEntry -->
  <!-- start interface org.bukkit.BanList -->
  <interface name="BanList"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getBanEntry" return="org.bukkit.BanEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a {@link BanEntry} by target.

 @param target entry parameter to search for
 @return the corresponding entry, or null if none found]]>
      </doc>
    </method>
    <method name="addBan" return="org.bukkit.BanEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a ban to the this list. If a previous ban exists, this will
 update the previous entry.

 @param target the target of the ban
 @param reason reason for the ban, null indicates implementation default
 @param expires date for the ban's expiration (unban), or null to imply
     forever
 @param source source of the ban, null indicates implementation default
 @return the entry for the newly created ban, or the entry for the
     (updated) previous ban]]>
      </doc>
    </method>
    <method name="getBanEntries" return="java.util.Set&lt;org.bukkit.BanEntry&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing every {@link BanEntry} in this list.

 @return an immutable set containing every entry tracked by this list]]>
      </doc>
    </method>
    <method name="isBanned" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets if a {@link BanEntry} exists for the target, indicating an active
 ban status.

 @param target the target to find
 @return true if a {@link BanEntry} exists for the name, indicating an
     active ban status, false otherwise]]>
      </doc>
    </method>
    <method name="pardon"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes the specified target from this list, therefore indicating a
 "not banned" status.

 @param target the target to remove from this list]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A ban list, containing bans of some {@link Type}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.BanList -->
  <!-- start class org.bukkit.BanList.Type -->
  <class name="BanList.Type" extends="java.lang.Enum&lt;org.bukkit.BanList.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.BanList.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.BanList.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents a ban-type that a {@link BanList} may track.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.BanList.Type -->
  <!-- start interface org.bukkit.BlockChangeDelegate -->
  <interface name="BlockChangeDelegate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setBlockData" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <param name="blockData" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Set a block data at the specified coordinates.

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @param blockData Block data
 @return true if the block was set successfully]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get the block data at the location.

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @return The block data]]>
      </doc>
    </method>
    <method name="getHeight" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the height of the world.

 @return Height of the world]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Checks if the specified block is empty (air) or not.

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @return True if the block is considered empty.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A delegate for handling block changes. This serves as a direct interface
 between generation algorithms in the server implementation and utilizing
 code.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.BlockChangeDelegate -->
  <!-- start class org.bukkit.Bukkit -->
  <class name="Bukkit" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getServer" return="org.bukkit.Server"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current {@link Server} singleton

 @return Server instance being ran]]>
      </doc>
    </method>
    <method name="setServer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="server" type="org.bukkit.Server"/>
      <doc>
      <![CDATA[Attempts to set the {@link Server} singleton.
 <p>
 This cannot be done if the Server is already set.

 @param server Server instance]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of this server implementation.

 @return name of this server implementation]]>
      </doc>
    </method>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the version string of this server implementation.

 @return version of this server implementation]]>
      </doc>
    </method>
    <method name="getBukkitVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Bukkit version that this server is running.

 @return version of Bukkit]]>
      </doc>
    </method>
    <method name="getMinecraftVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the version of game this server implements

 @return version of game]]>
      </doc>
    </method>
    <method name="getOnlinePlayers" return="java.util.Collection&lt;? extends org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a view of all currently logged in players. This {@linkplain
 Collections#unmodifiableCollection(Collection) view} is a reused
 object, making some operations like {@link Collection#size()}
 zero-allocation.
 <p>
 The collection is a view backed by the internal representation, such
 that, changes to the internal state of the server will be reflected
 immediately. However, the reuse of the returned collection (identity)
 is not strictly guaranteed for future or all implementations. Casting
 the collection, or relying on interface implementations (like {@link
 Serializable} or {@link List}), is deprecated.
 <p>
 Iteration behavior is undefined outside of self-contained main-thread
 uses. Normal and immediate iterator use without consequences that
 affect the collection are fully supported. The effects following
 (non-exhaustive) {@link Entity#teleport(Location) teleportation},
 {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
 String) kicking} are undefined. Any use of this collection from
 asynchronous threads is unsafe.
 <p>
 For safe consequential iteration or mimicking the old array behavior,
 using {@link Collection#toArray(Object[])} is recommended. For making
 snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.

 @return a view of currently online players.]]>
      </doc>
    </method>
    <method name="getMaxPlayers" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum amount of players which can login to this server.

 @return the amount of players this server allows]]>
      </doc>
    </method>
    <method name="setMaxPlayers"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxPlayers" type="int"/>
      <doc>
      <![CDATA[Set the maximum amount of players which can login to this server.

 @param maxPlayers the amount of players this server allows]]>
      </doc>
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the game port that the server runs on.

 @return the port number of this server]]>
      </doc>
    </method>
    <method name="getViewDistance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the view distance from this server.

 @return the view distance from this server.]]>
      </doc>
    </method>
    <method name="getIp" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the IP that this server is bound to, or empty string if not
 specified.

 @return the IP string that this server is bound to, otherwise empty
     string]]>
      </doc>
    </method>
    <method name="getWorldType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get world type (level-type setting) for default world.

 @return the value of level-type (e.g. DEFAULT, FLAT, DEFAULT_1_1)]]>
      </doc>
    </method>
    <method name="getGenerateStructures" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get generate-structures setting.

 @return true if structure generation is enabled, false otherwise]]>
      </doc>
    </method>
    <method name="getAllowEnd" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this server allows the End or not.

 @return whether this server allows the End or not]]>
      </doc>
    </method>
    <method name="getAllowNether" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this server allows the Nether or not.

 @return whether this server allows the Nether or not]]>
      </doc>
    </method>
    <method name="hasWhitelist" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this server has a whitelist or not.

 @return whether this server has a whitelist or not]]>
      </doc>
    </method>
    <method name="setWhitelist"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets if the server is whitelisted.

 @param value true for whitelist on, false for off]]>
      </doc>
    </method>
    <method name="getWhitelistedPlayers" return="java.util.Set&lt;org.bukkit.OfflinePlayer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of whitelisted players.

 @return a set containing all whitelisted players]]>
      </doc>
    </method>
    <method name="reloadWhitelist"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reloads the whitelist from disk.]]>
      </doc>
    </method>
    <method name="broadcastMessage" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Broadcast a message to all players.
 <p>
 This is the same as calling {@link #broadcast(java.lang.String,
 java.lang.String)} to {@link Server#BROADCAST_CHANNEL_USERS}

 @param message the message
 @return the number of players]]>
      </doc>
    </method>
    <method name="broadcast"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Sends the component to all online players.

 @param component the component to send]]>
      </doc>
    </method>
    <method name="broadcast"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an array of components as a single message to all online players.

 @param components the components to send]]>
      </doc>
    </method>
    <method name="getUpdateFolder" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the update folder. The update folder is used to safely
 update plugins at the right moment on a plugin load.
 <p>
 The update folder name is relative to the plugins folder.

 @return the name of the update folder]]>
      </doc>
    </method>
    <method name="getUpdateFolderFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the update folder. The update folder is used to safely update
 plugins at the right moment on a plugin load.

 @return the update folder]]>
      </doc>
    </method>
    <method name="getConnectionThrottle" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the connection throttle setting.

 @return the value of the connection throttle setting]]>
      </doc>
    </method>
    <method name="getTicksPerAnimalSpawns" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets default ticks per animal spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn monsters
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn monsters
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, animal spawning will be disabled. We
 recommend using spawn-animals to control this instead.
 <p>
 Minecraft default: 400.

 @return the default ticks per animal spawns value]]>
      </doc>
    </method>
    <method name="getTicksPerMonsterSpawns" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per monster spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn monsters
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn monsters
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, monsters spawning will be disabled. We
 recommend using spawn-monsters to control this instead.
 <p>
 Minecraft default: 1.

 @return the default ticks per monsters spawn value]]>
      </doc>
    </method>
    <method name="getTicksPerWaterSpawns" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per water mob spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn water mobs
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn water mobs
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, water mobs spawning will be disabled.
 <p>
 Minecraft default: 1.

 @return the default ticks per water mobs spawn value]]>
      </doc>
    </method>
    <method name="getTicksPerAmbientSpawns" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per ambient mob spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn ambient mobs
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn ambient mobs
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, ambient mobs spawning will be disabled.
 <p>
 Minecraft default: 1.

 @return the default ticks per ambient mobs spawn value]]>
      </doc>
    </method>
    <method name="getTicksPerWaterAmbientSpawns" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per water ambient mob spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn water ambient mobs
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn water ambient mobs
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, ambient mobs spawning will be disabled.
 <p>
 Minecraft default: 1.

 @return the default ticks per water ambient mobs spawn value]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a player object by the given username.
 <p>
 This method may not return objects for offline players.

 @param name the name to look up
 @return a player if one was found, null otherwise]]>
      </doc>
    </method>
    <method name="getPlayerExact" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the player with the exact given name, case insensitive.

 @param name Exact name of the player to retrieve
 @return a player object if one was found, null otherwise]]>
      </doc>
    </method>
    <method name="matchPlayer" return="java.util.List&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Attempts to match any players with the given name, and returns a list
 of all possibly matches.
 <p>
 This list is not sorted in any particular order. If an exact match is
 found, the returned list will only contain a single result.

 @param name the (partial) name to match
 @return list of all possible players]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets the player with the given UUID.

 @param id UUID of the player to retrieve
 @return a player object if one was found, null otherwise]]>
      </doc>
    </method>
    <method name="getPlayerUniqueId" return="java.util.UUID"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="playerName" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the unique ID of the player currently known as the specified player name
 In Offline Mode, will return an Offline UUID

 @param playerName the player name to look up the unique ID for
 @return A UUID, or null if that player name is not registered with Minecraft and the server is in online mode]]>
      </doc>
    </method>
    <method name="getPluginManager" return="org.bukkit.plugin.PluginManager"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin manager for interfacing with plugins.

 @return a plugin manager for this Server instance]]>
      </doc>
    </method>
    <method name="getScheduler" return="org.bukkit.scheduler.BukkitScheduler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the scheduler for managing scheduled events.

 @return a scheduling service for this server]]>
      </doc>
    </method>
    <method name="getServicesManager" return="org.bukkit.plugin.ServicesManager"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a services manager.

 @return s services manager]]>
      </doc>
    </method>
    <method name="getWorlds" return="java.util.List&lt;org.bukkit.World&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of all worlds on this server.

 @return a list of worlds]]>
      </doc>
    </method>
    <method name="createWorld" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="creator" type="org.bukkit.WorldCreator"/>
      <doc>
      <![CDATA[Creates or loads a world with the given name using the specified
 options.
 <p>
 If the world is already loaded, it will just return the equivalent of
 getWorld(creator.name()).

 @param creator the options to use when creating the world
 @return newly created or loaded world]]>
      </doc>
    </method>
    <method name="unloadWorld" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="save" type="boolean"/>
      <doc>
      <![CDATA[Unloads a world with the given name.

 @param name Name of the world to unload
 @param save whether to save the chunks before unloading
 @return true if successful, false otherwise]]>
      </doc>
    </method>
    <method name="unloadWorld" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="save" type="boolean"/>
      <doc>
      <![CDATA[Unloads the given world.

 @param world the world to unload
 @param save whether to save the chunks before unloading
 @return true if successful, false otherwise]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the world with the given name.

 @param name the name of the world to retrieve
 @return a world with the given name, or null if none exists]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets the world from the given Unique ID.

 @param uid a unique-id of the world to retrieve
 @return a world with the given Unique ID, or null if none exists]]>
      </doc>
    </method>
    <method name="getMap" return="org.bukkit.map.MapView"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Gets the map from the given item ID.

 @param id the id of the map to get
 @return a map view if it exists, or null otherwise
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="createMap" return="org.bukkit.map.MapView"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Create a new map with an automatically assigned ID.

 @param world the world the map will belong to
 @return a newly created map view]]>
      </doc>
    </method>
    <method name="createExplorerMap" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="structureType" type="org.bukkit.StructureType"/>
      <doc>
      <![CDATA[Create a new explorer map targeting the closest nearby structure of a
 given {@link StructureType}.
 <br>
 This method uses implementation default values for radius and
 findUnexplored (usually 100, true).

 @param world the world the map will belong to
 @param location the origin location to find the nearest structure
 @param structureType the type of structure to find
 @return a newly created item stack

 @see World#locateNearestStructure(org.bukkit.Location,
      org.bukkit.StructureType, int, boolean)]]>
      </doc>
    </method>
    <method name="createExplorerMap" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="structureType" type="org.bukkit.StructureType"/>
      <param name="radius" type="int"/>
      <param name="findUnexplored" type="boolean"/>
      <doc>
      <![CDATA[Create a new explorer map targeting the closest nearby structure of a
 given {@link StructureType}.
 <br>
 This method uses implementation default values for radius and
 findUnexplored (usually 100, true).

 @param world the world the map will belong to
 @param location the origin location to find the nearest structure
 @param structureType the type of structure to find
 @param radius radius to search, see World#locateNearestStructure for more
               information
 @param findUnexplored whether to find unexplored structures
 @return the newly created item stack

 @see World#locateNearestStructure(org.bukkit.Location,
      org.bukkit.StructureType, int, boolean)]]>
      </doc>
    </method>
    <method name="reload"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reloads the server, refreshing settings and plugin information.]]>
      </doc>
    </method>
    <method name="reloadData"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload only the Minecraft data for the server. This includes custom
 advancements and loot tables.]]>
      </doc>
    </method>
    <method name="getLogger" return="java.util.logging.Logger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the primary logger associated with this server instance.

 @return Logger associated with this server]]>
      </doc>
    </method>
    <method name="getPluginCommand" return="org.bukkit.command.PluginCommand"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a {@link PluginCommand} with the given name or alias.

 @param name the name of the command to retrieve
 @return a plugin command if found, null otherwise]]>
      </doc>
    </method>
    <method name="savePlayers"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Writes loaded players to disk.]]>
      </doc>
    </method>
    <method name="dispatchCommand" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="commandLine" type="java.lang.String"/>
      <exception name="CommandException" type="org.bukkit.command.CommandException"/>
      <doc>
      <![CDATA[Dispatches a command on this server, and executes it if found.

 @param sender the apparent sender of the command
 @param commandLine the command + arguments. Example: <code>test abc
     123</code>
 @return returns false if no target is found
 @throws CommandException thrown when the executor for the given command
     fails with an unhandled exception]]>
      </doc>
    </method>
    <method name="addRecipe" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipe" type="org.bukkit.inventory.Recipe"/>
      <doc>
      <![CDATA[Adds a recipe to the crafting manager.

 @param recipe the recipe to add
 @return true if the recipe was added, false if it wasn't for some
     reason]]>
      </doc>
    </method>
    <method name="getRecipesFor" return="java.util.List&lt;org.bukkit.inventory.Recipe&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Get a list of all recipes for a given item. The stack size is ignored
 in comparisons. If the durability is -1, it will match any data value.

 @param result the item to match against recipe results
 @return a list of recipes with the given result]]>
      </doc>
    </method>
    <method name="getRecipe" return="org.bukkit.inventory.Recipe"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipeKey" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Get the {@link Recipe} for the given key.

 @param recipeKey the key of the recipe to return
 @return the recipe for the given key or null.]]>
      </doc>
    </method>
    <method name="recipeIterator" return="java.util.Iterator&lt;org.bukkit.inventory.Recipe&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an iterator through the list of crafting recipes.

 @return an iterator]]>
      </doc>
    </method>
    <method name="clearRecipes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the list of crafting recipes.]]>
      </doc>
    </method>
    <method name="resetRecipes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the list of crafting recipes to the default.]]>
      </doc>
    </method>
    <method name="removeRecipe" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Remove a recipe from the server.

 <b>Note that removing a recipe may cause permanent loss of data
 associated with that recipe (eg whether it has been discovered by
 players).</b>

 @param key NamespacedKey of recipe to remove.
 @return True if recipe was removed]]>
      </doc>
    </method>
    <method name="getCommandAliases" return="java.util.Map&lt;java.lang.String, java.lang.String[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of command aliases defined in the server properties.

 @return a map of aliases to command names]]>
      </doc>
    </method>
    <method name="getSpawnRadius" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the radius, in blocks, around each worlds spawn point to protect.

 @return spawn radius, or 0 if none]]>
      </doc>
    </method>
    <method name="setSpawnRadius"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the radius, in blocks, around each worlds spawn point to protect.

 @param value new spawn radius, or 0 if none]]>
      </doc>
    </method>
    <method name="getOnlineMode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the Server is in online mode or not.

 @return true if the server authenticates clients, false otherwise]]>
      </doc>
    </method>
    <method name="getAllowFlight" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this server allows flying or not.

 @return true if the server allows flight, false otherwise]]>
      </doc>
    </method>
    <method name="isHardcore" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the server is in hardcore mode or not.

 @return true if the server mode is hardcore, false otherwise]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shutdowns the server, stopping everything.]]>
      </doc>
    </method>
    <method name="broadcast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="permission" type="java.lang.String"/>
      <doc>
      <![CDATA[Broadcasts the specified message to every user with the given
 permission name.

 @param message message to broadcast
 @param permission the required permission {@link Permissible
     permissibles} must have to receive the broadcast
 @return number of message recipients]]>
      </doc>
    </method>
    <method name="getOfflinePlayer" return="org.bukkit.OfflinePlayer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Persistent storage of users should be by UUID as names are no longer
             unique past a single session.">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the player by the given name, regardless if they are offline or
 online.
 <p>
 This method may involve a blocking web request to get the UUID for the
 given name.
 <p>
 This will return an object even if the player does not exist. To this
 method, all players will exist.

 @deprecated Persistent storage of users should be by UUID as names are no longer
             unique past a single session.
 @param name the name the player to retrieve
 @return an offline player
 @see #getOfflinePlayer(java.util.UUID)]]>
      </doc>
    </method>
    <method name="getOfflinePlayer" return="org.bukkit.OfflinePlayer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets the player by the given UUID, regardless if they are offline or
 online.
 <p>
 This will return an object even if the player does not exist. To this
 method, all players will exist.

 @param id the UUID of the player to retrieve
 @return an offline player]]>
      </doc>
    </method>
    <method name="getIPBans" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all current IPs that are banned.

 @return a set containing banned IP addresses]]>
      </doc>
    </method>
    <method name="banIP"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.lang.String"/>
      <doc>
      <![CDATA[Bans the specified address from the server.

 @param address the IP address to ban]]>
      </doc>
    </method>
    <method name="unbanIP"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.lang.String"/>
      <doc>
      <![CDATA[Unbans the specified address from the server.

 @param address the IP address to unban]]>
      </doc>
    </method>
    <method name="getBannedPlayers" return="java.util.Set&lt;org.bukkit.OfflinePlayer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all banned players.

 @return a set containing banned players]]>
      </doc>
    </method>
    <method name="getBanList" return="org.bukkit.BanList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.BanList.Type"/>
      <doc>
      <![CDATA[Gets a ban list for the supplied type.
 <p>
 Bans by name are no longer supported and this method will return
 null when trying to request them. The replacement is bans by UUID.

 @param type the type of list to fetch, cannot be null
 @return a ban list of the specified type]]>
      </doc>
    </method>
    <method name="getOperators" return="java.util.Set&lt;org.bukkit.OfflinePlayer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all player operators.

 @return a set containing player operators]]>
      </doc>
    </method>
    <method name="getDefaultGameMode" return="org.bukkit.GameMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default {@link GameMode} for new players.

 @return the default game mode]]>
      </doc>
    </method>
    <method name="setDefaultGameMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="org.bukkit.GameMode"/>
      <doc>
      <![CDATA[Sets the default {@link GameMode} for new players.

 @param mode the new game mode]]>
      </doc>
    </method>
    <method name="getConsoleSender" return="org.bukkit.command.ConsoleCommandSender"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a {@link ConsoleCommandSender} that may be used as an input source
 for this server.

 @return a console command sender]]>
      </doc>
    </method>
    <method name="getWorldContainer" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the folder that contains all of the various {@link World}s.

 @return folder that contains all worlds]]>
      </doc>
    </method>
    <method name="getOfflinePlayers" return="org.bukkit.OfflinePlayer[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets every player that has ever played on this server.

 @return an array containing all previous players]]>
      </doc>
    </method>
    <method name="getMessenger" return="org.bukkit.plugin.messaging.Messenger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link Messenger} responsible for this server.

 @return messenger responsible for this server]]>
      </doc>
    </method>
    <method name="getHelpMap" return="org.bukkit.help.HelpMap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link HelpMap} providing help topics for this server.

 @return a help map for this server]]>
      </doc>
    </method>
    <method name="createInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.inventory.InventoryHolder"/>
      <param name="type" type="org.bukkit.event.inventory.InventoryType"/>
      <doc>
      <![CDATA[Creates an empty inventory with the specified type. If the type
 is {@link InventoryType#CHEST}, the new inventory has a size of 27;
 otherwise the new inventory has the normal size for its type.
 <br>
 {@link InventoryType#WORKBENCH} will not process crafting recipes if
 created with this method. Use
 {@link Player#openWorkbench(Location, boolean)} instead.
 <br>
 {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
 for possible enchanting results. Use
 {@link Player#openEnchanting(Location, boolean)} instead.

 @param owner the holder of the inventory, or null to indicate no holder
 @param type the type of inventory to create
 @return a new inventory
 @throws IllegalArgumentException if the {@link InventoryType} cannot be
 viewed.

 @see InventoryType#isCreatable()]]>
      </doc>
    </method>
    <method name="createInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.inventory.InventoryHolder"/>
      <param name="type" type="org.bukkit.event.inventory.InventoryType"/>
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates an empty inventory with the specified type and title. If the type
 is {@link InventoryType#CHEST}, the new inventory has a size of 27;
 otherwise the new inventory has the normal size for its type.<br>
 It should be noted that some inventory types do not support titles and
 may not render with said titles on the Minecraft client.
 <br>
 {@link InventoryType#WORKBENCH} will not process crafting recipes if
 created with this method. Use
 {@link Player#openWorkbench(Location, boolean)} instead.
 <br>
 {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
 for possible enchanting results. Use
 {@link Player#openEnchanting(Location, boolean)} instead.

 @param owner The holder of the inventory; can be null if there's no holder.
 @param type The type of inventory to create.
 @param title The title of the inventory, to be displayed when it is viewed.
 @return The new inventory.
 @throws IllegalArgumentException if the {@link InventoryType} cannot be
 viewed.

 @see InventoryType#isCreatable()]]>
      </doc>
    </method>
    <method name="createInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.inventory.InventoryHolder"/>
      <param name="size" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates an empty inventory of type {@link InventoryType#CHEST} with the
 specified size.

 @param owner the holder of the inventory, or null to indicate no holder
 @param size a multiple of 9 as the size of inventory to create
 @return a new inventory
 @throws IllegalArgumentException if the size is not a multiple of 9]]>
      </doc>
    </method>
    <method name="createInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.inventory.InventoryHolder"/>
      <param name="size" type="int"/>
      <param name="title" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates an empty inventory of type {@link InventoryType#CHEST} with the
 specified size and title.

 @param owner the holder of the inventory, or null to indicate no holder
 @param size a multiple of 9 as the size of inventory to create
 @param title the title of the inventory, displayed when inventory is
     viewed
 @return a new inventory
 @throws IllegalArgumentException if the size is not a multiple of 9]]>
      </doc>
    </method>
    <method name="createMerchant" return="org.bukkit.inventory.Merchant"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates an empty merchant.

 @param title the title of the corresponding merchant inventory, displayed
 when the merchant inventory is viewed
 @return a new merchant]]>
      </doc>
    </method>
    <method name="getMonsterSpawnLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of monsters that can spawn in a
 chunk.

 @return the monster spawn limit]]>
      </doc>
    </method>
    <method name="getAnimalSpawnLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of animals that can spawn in a
 chunk.

 @return the animal spawn limit]]>
      </doc>
    </method>
    <method name="getWaterAnimalSpawnLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of water animals that can spawn in
 a chunk.

 @return the water animal spawn limit]]>
      </doc>
    </method>
    <method name="getWaterAmbientSpawnLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of water ambient mobs that can spawn
 in a chunk.

 @return the water ambient spawn limit]]>
      </doc>
    </method>
    <method name="getAmbientSpawnLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of ambient mobs that can spawn in
 a chunk.

 @return the ambient spawn limit]]>
      </doc>
    </method>
    <method name="isPrimaryThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks the current thread against the expected primary thread for the
 server.
 <p>
 <b>Note:</b> this method should not be used to indicate the current
 synchronized state of the runtime. A current thread matching the main
 thread indicates that it is synchronized, but a mismatch <b>does not
 preclude</b> the same assumption.

 @return true if the current thread matches the expected primary thread,
     false otherwise]]>
      </doc>
    </method>
    <method name="getMotd" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the message that is displayed on the server list.

 @return the servers MOTD]]>
      </doc>
    </method>
    <method name="getShutdownMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default message that is displayed when the server is stopped.

 @return the shutdown message]]>
      </doc>
    </method>
    <method name="getWarningState" return="org.bukkit.Warning.WarningState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current warning state for the server.

 @return the configured warning state]]>
      </doc>
    </method>
    <method name="getItemFactory" return="org.bukkit.inventory.ItemFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the instance of the item factory (for {@link ItemMeta}).

 @return the item factory
 @see ItemFactory]]>
      </doc>
    </method>
    <method name="getScoreboardManager" return="org.bukkit.scoreboard.ScoreboardManager"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the instance of the scoreboard manager.
 <p>
 This will only exist after the first world has loaded.

 @return the scoreboard manager or null if no worlds are loaded.]]>
      </doc>
    </method>
    <method name="getServerIcon" return="org.bukkit.util.CachedServerIcon"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an instance of the server's default server-icon.

 @return the default server-icon; null values may be used by the
     implementation to indicate no defined icon, but this behavior is
     not guaranteed]]>
      </doc>
    </method>
    <method name="loadServerIcon" return="org.bukkit.util.CachedServerIcon"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Loads an image from a file, and returns a cached image for the specific
 server-icon.
 <p>
 Size and type are implementation defined. An incompatible file is
 guaranteed to throw an implementation-defined {@link Exception}.

 @param file the file to load the from
 @throws IllegalArgumentException if image is null
 @throws Exception if the image does not meet current server server-icon
     specifications
 @return a cached server-icon that can be used for a {@link
     ServerListPingEvent#setServerIcon(CachedServerIcon)}]]>
      </doc>
    </method>
    <method name="loadServerIcon" return="org.bukkit.util.CachedServerIcon"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="image" type="java.awt.image.BufferedImage"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Creates a cached server-icon for the specific image.
 <p>
 Size and type are implementation defined. An incompatible file is
 guaranteed to throw an implementation-defined {@link Exception}.

 @param image the image to use
 @throws IllegalArgumentException if image is null
 @throws Exception if the image does not meet current server
     server-icon specifications
 @return a cached server-icon that can be used for a {@link
     ServerListPingEvent#setServerIcon(CachedServerIcon)}]]>
      </doc>
    </method>
    <method name="setIdleTimeout"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threshold" type="int"/>
      <doc>
      <![CDATA[Set the idle kick timeout. Any players idle for the specified amount of
 time will be automatically kicked.
 <p>
 A value of 0 will disable the idle kick timeout.

 @param threshold the idle timeout in minutes]]>
      </doc>
    </method>
    <method name="getIdleTimeout" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the idle kick timeout.

 @return the idle timeout in minutes]]>
      </doc>
    </method>
    <method name="createChunkData" return="org.bukkit.generator.ChunkGenerator.ChunkData"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Create a ChunkData for use in a generator.

 See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}

 @param world the world to create the ChunkData for
 @return a new ChunkData for the world]]>
      </doc>
    </method>
    <method name="createVanillaChunkData" return="org.bukkit.generator.ChunkGenerator.ChunkData"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Create a ChunkData for use in a generator, that is populated by the vanilla generator for that world

 @param world the world to create the ChunkData for
 @param x the x coordinate of the chunk
 @param z the z coordinate of the chunk
 @return a new ChunkData for the world]]>
      </doc>
    </method>
    <method name="createBossBar" return="org.bukkit.boss.BossBar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
      <param name="color" type="org.bukkit.boss.BarColor"/>
      <param name="style" type="org.bukkit.boss.BarStyle"/>
      <param name="flags" type="org.bukkit.boss.BarFlag[]"/>
      <doc>
      <![CDATA[Creates a boss bar instance to display to players. The progress
 defaults to 1.0

 @param title the title of the boss bar
 @param color the color of the boss bar
 @param style the style of the boss bar
 @param flags an optional list of flags to set on the boss bar
 @return the created boss bar]]>
      </doc>
    </method>
    <method name="createBossBar" return="org.bukkit.boss.KeyedBossBar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="title" type="java.lang.String"/>
      <param name="color" type="org.bukkit.boss.BarColor"/>
      <param name="style" type="org.bukkit.boss.BarStyle"/>
      <param name="flags" type="org.bukkit.boss.BarFlag[]"/>
      <doc>
      <![CDATA[Creates a boss bar instance to display to players. The progress defaults
 to 1.0.
 <br>
 This instance is added to the persistent storage of the server and will
 be editable by commands and restored after restart.

 @param key the key of the boss bar that is used to access the boss bar
 @param title the title of the boss bar
 @param color the color of the boss bar
 @param style the style of the boss bar
 @param flags an optional list of flags to set on the boss bar
 @return the created boss bar]]>
      </doc>
    </method>
    <method name="getBossBars" return="java.util.Iterator&lt;org.bukkit.boss.KeyedBossBar&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an unmodifiable iterator through all persistent bossbars.
 <ul>
   <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
   <li>
     <b>not</b> created using
     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   </li>
 </ul>

 e.g. bossbars created using the bossbar command

 @return a bossbar iterator]]>
      </doc>
    </method>
    <method name="getBossBar" return="org.bukkit.boss.KeyedBossBar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Gets the {@link KeyedBossBar} specified by this key.
 <ul>
   <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
   <li>
     <b>not</b> created using
     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   </li>
 </ul>

 e.g. bossbars created using the bossbar command

 @param key unique bossbar key
 @return bossbar or null if not exists]]>
      </doc>
    </method>
    <method name="removeBossBar" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Removes a {@link KeyedBossBar} specified by this key.
 <ul>
   <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
   <li>
     <b>not</b> created using
     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   </li>
 </ul>

 e.g. bossbars created using the bossbar command

 @param key unique bossbar key
 @return true if removal succeeded or false]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets an entity on the server by its UUID

 @param uuid the UUID of the entity
 @return the entity with the given UUID, or null if it isn't found]]>
      </doc>
    </method>
    <method name="getTPS" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current server TPS
 @return current server TPS (1m, 5m, 15m in Paper-Server)]]>
      </doc>
    </method>
    <method name="getTickTimes" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a sample of the servers last tick times (in nanos)

 @return A sample of the servers last tick times (in nanos)]]>
      </doc>
    </method>
    <method name="getAverageTickTime" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the average tick time (in millis)

 @return Average tick time (in millis)]]>
      </doc>
    </method>
    <method name="getAdvancement" return="org.bukkit.advancement.Advancement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Get the advancement specified by this key.

 @param key unique advancement key
 @return advancement or null if not exists]]>
      </doc>
    </method>
    <method name="advancementIterator" return="java.util.Iterator&lt;org.bukkit.advancement.Advancement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an iterator through all advancements. Advancements cannot be removed
 from this iterator,

 @return an advancement iterator]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for the specified Material, with
 all properties initialized to unspecified defaults.

 @param material the material
 @return new data instance]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <param name="consumer" type="java.util.function.Consumer&lt;org.bukkit.block.data.BlockData&gt;"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for the specified Material, with
 all properties initialized to unspecified defaults.

 @param material the material
 @param consumer consumer to run on new instance before returning
 @return new data instance]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance with material and properties
 parsed from provided data.

 @param data data string
 @return new data instance
 @throws IllegalArgumentException if the specified data is not valid]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <param name="data" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for the specified Material, with
 all properties initialized to unspecified defaults, except for those
 provided in data.

 @param material the material
 @param data data string
 @return new data instance
 @throws IllegalArgumentException if the specified data is not valid]]>
      </doc>
    </method>
    <method name="getTag" return="org.bukkit.Tag&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="registry" type="java.lang.String"/>
      <param name="tag" type="org.bukkit.NamespacedKey"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a tag which has already been defined within the server. Plugins are
 suggested to use the concrete tags in {@link Tag} rather than this method
 which makes no guarantees about which tags are available, and may also be
 less performant due to lack of caching.
 <br>
 Tags will be searched for in an implementation specific manner, but a
 path consisting of namespace/tags/registry/key is expected.
 <br>
 Server implementations are allowed to handle only the registries
 indicated in {@link Tag}.

 @param <T> type of the tag
 @param registry the tag registry to look at
 @param tag the name of the tag
 @param clazz the class of the tag entries
 @return the tag or null]]>
      </doc>
    </method>
    <method name="getTags" return="java.lang.Iterable&lt;org.bukkit.Tag&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="registry" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a all tags which have been defined within the server.
 <br>
 Server implementations are allowed to handle only the registries
 indicated in {@link Tag}.
 <br>
 No guarantees are made about the mutability of the returned iterator.

 @param <T> type of the tag
 @param registry the tag registry to look at
 @param clazz the class of the tag entries
 @return all defined tags]]>
      </doc>
    </method>
    <method name="getLootTable" return="org.bukkit.loot.LootTable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Gets the specified {@link LootTable}.

 @param key the name of the LootTable
 @return the LootTable, or null if no LootTable is found with that name]]>
      </doc>
    </method>
    <method name="selectEntities" return="java.util.List&lt;org.bukkit.entity.Entity&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="selector" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Selects entities using the given Vanilla selector.
 <br>
 No guarantees are made about the selector format, other than they match
 the Vanilla format for the active Minecraft version.
 <br>
 Usually a selector will start with '@', unless selecting a Player in
 which case it may simply be the Player's name or UUID.
 <br>
 Note that in Vanilla, elevated permissions are usually required to use
 '@' selectors, but this method should not check such permissions from the
 sender.

 @param sender the sender to execute as, must be provided
 @param selector the selection string
 @return a list of the selected entities. The list will not be null, but
 no further guarantees are made.
 @throws IllegalArgumentException if the selector is malformed in any way
 or a parameter is null]]>
      </doc>
    </method>
    <method name="getUnsafe" return="org.bukkit.UnsafeValues"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see UnsafeValues
 @return the unsafe values instance]]>
      </doc>
    </method>
    <method name="getCommandMap" return="org.bukkit.command.CommandMap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the active {@link org.bukkit.command.CommandMap}

 @return the active command map]]>
      </doc>
    </method>
    <method name="reloadPermissions"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload the Permissions in permissions.yml]]>
      </doc>
    </method>
    <method name="reloadCommandAliases" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload the Command Aliases in commands.yml

 @return Whether the reload was successful]]>
      </doc>
    </method>
    <method name="suggestPlayerNamesWhenNullTabCompletions" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if player names should be suggested when a command returns {@code null} as
 their tab completion result.

 @return true if player names should be suggested]]>
      </doc>
    </method>
    <method name="getPermissionMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the default no permission message used on the server]]>
      </doc>
    </method>
    <method name="createProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Creates a PlayerProfile for the specified uuid, with name as null
 @param uuid UUID to create profile for
 @return A PlayerProfile object]]>
      </doc>
    </method>
    <method name="createProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a PlayerProfile for the specified name, with UUID as null
 @param name Name to create profile for
 @return A PlayerProfile object]]>
      </doc>
    </method>
    <method name="createProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a PlayerProfile for the specified name/uuid

 Both UUID and Name can not be null at same time. One must be supplied.

 @param uuid UUID to create profile for
 @param name Name to create profile for
 @return A PlayerProfile object]]>
      </doc>
    </method>
    <method name="getCurrentTick" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStopping" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the server is in the process of being shutdown.

 @return true if server is in the process of being shutdown]]>
      </doc>
    </method>
    <method name="getMobGoals" return="com.destroystokyo.paper.entity.ai.MobGoals"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link com.destroystokyo.paper.entity.ai.MobGoals} manager

 @return the mob goals manager]]>
      </doc>
    </method>
    <method name="spigot" return="org.bukkit.Server.Spigot"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the Bukkit core, for version and Server singleton handling]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Bukkit -->
  <!-- start class org.bukkit.ChatColor -->
  <class name="ChatColor" extends="java.lang.Enum&lt;org.bukkit.ChatColor&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.ChatColor[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.ChatColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="asBungee" return="net.md_5.bungee.api.ChatColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChar" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the char value associated with this color

 @return A char value of this color code]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isFormat" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this code is a format code as opposed to a color code.

 @return whether this ChatColor is a format code]]>
      </doc>
    </method>
    <method name="isColor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this code is a color code as opposed to a format code.

 @return whether this ChatColor is a color code]]>
      </doc>
    </method>
    <method name="getByChar" return="org.bukkit.ChatColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="code" type="char"/>
      <doc>
      <![CDATA[Gets the color represented by the specified color code

 @param code Code to check
 @return Associative {@link org.bukkit.ChatColor} with the given code,
     or null if it doesn't exist]]>
      </doc>
    </method>
    <method name="getByChar" return="org.bukkit.ChatColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="code" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the color represented by the specified color code

 @param code Code to check
 @return Associative {@link org.bukkit.ChatColor} with the given code,
     or null if it doesn't exist]]>
      </doc>
    </method>
    <method name="stripColor" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Strips the given message of all color codes

 @param input String to strip of color
 @return A copy of the input string, without any coloring]]>
      </doc>
    </method>
    <method name="translateAlternateColorCodes" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="altColorChar" type="char"/>
      <param name="textToTranslate" type="java.lang.String"/>
      <doc>
      <![CDATA[Translates a string using an alternate color code character into a
 string that uses the internal ChatColor.COLOR_CODE color code
 character. The alternate color code character will only be replaced if
 it is immediately followed by 0-9, A-F, a-f, K-O, k-o, R or r.

 @param altColorChar The alternate color code character to replace. Ex: {@literal &}
 @param textToTranslate Text containing the alternate color code character.
 @return Text containing the ChatColor.COLOR_CODE color code character.]]>
      </doc>
    </method>
    <method name="getLastColors" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the ChatColors used at the end of the given input string.

 @param input Input string to retrieve the colors from.
 @return Any remaining ChatColors to pass onto the next line.]]>
      </doc>
    </method>
    <field name="COLOR_CHAR" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The special character which prefixes all chat colour codes. Use this if
 you need to dynamically convert colour codes from your custom format.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[All supported color values for chat]]>
    </doc>
  </class>
  <!-- end class org.bukkit.ChatColor -->
  <!-- start interface org.bukkit.Chunk -->
  <interface name="Chunk"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.persistence.PersistentDataHolder"/>
    <method name="getX" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the X-coordinate of this chunk

 @return X-coordinate]]>
      </doc>
    </method>
    <method name="getZ" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Z-coordinate of this chunk

 @return Z-coordinate]]>
      </doc>
    </method>
    <method name="getChunkKey" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The Chunks X and Z coordinates packed into a long]]>
      </doc>
    </method>
    <method name="getChunkKey" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[@param loc Location to get chunk key
 @return Location's chunk coordinates packed into a long]]>
      </doc>
    </method>
    <method name="getChunkKey" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[@param x X Coordinate
 @param z Z Coordinate
 @return Chunk coordinates packed into a long]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world containing this chunk

 @return Parent World]]>
      </doc>
    </method>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets a block from this chunk

 @param x 0-15
 @param y 0-255
 @param z 0-15
 @return the Block]]>
      </doc>
    </method>
    <method name="getChunkSnapshot" return="org.bukkit.ChunkSnapshot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Capture thread-safe read-only snapshot of chunk data

 @return ChunkSnapshot]]>
      </doc>
    </method>
    <method name="getChunkSnapshot" return="org.bukkit.ChunkSnapshot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="includeMaxblocky" type="boolean"/>
      <param name="includeBiome" type="boolean"/>
      <param name="includeBiomeTempRain" type="boolean"/>
      <doc>
      <![CDATA[Capture thread-safe read-only snapshot of chunk data

 @param includeMaxblocky - if true, snapshot includes per-coordinate
     maximum Y values
 @param includeBiome - if true, snapshot includes per-coordinate biome
     type
 @param includeBiomeTempRain - if true, snapshot includes per-coordinate
     raw biome temperature and rainfall
 @return ChunkSnapshot]]>
      </doc>
    </method>
    <method name="getEntities" return="org.bukkit.entity.Entity[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of all entities in the chunk.

 @return The entities.]]>
      </doc>
    </method>
    <method name="getTileEntities" return="org.bukkit.block.BlockState[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of all tile entities in the chunk.

 @return The tile entities.]]>
      </doc>
    </method>
    <method name="getTileEntities" return="org.bukkit.block.BlockState[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="useSnapshot" type="boolean"/>
      <doc>
      <![CDATA[Get a list of all tile entities in the chunk.

 @param useSnapshot Take snapshots or direct references
 @return The tile entities.]]>
      </doc>
    </method>
    <method name="isLoaded" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the chunk is loaded.

 @return True if it is loaded.]]>
      </doc>
    </method>
    <method name="load" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="generate" type="boolean"/>
      <doc>
      <![CDATA[Loads the chunk.

 @param generate Whether or not to generate a chunk if it doesn't
     already exist
 @return true if the chunk has loaded successfully, otherwise false]]>
      </doc>
    </method>
    <method name="load" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Loads the chunk.

 @return true if the chunk has loaded successfully, otherwise false]]>
      </doc>
    </method>
    <method name="unload" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="save" type="boolean"/>
      <doc>
      <![CDATA[Unloads and optionally saves the Chunk

 @param save Controls whether the chunk is saved
 @return true if the chunk has unloaded successfully, otherwise false]]>
      </doc>
    </method>
    <method name="unload" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unloads and optionally saves the Chunk

 @return true if the chunk has unloaded successfully, otherwise false]]>
      </doc>
    </method>
    <method name="isSlimeChunk" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this chunk can spawn slimes without being a swamp biome.

 @return true if slimes are able to spawn in this chunk]]>
      </doc>
    </method>
    <method name="isForceLoaded" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the chunk at the specified chunk coordinates is force
 loaded.
 <p>
 A force loaded chunk will not be unloaded due to lack of player activity.

 @return force load status
 @see World#isChunkForceLoaded(int, int)]]>
      </doc>
    </method>
    <method name="setForceLoaded"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forced" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the chunk at the specified chunk coordinates is force
 loaded.
 <p>
 A force loaded chunk will not be unloaded due to lack of player activity.

 @param forced force load status
 @see World#setChunkForceLoaded(int, int, boolean)]]>
      </doc>
    </method>
    <method name="addPluginChunkTicket" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Adds a plugin ticket for this chunk, loading this chunk if it is not
 already loaded.
 <p>
 A plugin ticket will prevent a chunk from unloading until it is
 explicitly removed. A plugin instance may only have one ticket per chunk,
 but each chunk can have multiple plugin tickets.
 </p>

 @param plugin Plugin which owns the ticket
 @return {@code true} if a plugin ticket was added, {@code false} if the
 ticket already exists for the plugin
 @throws IllegalStateException If the specified plugin is not enabled
 @see World#addPluginChunkTicket(int, int, Plugin)]]>
      </doc>
    </method>
    <method name="removePluginChunkTicket" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Removes the specified plugin's ticket for this chunk
 <p>
 A plugin ticket will prevent a chunk from unloading until it is
 explicitly removed. A plugin instance may only have one ticket per chunk,
 but each chunk can have multiple plugin tickets.
 </p>

 @param plugin Plugin which owns the ticket
 @return {@code true} if the plugin ticket was removed, {@code false} if
 there is no plugin ticket for the chunk
 @see World#removePluginChunkTicket(int, int, Plugin)]]>
      </doc>
    </method>
    <method name="getPluginChunkTickets" return="java.util.Collection&lt;org.bukkit.plugin.Plugin&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves a collection specifying which plugins have tickets for this
 chunk. This collection is not updated when plugin tickets are added or
 removed to this chunk.
 <p>
 A plugin ticket will prevent a chunk from unloading until it is
 explicitly removed. A plugin instance may only have one ticket per chunk,
 but each chunk can have multiple plugin tickets.
 </p>

 @return unmodifiable collection containing which plugins have tickets for
 this chunk
 @see World#getPluginChunkTickets(int, int)]]>
      </doc>
    </method>
    <method name="getInhabitedTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of time in ticks that this chunk has been inhabited.

 Note that the time is incremented once per tick per player in the chunk.

 @return inhabited time]]>
      </doc>
    </method>
    <method name="setInhabitedTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="long"/>
      <doc>
      <![CDATA[Sets the amount of time in ticks that this chunk has been inhabited.

 @param ticks new inhabited time]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Tests if this chunk contains the specified block.

 @param block block to test
 @return if the block is contained within]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a chunk of blocks]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.Chunk -->
  <!-- start interface org.bukkit.ChunkSnapshot -->
  <interface name="ChunkSnapshot"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getX" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the X-coordinate of this chunk

 @return X-coordinate]]>
      </doc>
    </method>
    <method name="getZ" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Z-coordinate of this chunk

 @return Z-coordinate]]>
      </doc>
    </method>
    <method name="getWorldName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets name of the world containing this chunk

 @return Parent World Name]]>
      </doc>
    </method>
    <method name="getBlockType" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get block type for block at corresponding coordinate in the chunk

 @param x 0-15
 @param y 0-255
 @param z 0-15
 @return block material type]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get block data for block at corresponding coordinate in the chunk

 @param x 0-15
 @param y 0-255
 @param z 0-15
 @return block material type]]>
      </doc>
    </method>
    <method name="getData" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get block data for block at corresponding coordinate in the chunk

 @param x 0-15
 @param y 0-255
 @param z 0-15
 @return 0-15
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getBlockSkyLight" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get sky light level for block at corresponding coordinate in the chunk

 @param x 0-15
 @param y 0-255
 @param z 0-15
 @return 0-15]]>
      </doc>
    </method>
    <method name="getBlockEmittedLight" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get light level emitted by block at corresponding coordinate in the
 chunk

 @param x 0-15
 @param y 0-255
 @param z 0-15
 @return 0-15]]>
      </doc>
    </method>
    <method name="getHighestBlockYAt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the highest non-air coordinate at the given coordinates

 @param x X-coordinate of the blocks (0-15)
 @param z Z-coordinate of the blocks (0-15)
 @return Y-coordinate of the highest non-air block]]>
      </doc>
    </method>
    <method name="getBiome" return="org.bukkit.block.Biome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="biomes are now 3-dimensional">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get biome at given coordinates

 @param x X-coordinate (0-15)
 @param z Z-coordinate (0-15)
 @return Biome at given coordinate
 @deprecated biomes are now 3-dimensional]]>
      </doc>
    </method>
    <method name="getBiome" return="org.bukkit.block.Biome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get biome at given coordinates

 @param x X-coordinate (0-15)
 @param y Y-coordinate (0-255)
 @param z Z-coordinate (0-15)
 @return Biome at given coordinate]]>
      </doc>
    </method>
    <method name="getRawBiomeTemperature" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="biomes are now 3-dimensional">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get raw biome temperature at given coordinates

 @param x X-coordinate (0-15)
 @param z Z-coordinate (0-15)
 @return temperature at given coordinate
 @deprecated biomes are now 3-dimensional]]>
      </doc>
    </method>
    <method name="getRawBiomeTemperature" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get raw biome temperature at given coordinates

 @param x X-coordinate (0-15)
 @param y Y-coordinate (0-15)
 @param z Z-coordinate (0-15)
 @return temperature at given coordinate]]>
      </doc>
    </method>
    <method name="getCaptureFullTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get world full time when chunk snapshot was captured

 @return time in ticks]]>
      </doc>
    </method>
    <method name="isSectionEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sy" type="int"/>
      <doc>
      <![CDATA[Test if section is empty

 @param sy - section Y coordinate (block Y / 16, 0-255)
 @return true if empty, false if not]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Tests if this snapshot contains the specified block.

 @param block block to test
 @return if the block is contained within]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a static, thread-safe snapshot of chunk of blocks.
 <p>
 Purpose is to allow clean, efficient copy of a chunk data to be made, and
 then handed off for processing in another thread (e.g. map rendering)]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.ChunkSnapshot -->
  <!-- start class org.bukkit.CoalType -->
  <class name="CoalType" extends="java.lang.Enum&lt;org.bukkit.CoalType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.CoalType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.CoalType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the associated data value representing this type of coal

 @return A byte containing the data value of this coal type
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByData" return="org.bukkit.CoalType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Gets the type of coal with the given data value

 @param data Data value to fetch
 @return The {@link CoalType} representing the given value, or null if
     it doesn't exist
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the two types of coal]]>
    </doc>
  </class>
  <!-- end class org.bukkit.CoalType -->
  <!-- start class org.bukkit.Color -->
  <class name="Color" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <method name="fromRGB" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="red" type="int"/>
      <param name="green" type="int"/>
      <param name="blue" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new Color object from a red, green, and blue

 @param red integer from 0-255
 @param green integer from 0-255
 @param blue integer from 0-255
 @return a new Color object for the red, green, blue
 @throws IllegalArgumentException if any value is strictly {@literal >255 or <0}]]>
      </doc>
    </method>
    <method name="fromBGR" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blue" type="int"/>
      <param name="green" type="int"/>
      <param name="red" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new Color object from a blue, green, and red

 @param blue integer from 0-255
 @param green integer from 0-255
 @param red integer from 0-255
 @return a new Color object for the red, green, blue
 @throws IllegalArgumentException if any value is strictly {@literal >255 or <0}]]>
      </doc>
    </method>
    <method name="fromRGB" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rgb" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new color object from an integer that contains the red,
 green, and blue bytes in the lowest order 24 bits.

 @param rgb the integer storing the red, green, and blue values
 @return a new color object for specified values
 @throws IllegalArgumentException if any data is in the highest order 8
     bits]]>
      </doc>
    </method>
    <method name="fromBGR" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bgr" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new color object from an integer that contains the blue,
 green, and red bytes in the lowest order 24 bits.

 @param bgr the integer storing the blue, green, and red values
 @return a new color object for specified values
 @throws IllegalArgumentException if any data is in the highest order 8
     bits]]>
      </doc>
    </method>
    <method name="getRed" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the red component

 @return red component, from 0 to 255]]>
      </doc>
    </method>
    <method name="setRed" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="red" type="int"/>
      <doc>
      <![CDATA[Creates a new Color object with specified component

 @param red the red component, from 0 to 255
 @return a new color object with the red component]]>
      </doc>
    </method>
    <method name="getGreen" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the green component

 @return green component, from 0 to 255]]>
      </doc>
    </method>
    <method name="setGreen" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="green" type="int"/>
      <doc>
      <![CDATA[Creates a new Color object with specified component

 @param green the red component, from 0 to 255
 @return a new color object with the red component]]>
      </doc>
    </method>
    <method name="getBlue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the blue component

 @return blue component, from 0 to 255]]>
      </doc>
    </method>
    <method name="setBlue" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blue" type="int"/>
      <doc>
      <![CDATA[Creates a new Color object with specified component

 @param blue the red component, from 0 to 255
 @return a new color object with the red component]]>
      </doc>
    </method>
    <method name="asRGB" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color as an RGB integer.

 @return An integer representation of this color, as 0xRRGGBB]]>
      </doc>
    </method>
    <method name="asBGR" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color as an BGR integer.

 @return An integer representation of this color, as 0xBBGGRR]]>
      </doc>
    </method>
    <method name="mixDyes" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="colors" type="org.bukkit.DyeColor[]"/>
      <doc>
      <![CDATA[Creates a new color with its RGB components changed as if it was dyed
 with the colors passed in, replicating vanilla workbench dyeing

 @param colors The DyeColors to dye with
 @return A new color with the changed rgb components]]>
      </doc>
    </method>
    <method name="mixColors" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="colors" type="org.bukkit.Color[]"/>
      <doc>
      <![CDATA[Creates a new color with its RGB components changed as if it was dyed
 with the colors passed in, replicating vanilla workbench dyeing

 @param colors The colors to dye with
 @return A new color with the changed rgb components]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="deserialize" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="WHITE" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[White, or (0xFF,0xFF,0xFF) in (R,G,B)]]>
      </doc>
    </field>
    <field name="SILVER" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Silver, or (0xC0,0xC0,0xC0) in (R,G,B)]]>
      </doc>
    </field>
    <field name="GRAY" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gray, or (0x80,0x80,0x80) in (R,G,B)]]>
      </doc>
    </field>
    <field name="BLACK" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Black, or (0x00,0x00,0x00) in (R,G,B)]]>
      </doc>
    </field>
    <field name="RED" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Red, or (0xFF,0x00,0x00) in (R,G,B)]]>
      </doc>
    </field>
    <field name="MAROON" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Maroon, or (0x80,0x00,0x00) in (R,G,B)]]>
      </doc>
    </field>
    <field name="YELLOW" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Yellow, or (0xFF,0xFF,0x00) in (R,G,B)]]>
      </doc>
    </field>
    <field name="OLIVE" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Olive, or (0x80,0x80,0x00) in (R,G,B)]]>
      </doc>
    </field>
    <field name="LIME" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Lime, or (0x00,0xFF,0x00) in (R,G,B)]]>
      </doc>
    </field>
    <field name="GREEN" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Green, or (0x00,0x80,0x00) in (R,G,B)]]>
      </doc>
    </field>
    <field name="AQUA" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Aqua, or (0x00,0xFF,0xFF) in (R,G,B)]]>
      </doc>
    </field>
    <field name="TEAL" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Teal, or (0x00,0x80,0x80) in (R,G,B)]]>
      </doc>
    </field>
    <field name="BLUE" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Blue, or (0x00,0x00,0xFF) in (R,G,B)]]>
      </doc>
    </field>
    <field name="NAVY" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Navy, or (0x00,0x00,0x80) in (R,G,B)]]>
      </doc>
    </field>
    <field name="FUCHSIA" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Fuchsia, or (0xFF,0x00,0xFF) in (R,G,B)]]>
      </doc>
    </field>
    <field name="PURPLE" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Purple, or (0x80,0x00,0x80) in (R,G,B)]]>
      </doc>
    </field>
    <field name="ORANGE" type="org.bukkit.Color"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Orange, or (0xFF,0xA5,0x00) in (R,G,B)]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A container for a color palette. This class is immutable; the set methods
 return a new color. The color names listed as fields are HTML4 standards,
 but subject to change.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Color -->
  <!-- start class org.bukkit.CropState -->
  <class name="CropState" extends="java.lang.Enum&lt;org.bukkit.CropState&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.CropState[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.CropState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the associated data value representing this growth state

 @return A byte containing the data value of this growth state
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByData" return="org.bukkit.CropState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Gets the CropState with the given data value

 @param data Data value to fetch
 @return The {@link CropState} representing the given value, or null if
     it doesn't exist
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the different growth states of crops]]>
    </doc>
  </class>
  <!-- end class org.bukkit.CropState -->
  <!-- start class org.bukkit.Difficulty -->
  <class name="Difficulty" extends="java.lang.Enum&lt;org.bukkit.Difficulty&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Difficulty[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Difficulty"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the difficulty value associated with this Difficulty.

 @return An integer value of this difficulty
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByValue" return="org.bukkit.Difficulty"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Gets the Difficulty represented by the specified value

 @param value Value to check
 @return Associative {@link Difficulty} with the given value, or null if
     it doesn't exist
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the various difficulty levels that are available.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Difficulty -->
  <!-- start class org.bukkit.DyeColor -->
  <class name="DyeColor" extends="java.lang.Enum&lt;org.bukkit.DyeColor&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.DyeColor[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getWoolData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the associated wool data value representing this color.

 @return A byte containing the wool data value of this color
 @see #getDyeData()
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getDyeData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the associated dye data value representing this color.

 @return A byte containing the dye data value of this color
 @see #getWoolData()
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color that this dye represents.

 @return The {@link Color} that this dye represents]]>
      </doc>
    </method>
    <method name="getFireworkColor" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the firework color that this dye represents.

 @return The {@link Color} that this dye represents]]>
      </doc>
    </method>
    <method name="getByWoolData" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Gets the DyeColor with the given wool data value.

 @param data Wool data value to fetch
 @return The {@link DyeColor} representing the given value, or null if
     it doesn't exist
 @see #getByDyeData(byte)
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByDyeData" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Gets the DyeColor with the given dye data value.

 @param data Dye data value to fetch
 @return The {@link DyeColor} representing the given value, or null if
     it doesn't exist
 @see #getByWoolData(byte)
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByColor" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Gets the DyeColor with the given color value.

 @param color Color value to get the dye by
 @return The {@link DyeColor} representing the given value, or null if
     it doesn't exist]]>
      </doc>
    </method>
    <method name="getByFireworkColor" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Gets the DyeColor with the given firework color value.

 @param color Color value to get dye by
 @return The {@link DyeColor} representing the given value, or null if
     it doesn't exist]]>
      </doc>
    </method>
    <method name="legacyValueOf" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="legacy use only">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the DyeColor for the given name, possibly doing legacy transformations.

 @param name dye name
 @return dye color
 @deprecated legacy use only]]>
      </doc>
    </method>
    <doc>
    <![CDATA[All supported color values for dyes and cloth]]>
    </doc>
  </class>
  <!-- end class org.bukkit.DyeColor -->
  <!-- start class org.bukkit.Effect -->
  <class name="Effect" extends="java.lang.Enum&lt;org.bukkit.Effect&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Effect[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Effect"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the ID for this effect.

 @return ID of this effect
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.Effect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The type of the effect.]]>
      </doc>
    </method>
    <method name="getData" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The class which represents data for this effect, or null if
     none]]>
      </doc>
    </method>
    <method name="getById" return="org.bukkit.Effect"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Gets the Effect associated with the given ID.

 @param id ID of the Effect to return
 @return Effect with the given ID
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A list of effects that the server is able to send to players.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Effect -->
  <!-- start class org.bukkit.Effect.Type -->
  <class name="Effect.Type" extends="java.lang.Enum&lt;org.bukkit.Effect.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Effect.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Effect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the type of an effect.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Effect.Type -->
  <!-- start class org.bukkit.EntityEffect -->
  <class name="EntityEffect" extends="java.lang.Enum&lt;org.bukkit.EntityEffect&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.EntityEffect[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.EntityEffect"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the data value of this EntityEffect

 @return The data value
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getApplicable" return="java.lang.Class&lt;? extends org.bukkit.entity.Entity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets entity superclass which this affect is applicable to.

 @return applicable class]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A list of all Effects that can happen to entities.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.EntityEffect -->
  <!-- start class org.bukkit.FireworkEffect -->
  <class name="FireworkEffect" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <method name="builder" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a firework effect.

 @return A utility object for building a firework effect]]>
      </doc>
    </method>
    <method name="hasFlicker" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether the firework effect flickers.

 @return true if it flickers, false if not]]>
      </doc>
    </method>
    <method name="hasTrail" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether the firework effect has a trail.

 @return true if it has a trail, false if not]]>
      </doc>
    </method>
    <method name="getColors" return="java.util.List&lt;org.bukkit.Color&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the primary colors of the firework effect.

 @return An immutable list of the primary colors]]>
      </doc>
    </method>
    <method name="getFadeColors" return="java.util.List&lt;org.bukkit.Color&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the fade colors of the firework effect.

 @return An immutable list of the fade colors]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.FireworkEffect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of the firework effect.

 @return The effect type]]>
      </doc>
    </method>
    <method name="deserialize" return="org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[@see ConfigurationSerializable
 @param map the map to deserialize
 @return the resulting serializable]]>
      </doc>
    </method>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Represents a single firework effect.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.FireworkEffect -->
  <!-- start class org.bukkit.FireworkEffect.Builder -->
  <class name="FireworkEffect.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="with" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.FireworkEffect.Type"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Specify the type of the firework effect.

 @param type The effect type
 @return This object, for chaining
 @throws IllegalArgumentException If type is null]]>
      </doc>
    </method>
    <method name="withFlicker" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Add a flicker to the firework effect.

 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="flicker" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flicker" type="boolean"/>
      <doc>
      <![CDATA[Set whether the firework effect should flicker.

 @param flicker true if it should flicker, false if not
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="withTrail" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Add a trail to the firework effect.

 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="trail" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trail" type="boolean"/>
      <doc>
      <![CDATA[Set whether the firework effect should have a trail.

 @param trail true if it should have a trail, false for no trail
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="withColor" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add a primary color to the firework effect.

 @param color The color to add
 @return This object, for chaining
 @throws IllegalArgumentException If color is null]]>
      </doc>
    </method>
    <method name="withColor" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="colors" type="org.bukkit.Color[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add several primary colors to the firework effect.

 @param colors The colors to add
 @return This object, for chaining
 @throws IllegalArgumentException If colors is null
 @throws IllegalArgumentException If any color is null (may be
     thrown after changes have occurred)]]>
      </doc>
    </method>
    <method name="withColor" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="colors" type="java.lang.Iterable&lt;?&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add several primary colors to the firework effect.

 @param colors An iterable object whose iterator yields the desired
     colors
 @return This object, for chaining
 @throws IllegalArgumentException If colors is null
 @throws IllegalArgumentException If any color is null (may be
     thrown after changes have occurred)]]>
      </doc>
    </method>
    <method name="withFade" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add a fade color to the firework effect.

 @param color The color to add
 @return This object, for chaining
 @throws IllegalArgumentException If colors is null
 @throws IllegalArgumentException If any color is null (may be
     thrown after changes have occurred)]]>
      </doc>
    </method>
    <method name="withFade" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="colors" type="org.bukkit.Color[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add several fade colors to the firework effect.

 @param colors The colors to add
 @return This object, for chaining
 @throws IllegalArgumentException If colors is null
 @throws IllegalArgumentException If any color is null (may be
     thrown after changes have occurred)]]>
      </doc>
    </method>
    <method name="withFade" return="org.bukkit.FireworkEffect.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="colors" type="java.lang.Iterable&lt;?&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add several fade colors to the firework effect.

 @param colors An iterable object whose iterator yields the desired
     colors
 @return This object, for chaining
 @throws IllegalArgumentException If colors is null
 @throws IllegalArgumentException If any color is null (may be
     thrown after changes have occurred)]]>
      </doc>
    </method>
    <method name="build" return="org.bukkit.FireworkEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link FireworkEffect} from the current contents of this
 builder.
 <p>
 To successfully build, you must have specified at least one color.

 @return The representative firework effect]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is a builder for FireworkEffects.

 @see FireworkEffect#builder()]]>
    </doc>
  </class>
  <!-- end class org.bukkit.FireworkEffect.Builder -->
  <!-- start class org.bukkit.FireworkEffect.Type -->
  <class name="FireworkEffect.Type" extends="java.lang.Enum&lt;org.bukkit.FireworkEffect.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.FireworkEffect.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.FireworkEffect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The type or shape of the effect.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.FireworkEffect.Type -->
  <!-- start class org.bukkit.Fluid -->
  <class name="Fluid" extends="java.lang.Enum&lt;org.bukkit.Fluid&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.Fluid[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Fluid"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.Fluid -->
  <!-- start class org.bukkit.FluidCollisionMode -->
  <class name="FluidCollisionMode" extends="java.lang.Enum&lt;org.bukkit.FluidCollisionMode&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.FluidCollisionMode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.FluidCollisionMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Determines the collision behavior when fluids get hit during ray tracing.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.FluidCollisionMode -->
  <!-- start class org.bukkit.GameMode -->
  <class name="GameMode" extends="java.lang.Enum&lt;org.bukkit.GameMode&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.GameMode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.GameMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the mode value associated with this GameMode

 @return An integer value of this gamemode
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByValue" return="org.bukkit.GameMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Gets the GameMode represented by the specified value

 @param value Value to check
 @return Associative {@link GameMode} with the given value, or null if
     it doesn't exist
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the various type of game modes that {@link HumanEntity}s may
 have]]>
    </doc>
  </class>
  <!-- end class org.bukkit.GameMode -->
  <!-- start class org.bukkit.GameRule -->
  <class name="GameRule" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of this GameRule.

 @return the name of this GameRule]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of this rule.

 @return the rule type; Integer or Boolean]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getByName" return="org.bukkit.GameRule&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rule" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a {@link GameRule} by its name.

 @param rule the name of the GameRule
 @return the {@link GameRule} or null if no GameRule matches the given
 name]]>
      </doc>
    </method>
    <method name="values" return="org.bukkit.GameRule[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an immutable collection of {@link GameRule}s.

 @return an immutable collection containing all registered GameRules.]]>
      </doc>
    </method>
    <field name="ANNOUNCE_ADVANCEMENTS" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Toggles the announcing of advancements.]]>
      </doc>
    </field>
    <field name="COMMAND_BLOCK_OUTPUT" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether command blocks should notify admins when they perform commands.]]>
      </doc>
    </field>
    <field name="DISABLE_ELYTRA_MOVEMENT_CHECK" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the server should skip checking player speed when the player is
 wearing elytra.]]>
      </doc>
    </field>
    <field name="DO_DAYLIGHT_CYCLE" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether time progresses from the current moment.]]>
      </doc>
    </field>
    <field name="DO_ENTITY_DROPS" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether entities that are not mobs should have drops.]]>
      </doc>
    </field>
    <field name="DO_FIRE_TICK" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether fire should spread and naturally extinguish.]]>
      </doc>
    </field>
    <field name="DO_LIMITED_CRAFTING" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether players should only be able to craft recipes they've unlocked
 first.]]>
      </doc>
    </field>
    <field name="DO_MOB_LOOT" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether mobs should drop items.]]>
      </doc>
    </field>
    <field name="DO_MOB_SPAWNING" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether mobs should naturally spawn.]]>
      </doc>
    </field>
    <field name="DO_TILE_DROPS" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether blocks should have drops.]]>
      </doc>
    </field>
    <field name="DO_WEATHER_CYCLE" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the weather will change from the current moment.]]>
      </doc>
    </field>
    <field name="KEEP_INVENTORY" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the player should keep items in their inventory after death.]]>
      </doc>
    </field>
    <field name="LOG_ADMIN_COMMANDS" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to log admin commands to server log.]]>
      </doc>
    </field>
    <field name="MOB_GRIEFING" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether mobs can pick up items or change blocks.]]>
      </doc>
    </field>
    <field name="NATURAL_REGENERATION" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether players can regenerate health naturally through their hunger bar.]]>
      </doc>
    </field>
    <field name="REDUCED_DEBUG_INFO" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the debug screen shows all or reduced information.]]>
      </doc>
    </field>
    <field name="SEND_COMMAND_FEEDBACK" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the feedback from commands executed by a player should show up in
 chat. Also affects the default behavior of whether command blocks store
 their output text.]]>
      </doc>
    </field>
    <field name="SHOW_DEATH_MESSAGES" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether a message appears in chat when a player dies.]]>
      </doc>
    </field>
    <field name="SPECTATORS_GENERATE_CHUNKS" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether players in spectator mode can generate chunks.]]>
      </doc>
    </field>
    <field name="DISABLE_RAIDS" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether pillager raids are enabled or not.]]>
      </doc>
    </field>
    <field name="DO_INSOMNIA" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether phantoms will appear without sleeping or not.]]>
      </doc>
    </field>
    <field name="DO_IMMEDIATE_RESPAWN" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether clients will respawn immediately after death or not.]]>
      </doc>
    </field>
    <field name="DROWNING_DAMAGE" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether drowning damage is enabled or not.]]>
      </doc>
    </field>
    <field name="FALL_DAMAGE" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether fall damage is enabled or not.]]>
      </doc>
    </field>
    <field name="FIRE_DAMAGE" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether fire damage is enabled or not.]]>
      </doc>
    </field>
    <field name="DO_PATROL_SPAWNING" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether patrols should naturally spawn.]]>
      </doc>
    </field>
    <field name="DO_TRADER_SPAWNING" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether traders should naturally spawn.]]>
      </doc>
    </field>
    <field name="FORGIVE_DEAD_PLAYERS" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether mobs should cease being angry at a player once they die.]]>
      </doc>
    </field>
    <field name="UNIVERSAL_ANGER" type="org.bukkit.GameRule&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether mobs will target all player entities once angered.]]>
      </doc>
    </field>
    <field name="RANDOM_TICK_SPEED" type="org.bukkit.GameRule&lt;java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[How often a random block tick occurs (such as plant growth, leaf decay,
 etc.) per chunk section per game tick. 0 will disable random ticks,
 higher numbers will increase random ticks.]]>
      </doc>
    </field>
    <field name="SPAWN_RADIUS" type="org.bukkit.GameRule&lt;java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of blocks outward from the world spawn coordinates that a
 player will spawn in when first joining a server or when dying without a
 spawnpoint.]]>
      </doc>
    </field>
    <field name="MAX_ENTITY_CRAMMING" type="org.bukkit.GameRule&lt;java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The maximum number of other pushable entities a mob or player can push,
 before taking suffocation damage.
 <br>
 Setting to 0 disables this rule.]]>
      </doc>
    </field>
    <field name="MAX_COMMAND_CHAIN_LENGTH" type="org.bukkit.GameRule&lt;java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines the number at which the chain of command blocks act as a
 "chain."
 <br>
 This is the maximum amount of command blocks that can be activated in a
 single tick from a single chain.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[GameRules dictate certain behavior within Minecraft itself
 <br>
 For more information please visit the
 <a href="https://minecraft.gamepedia.com/Commands/gamerule">Minecraft
 Wiki</a>

 @param <T> type of rule (Boolean or Integer)]]>
    </doc>
  </class>
  <!-- end class org.bukkit.GameRule -->
  <!-- start class org.bukkit.GrassSpecies -->
  <class name="GrassSpecies" extends="java.lang.Enum&lt;org.bukkit.GrassSpecies&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.GrassSpecies[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.GrassSpecies"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the associated data value representing this species

 @return A byte containing the data value of this grass species
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByData" return="org.bukkit.GrassSpecies"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Gets the GrassSpecies with the given data value

 @param data Data value to fetch
 @return The {@link GrassSpecies} representing the given value, or null
     if it doesn't exist
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the different types of grass.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.GrassSpecies -->
  <!-- start class org.bukkit.HeightMap -->
  <class name="HeightMap" extends="java.lang.Enum&lt;org.bukkit.HeightMap&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.HeightMap[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.HeightMap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Further information regarding heightmaps.

 @see <a href="https://minecraft.gamepedia.com/Chunk_format">Gamepedia Chunk
 Format</a>]]>
    </doc>
  </class>
  <!-- end class org.bukkit.HeightMap -->
  <!-- start class org.bukkit.Instrument -->
  <class name="Instrument" extends="java.lang.Enum&lt;org.bukkit.Instrument&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Instrument[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Instrument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getType" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@return The type ID of this instrument.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByType" return="org.bukkit.Instrument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="type" type="byte"/>
      <doc>
      <![CDATA[Get an instrument by its type ID.

 @param type The type ID
 @return The instrument
 @deprecated Magic value]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.Instrument -->
  <!-- start interface org.bukkit.Keyed -->
  <interface name="Keyed"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the namespaced identifier for this object.

 @return this object's key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an object which has a {@link NamespacedKey} attached to it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.Keyed -->
  <!-- start class org.bukkit.Location -->
  <class name="Location" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <constructor name="Location" type="org.bukkit.World, double, double, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new Location with the given coordinates

 @param world The world in which this location resides
 @param x The x-coordinate of this new location
 @param y The y-coordinate of this new location
 @param z The z-coordinate of this new location]]>
      </doc>
    </constructor>
    <constructor name="Location" type="org.bukkit.World, double, double, double, float, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new Location with the given coordinates and direction

 @param world The world in which this location resides
 @param x The x-coordinate of this new location
 @param y The y-coordinate of this new location
 @param z The z-coordinate of this new location
 @param yaw The absolute rotation on the x-plane, in degrees
 @param pitch The absolute rotation on the y-plane, in degrees]]>
      </doc>
    </constructor>
    <method name="setWorld"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Sets the world that this location resides in

 @param world New world that this location resides in]]>
      </doc>
    </method>
    <method name="isWorldLoaded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if world in this location is present and loaded.

 @return true if is loaded, otherwise false]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world that this location resides in

 @return World that contains this location, or {@code null} if it is not set
 @throws IllegalArgumentException when world is unloaded
 @see #isWorldLoaded()]]>
      </doc>
    </method>
    <method name="getChunk" return="org.bukkit.Chunk"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chunk at the represented location

 @return Chunk at the represented location]]>
      </doc>
    </method>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block at the represented location

 @return Block at the represented location]]>
      </doc>
    </method>
    <method name="setX"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Sets the x-coordinate of this location

 @param x X-coordinate]]>
      </doc>
    </method>
    <method name="getX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the x-coordinate of this location

 @return x-coordinate]]>
      </doc>
    </method>
    <method name="getBlockX" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the floored value of the X component, indicating the block that
 this location is contained with.

 @return block X]]>
      </doc>
    </method>
    <method name="setY"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="y" type="double"/>
      <doc>
      <![CDATA[Sets the y-coordinate of this location

 @param y y-coordinate]]>
      </doc>
    </method>
    <method name="getY" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the y-coordinate of this location

 @return y-coordinate]]>
      </doc>
    </method>
    <method name="getBlockY" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the floored value of the Y component, indicating the block that
 this location is contained with.

 @return block y]]>
      </doc>
    </method>
    <method name="setZ"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Sets the z-coordinate of this location

 @param z z-coordinate]]>
      </doc>
    </method>
    <method name="getZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the z-coordinate of this location

 @return z-coordinate]]>
      </doc>
    </method>
    <method name="getBlockZ" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the floored value of the Z component, indicating the block that
 this location is contained with.

 @return block z]]>
      </doc>
    </method>
    <method name="setYaw"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="yaw" type="float"/>
      <doc>
      <![CDATA[Sets the yaw of this location, measured in degrees.
 <ul>
 <li>A yaw of 0 or 360 represents the positive z direction.
 <li>A yaw of 180 represents the negative z direction.
 <li>A yaw of 90 represents the negative x direction.
 <li>A yaw of 270 represents the positive x direction.
 </ul>
 Increasing yaw values are the equivalent of turning to your
 right-facing, increasing the scale of the next respective axis, and
 decreasing the scale of the previous axis.

 @param yaw new rotation's yaw]]>
      </doc>
    </method>
    <method name="getYaw" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the yaw of this location, measured in degrees.
 <ul>
 <li>A yaw of 0 or 360 represents the positive z direction.
 <li>A yaw of 180 represents the negative z direction.
 <li>A yaw of 90 represents the negative x direction.
 <li>A yaw of 270 represents the positive x direction.
 </ul>
 Increasing yaw values are the equivalent of turning to your
 right-facing, increasing the scale of the next respective axis, and
 decreasing the scale of the previous axis.

 @return the rotation's yaw]]>
      </doc>
    </method>
    <method name="setPitch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Sets the pitch of this location, measured in degrees.
 <ul>
 <li>A pitch of 0 represents level forward facing.
 <li>A pitch of 90 represents downward facing, or negative y
     direction.
 <li>A pitch of -90 represents upward facing, or positive y direction.
 </ul>
 Increasing pitch values the equivalent of looking down.

 @param pitch new incline's pitch]]>
      </doc>
    </method>
    <method name="getPitch" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the pitch of this location, measured in degrees.
 <ul>
 <li>A pitch of 0 represents level forward facing.
 <li>A pitch of 90 represents downward facing, or negative y
     direction.
 <li>A pitch of -90 represents upward facing, or positive y direction.
 </ul>
 Increasing pitch values the equivalent of looking down.

 @return the incline's pitch]]>
      </doc>
    </method>
    <method name="getDirection" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a unit-vector pointing in the direction that this Location is
 facing.

 @return a vector pointing the direction of this location's {@link
     #getPitch() pitch} and {@link #getYaw() yaw}]]>
      </doc>
    </method>
    <method name="setDirection" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vector" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets the {@link #getYaw() yaw} and {@link #getPitch() pitch} to point
 in the direction of the vector.

 @param vector the direction vector
 @return the same location]]>
      </doc>
    </method>
    <method name="add" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Adds the location by another.

 @see Vector
 @param vec The other location
 @return the same location
 @throws IllegalArgumentException for differing worlds]]>
      </doc>
    </method>
    <method name="add" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Adds the location by a vector.

 @see Vector
 @param vec Vector to use
 @return the same location]]>
      </doc>
    </method>
    <method name="add" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Adds the location by another. Not world-aware.

 @see Vector
 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @return the same location]]>
      </doc>
    </method>
    <method name="subtract" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Subtracts the location by another.

 @see Vector
 @param vec The other location
 @return the same location
 @throws IllegalArgumentException for differing worlds]]>
      </doc>
    </method>
    <method name="subtract" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Subtracts the location by a vector.

 @see Vector
 @param vec The vector to use
 @return the same location]]>
      </doc>
    </method>
    <method name="subtract" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Subtracts the location by another. Not world-aware and
 orientation independent.

 @see Vector
 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @return the same location]]>
      </doc>
    </method>
    <method name="length" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
 value of this method is not cached and uses a costly square-root
 function, so do not repeatedly call this method to get the location's
 magnitude. NaN will be returned if the inner result of the sqrt()
 function overflows, which will be caused if the length is too long. Not
 world-aware and orientation independent.

 @return the magnitude
 @see Vector]]>
      </doc>
    </method>
    <method name="lengthSquared" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the magnitude of the location squared. Not world-aware and
 orientation independent.

 @return the magnitude
 @see Vector]]>
      </doc>
    </method>
    <method name="distance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Get the distance between this location and another. The value of this
 method is not cached and uses a costly square-root function, so do not
 repeatedly call this method to get the location's magnitude. NaN will
 be returned if the inner result of the sqrt() function overflows, which
 will be caused if the distance is too long.

 @param o The other location
 @return the distance
 @throws IllegalArgumentException for differing worlds
 @see Vector]]>
      </doc>
    </method>
    <method name="distanceSquared" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Get the squared distance between this location and another.

 @param o The other location
 @return the distance
 @throws IllegalArgumentException for differing worlds
 @see Vector]]>
      </doc>
    </method>
    <method name="multiply" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="double"/>
      <doc>
      <![CDATA[Performs scalar multiplication, multiplying all components with a
 scalar. Not world-aware.

 @param m The factor
 @return the same location
 @see Vector]]>
      </doc>
    </method>
    <method name="zero" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Zero this location's components. Not world-aware.

 @return the same location
 @see Vector]]>
      </doc>
    </method>
    <method name="isChunkLoaded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isGenerated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if a {@link Chunk} has been generated at this location.

 @return true if a chunk has been generated at this location]]>
      </doc>
    </method>
    <method name="set" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Sets the position of this Location and returns itself

 This mutates this object, clone first.
 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @return self (not cloned)]]>
      </doc>
    </method>
    <method name="add" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="base" type="org.bukkit.Location"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Takes the x/y/z from base and adds the specified x/y/z to it and returns self

 This mutates this object, clone first.
 @param base The base coordinate to modify
 @param x X coordinate to add to base
 @param y Y coordinate to add to base
 @param z Z coordinate to add to base
 @return self (not cloned)]]>
      </doc>
    </method>
    <method name="subtract" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="base" type="org.bukkit.Location"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Takes the x/y/z from base and subtracts the specified x/y/z to it and returns self

 This mutates this object, clone first.
 @param base The base coordinate to modify
 @param x X coordinate to subtract from base
 @param y Y coordinate to subtract from base
 @param z Z coordinate to subtract from base
 @return self (not cloned)]]>
      </doc>
    </method>
    <method name="toBlockLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return A new location where X/Y/Z are on the Block location (integer value of X/Y/Z)]]>
      </doc>
    </method>
    <method name="toBlockKey" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The block key for this location's block location.
 @see Block#getBlockKey(int, int, int)]]>
      </doc>
    </method>
    <method name="toCenterLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return A new location where X/Y/Z are the center of the block]]>
      </doc>
    </method>
    <method name="toHighestLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ())
 @return A copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ())
 @throws NullPointerException if {{@link #getWorld()}} is {@code null}]]>
      </doc>
    </method>
    <method name="toHighestLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="heightmap" type="com.destroystokyo.paper.HeightmapType"/>
      <doc>
      <![CDATA[Returns a copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ(), heightmap)
 @param heightmap The heightmap to use for finding the highest y location.
 @return A copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ(), heightmap)
 @throws NullPointerException if {{@link #getWorld()}} is {@code null}
 @throws UnsupportedOperationException if {@link World#getHighestBlockYAt(int, int, com.destroystokyo.paper.HeightmapType)} does not support the specified heightmap]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="power" type="float"/>
      <doc>
      <![CDATA[Creates explosion at this location with given power

 Will break blocks and ignite blocks on fire.

 @param power The power of explosion, where 4F is TNT
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at this location with given power and optionally
 setting blocks on fire.

 Will break blocks.

 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <param name="breakBlocks" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at this location with given power and optionally
 setting blocks on fire.

 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @param breakBlocks Whether or not to have blocks be destroyed
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="power" type="float"/>
      <doc>
      <![CDATA[Creates explosion at this location with given power, with the specified entity as the source.

 Will break blocks and ignite blocks on fire.

 @param source The source entity of the explosion
 @param power The power of explosion, where 4F is TNT
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at this location with given power and optionally
 setting blocks on fire, with the specified entity as the source.

 Will break blocks.

 @param source The source entity of the explosion
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <param name="breakBlocks" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at this location with given power and optionally
 setting blocks on fire, with the specified entity as the source.

 @param source The source entity of the explosion
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @param breakBlocks Whether or not to have blocks be destroyed
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="getNearbyEntities" return="java.util.Collection&lt;org.bukkit.entity.Entity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Returns a list of entities within a bounding box centered around a Location.

 Some implementations may impose artificial restrictions on the size of the search bounding box.

 @param x 1/2 the size of the box along x axis
 @param y 1/2 the size of the box along y axis
 @param z 1/2 the size of the box along z axis
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param radius X Radius
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param xzRadius X/Z Radius
 @param yRadius Y Radius
 @return the collection of living entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z radius
 @return the collection of living entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.LivingEntity&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param radius Radius
 @param predicate a predicate used to filter results
 @return the collection of living entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.LivingEntity&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param xzRadius X/Z Radius
 @param yRadius Y Radius
 @param predicate a predicate used to filter results
 @return the collection of living entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.LivingEntity&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z radius
 @param predicate a predicate used to filter results
 @return the collection of living entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param radius X/Y/Z Radius
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param xzRadius X/Z Radius
 @param yRadius Y Radius
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z Radius
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.Player&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param radius X/Y/Z Radius
 @param predicate a predicate used to filter results
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.Player&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param xzRadius X/Z Radius
 @param yRadius Y Radius
 @param predicate a predicate used to filter results
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.Player&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z Radius
 @param predicate a predicate used to filter results
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="radius" type="double"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius (bounding box)
 @param clazz Type to filter by
 @param radius X/Y/Z radius to search within
 @param <T> the entity type
 @return the collection of entities of type clazz near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius, with x and x radius matching (bounding box)
 @param clazz Type to filter by
 @param xzRadius X/Z radius to search within
 @param yRadius Y radius to search within
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius (bounding box)
 @param clazz Type to filter by
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z Radius
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="radius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius (bounding box)
 @param clazz Type to filter by
 @param radius X/Y/Z radius to search within
 @param predicate a predicate used to filter results
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius, with x and x radius matching (bounding box)
 @param clazz Type to filter by
 @param xzRadius X/Z radius to search within
 @param yRadius Y radius to search within
 @param predicate a predicate used to filter results
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends org.bukkit.entity.Entity&gt;"/>
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius (bounding box)
 @param clazz Type to filter by
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z Radius
 @param predicate a predicate used to filter results
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toVector" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link Vector} based on this Location

 @return New Vector containing the coordinates represented by this
     Location]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="checkFinite"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Check if each component of this Location is finite.

 @throws IllegalArgumentException if any component is not finite]]>
      </doc>
    </method>
    <method name="locToBlock" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="double"/>
      <doc>
      <![CDATA[Safely converts a double (location coordinate) to an int (block
 coordinate)

 @param loc Precise coordinate
 @return Block coordinate]]>
      </doc>
    </method>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="deserialize" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Required method for deserialization

 @param args map to deserialize
 @return deserialized location
 @throws IllegalArgumentException if the world don't exists
 @see ConfigurationSerializable]]>
      </doc>
    </method>
    <method name="normalizeYaw" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="yaw" type="float"/>
      <doc>
      <![CDATA[Normalizes the given yaw angle to a value between <code>+/-180</code>
 degrees.

 @param yaw the yaw in degrees
 @return the normalized yaw in degrees
 @see Location#getYaw()]]>
      </doc>
    </method>
    <method name="normalizePitch" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Normalizes the given pitch angle to a value between <code>+/-90</code>
 degrees.

 @param pitch the pitch in degrees
 @return the normalized pitch in degrees
 @see Location#getPitch()]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a 3-dimensional position in a world.
 <br>
 No constraints are placed on any angular values other than that they be
 specified in degrees. This means that negative angles or angles of greater
 magnitude than 360 are valid, but may be normalized to any other equivalent
 representation by the implementation.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Location -->
  <!-- start class org.bukkit.Material -->
  <class name="Material" extends="java.lang.Enum&lt;org.bukkit.Material&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.Material[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return If the type is either AIR, CAVE_AIR or VOID_AIR]]>
      </doc>
    </method>
    <method name="getTranslationKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the translation key for the Material, so the client can translate it into the active
 locale when using a TranslatableComponent.
 @return the translation key]]>
      </doc>
    </method>
    <method name="getId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Do not use for any reason.

 @return ID of this material
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="isLegacy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do not use for any reason.

 @return legacy status]]>
      </doc>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxStackSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum amount of this material that can be held in a stack

 @return Maximum stack size for this material]]>
      </doc>
    </method>
    <method name="getMaxDurability" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum durability of this material

 @return Maximum durability for this material]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for this Material, with all
 properties initialized to unspecified defaults.

 @return new data instance]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="java.util.function.Consumer&lt;org.bukkit.block.data.BlockData&gt;"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for this Material, with
 all properties initialized to unspecified defaults.

 @param consumer consumer to run on new instance before returning
 @return new data instance]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for this Material, with all
 properties initialized to unspecified defaults, except for those provided
 in data.

 @param data data string
 @return new data instance
 @throws IllegalArgumentException if the specified data is not valid]]>
      </doc>
    </method>
    <method name="getData" return="java.lang.Class&lt;? extends org.bukkit.material.MaterialData&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the MaterialData class associated with this Material

 @return MaterialData associated with this Material]]>
      </doc>
    </method>
    <method name="getNewData" return="org.bukkit.material.MaterialData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="raw" type="byte"/>
      <doc>
      <![CDATA[Constructs a new MaterialData relevant for this Material, with the
 given initial data

 @param raw Initial data to construct the MaterialData with
 @return New MaterialData with the given data
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="isBlock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this Material is a placable block

 @return true if this material is a block]]>
      </doc>
    </method>
    <method name="isEdible" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this Material is edible.

 @return true if this Material is edible.]]>
      </doc>
    </method>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Attempts to get the Material with the given name.
 <p>
 This is a normal lookup, names must be the precise name they are given
 in the enum.

 @param name Name of the material to get
 @return Material if found, or null]]>
      </doc>
    </method>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="legacyName" type="boolean"/>
      <doc>
      <![CDATA[Attempts to get the Material with the given name.
 <p>
 This is a normal lookup, names must be the precise name they are given in
 the enum (but optionally including the LEGACY_PREFIX if legacyName is
 true).
 <p>
 If legacyName is true, then the lookup will be against legacy materials,
 but the returned Material will be a modern material (ie this method is
 useful for updating stored data).

 @param name Name of the material to get
 @param legacyName whether this is a legacy name lookup
 @return Material if found, or null]]>
      </doc>
    </method>
    <method name="matchMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Attempts to match the Material with the given name.
 <p>
 This is a match lookup; names will be stripped of the "minecraft:"
 namespace, converted to uppercase, then stripped of special characters in
 an attempt to format it like the enum.

 @param name Name of the material to get
 @return Material if found, or null]]>
      </doc>
    </method>
    <method name="matchMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="legacyName" type="boolean"/>
      <doc>
      <![CDATA[Attempts to match the Material with the given name.
 <p>
 This is a match lookup; names will be stripped of the "minecraft:"
 namespace, converted to uppercase, then stripped of special characters in
 an attempt to format it like the enum.

 @param name Name of the material to get
 @param legacyName whether this is a legacy name (see
 {@link #getMaterial(java.lang.String, boolean)}
 @return Material if found, or null]]>
      </doc>
    </method>
    <method name="isRecord" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return True if this material represents a playable music disk.]]>
      </doc>
    </method>
    <method name="isSolid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the material is a block and solid (can be built upon)

 @return True if this material is a block and solid]]>
      </doc>
    </method>
    <method name="isAir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the material is an air block.

 @return True if this material is an air block.]]>
      </doc>
    </method>
    <method name="isTransparent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="currently does not have an implementation which is well
 linked to the underlying server. Contributions welcome.">
      <doc>
      <![CDATA[Check if the material is a block and does not block any light

 @return True if this material is a block and does not block any light
 @deprecated currently does not have an implementation which is well
 linked to the underlying server. Contributions welcome.]]>
      </doc>
    </method>
    <method name="isFlammable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the material is a block and can catch fire

 @return True if this material is a block and can catch fire]]>
      </doc>
    </method>
    <method name="isBurnable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the material is a block and can burn away

 @return True if this material is a block and can burn away]]>
      </doc>
    </method>
    <method name="isFuel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this Material can be used as fuel in a Furnace

 @return true if this Material can be used as fuel.]]>
      </doc>
    </method>
    <method name="isOccluding" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the material is a block and completely blocks vision

 @return True if this material is a block and completely blocks vision]]>
      </doc>
    </method>
    <method name="hasGravity" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return True if this material is affected by gravity.]]>
      </doc>
    </method>
    <method name="isItem" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this Material is an obtainable item.

 @return true if this material is an item]]>
      </doc>
    </method>
    <method name="isInteractable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this Material can be interacted with.

 Interactable materials include those with functionality when they are
 interacted with by a player such as chests, furnaces, etc.

 Some blocks such as piston heads and stairs are considered interactable
 though may not perform any additional functionality.

 Note that the interactability of some materials may be dependant on their
 state as well. This method will return true if there is at least one
 state in which additional interact handling is performed for the
 material.

 @return true if this material can be interacted with.]]>
      </doc>
    </method>
    <method name="getHardness" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtains the block's hardness level (also known as "strength").
 <br>
 This number is used to calculate the time required to break each block.
 <br>
 Only available when {@link #isBlock()} is true.

 @return the hardness of that material.]]>
      </doc>
    </method>
    <method name="getBlastResistance" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtains the blast resistance value (also known as block "durability").
 <br>
 This value is used in explosions to calculate whether a block should be
 broken or not.
 <br>
 Only available when {@link #isBlock()} is true.

 @return the blast resistance of that material.]]>
      </doc>
    </method>
    <method name="getCraftingRemainingItem" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines the remaining item in a crafting grid after crafting with this
 ingredient.
 <br>
 Only available when {@link #isItem()} is true.

 @return the item left behind when crafting, or null if nothing is.]]>
      </doc>
    </method>
    <field name="LEGACY_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="data" type="java.lang.Class&lt;?&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An enum of all material IDs accepted by the official server and client]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Material -->
  <!-- start interface org.bukkit.Nameable -->
  <interface name="Nameable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getCustomName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the custom name on a mob or block. If there is no name this method
 will return null.
 <p>
 This value has no effect on players, they will always use their real
 name.

 @return name of the mob/block or null]]>
      </doc>
    </method>
    <method name="setCustomName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets a custom name on a mob or block. This name will be used in death
 messages and can be sent to the client as a nameplate over the mob.
 <p>
 Setting the name to null or an empty string will clear it.
 <p>
 This value has no effect on players, they will always use their real
 name.

 @param name the name to set]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.Nameable -->
  <!-- start class org.bukkit.NamespacedKey -->
  <class name="NamespacedKey" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.destroystokyo.paper.Namespaced"/>
    <constructor name="NamespacedKey" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="should never be used by plugins, for internal use only!!">
      <doc>
      <![CDATA[Create a key in a specific namespace.

 @param namespace namespace
 @param key key
 @deprecated should never be used by plugins, for internal use only!!]]>
      </doc>
    </constructor>
    <constructor name="NamespacedKey" type="org.bukkit.plugin.Plugin, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a key in the plugin's namespace.
 <p>
 Namespaces may only contain lowercase alphanumeric characters, periods,
 underscores, and hyphens.
 <p>
 Keys may only contain lowercase alphanumeric characters, periods,
 underscores, hyphens, and forward slashes.

 @param plugin the plugin to use for the namespace
 @param key the key to create]]>
      </doc>
    </constructor>
    <method name="getNamespace" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="randomKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="should never be used by plugins, for internal use only!!">
      <doc>
      <![CDATA[Return a new random key in the {@link #BUKKIT} namespace.

 @return new key
 @deprecated should never be used by plugins, for internal use only!!]]>
      </doc>
    </method>
    <method name="minecraft" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a key in the Minecraft namespace.

 @param key the key to use
 @return new key in the Minecraft namespace]]>
      </doc>
    </method>
    <field name="MINECRAFT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The namespace representing all inbuilt keys.]]>
      </doc>
    </field>
    <field name="BUKKIT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The namespace representing all keys generated by Bukkit for backwards
 compatibility measures.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents a String based key which consists of two components - a namespace
 and a key.

 Namespaces may only contain lowercase alphanumeric characters, periods,
 underscores, and hyphens.
 <p>
 Keys may only contain lowercase alphanumeric characters, periods,
 underscores, hyphens, and forward slashes.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.NamespacedKey -->
  <!-- start class org.bukkit.NetherWartsState -->
  <class name="NetherWartsState" extends="java.lang.Enum&lt;org.bukkit.NetherWartsState&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.NetherWartsState[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.NetherWartsState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.NetherWartsState -->
  <!-- start class org.bukkit.Note -->
  <class name="Note" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Note" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new note.

 @param note Internal note id. {@link #getId()} always return this
     value. The value has to be in the interval [0;&nbsp;24].]]>
      </doc>
    </constructor>
    <constructor name="Note" type="int, org.bukkit.Note.Tone, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new note.

 @param octave The octave where the note is in. Has to be 0 - 2.
 @param tone The tone within the octave. If the octave is 2 the note has
     to be F#.
 @param sharped Set if the tone is sharped (e.g. for F#).]]>
      </doc>
    </constructor>
    <method name="flat" return="org.bukkit.Note"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="octave" type="int"/>
      <param name="tone" type="org.bukkit.Note.Tone"/>
      <doc>
      <![CDATA[Creates a new note for a flat tone, such as A-flat.

 @param octave The octave where the note is in. Has to be 0 - 1.
 @param tone The tone within the octave.
 @return The new note.]]>
      </doc>
    </method>
    <method name="sharp" return="org.bukkit.Note"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="octave" type="int"/>
      <param name="tone" type="org.bukkit.Note.Tone"/>
      <doc>
      <![CDATA[Creates a new note for a sharp tone, such as A-sharp.

 @param octave The octave where the note is in. Has to be 0 - 2.
 @param tone The tone within the octave. If the octave is 2 the note has
     to be F#.
 @return The new note.]]>
      </doc>
    </method>
    <method name="natural" return="org.bukkit.Note"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="octave" type="int"/>
      <param name="tone" type="org.bukkit.Note.Tone"/>
      <doc>
      <![CDATA[Creates a new note for a natural tone, such as A-natural.

 @param octave The octave where the note is in. Has to be 0 - 1.
 @param tone The tone within the octave.
 @return The new note.]]>
      </doc>
    </method>
    <method name="sharped" return="org.bukkit.Note"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The note a semitone above this one.]]>
      </doc>
    </method>
    <method name="flattened" return="org.bukkit.Note"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The note a semitone below this one.]]>
      </doc>
    </method>
    <method name="getId" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Returns the internal id of this note.

 @return the internal id of this note.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getOctave" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the octave of this note.

 @return the octave of this note.]]>
      </doc>
    </method>
    <method name="getTone" return="org.bukkit.Note.Tone"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the tone of this note.

 @return the tone of this note.]]>
      </doc>
    </method>
    <method name="isSharped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if this note is sharped.

 @return if this note is sharped.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A note class to store a specific note.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Note -->
  <!-- start class org.bukkit.Note.Tone -->
  <class name="Note.Tone" extends="java.lang.Enum&lt;org.bukkit.Note.Tone&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Note.Tone[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Note.Tone"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getId" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Returns the not sharped id of this tone.

 @return the not sharped id of this tone.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getId" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="sharped" type="boolean"/>
      <doc>
      <![CDATA[Returns the id of this tone. These method allows to return the
 sharped id of the tone. If the tone couldn't be sharped it always
 return the not sharped id of this tone.

 @param sharped Set to true to return the sharped id.
 @return the id of this tone.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="isSharpable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if this tone could be sharped.

 @return if this tone could be sharped.]]>
      </doc>
    </method>
    <method name="isSharped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="byte"/>
      <doc>
      <![CDATA[Returns if this tone id is the sharped id of the tone.

 @param id the id of the tone.
 @return if the tone id is the sharped id of the tone.
 @throws IllegalArgumentException if neither the tone nor the
     semitone have the id.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getById" return="org.bukkit.Note.Tone"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="byte"/>
      <doc>
      <![CDATA[Returns the tone to id. Also returning the semitones.

 @param id the id of the tone.
 @return the tone to id.
 @deprecated Magic value]]>
      </doc>
    </method>
    <field name="TONES_COUNT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of tones including sharped tones.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An enum holding tones.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Note.Tone -->
  <!-- start interface org.bukkit.OfflinePlayer -->
  <interface name="OfflinePlayer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.permissions.ServerOperator"/>
    <implements name="org.bukkit.entity.AnimalTamer"/>
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <method name="isOnline" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this player is currently online

 @return true if they are online]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this player
 <p>
 Names are no longer unique past a single game session. For persistent storage
 it is recommended that you use {@link #getUniqueId()} instead.

 @return Player name or null if we have not seen a name for this player yet]]>
      </doc>
    </method>
    <method name="getUniqueId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the UUID of this player

 @return Player UUID]]>
      </doc>
    </method>
    <method name="isBanned" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this player is banned or not

 @return true if banned, otherwise false]]>
      </doc>
    </method>
    <method name="banPlayer" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <doc>
      <![CDATA[Permanently Bans this player from the server

 @param reason Reason for Ban
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayer" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Permanently Bans this player from the server
 @param reason Reason for Ban
 @param source Source of the ban, or null for default
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayer" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <doc>
      <![CDATA[Bans this player from the server
 @param reason Reason for Ban
 @param expires When to expire the ban
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayer" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Bans this player from the server
 @param reason Reason for Ban
 @param expires When to expire the ban
 @param source Source of the ban or null for default
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayer" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <param name="source" type="java.lang.String"/>
      <param name="kickIfOnline" type="boolean"/>
    </method>
    <method name="isWhitelisted" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this player is whitelisted or not

 @return true if whitelisted]]>
      </doc>
    </method>
    <method name="setWhitelisted"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets if this player is whitelisted or not

 @param value true if whitelisted]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a {@link Player} object that this represents, if there is one
 <p>
 If the player is online, this will return that player. Otherwise,
 it will return null.

 @return Online player]]>
      </doc>
    </method>
    <method name="getFirstPlayed" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the first date and time that this player was witnessed on this
 server.
 <p>
 If the player has never played before, this will return 0. Otherwise,
 it will be the amount of milliseconds since midnight, January 1, 1970
 UTC.

 @return Date of first log-in for this player, or 0]]>
      </doc>
    </method>
    <method name="getLastPlayed" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="The API contract is ambiguous and the implementation may or may not return the correct value given this API ambiguity. It is instead recommended use {@link #getLastLogin()} or {@link #getLastSeen()} depending on your needs.">
      <doc>
      <![CDATA[Gets the last date and time that this player was witnessed on this
 server.
 <p>
 If the player has never played before, this will return 0. Otherwise,
 it will be the amount of milliseconds since midnight, January 1, 1970
 UTC.

 @return Date of last log-in for this player, or 0
 @deprecated The API contract is ambiguous and the implementation may or may not return the correct value given this API ambiguity. It is instead recommended use {@link #getLastLogin()} or {@link #getLastSeen()} depending on your needs.]]>
      </doc>
    </method>
    <method name="hasPlayedBefore" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this player has played on this server before.

 @return True if the player has played before, otherwise false]]>
      </doc>
    </method>
    <method name="getBedSpawnLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Location where the player will spawn at their bed, null if
 they have not slept in one or their current bed spawn is invalid.

 @return Bed Spawn Location if bed exists, otherwise null.]]>
      </doc>
    </method>
    <method name="getLastLogin" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the last date and time that this player logged into the server.
 <p>
 If the player has never played before, this will return 0. Otherwise,
 it will be the amount of milliseconds since midnight, January 1, 1970
 UTC.

 @return last login time]]>
      </doc>
    </method>
    <method name="getLastSeen" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the last date and time that this player was seen on the server.
 <p>
 If the player has never played before, this will return 0. If the
 player is currently online, this will return the current time.
 Otherwise it will be the amount of milliseconds since midnight,
 January 1, 1970 UTC.

 @return last seen time]]>
      </doc>
    </method>
    <method name="incrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Increments the given statistic for this player.
 <p>
 This is equivalent to the following code:
 <code>incrementStatistic(Statistic, 1)</code>

 @param statistic Statistic to increment
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if the statistic requires an
     additional parameter]]>
      </doc>
    </method>
    <method name="decrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Decrements the given statistic for this player.
 <p>
 This is equivalent to the following code:
 <code>decrementStatistic(Statistic, 1)</code>

 @param statistic Statistic to decrement
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if the statistic requires an
     additional parameter]]>
      </doc>
    </method>
    <method name="incrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="amount" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Increments the given statistic for this player.

 @param statistic Statistic to increment
 @param amount Amount to increment this statistic by
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if amount is negative
 @throws IllegalArgumentException if the statistic requires an
     additional parameter]]>
      </doc>
    </method>
    <method name="decrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="amount" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Decrements the given statistic for this player.

 @param statistic Statistic to decrement
 @param amount Amount to decrement this statistic by
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if amount is negative
 @throws IllegalArgumentException if the statistic requires an
     additional parameter]]>
      </doc>
    </method>
    <method name="setStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="newValue" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the given statistic for this player.

 @param statistic Statistic to set
 @param newValue The value to set this statistic to
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if newValue is negative
 @throws IllegalArgumentException if the statistic requires an
     additional parameter]]>
      </doc>
    </method>
    <method name="getStatistic" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets the value of the given statistic for this player.

 @param statistic Statistic to check
 @return the value of the given statistic
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if the statistic requires an
     additional parameter]]>
      </doc>
    </method>
    <method name="incrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Increments the given statistic for this player for the given material.
 <p>
 This is equivalent to the following code:
 <code>incrementStatistic(Statistic, Material, 1)</code>

 @param statistic Statistic to increment
 @param material Material to offset the statistic with
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if material is null
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="decrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Decrements the given statistic for this player for the given material.
 <p>
 This is equivalent to the following code:
 <code>decrementStatistic(Statistic, Material, 1)</code>

 @param statistic Statistic to decrement
 @param material Material to offset the statistic with
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if material is null
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="getStatistic" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets the value of the given statistic for this player.

 @param statistic Statistic to check
 @param material Material offset of the statistic
 @return the value of the given statistic
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if material is null
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="incrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="material" type="org.bukkit.Material"/>
      <param name="amount" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Increments the given statistic for this player for the given material.

 @param statistic Statistic to increment
 @param material Material to offset the statistic with
 @param amount Amount to increment this statistic by
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if material is null
 @throws IllegalArgumentException if amount is negative
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="decrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="material" type="org.bukkit.Material"/>
      <param name="amount" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Decrements the given statistic for this player for the given material.

 @param statistic Statistic to decrement
 @param material Material to offset the statistic with
 @param amount Amount to decrement this statistic by
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if material is null
 @throws IllegalArgumentException if amount is negative
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="setStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="material" type="org.bukkit.Material"/>
      <param name="newValue" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the given statistic for this player for the given material.

 @param statistic Statistic to set
 @param material Material to offset the statistic with
 @param newValue The value to set this statistic to
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if material is null
 @throws IllegalArgumentException if newValue is negative
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="incrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="entityType" type="org.bukkit.entity.EntityType"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Increments the given statistic for this player for the given entity.
 <p>
 This is equivalent to the following code:
 <code>incrementStatistic(Statistic, EntityType, 1)</code>

 @param statistic Statistic to increment
 @param entityType EntityType to offset the statistic with
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if entityType is null
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="decrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="entityType" type="org.bukkit.entity.EntityType"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Decrements the given statistic for this player for the given entity.
 <p>
 This is equivalent to the following code:
 <code>decrementStatistic(Statistic, EntityType, 1)</code>

 @param statistic Statistic to decrement
 @param entityType EntityType to offset the statistic with
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if entityType is null
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="getStatistic" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="entityType" type="org.bukkit.entity.EntityType"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets the value of the given statistic for this player.

 @param statistic Statistic to check
 @param entityType EntityType offset of the statistic
 @return the value of the given statistic
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if entityType is null
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="incrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="entityType" type="org.bukkit.entity.EntityType"/>
      <param name="amount" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Increments the given statistic for this player for the given entity.

 @param statistic Statistic to increment
 @param entityType EntityType to offset the statistic with
 @param amount Amount to increment this statistic by
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if entityType is null
 @throws IllegalArgumentException if amount is negative
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="decrementStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="entityType" type="org.bukkit.entity.EntityType"/>
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Decrements the given statistic for this player for the given entity.

 @param statistic Statistic to decrement
 @param entityType EntityType to offset the statistic with
 @param amount Amount to decrement this statistic by
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if entityType is null
 @throws IllegalArgumentException if amount is negative
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
    <method name="setStatistic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistic" type="org.bukkit.Statistic"/>
      <param name="entityType" type="org.bukkit.entity.EntityType"/>
      <param name="newValue" type="int"/>
      <doc>
      <![CDATA[Sets the given statistic for this player for the given entity.

 @param statistic Statistic to set
 @param entityType EntityType to offset the statistic with
 @param newValue The value to set this statistic to
 @throws IllegalArgumentException if statistic is null
 @throws IllegalArgumentException if entityType is null
 @throws IllegalArgumentException if newValue is negative
 @throws IllegalArgumentException if the given parameter is not valid
     for the statistic]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.OfflinePlayer -->
  <!-- start class org.bukkit.Particle -->
  <class name="Particle" extends="java.lang.Enum&lt;org.bukkit.Particle&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Particle[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Particle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getDataType" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the required data type for the particle
 @return the required data type]]>
      </doc>
    </method>
    <method name="builder" return="com.destroystokyo.paper.ParticleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@link com.destroystokyo.paper.ParticleBuilder}

 @return a {@link com.destroystokyo.paper.ParticleBuilder} for the particle]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.Particle -->
  <!-- start class org.bukkit.Particle.DustOptions -->
  <class name="Particle.DustOptions" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DustOptions" type="org.bukkit.Color, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getColor" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The color of the particles to be displayed.

 @return particle color]]>
      </doc>
    </method>
    <method name="getSize" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Relative size of the particle.

 @return relative particle size]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Options which can be applied to redstone dust particles - a particle
 color and size.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Particle.DustOptions -->
  <!-- start class org.bukkit.PortalType -->
  <class name="PortalType" extends="java.lang.Enum&lt;org.bukkit.PortalType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.PortalType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.PortalType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents various types of portals that can be made in a world.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.PortalType -->
  <!-- start interface org.bukkit.Raid -->
  <interface name="Raid"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isStarted" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether this raid started.

 @return whether raid is started]]>
      </doc>
    </method>
    <method name="getActiveTicks" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of ticks this raid has existed.

 @return active ticks]]>
      </doc>
    </method>
    <method name="getBadOmenLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Bad Omen level of this raid.

 @return Bad Omen level (between 0 and 5)]]>
      </doc>
    </method>
    <method name="setBadOmenLevel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="badOmenLevel" type="int"/>
      <doc>
      <![CDATA[Sets the Bad Omen level.
 <br>
 If the level is higher than 1, there will be an additional wave that as
 strong as the final wave.

 @param badOmenLevel new Bad Omen level (from 0-5)
 @throws IllegalArgumentException if invalid Bad Omen level]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the center location where the raid occurs.

 @return location]]>
      </doc>
    </method>
    <method name="getStatus" return="org.bukkit.Raid.RaidStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current status of the raid.
 <br>
 Do not use this method to check if the raid has been started, call
 {@link #isStarted()} instead.

 @return Raids status]]>
      </doc>
    </method>
    <method name="getSpawnedGroups" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of raider groups which have spawned.

 @return total spawned groups]]>
      </doc>
    </method>
    <method name="getTotalGroups" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of raider groups which would spawn.
 <br>
 This also includes the group which spawns in the additional wave (if
 present).

 @return total groups]]>
      </doc>
    </method>
    <method name="getTotalWaves" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of waves in this raid (exclude the additional wave).

 @return number of waves]]>
      </doc>
    </method>
    <method name="getTotalHealth" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the sum of all raider's health.

 @return total raiders health]]>
      </doc>
    </method>
    <method name="getHeroes" return="java.util.Set&lt;java.util.UUID&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the UUID of all heroes in this raid.

 @return a set of unique ids]]>
      </doc>
    </method>
    <method name="getRaiders" return="java.util.List&lt;org.bukkit.entity.Raider&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all remaining {@link Raider} in the present wave.

 @return a list of current raiders]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a raid event.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.Raid -->
  <!-- start class org.bukkit.Raid.RaidStatus -->
  <class name="Raid.RaidStatus" extends="java.lang.Enum&lt;org.bukkit.Raid.RaidStatus&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Raid.RaidStatus[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Raid.RaidStatus"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the status of a {@link Raid}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Raid.RaidStatus -->
  <!-- start interface org.bukkit.Registry -->
  <interface name="Registry"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable&lt;T&gt;"/>
    <method name="get" return="T extends org.bukkit.Keyed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Get the object by its key.

 @param key non-null key
 @return item or null if does not exist]]>
      </doc>
    </method>
    <field name="ADVANCEMENT" type="org.bukkit.Registry&lt;org.bukkit.advancement.Advancement&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server advancements.

 @see Bukkit#getAdvancement(org.bukkit.NamespacedKey)
 @see Bukkit#advancementIterator()]]>
      </doc>
    </field>
    <field name="ART" type="org.bukkit.Registry&lt;org.bukkit.Art&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server art.

 @see Art]]>
      </doc>
    </field>
    <field name="ATTRIBUTE" type="org.bukkit.Registry&lt;org.bukkit.attribute.Attribute&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attribute.

 @see Attribute]]>
      </doc>
    </field>
    <field name="BIOME" type="org.bukkit.Registry&lt;org.bukkit.block.Biome&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server biomes.

 @see Biome]]>
      </doc>
    </field>
    <field name="BOSS_BARS" type="org.bukkit.Registry&lt;org.bukkit.boss.KeyedBossBar&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Custom boss bars.

 @see Bukkit#getBossBar(org.bukkit.NamespacedKey)
 @see Bukkit#getBossBars()]]>
      </doc>
    </field>
    <field name="ENCHANTMENT" type="org.bukkit.Registry&lt;org.bukkit.enchantments.Enchantment&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server enchantments.

 @see Enchantment#getByKey(org.bukkit.NamespacedKey)]]>
      </doc>
    </field>
    <field name="ENTITY_TYPE" type="org.bukkit.Registry&lt;org.bukkit.entity.EntityType&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server entity types.

 @see EntityType]]>
      </doc>
    </field>
    <field name="LOOT_TABLES" type="org.bukkit.Registry&lt;org.bukkit.loot.LootTables&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default server loot tables.

 @see LootTables]]>
      </doc>
    </field>
    <field name="MATERIAL" type="org.bukkit.Registry&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server materials.

 @see Material]]>
      </doc>
    </field>
    <field name="STATISTIC" type="org.bukkit.Registry&lt;org.bukkit.Statistic&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server statistics.

 @see Statistic]]>
      </doc>
    </field>
    <field name="VILLAGER_PROFESSION" type="org.bukkit.Registry&lt;org.bukkit.entity.Villager.Profession&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Villager profession.

 @see Villager.Profession]]>
      </doc>
    </field>
    <field name="VILLAGER_TYPE" type="org.bukkit.Registry&lt;org.bukkit.entity.Villager.Type&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Villager type.

 @see Villager.Type]]>
      </doc>
    </field>
    <field name="MEMORY_MODULE_TYPE" type="org.bukkit.Registry&lt;org.bukkit.entity.memory.MemoryKey&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Memory Keys.

 @see MemoryKey]]>
      </doc>
    </field>
    <field name="FLUID" type="org.bukkit.Registry&lt;org.bukkit.Fluid&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server fluids.

 @see Fluid]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents a registry of Bukkit objects that may be retrieved by
 {@link NamespacedKey}.

 @param <T> type of item in the registry]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.Registry -->
  <!-- start class org.bukkit.Registry.SimpleRegistry -->
  <class name="Registry.SimpleRegistry" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Registry&lt;T&gt;"/>
    <constructor name="SimpleRegistry" type="java.lang.Class&lt;T&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleRegistry" type="java.lang.Class&lt;T&gt;, java.util.function.Predicate&lt;T&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="T extends java.lang.Enum&lt;T&gt;  org.bukkit.Keyed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.Registry.SimpleRegistry -->
  <!-- start class org.bukkit.Rotation -->
  <class name="Rotation" extends="java.lang.Enum&lt;org.bukkit.Rotation&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Rotation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Rotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="rotateClockwise" return="org.bukkit.Rotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Rotate clockwise by 90 degrees.

 @return the relative rotation]]>
      </doc>
    </method>
    <method name="rotateCounterClockwise" return="org.bukkit.Rotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Rotate counter-clockwise by 90 degrees.

 @return the relative rotation]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An enum to specify a rotation based orientation, like that on a clock.
 <p>
 It represents how something is viewed, as opposed to cardinal directions.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Rotation -->
  <!-- start class org.bukkit.SandstoneType -->
  <class name="SandstoneType" extends="java.lang.Enum&lt;org.bukkit.SandstoneType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.SandstoneType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.SandstoneType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the associated data value representing this type of sandstone

 @return A byte containing the data value of this sandstone type
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByData" return="org.bukkit.SandstoneType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Gets the type of sandstone with the given data value

 @param data Data value to fetch
 @return The {@link SandstoneType} representing the given value, or null
     if it doesn't exist
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the three different types of Sandstone]]>
    </doc>
  </class>
  <!-- end class org.bukkit.SandstoneType -->
  <!-- start interface org.bukkit.Server -->
  <interface name="Server"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.messaging.PluginMessageRecipient"/>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of this server implementation.

 @return name of this server implementation]]>
      </doc>
    </method>
    <method name="getVersion" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the version string of this server implementation.

 @return version of this server implementation]]>
      </doc>
    </method>
    <method name="getBukkitVersion" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Bukkit version that this server is running.

 @return version of Bukkit]]>
      </doc>
    </method>
    <method name="getMinecraftVersion" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the version of game this server implements

 @return version of game]]>
      </doc>
    </method>
    <method name="getOnlinePlayers" return="java.util.Collection&lt;? extends org.bukkit.entity.Player&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a view of all currently logged in players. This {@linkplain
 Collections#unmodifiableCollection(Collection) view} is a reused
 object, making some operations like {@link Collection#size()}
 zero-allocation.
 <p>
 The collection is a view backed by the internal representation, such
 that, changes to the internal state of the server will be reflected
 immediately. However, the reuse of the returned collection (identity)
 is not strictly guaranteed for future or all implementations. Casting
 the collection, or relying on interface implementations (like {@link
 Serializable} or {@link List}), is deprecated.
 <p>
 Iteration behavior is undefined outside of self-contained main-thread
 uses. Normal and immediate iterator use without consequences that
 affect the collection are fully supported. The effects following
 (non-exhaustive) {@link Entity#teleport(Location) teleportation},
 {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
 String) kicking} are undefined. Any use of this collection from
 asynchronous threads is unsafe.
 <p>
 For safe consequential iteration or mimicking the old array behavior,
 using {@link Collection#toArray(Object[])} is recommended. For making
 snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.

 @return a view of currently online players.]]>
      </doc>
    </method>
    <method name="getMaxPlayers" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum amount of players which can login to this server.

 @return the amount of players this server allows]]>
      </doc>
    </method>
    <method name="setMaxPlayers"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxPlayers" type="int"/>
      <doc>
      <![CDATA[Set the maximum amount of players which can login to this server.

 @param maxPlayers the amount of players this server allows]]>
      </doc>
    </method>
    <method name="getPort" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the game port that the server runs on.

 @return the port number of this server]]>
      </doc>
    </method>
    <method name="getViewDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the view distance from this server.

 @return the view distance from this server.]]>
      </doc>
    </method>
    <method name="getIp" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the IP that this server is bound to, or empty string if not
 specified.

 @return the IP string that this server is bound to, otherwise empty
     string]]>
      </doc>
    </method>
    <method name="getWorldType" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get world type (level-type setting) for default world.

 @return the value of level-type (e.g. DEFAULT, FLAT, DEFAULT_1_1)]]>
      </doc>
    </method>
    <method name="getGenerateStructures" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get generate-structures setting.

 @return true if structure generation is enabled, false otherwise]]>
      </doc>
    </method>
    <method name="getAllowEnd" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this server allows the End or not.

 @return whether this server allows the End or not]]>
      </doc>
    </method>
    <method name="getAllowNether" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this server allows the Nether or not.

 @return whether this server allows the Nether or not]]>
      </doc>
    </method>
    <method name="hasWhitelist" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this server has a whitelist or not.

 @return whether this server has a whitelist or not]]>
      </doc>
    </method>
    <method name="setWhitelist"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets if the server is whitelisted.

 @param value true for whitelist on, false for off]]>
      </doc>
    </method>
    <method name="getWhitelistedPlayers" return="java.util.Set&lt;org.bukkit.OfflinePlayer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of whitelisted players.

 @return a set containing all whitelisted players]]>
      </doc>
    </method>
    <method name="reloadWhitelist"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reloads the whitelist from disk.]]>
      </doc>
    </method>
    <method name="broadcastMessage" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Broadcast a message to all players.
 <p>
 This is the same as calling {@link #broadcast(java.lang.String,
 java.lang.String)} to {@link #BROADCAST_CHANNEL_USERS}

 @param message the message
 @return the number of players]]>
      </doc>
    </method>
    <method name="broadcast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Sends the component to all online players.

 @param component the component to send]]>
      </doc>
    </method>
    <method name="broadcast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an array of components as a single message to all online players.

 @param components the components to send]]>
      </doc>
    </method>
    <method name="getUpdateFolder" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the update folder. The update folder is used to safely
 update plugins at the right moment on a plugin load.
 <p>
 The update folder name is relative to the plugins folder.

 @return the name of the update folder]]>
      </doc>
    </method>
    <method name="getUpdateFolderFile" return="java.io.File"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the update folder. The update folder is used to safely update
 plugins at the right moment on a plugin load.

 @return the update folder]]>
      </doc>
    </method>
    <method name="getConnectionThrottle" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the connection throttle setting.

 @return the value of the connection throttle setting]]>
      </doc>
    </method>
    <method name="getTicksPerAnimalSpawns" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets default ticks per animal spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn monsters
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn monsters
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, animal spawning will be disabled. We
 recommend using spawn-animals to control this instead.
 <p>
 Minecraft default: 400.

 @return the default ticks per animal spawns value]]>
      </doc>
    </method>
    <method name="getTicksPerMonsterSpawns" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per monster spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn monsters
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn monsters
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, monsters spawning will be disabled. We
 recommend using spawn-monsters to control this instead.
 <p>
 Minecraft default: 1.

 @return the default ticks per monsters spawn value]]>
      </doc>
    </method>
    <method name="getTicksPerWaterSpawns" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per water mob spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn water mobs
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn water mobs
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, water mobs spawning will be disabled.
 <p>
 Minecraft default: 1.

 @return the default ticks per water mobs spawn value]]>
      </doc>
    </method>
    <method name="getTicksPerWaterAmbientSpawns" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per water ambient mob spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn water ambient mobs
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn water ambient mobs
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, ambient mobs spawning will be disabled.
 <p>
 Minecraft default: 1.

 @return the default ticks per water ambient mobs spawn value]]>
      </doc>
    </method>
    <method name="getTicksPerAmbientSpawns" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per ambient mob spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn ambient mobs
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn ambient mobs
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, ambient mobs spawning will be disabled.
 <p>
 Minecraft default: 1.

 @return the default ticks per ambient mobs spawn value]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a player object by the given username.
 <p>
 This method may not return objects for offline players.

 @param name the name to look up
 @return a player if one was found, null otherwise]]>
      </doc>
    </method>
    <method name="getPlayerExact" return="org.bukkit.entity.Player"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the player with the exact given name, case insensitive.

 @param name Exact name of the player to retrieve
 @return a player object if one was found, null otherwise]]>
      </doc>
    </method>
    <method name="matchPlayer" return="java.util.List&lt;org.bukkit.entity.Player&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Attempts to match any players with the given name, and returns a list
 of all possibly matches.
 <p>
 This list is not sorted in any particular order. If an exact match is
 found, the returned list will only contain a single result.

 @param name the (partial) name to match
 @return list of all possible players]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets the player with the given UUID.

 @param id UUID of the player to retrieve
 @return a player object if one was found, null otherwise]]>
      </doc>
    </method>
    <method name="getPlayerUniqueId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="playerName" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the unique ID of the player currently known as the specified player name
 In Offline Mode, will return an Offline UUID

 @param playerName the player name to look up the unique ID for
 @return A UUID, or null if that player name is not registered with Minecraft and the server is in online mode]]>
      </doc>
    </method>
    <method name="getPluginManager" return="org.bukkit.plugin.PluginManager"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin manager for interfacing with plugins.

 @return a plugin manager for this Server instance]]>
      </doc>
    </method>
    <method name="getScheduler" return="org.bukkit.scheduler.BukkitScheduler"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the scheduler for managing scheduled events.

 @return a scheduling service for this server]]>
      </doc>
    </method>
    <method name="getServicesManager" return="org.bukkit.plugin.ServicesManager"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a services manager.

 @return s services manager]]>
      </doc>
    </method>
    <method name="getWorlds" return="java.util.List&lt;org.bukkit.World&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of all worlds on this server.

 @return a list of worlds]]>
      </doc>
    </method>
    <method name="createWorld" return="org.bukkit.World"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="creator" type="org.bukkit.WorldCreator"/>
      <doc>
      <![CDATA[Creates or loads a world with the given name using the specified
 options.
 <p>
 If the world is already loaded, it will just return the equivalent of
 getWorld(creator.name()).

 @param creator the options to use when creating the world
 @return newly created or loaded world]]>
      </doc>
    </method>
    <method name="unloadWorld" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="save" type="boolean"/>
      <doc>
      <![CDATA[Unloads a world with the given name.

 @param name Name of the world to unload
 @param save whether to save the chunks before unloading
 @return true if successful, false otherwise]]>
      </doc>
    </method>
    <method name="unloadWorld" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="save" type="boolean"/>
      <doc>
      <![CDATA[Unloads the given world.

 @param world the world to unload
 @param save whether to save the chunks before unloading
 @return true if successful, false otherwise]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the world with the given name.

 @param name the name of the world to retrieve
 @return a world with the given name, or null if none exists]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets the world from the given Unique ID.

 @param uid a unique-id of the world to retrieve
 @return a world with the given Unique ID, or null if none exists]]>
      </doc>
    </method>
    <method name="getMap" return="org.bukkit.map.MapView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Gets the map from the given item ID.

 @param id the id of the map to get
 @return a map view if it exists, or null otherwise
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="createMap" return="org.bukkit.map.MapView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Create a new map with an automatically assigned ID.

 @param world the world the map will belong to
 @return a newly created map view]]>
      </doc>
    </method>
    <method name="createExplorerMap" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="structureType" type="org.bukkit.StructureType"/>
      <doc>
      <![CDATA[Create a new explorer map targeting the closest nearby structure of a
 given {@link StructureType}.
 <br>
 This method uses implementation default values for radius and
 findUnexplored (usually 100, true).

 @param world the world the map will belong to
 @param location the origin location to find the nearest structure
 @param structureType the type of structure to find
 @return a newly created item stack

 @see World#locateNearestStructure(org.bukkit.Location,
      org.bukkit.StructureType, int, boolean)]]>
      </doc>
    </method>
    <method name="createExplorerMap" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="structureType" type="org.bukkit.StructureType"/>
      <param name="radius" type="int"/>
      <param name="findUnexplored" type="boolean"/>
      <doc>
      <![CDATA[Create a new explorer map targeting the closest nearby structure of a
 given {@link StructureType}.
 <br>
 This method uses implementation default values for radius and
 findUnexplored (usually 100, true).

 @param world the world the map will belong to
 @param location the origin location to find the nearest structure
 @param structureType the type of structure to find
 @param radius radius to search, see World#locateNearestStructure for more
               information
 @param findUnexplored whether to find unexplored structures
 @return the newly created item stack

 @see World#locateNearestStructure(org.bukkit.Location,
      org.bukkit.StructureType, int, boolean)]]>
      </doc>
    </method>
    <method name="reload"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reloads the server, refreshing settings and plugin information.]]>
      </doc>
    </method>
    <method name="reloadData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload only the Minecraft data for the server. This includes custom
 advancements and loot tables.]]>
      </doc>
    </method>
    <method name="getLogger" return="java.util.logging.Logger"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the primary logger associated with this server instance.

 @return Logger associated with this server]]>
      </doc>
    </method>
    <method name="getPluginCommand" return="org.bukkit.command.PluginCommand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a {@link PluginCommand} with the given name or alias.

 @param name the name of the command to retrieve
 @return a plugin command if found, null otherwise]]>
      </doc>
    </method>
    <method name="savePlayers"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Writes loaded players to disk.]]>
      </doc>
    </method>
    <method name="dispatchCommand" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="commandLine" type="java.lang.String"/>
      <exception name="CommandException" type="org.bukkit.command.CommandException"/>
      <doc>
      <![CDATA[Dispatches a command on this server, and executes it if found.

 @param sender the apparent sender of the command
 @param commandLine the command + arguments. Example: <code>test abc
     123</code>
 @return returns false if no target is found
 @throws CommandException thrown when the executor for the given command
     fails with an unhandled exception]]>
      </doc>
    </method>
    <method name="addRecipe" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipe" type="org.bukkit.inventory.Recipe"/>
      <doc>
      <![CDATA[Adds a recipe to the crafting manager.

 @param recipe the recipe to add
 @return true if the recipe was added, false if it wasn't for some
     reason]]>
      </doc>
    </method>
    <method name="getRecipesFor" return="java.util.List&lt;org.bukkit.inventory.Recipe&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Get a list of all recipes for a given item. The stack size is ignored
 in comparisons. If the durability is -1, it will match any data value.

 @param result the item to match against recipe results
 @return a list of recipes with the given result]]>
      </doc>
    </method>
    <method name="getRecipe" return="org.bukkit.inventory.Recipe"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipeKey" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Get the {@link Recipe} for the given key.

 @param recipeKey the key of the recipe to return
 @return the recipe for the given key or null.]]>
      </doc>
    </method>
    <method name="recipeIterator" return="java.util.Iterator&lt;org.bukkit.inventory.Recipe&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an iterator through the list of crafting recipes.

 @return an iterator]]>
      </doc>
    </method>
    <method name="clearRecipes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the list of crafting recipes.]]>
      </doc>
    </method>
    <method name="resetRecipes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the list of crafting recipes to the default.]]>
      </doc>
    </method>
    <method name="removeRecipe" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Remove a recipe from the server.

 <b>Note that removing a recipe may cause permanent loss of data
 associated with that recipe (eg whether it has been discovered by
 players).</b>

 @param key NamespacedKey of recipe to remove.
 @return True if recipe was removed]]>
      </doc>
    </method>
    <method name="getCommandAliases" return="java.util.Map&lt;java.lang.String, java.lang.String[]&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of command aliases defined in the server properties.

 @return a map of aliases to command names]]>
      </doc>
    </method>
    <method name="getSpawnRadius" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the radius, in blocks, around each worlds spawn point to protect.

 @return spawn radius, or 0 if none]]>
      </doc>
    </method>
    <method name="setSpawnRadius"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the radius, in blocks, around each worlds spawn point to protect.

 @param value new spawn radius, or 0 if none]]>
      </doc>
    </method>
    <method name="getOnlineMode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the Server is in online mode or not.

 @return true if the server authenticates clients, false otherwise]]>
      </doc>
    </method>
    <method name="getAllowFlight" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this server allows flying or not.

 @return true if the server allows flight, false otherwise]]>
      </doc>
    </method>
    <method name="isHardcore" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the server is in hardcore mode or not.

 @return true if the server mode is hardcore, false otherwise]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shutdowns the server, stopping everything.]]>
      </doc>
    </method>
    <method name="broadcast" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="permission" type="java.lang.String"/>
      <doc>
      <![CDATA[Broadcasts the specified message to every user with the given
 permission name.

 @param message message to broadcast
 @param permission the required permission {@link Permissible
     permissibles} must have to receive the broadcast
 @return number of message recipients]]>
      </doc>
    </method>
    <method name="getOfflinePlayer" return="org.bukkit.OfflinePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Persistent storage of users should be by UUID as names are no longer
             unique past a single session.">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the player by the given name, regardless if they are offline or
 online.
 <p>
 This method may involve a blocking web request to get the UUID for the
 given name.
 <p>
 This will return an object even if the player does not exist. To this
 method, all players will exist.

 @deprecated Persistent storage of users should be by UUID as names are no longer
             unique past a single session.
 @param name the name the player to retrieve
 @return an offline player
 @see #getOfflinePlayer(java.util.UUID)]]>
      </doc>
    </method>
    <method name="getOfflinePlayer" return="org.bukkit.OfflinePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets the player by the given UUID, regardless if they are offline or
 online.
 <p>
 This will return an object even if the player does not exist. To this
 method, all players will exist.

 @param id the UUID of the player to retrieve
 @return an offline player]]>
      </doc>
    </method>
    <method name="getIPBans" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all current IPs that are banned.

 @return a set containing banned IP addresses]]>
      </doc>
    </method>
    <method name="banIP"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.lang.String"/>
      <doc>
      <![CDATA[Bans the specified address from the server.

 @param address the IP address to ban]]>
      </doc>
    </method>
    <method name="unbanIP"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.lang.String"/>
      <doc>
      <![CDATA[Unbans the specified address from the server.

 @param address the IP address to unban]]>
      </doc>
    </method>
    <method name="getBannedPlayers" return="java.util.Set&lt;org.bukkit.OfflinePlayer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all banned players.

 @return a set containing banned players]]>
      </doc>
    </method>
    <method name="getBanList" return="org.bukkit.BanList"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.BanList.Type"/>
      <doc>
      <![CDATA[Gets a ban list for the supplied type.
 <p>
 Bans by name are no longer supported and this method will return
 null when trying to request them. The replacement is bans by UUID.

 @param type the type of list to fetch, cannot be null
 @return a ban list of the specified type]]>
      </doc>
    </method>
    <method name="getOperators" return="java.util.Set&lt;org.bukkit.OfflinePlayer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all player operators.

 @return a set containing player operators]]>
      </doc>
    </method>
    <method name="getDefaultGameMode" return="org.bukkit.GameMode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default {@link GameMode} for new players.

 @return the default game mode]]>
      </doc>
    </method>
    <method name="setDefaultGameMode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="org.bukkit.GameMode"/>
      <doc>
      <![CDATA[Sets the default {@link GameMode} for new players.

 @param mode the new game mode]]>
      </doc>
    </method>
    <method name="getConsoleSender" return="org.bukkit.command.ConsoleCommandSender"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a {@link ConsoleCommandSender} that may be used as an input source
 for this server.

 @return a console command sender]]>
      </doc>
    </method>
    <method name="getWorldContainer" return="java.io.File"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the folder that contains all of the various {@link World}s.

 @return folder that contains all worlds]]>
      </doc>
    </method>
    <method name="getOfflinePlayers" return="org.bukkit.OfflinePlayer[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets every player that has ever played on this server.

 @return an array containing all previous players]]>
      </doc>
    </method>
    <method name="getMessenger" return="org.bukkit.plugin.messaging.Messenger"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link Messenger} responsible for this server.

 @return messenger responsible for this server]]>
      </doc>
    </method>
    <method name="getHelpMap" return="org.bukkit.help.HelpMap"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link HelpMap} providing help topics for this server.

 @return a help map for this server]]>
      </doc>
    </method>
    <method name="createInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.inventory.InventoryHolder"/>
      <param name="type" type="org.bukkit.event.inventory.InventoryType"/>
      <doc>
      <![CDATA[Creates an empty inventory with the specified type. If the type
 is {@link InventoryType#CHEST}, the new inventory has a size of 27;
 otherwise the new inventory has the normal size for its type.
 <br>
 {@link InventoryType#WORKBENCH} will not process crafting recipes if
 created with this method. Use
 {@link Player#openWorkbench(Location, boolean)} instead.
 <br>
 {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
 for possible enchanting results. Use
 {@link Player#openEnchanting(Location, boolean)} instead.

 @param owner the holder of the inventory, or null to indicate no holder
 @param type the type of inventory to create
 @return a new inventory
 @throws IllegalArgumentException if the {@link InventoryType} cannot be
 viewed.

 @see InventoryType#isCreatable()]]>
      </doc>
    </method>
    <method name="createInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.inventory.InventoryHolder"/>
      <param name="type" type="org.bukkit.event.inventory.InventoryType"/>
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates an empty inventory with the specified type and title. If the type
 is {@link InventoryType#CHEST}, the new inventory has a size of 27;
 otherwise the new inventory has the normal size for its type.<br>
 It should be noted that some inventory types do not support titles and
 may not render with said titles on the Minecraft client.
 <br>
 {@link InventoryType#WORKBENCH} will not process crafting recipes if
 created with this method. Use
 {@link Player#openWorkbench(Location, boolean)} instead.
 <br>
 {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
 for possible enchanting results. Use
 {@link Player#openEnchanting(Location, boolean)} instead.

 @param owner The holder of the inventory; can be null if there's no holder.
 @param type The type of inventory to create.
 @param title The title of the inventory, to be displayed when it is viewed.
 @return The new inventory.
 @throws IllegalArgumentException if the {@link InventoryType} cannot be
 viewed.

 @see InventoryType#isCreatable()]]>
      </doc>
    </method>
    <method name="createInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.inventory.InventoryHolder"/>
      <param name="size" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates an empty inventory of type {@link InventoryType#CHEST} with the
 specified size.

 @param owner the holder of the inventory, or null to indicate no holder
 @param size a multiple of 9 as the size of inventory to create
 @return a new inventory
 @throws IllegalArgumentException if the size is not a multiple of 9]]>
      </doc>
    </method>
    <method name="createInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.inventory.InventoryHolder"/>
      <param name="size" type="int"/>
      <param name="title" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates an empty inventory of type {@link InventoryType#CHEST} with the
 specified size and title.

 @param owner the holder of the inventory, or null to indicate no holder
 @param size a multiple of 9 as the size of inventory to create
 @param title the title of the inventory, displayed when inventory is
     viewed
 @return a new inventory
 @throws IllegalArgumentException if the size is not a multiple of 9]]>
      </doc>
    </method>
    <method name="createMerchant" return="org.bukkit.inventory.Merchant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates an empty merchant.

 @param title the title of the corresponding merchant inventory, displayed
 when the merchant inventory is viewed
 @return a new merchant]]>
      </doc>
    </method>
    <method name="getMonsterSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of monsters that can spawn in a
 chunk.

 @return the monster spawn limit]]>
      </doc>
    </method>
    <method name="getAnimalSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of animals that can spawn in a
 chunk.

 @return the animal spawn limit]]>
      </doc>
    </method>
    <method name="getWaterAnimalSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of water animals that can spawn in
 a chunk.

 @return the water animal spawn limit]]>
      </doc>
    </method>
    <method name="getWaterAmbientSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of water ambient mobs that can spawn
 in a chunk.

 @return the water ambient spawn limit]]>
      </doc>
    </method>
    <method name="getAmbientSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of ambient mobs that can spawn in
 a chunk.

 @return the ambient spawn limit]]>
      </doc>
    </method>
    <method name="isPrimaryThread" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks the current thread against the expected primary thread for the
 server.
 <p>
 <b>Note:</b> this method should not be used to indicate the current
 synchronized state of the runtime. A current thread matching the main
 thread indicates that it is synchronized, but a mismatch <b>does not
 preclude</b> the same assumption.

 @return true if the current thread matches the expected primary thread,
     false otherwise]]>
      </doc>
    </method>
    <method name="getMotd" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the message that is displayed on the server list.

 @return the servers MOTD]]>
      </doc>
    </method>
    <method name="getShutdownMessage" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default message that is displayed when the server is stopped.

 @return the shutdown message]]>
      </doc>
    </method>
    <method name="getWarningState" return="org.bukkit.Warning.WarningState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current warning state for the server.

 @return the configured warning state]]>
      </doc>
    </method>
    <method name="getItemFactory" return="org.bukkit.inventory.ItemFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the instance of the item factory (for {@link ItemMeta}).

 @return the item factory
 @see ItemFactory]]>
      </doc>
    </method>
    <method name="getScoreboardManager" return="org.bukkit.scoreboard.ScoreboardManager"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the instance of the scoreboard manager.
 <p>
 This will only exist after the first world has loaded.

 @return the scoreboard manager or null if no worlds are loaded.]]>
      </doc>
    </method>
    <method name="getServerIcon" return="org.bukkit.util.CachedServerIcon"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an instance of the server's default server-icon.

 @return the default server-icon; null values may be used by the
     implementation to indicate no defined icon, but this behavior is
     not guaranteed]]>
      </doc>
    </method>
    <method name="loadServerIcon" return="org.bukkit.util.CachedServerIcon"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Loads an image from a file, and returns a cached image for the specific
 server-icon.
 <p>
 Size and type are implementation defined. An incompatible file is
 guaranteed to throw an implementation-defined {@link Exception}.

 @param file the file to load the from
 @throws IllegalArgumentException if image is null
 @throws Exception if the image does not meet current server server-icon
     specifications
 @return a cached server-icon that can be used for a {@link
     ServerListPingEvent#setServerIcon(CachedServerIcon)}]]>
      </doc>
    </method>
    <method name="loadServerIcon" return="org.bukkit.util.CachedServerIcon"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="image" type="java.awt.image.BufferedImage"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Creates a cached server-icon for the specific image.
 <p>
 Size and type are implementation defined. An incompatible file is
 guaranteed to throw an implementation-defined {@link Exception}.

 @param image the image to use
 @throws IllegalArgumentException if image is null
 @throws Exception if the image does not meet current server
     server-icon specifications
 @return a cached server-icon that can be used for a {@link
     ServerListPingEvent#setServerIcon(CachedServerIcon)}]]>
      </doc>
    </method>
    <method name="setIdleTimeout"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threshold" type="int"/>
      <doc>
      <![CDATA[Set the idle kick timeout. Any players idle for the specified amount of
 time will be automatically kicked.
 <p>
 A value of 0 will disable the idle kick timeout.

 @param threshold the idle timeout in minutes]]>
      </doc>
    </method>
    <method name="getIdleTimeout" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the idle kick timeout.

 @return the idle timeout in minutes]]>
      </doc>
    </method>
    <method name="createChunkData" return="org.bukkit.generator.ChunkGenerator.ChunkData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Create a ChunkData for use in a generator.

 See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}

 @param world the world to create the ChunkData for
 @return a new ChunkData for the world]]>
      </doc>
    </method>
    <method name="createVanillaChunkData" return="org.bukkit.generator.ChunkGenerator.ChunkData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Create a ChunkData for use in a generator, that is populated by the vanilla generator for that world

 @param world the world to create the ChunkData for
 @param x the x coordinate of the chunk
 @param z the z coordinate of the chunk
 @return a new ChunkData for the world]]>
      </doc>
    </method>
    <method name="createBossBar" return="org.bukkit.boss.BossBar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
      <param name="color" type="org.bukkit.boss.BarColor"/>
      <param name="style" type="org.bukkit.boss.BarStyle"/>
      <param name="flags" type="org.bukkit.boss.BarFlag[]"/>
      <doc>
      <![CDATA[Creates a boss bar instance to display to players. The progress
 defaults to 1.0

 @param title the title of the boss bar
 @param color the color of the boss bar
 @param style the style of the boss bar
 @param flags an optional list of flags to set on the boss bar
 @return the created boss bar]]>
      </doc>
    </method>
    <method name="createBossBar" return="org.bukkit.boss.KeyedBossBar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="title" type="java.lang.String"/>
      <param name="color" type="org.bukkit.boss.BarColor"/>
      <param name="style" type="org.bukkit.boss.BarStyle"/>
      <param name="flags" type="org.bukkit.boss.BarFlag[]"/>
      <doc>
      <![CDATA[Creates a boss bar instance to display to players. The progress defaults
 to 1.0.
 <br>
 This instance is added to the persistent storage of the server and will
 be editable by commands and restored after restart.

 @param key the key of the boss bar that is used to access the boss bar
 @param title the title of the boss bar
 @param color the color of the boss bar
 @param style the style of the boss bar
 @param flags an optional list of flags to set on the boss bar
 @return the created boss bar]]>
      </doc>
    </method>
    <method name="getBossBars" return="java.util.Iterator&lt;org.bukkit.boss.KeyedBossBar&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an unmodifiable iterator through all persistent bossbars.
 <ul>
   <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
   <li>
     <b>not</b> created using
     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   </li>
 </ul>

 e.g. bossbars created using the bossbar command

 @return a bossbar iterator]]>
      </doc>
    </method>
    <method name="getBossBar" return="org.bukkit.boss.KeyedBossBar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Gets the {@link KeyedBossBar} specified by this key.
 <ul>
   <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
   <li>
     <b>not</b> created using
     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   </li>
 </ul>

 e.g. bossbars created using the bossbar command

 @param key unique bossbar key
 @return bossbar or null if not exists]]>
      </doc>
    </method>
    <method name="removeBossBar" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Removes a {@link KeyedBossBar} specified by this key.
 <ul>
   <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
   <li>
     <b>not</b> created using
     {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
   </li>
 </ul>

 e.g. bossbars created using the bossbar command

 @param key unique bossbar key
 @return true if removal succeeded or false]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets an entity on the server by its UUID

 @param uuid the UUID of the entity
 @return the entity with the given UUID, or null if it isn't found]]>
      </doc>
    </method>
    <method name="getTPS" return="double[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current server TPS

 @return current server TPS (1m, 5m, 15m in Paper-Server)]]>
      </doc>
    </method>
    <method name="getTickTimes" return="long[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a sample of the servers last tick times (in nanos)

 @return A sample of the servers last tick times (in nanos)]]>
      </doc>
    </method>
    <method name="getAverageTickTime" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the average tick time (in millis)

 @return Average tick time (in millis)]]>
      </doc>
    </method>
    <method name="getCommandMap" return="org.bukkit.command.CommandMap"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the active {@link org.bukkit.command.CommandMap}

 @return the active command map]]>
      </doc>
    </method>
    <method name="getAdvancement" return="org.bukkit.advancement.Advancement"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Get the advancement specified by this key.

 @param key unique advancement key
 @return advancement or null if not exists]]>
      </doc>
    </method>
    <method name="advancementIterator" return="java.util.Iterator&lt;org.bukkit.advancement.Advancement&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an iterator through all advancements. Advancements cannot be removed
 from this iterator,

 @return an advancement iterator]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for the specified Material, with
 all properties initialized to unspecified defaults.

 @param material the material
 @return new data instance]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <param name="consumer" type="java.util.function.Consumer&lt;org.bukkit.block.data.BlockData&gt;"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for the specified Material, with
 all properties initialized to unspecified defaults.

 @param material the material
 @param consumer consumer to run on new instance before returning
 @return new data instance]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance with material and properties
 parsed from provided data.

 @param data data string
 @return new data instance
 @throws IllegalArgumentException if the specified data is not valid]]>
      </doc>
    </method>
    <method name="createBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <param name="data" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new {@link BlockData} instance for the specified Material, with
 all properties initialized to unspecified defaults, except for those
 provided in data.
 <br>
 If <code>material</code> is specified, then the data string must not also
 contain the material.

 @param material the material
 @param data data string
 @return new data instance
 @throws IllegalArgumentException if the specified data is not valid]]>
      </doc>
    </method>
    <method name="getTag" return="org.bukkit.Tag&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="registry" type="java.lang.String"/>
      <param name="tag" type="org.bukkit.NamespacedKey"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a tag which has already been defined within the server. Plugins are
 suggested to use the concrete tags in {@link Tag} rather than this method
 which makes no guarantees about which tags are available, and may also be
 less performant due to lack of caching.
 <br>
 Tags will be searched for in an implementation specific manner, but a
 path consisting of namespace/tags/registry/key is expected.
 <br>
 Server implementations are allowed to handle only the registries
 indicated in {@link Tag}.

 @param <T> type of the tag
 @param registry the tag registry to look at
 @param tag the name of the tag
 @param clazz the class of the tag entries
 @return the tag or null]]>
      </doc>
    </method>
    <method name="getTags" return="java.lang.Iterable&lt;org.bukkit.Tag&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="registry" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a all tags which have been defined within the server.
 <br>
 Server implementations are allowed to handle only the registries
 indicated in {@link Tag}.
 <br>
 No guarantees are made about the mutability of the returned iterator.

 @param <T> type of the tag
 @param registry the tag registry to look at
 @param clazz the class of the tag entries
 @return all defined tags]]>
      </doc>
    </method>
    <method name="getLootTable" return="org.bukkit.loot.LootTable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Gets the specified {@link LootTable}.

 @param key the name of the LootTable
 @return the LootTable, or null if no LootTable is found with that name]]>
      </doc>
    </method>
    <method name="selectEntities" return="java.util.List&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="selector" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Selects entities using the given Vanilla selector.
 <br>
 No guarantees are made about the selector format, other than they match
 the Vanilla format for the active Minecraft version.
 <br>
 Usually a selector will start with '@', unless selecting a Player in
 which case it may simply be the Player's name or UUID.
 <br>
 Note that in Vanilla, elevated permissions are usually required to use
 '@' selectors, but this method should not check such permissions from the
 sender.

 @param sender the sender to execute as, must be provided
 @param selector the selection string
 @return a list of the selected entities. The list will not be null, but
 no further guarantees are made.
 @throws IllegalArgumentException if the selector is malformed in any way
 or a parameter is null]]>
      </doc>
    </method>
    <method name="getUnsafe" return="org.bukkit.UnsafeValues"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see UnsafeValues
 @return the unsafe values instance]]>
      </doc>
    </method>
    <method name="spigot" return="org.bukkit.Server.Spigot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reloadPermissions"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reloadCommandAliases" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="suggestPlayerNamesWhenNullTabCompletions" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if player names should be suggested when a command returns {@code null} as
 their tab completion result.

 @return true if player names should be suggested]]>
      </doc>
    </method>
    <method name="getPermissionMessage" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the default no permission message used on the server]]>
      </doc>
    </method>
    <method name="createProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Creates a PlayerProfile for the specified uuid, with name as null
 @param uuid UUID to create profile for
 @return A PlayerProfile object]]>
      </doc>
    </method>
    <method name="createProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a PlayerProfile for the specified name, with UUID as null
 @param name Name to create profile for
 @return A PlayerProfile object]]>
      </doc>
    </method>
    <method name="createProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a PlayerProfile for the specified name/uuid

 Both UUID and Name can not be null at same time. One must be supplied.

 @param uuid UUID to create profile for
 @param name Name to create profile for
 @return A PlayerProfile object]]>
      </doc>
    </method>
    <method name="getCurrentTick" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current internal server tick

 @return Current tick]]>
      </doc>
    </method>
    <method name="isStopping" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the server is in the process of being shutdown.

 @return true if server is in the process of being shutdown]]>
      </doc>
    </method>
    <method name="getMobGoals" return="com.destroystokyo.paper.entity.ai.MobGoals"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link com.destroystokyo.paper.entity.ai.MobGoals} manager

 @return the mob goals manager]]>
      </doc>
    </method>
    <field name="BROADCAST_CHANNEL_ADMINISTRATIVE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used for all administrative messages, such as an operator using a
 command.
 <p>
 For use in {@link #broadcast(java.lang.String, java.lang.String)}.]]>
      </doc>
    </field>
    <field name="BROADCAST_CHANNEL_USERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used for all announcement messages, such as informing users that a
 player has joined.
 <p>
 For use in {@link #broadcast(java.lang.String, java.lang.String)}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents a server implementation.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.Server -->
  <!-- start class org.bukkit.Server.Spigot -->
  <class name="Server.Spigot" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spigot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getConfig" return="org.bukkit.configuration.file.YamlConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBukkitConfig" return="org.bukkit.configuration.file.YamlConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSpigotConfig" return="org.bukkit.configuration.file.YamlConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPaperConfig" return="org.bukkit.configuration.file.YamlConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="broadcast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Sends the component to the player

 @param component the components to send]]>
      </doc>
    </method>
    <method name="broadcast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an array of components as a single message to the player

 @param components the components to send]]>
      </doc>
    </method>
    <method name="restart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Restart the server. If the server administrator has not configured restarting, the server will stop.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.Server.Spigot -->
  <!-- start class org.bukkit.SkullType -->
  <class name="SkullType" extends="java.lang.Enum&lt;org.bukkit.SkullType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="check {@link Material} instead">
    <method name="values" return="org.bukkit.SkullType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.SkullType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the different types of skulls.
 @deprecated check {@link Material} instead]]>
    </doc>
  </class>
  <!-- end class org.bukkit.SkullType -->
  <!-- start class org.bukkit.Sound -->
  <class name="Sound" extends="java.lang.Enum&lt;org.bukkit.Sound&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Sound[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Sound"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An Enum of Sounds the server is able to send to players.
 <p>
 WARNING: At any time, sounds may be added/removed from this Enum or even
 MineCraft itself! There is no guarantee the sounds will play. There is no
 guarantee values will not be removed from this Enum. As such, you should not
 depend on the ordinal values of this class.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Sound -->
  <!-- start class org.bukkit.SoundCategory -->
  <class name="SoundCategory" extends="java.lang.Enum&lt;org.bukkit.SoundCategory&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.SoundCategory[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.SoundCategory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An Enum of categories for sounds.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.SoundCategory -->
  <!-- start class org.bukkit.Statistic -->
  <class name="Statistic" extends="java.lang.Enum&lt;org.bukkit.Statistic&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.Statistic[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Statistic"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getType" return="org.bukkit.Statistic.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of this statistic.

 @return the type of this statistic]]>
      </doc>
    </method>
    <method name="isSubstatistic" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this is a substatistic.
 <p>
 A substatistic exists en masse for each block, item, or entitytype, depending on
 {@link #getType()}.
 <p>
 This is a redundant method and equivalent to checking
 <code>getType() != Type.UNTYPED</code>

 @return true if this is a substatistic]]>
      </doc>
    </method>
    <method name="isBlock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this is a substatistic dealing with blocks.
 <p>
 This is a redundant method and equivalent to checking
 <code>getType() == Type.BLOCK</code>

 @return true if this deals with blocks]]>
      </doc>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a countable statistic, which is tracked by the server.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Statistic -->
  <!-- start class org.bukkit.Statistic.Type -->
  <class name="Statistic.Type" extends="java.lang.Enum&lt;org.bukkit.Statistic.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Statistic.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Statistic.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The type of statistic.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Statistic.Type -->
  <!-- start class org.bukkit.StructureType -->
  <class name="StructureType" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of this structure. This is case-sensitive when used in
 commands.

 @return the name of this structure]]>
      </doc>
    </method>
    <method name="getMapIcon" return="org.bukkit.map.MapCursor.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link org.bukkit.map.MapCursor.Type} that this structure can use on maps. If
 this is null, this structure will not appear on explorer maps.

 @return the {@link org.bukkit.map.MapCursor.Type} or null.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStructureTypes" return="java.util.Map&lt;java.lang.String, org.bukkit.StructureType&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all registered {@link StructureType}s.

 @return an immutable copy of registered structure types.]]>
      </doc>
    </method>
    <field name="MINESHAFT" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Mineshafts are underground structures which consist of branching mining
 tunnels with wooden supports and broken rails.
 <br>
 They are the only place where cave spider spawners and minecarts with
 chests can be found naturally.]]>
      </doc>
    </field>
    <field name="VILLAGE" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Villages are naturally generating structures that form above ground.
 <br>
 They are usually generated in desert, plains, taiga, and savanna biomes
 and are a site for villager spawns, with whom the player can trade.]]>
      </doc>
    </field>
    <field name="NETHER_FORTRESS" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Nether fortresses are very large complexes that mainly consist of
 netherbricks.
 <br>
 They contain blaze spawners, nether wart farms, and loot chests. They are
 only generated in the nether dimension.]]>
      </doc>
    </field>
    <field name="STRONGHOLD" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Strongholds are underground structures that consist of many rooms,
 libraries, and an end portal room.
 <br>
 They can be found using an {@link Material#ENDER_EYE}.]]>
      </doc>
    </field>
    <field name="JUNGLE_PYRAMID" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Jungle pyramids (also known as jungle temples) are found in jungles.
 <br>
 They are usually composed of cobblestone and mossy cobblestone. They
 consist of three floors, with the bottom floor containing treasure
 chests.]]>
      </doc>
    </field>
    <field name="OCEAN_RUIN" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ocean ruins are clusters of many different blocks that generate
 underwater in ocean biomes (as well as on the surface of beaches).
 <br>
 They come in my different variations. The cold variants consist primarily
 of stone brick, and the warm variants consist of sandstone.]]>
      </doc>
    </field>
    <field name="DESERT_PYRAMID" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Desert pyramids (also known as desert temples) are found in deserts.
 <br>
 They are usually composed of sandstone and stained terracotta.]]>
      </doc>
    </field>
    <field name="IGLOO" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Igloos are structures that generate in snowy biomes.
 <br>
 They consist of the house, as well as a basement.]]>
      </doc>
    </field>
    <field name="SWAMP_HUT" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Swamp huts (also known as witch huts) generate in swamp biomes and have
 the ability to spawn witches.]]>
      </doc>
    </field>
    <field name="OCEAN_MONUMENT" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ocean monuments are underwater structures.
 <br>
 They are usually composed on all three different prismarine types and sea
 lanterns. They are the only place guardians and elder guardians spawn
 naturally.]]>
      </doc>
    </field>
    <field name="END_CITY" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End Cities are tall castle-like structures that generate in the outer
 island of the End dimension.
 <br>
 They consist primarily of end stone bricks, purpur blocks, and end rods.
 They are the only place where shulkers can be found.]]>
      </doc>
    </field>
    <field name="WOODLAND_MANSION" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Mansions (also known as woodland mansions) are massive house structures
 that generate in dark forests, containing a wide variety of rooms.
 <br>
 They are the only place where evokers, vindicators, and vexes spawn
 naturally (but only once)]]>
      </doc>
    </field>
    <field name="BURIED_TREASURE" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Buried treasure consists of a single chest buried in the beach sand or
 gravel, with random loot in it.]]>
      </doc>
    </field>
    <field name="SHIPWRECK" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shipwrecks are structures that generate on the floor of oceans or
 beaches.
 <br>
 They are made up of wood materials, and contain 1-3 loot chests. They can
 generate sideways, upside-down, or upright.]]>
      </doc>
    </field>
    <field name="PILLAGER_OUTPOST" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Pillager outposts may contain crossbows.]]>
      </doc>
    </field>
    <field name="NETHER_FOSSIL" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Nether fossils.]]>
      </doc>
    </field>
    <field name="RUINED_PORTAL" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ruined portal.]]>
      </doc>
    </field>
    <field name="BASTION_REMNANT" type="org.bukkit.StructureType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bastion remnant.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This class handles the creation and storage of all structure types for
 Bukkit. Structure Types are the different kinds of structures that can be
 generated during world/chunk generation. These include Villages, Mineshafts,
 Mansions, etc.
 <br>
 The registration of new {@link StructureType}s is case-sensitive.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.StructureType -->
  <!-- start interface org.bukkit.Tag -->
  <interface name="Tag"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="isTagged" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="T extends org.bukkit.Keyed"/>
      <doc>
      <![CDATA[Returns whether or not this tag has an entry for the specified item.

 @param item to check
 @return if it is tagged]]>
      </doc>
    </method>
    <method name="getValues" return="java.util.Set&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an immutable set of all tagged items.

 @return set of tagged items]]>
      </doc>
    </method>
    <field name="REGISTRY_BLOCKS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key for the built in block registry.]]>
      </doc>
    </field>
    <field name="WOOL" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all colors of wool.]]>
      </doc>
    </field>
    <field name="PLANKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all plank variants.]]>
      </doc>
    </field>
    <field name="STONE_BRICKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all regular/mossy/cracked/chiseled stone
 bricks.]]>
      </doc>
    </field>
    <field name="WOODEN_BUTTONS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wooden buttons.]]>
      </doc>
    </field>
    <field name="BUTTONS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all buttons (inherits from
 {@link #WOODEN_BUTTONS}.]]>
      </doc>
    </field>
    <field name="CARPETS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all colors of carpet.]]>
      </doc>
    </field>
    <field name="WOODEN_DOORS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wooden doors.]]>
      </doc>
    </field>
    <field name="WOODEN_STAIRS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wooden stairs.]]>
      </doc>
    </field>
    <field name="WOODEN_SLABS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wooden slabs.]]>
      </doc>
    </field>
    <field name="WOODEN_FENCES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wooden fences.]]>
      </doc>
    </field>
    <field name="PRESSURE_PLATES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all pressure plates.]]>
      </doc>
    </field>
    <field name="WOODEN_PRESSURE_PLATES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wooden pressure plates.]]>
      </doc>
    </field>
    <field name="STONE_PRESSURE_PLATES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all stone pressure plates.]]>
      </doc>
    </field>
    <field name="WOODEN_TRAPDOORS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wooden trapdoors.]]>
      </doc>
    </field>
    <field name="DOORS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all doors (inherits from
 {@link #WOODEN_DOORS}.]]>
      </doc>
    </field>
    <field name="SAPLINGS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all sapling variants.]]>
      </doc>
    </field>
    <field name="LOGS_THAT_BURN" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all log and bark variants that burn.]]>
      </doc>
    </field>
    <field name="LOGS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all log and bark variants.]]>
      </doc>
    </field>
    <field name="DARK_OAK_LOGS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all dark oak log and bark variants.]]>
      </doc>
    </field>
    <field name="OAK_LOGS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all oak log and bark variants.]]>
      </doc>
    </field>
    <field name="BIRCH_LOGS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all birch log and bark variants.]]>
      </doc>
    </field>
    <field name="ACACIA_LOGS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all acacia log and bark variants.]]>
      </doc>
    </field>
    <field name="JUNGLE_LOGS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all jungle log and bark variants.]]>
      </doc>
    </field>
    <field name="SPRUCE_LOGS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all spruce log and bark variants.]]>
      </doc>
    </field>
    <field name="CRIMSON_STEMS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all crimson stems.]]>
      </doc>
    </field>
    <field name="WARPED_STEMS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all warped stems.]]>
      </doc>
    </field>
    <field name="BANNERS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all banner blocks.]]>
      </doc>
    </field>
    <field name="SAND" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all sand blocks.]]>
      </doc>
    </field>
    <field name="STAIRS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all stairs.]]>
      </doc>
    </field>
    <field name="SLABS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all slabs.]]>
      </doc>
    </field>
    <field name="WALLS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all walls.]]>
      </doc>
    </field>
    <field name="ANVIL" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all damaged and undamaged anvils.]]>
      </doc>
    </field>
    <field name="RAILS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all Minecart rails.]]>
      </doc>
    </field>
    <field name="LEAVES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all leaves fans.]]>
      </doc>
    </field>
    <field name="TRAPDOORS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all trapdoors (inherits from
 {@link #WOODEN_TRAPDOORS}.]]>
      </doc>
    </field>
    <field name="FLOWER_POTS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all empty and filled flower pots.]]>
      </doc>
    </field>
    <field name="SMALL_FLOWERS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all small flowers.]]>
      </doc>
    </field>
    <field name="BEDS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all beds.]]>
      </doc>
    </field>
    <field name="FENCES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all fences.]]>
      </doc>
    </field>
    <field name="TALL_FLOWERS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all tall flowers.]]>
      </doc>
    </field>
    <field name="FLOWERS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all flowers.]]>
      </doc>
    </field>
    <field name="PIGLIN_REPELLENTS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all piglin repellents.]]>
      </doc>
    </field>
    <field name="GOLD_ORES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all gold ores.]]>
      </doc>
    </field>
    <field name="NON_FLAMMABLE_WOOD" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all non flammable wood.]]>
      </doc>
    </field>
    <field name="ENDERMAN_HOLDABLE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag denoting blocks that enderman may pick up and hold.]]>
      </doc>
    </field>
    <field name="ICE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag denoting ice blocks.]]>
      </doc>
    </field>
    <field name="VALID_SPAWN" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag denoting all valid mob spawn positions.]]>
      </doc>
    </field>
    <field name="IMPERMEABLE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag denoting impermeable blocks which do not drip fluids.]]>
      </doc>
    </field>
    <field name="UNDERWATER_BONEMEALS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag denoting all underwater blocks which may be bonemealed.]]>
      </doc>
    </field>
    <field name="CORAL_BLOCKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all coral blocks.]]>
      </doc>
    </field>
    <field name="WALL_CORALS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wall corals.]]>
      </doc>
    </field>
    <field name="CORAL_PLANTS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all coral plants.]]>
      </doc>
    </field>
    <field name="CORALS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all coral.]]>
      </doc>
    </field>
    <field name="BAMBOO_PLANTABLE_ON" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag denoting all blocks bamboo may be planted on.]]>
      </doc>
    </field>
    <field name="STANDING_SIGNS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all standing signs.]]>
      </doc>
    </field>
    <field name="WALL_SIGNS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wall signs.]]>
      </doc>
    </field>
    <field name="SIGNS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all signs.]]>
      </doc>
    </field>
    <field name="DRAGON_IMMUNE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all blocks immune to dragons.]]>
      </doc>
    </field>
    <field name="WITHER_IMMUNE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all blocks immune to withers.]]>
      </doc>
    </field>
    <field name="WITHER_SUMMON_BASE_BLOCKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all base blocks used for wither summoning.]]>
      </doc>
    </field>
    <field name="BEEHIVES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all beehives.]]>
      </doc>
    </field>
    <field name="CROPS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all crops.]]>
      </doc>
    </field>
    <field name="BEE_GROWABLES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all bee growables.]]>
      </doc>
    </field>
    <field name="PORTALS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all portals.]]>
      </doc>
    </field>
    <field name="FIRE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all fire blocks.]]>
      </doc>
    </field>
    <field name="NYLIUM" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all nylium blocks.]]>
      </doc>
    </field>
    <field name="WART_BLOCKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wart blocks.]]>
      </doc>
    </field>
    <field name="BEACON_BASE_BLOCKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all beacon base blocks.]]>
      </doc>
    </field>
    <field name="SOUL_SPEED_BLOCKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all blocks affected by the soul speed enchantment.]]>
      </doc>
    </field>
    <field name="WALL_POST_OVERRIDE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all wall post overrides.]]>
      </doc>
    </field>
    <field name="CLIMBABLE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all climbable blocks.]]>
      </doc>
    </field>
    <field name="SHULKER_BOXES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all shulker boxes.]]>
      </doc>
    </field>
    <field name="HOGLIN_REPELLENTS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all hoglin repellents.]]>
      </doc>
    </field>
    <field name="SOUL_FIRE_BASE_BLOCKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all soul fire base blocks.]]>
      </doc>
    </field>
    <field name="STRIDER_WARM_BLOCKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all warm strider blocks.]]>
      </doc>
    </field>
    <field name="CAMPFIRES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all campfires.]]>
      </doc>
    </field>
    <field name="GUARDED_BY_PIGLINS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all blocks guarded by piglins.]]>
      </doc>
    </field>
    <field name="PREVENT_MOB_SPAWNING_INSIDE" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all blocks that prevent inside mob
 spawning.]]>
      </doc>
    </field>
    <field name="FENCE_GATES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all fence gates.]]>
      </doc>
    </field>
    <field name="UNSTABLE_BOTTOM_CENTER" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all unstable bottom center blocks.]]>
      </doc>
    </field>
    <field name="INFINIBURN_OVERWORLD" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all blocks that burn forever in the
 overworld.]]>
      </doc>
    </field>
    <field name="INFINIBURN_NETHER" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all blocks that burn forever in the
 nether.]]>
      </doc>
    </field>
    <field name="INFINIBURN_END" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla block tag representing all blocks that burn forever in the end.]]>
      </doc>
    </field>
    <field name="REGISTRY_ITEMS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key for the built in item registry.]]>
      </doc>
    </field>
    <field name="ITEMS_PIGLIN_LOVED" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all items loved by piglins.]]>
      </doc>
    </field>
    <field name="ITEMS_BANNERS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all banner items.]]>
      </doc>
    </field>
    <field name="ITEMS_BOATS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all boat items.]]>
      </doc>
    </field>
    <field name="ITEMS_FISHES" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all fish items.]]>
      </doc>
    </field>
    <field name="ITEMS_MUSIC_DISCS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all music disc items.]]>
      </doc>
    </field>
    <field name="ITEMS_CREEPER_DROP_MUSIC_DISCS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all music disc items dropped by creepers.]]>
      </doc>
    </field>
    <field name="ITEMS_COALS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all coal items.]]>
      </doc>
    </field>
    <field name="ITEMS_ARROWS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all arrow items.]]>
      </doc>
    </field>
    <field name="ITEMS_LECTERN_BOOKS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all books that may be placed on lecterns.]]>
      </doc>
    </field>
    <field name="ITEMS_BEACON_PAYMENT_ITEMS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all items that may be placed in beacons.]]>
      </doc>
    </field>
    <field name="ITEMS_STONE_TOOL_MATERIALS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all stone tool materials.]]>
      </doc>
    </field>
    <field name="ITEMS_FURNACE_MATERIALS" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla item tag representing all furnace materials.]]>
      </doc>
    </field>
    <field name="REGISTRY_FLUIDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key for the built in fluid registry.]]>
      </doc>
    </field>
    <field name="FLUIDS_LAVA" type="org.bukkit.Tag&lt;org.bukkit.Fluid&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla fluid tag representing lava and flowing lava.]]>
      </doc>
    </field>
    <field name="FLUIDS_WATER" type="org.bukkit.Tag&lt;org.bukkit.Fluid&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vanilla fluid tag representing water and flowing water.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents a tag that may be defined by the server or a resource pack to
 group like things together.

 Note that whilst all tags defined within this interface must be present in
 implementations, their existence is not guaranteed across future versions.

 @param <T> the type of things grouped by this tag]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.Tag -->
  <!-- start class org.bukkit.TreeSpecies -->
  <class name="TreeSpecies" extends="java.lang.Enum&lt;org.bukkit.TreeSpecies&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.TreeSpecies[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.TreeSpecies"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the associated data value representing this species

 @return A byte containing the data value of this tree species
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByData" return="org.bukkit.TreeSpecies"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Gets the TreeSpecies with the given data value

 @param data Data value to fetch
 @return The {@link TreeSpecies} representing the given value, or null
     if it doesn't exist
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the different species of trees regardless of size.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.TreeSpecies -->
  <!-- start class org.bukkit.TreeType -->
  <class name="TreeType" extends="java.lang.Enum&lt;org.bukkit.TreeType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.TreeType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.TreeType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Tree and organic structure types.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.TreeType -->
  <!-- start class org.bukkit.UndefinedNullability -->
  <class name="UndefinedNullability"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="This should generally not be used in any new API code as it
 suggests a bad API design.">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotation for types, whose nullability is not well defined, so
 {@link org.jetbrains.annotations.NotNull} nor
 {@link org.jetbrains.annotations.Nullable} is applicable. For example when
 interface defines a method, whose nullability depends on the implementation.

 @deprecated This should generally not be used in any new API code as it
 suggests a bad API design.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.UndefinedNullability -->
  <!-- start interface org.bukkit.UnsafeValues -->
  <interface name="UnsafeValues"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="reportTimings"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toLegacy" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
    </method>
    <method name="fromLegacy" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
    </method>
    <method name="fromLegacy" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.material.MaterialData"/>
    </method>
    <method name="fromLegacy" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.material.MaterialData"/>
      <param name="itemPriority" type="boolean"/>
    </method>
    <method name="fromLegacy" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <param name="data" type="byte"/>
    </method>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="java.lang.String"/>
      <param name="version" type="int"/>
    </method>
    <method name="getDataVersion" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="modifyItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <param name="arguments" type="java.lang.String"/>
    </method>
    <method name="checkSupported"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pdf" type="org.bukkit.plugin.PluginDescriptionFile"/>
      <exception name="InvalidPluginException" type="org.bukkit.plugin.InvalidPluginException"/>
    </method>
    <method name="processClass" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pdf" type="org.bukkit.plugin.PluginDescriptionFile"/>
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="byte[]"/>
    </method>
    <method name="loadAdvancement" return="org.bukkit.advancement.Advancement"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="advancement" type="java.lang.String"/>
      <doc>
      <![CDATA[Load an advancement represented by the specified string into the server.
 The advancement format is governed by Minecraft and has no specified
 layout.
 <br>
 It is currently a JSON object, as described by the Minecraft Wiki:
 http://minecraft.gamepedia.com/Advancements
 <br>
 Loaded advancements will be stored and persisted across server restarts
 and reloads.
 <br>
 Callers should be prepared for {@link Exception} to be thrown.

 @param key the unique advancement key
 @param advancement representation of the advancement
 @return the loaded advancement or null if an error occurred]]>
      </doc>
    </method>
    <method name="removeAdvancement" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Delete an advancement which was loaded and saved by
 {@link #loadAdvancement(org.bukkit.NamespacedKey, java.lang.String)}.
 <br>
 This method will only remove advancement from persistent storage. It
 should be accompanied by a call to {@link Server#reloadData()} in order
 to fully remove it from the running instance.

 @param key the unique advancement key
 @return true if a file matching this key was found and deleted]]>
      </doc>
    </method>
    <method name="getTimingsServerName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Server name to report to timings v2
 @return name]]>
      </doc>
    </method>
    <method name="getVersionFetcher" return="com.destroystokyo.paper.util.VersionFetcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called once by the version command on first use, then cached.]]>
      </doc>
    </method>
    <method name="isSupportedApiVersion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="apiVersion" type="java.lang.String"/>
    </method>
    <method name="isLegacyPlugin" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="serializeItem" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="deserializeItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
    </method>
    <method name="getTranslationKey" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mat" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Return the translation key for the Material, so the client can translate it into the active
 locale when using a TranslatableComponent.
 @return the translation key]]>
      </doc>
    </method>
    <method name="getTranslationKey" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <doc>
      <![CDATA[Return the translation key for the Block, so the client can translate it into the active
 locale when using a TranslatableComponent.
 @return the translation key]]>
      </doc>
    </method>
    <method name="getTranslationKey" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.entity.EntityType"/>
      <doc>
      <![CDATA[Return the translation key for the EntityType, so the client can translate it into the active
 locale when using a TranslatableComponent.<br>
 This is <code>null</code>, when the EntityType isn't known to NMS (custom entities)
 @return the translation key]]>
      </doc>
    </method>
    <method name="nextEntityId" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates and returns the next EntityId available.
 <p>
 Use this when sending custom packets, so that there are no collisions on the client or server.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface provides value conversions that may be specific to a
 runtime, or have arbitrary meaning (read: magic values).
 <p>
 Their existence and behavior is not guaranteed across future versions. They
 may be poorly named, throw exceptions, have misleading parameters, or any
 other bad programming practice.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.UnsafeValues -->
  <!-- start class org.bukkit.Utility -->
  <class name="Utility"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[This annotation indicates a method (and sometimes constructor) will chain
 its internal operations.
 <p>
 This is solely meant for identifying methods that don't need to be
 overridden / handled manually.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Utility -->
  <!-- start class org.bukkit.Warning -->
  <class name="Warning"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[This designates the warning state for a specific item.
 <p>
 When the server settings dictate 'default' warnings, warnings are printed
 if the {@link #value()} is true.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Warning -->
  <!-- start class org.bukkit.Warning.WarningState -->
  <class name="Warning.WarningState" extends="java.lang.Enum&lt;org.bukkit.Warning.WarningState&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.Warning.WarningState[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.Warning.WarningState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="printFor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="warning" type="org.bukkit.Warning"/>
      <doc>
      <![CDATA[This method checks the provided warning should be printed for this
 state

 @param warning The warning annotation added to a deprecated item
 @return <ul>
     <li>ON is always True
     <li>OFF is always false
     <li>DEFAULT is false if and only if annotation is not null and
     specifies false for {@link Warning#value()}, true otherwise.
     </ul>]]>
      </doc>
    </method>
    <method name="value" return="org.bukkit.Warning.WarningState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[This method returns the corresponding warning state for the given
 string value.

 @param value The string value to check
 @return {@link #DEFAULT} if not found, or the respective
     WarningState]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This represents the states that server verbose for warnings may be.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.Warning.WarningState -->
  <!-- start class org.bukkit.WeatherType -->
  <class name="WeatherType" extends="java.lang.Enum&lt;org.bukkit.WeatherType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.WeatherType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.WeatherType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum of all current weather types]]>
    </doc>
  </class>
  <!-- end class org.bukkit.WeatherType -->
  <!-- start interface org.bukkit.World -->
  <interface name="World"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.messaging.PluginMessageRecipient"/>
    <implements name="org.bukkit.metadata.Metadatable"/>
    <method name="getEntityCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The amount of Entities in this world]]>
      </doc>
    </method>
    <method name="getTileEntityCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The amount of Tile Entities in this world]]>
      </doc>
    </method>
    <method name="getTickableTileEntityCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The amount of Tickable Tile Entities in this world]]>
      </doc>
    </method>
    <method name="getChunkCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The amount of Chunks in this world]]>
      </doc>
    </method>
    <method name="getPlayerCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The amount of Players in this world]]>
      </doc>
    </method>
    <method name="getMoonPhase" return="io.papermc.paper.world.MoonPhase"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the current moon phase at the current time in the world]]>
      </doc>
    </method>
    <method name="getBlockAt" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the {@link Block} at the given coordinates

 @param x X-coordinate of the block
 @param y Y-coordinate of the block
 @param z Z-coordinate of the block
 @return Block at the given coordinates]]>
      </doc>
    </method>
    <method name="getBlockAt" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Gets the {@link Block} at the given {@link Location}

 @param location Location of the block
 @return Block at the given location]]>
      </doc>
    </method>
    <method name="getBlockAtKey" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="long"/>
      <doc>
      <![CDATA[Gets the {@link Block} at the given block key

 @param key The block key. See {@link Block#getBlockKey()}
 @return Block at the key
 @see Block#getBlockKey(int, int, int)]]>
      </doc>
    </method>
    <method name="getLocationAtKey" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="long"/>
      <doc>
      <![CDATA[Gets the {@link Location} at the given block key

 @param key The block key. See {@link Location#toBlockKey()}
 @return Location at the key
 @see Block#getBlockKey(int, int, int)]]>
      </doc>
    </method>
    <method name="getHighestBlockYAt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the highest non-empty (impassable) coordinate at the given
 coordinates.

 @param x X-coordinate of the blocks
 @param z Z-coordinate of the blocks
 @return Y-coordinate of the highest non-empty block]]>
      </doc>
    </method>
    <method name="getHighestBlockYAt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Gets the highest non-empty (impassable) coordinate at the given
 {@link Location}.

 @param location Location of the blocks
 @return Y-coordinate of the highest non-empty block]]>
      </doc>
    </method>
    <method name="getHighestBlockAt" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the highest non-empty (impassable) block at the given coordinates.

 @param x X-coordinate of the block
 @param z Z-coordinate of the block
 @return Highest non-empty block]]>
      </doc>
    </method>
    <method name="getHighestBlockAt" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Gets the highest non-empty (impassable) block at the given coordinates.

 @param location Coordinates to get the highest block
 @return Highest non-empty block]]>
      </doc>
    </method>
    <method name="getHighestBlockYAt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Upstream has added support for this, use {@link World#getHighestBlockYAt(int, int, HeightMap)}">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="heightmap" type="com.destroystokyo.paper.HeightmapType"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Returns the highest block's y-coordinate at the specified block coordinates that match the specified heightmap's conditions.
 <p>
 <b>implNote:</b> Implementations are recommended to use an iterative search as a fallback before resorting to
 throwing an {@code UnsupportedOperationException}.
 </p>

 @param x The block's x-coordinate.
 @param z The block's z-coordinate.
 @param heightmap The specified heightmap to use. See {@link com.destroystokyo.paper.HeightmapType}
 @return The highest block's y-coordinate at (x, z) that matches the specified heightmap's conditions.
 @throws UnsupportedOperationException If the heightmap type is not supported.
 @deprecated Upstream has added support for this, use {@link World#getHighestBlockYAt(int, int, HeightMap)}

 @see com.destroystokyo.paper.HeightmapType]]>
      </doc>
    </method>
    <method name="getHighestBlockYAt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Upstream has added support for this, use {@link World#getHighestBlockYAt(Location, HeightMap)}">
      <param name="location" type="org.bukkit.Location"/>
      <param name="heightmap" type="com.destroystokyo.paper.HeightmapType"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Returns the highest block's y-coordinate at the specified block coordinates that match the specified heightmap's conditions.
 Note that the y-coordinate of the specified location is ignored.
 <p>
 <b>implNote:</b> Implementations are recommended to use an iterative search as a fallback before resorting to
 throwing an {@code UnsupportedOperationException}.
 </p>

 @param location The specified block coordinates.
 @param heightmap The specified heightmap to use. See {@link com.destroystokyo.paper.HeightmapType}
 @return The highest block's y-coordinate at {@code location} that matches the specified heightmap's conditions.
 @throws UnsupportedOperationException If the heightmap type is not supported.
 @deprecated Upstream has added support for this, use {@link World#getHighestBlockYAt(Location, HeightMap)}
 @see com.destroystokyo.paper.HeightmapType]]>
      </doc>
    </method>
    <method name="getHighestBlockAt" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Upstream has added support for this, use {@link World#getHighestBlockAt(int, int, HeightMap)}">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="heightmap" type="com.destroystokyo.paper.HeightmapType"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Returns the highest {@link Block} at the specified block coordinates that match the specified heightmap's conditions.
 <p>
 <b>implNote:</b> Implementations are recommended to use an iterative search as a fallback before resorting to
 throwing an {@code UnsupportedOperationException}.
 </p>
 @param x The block's x-coordinate.
 @param z The block's z-coordinate.
 @param heightmap The specified heightmap to use. See {@link com.destroystokyo.paper.HeightmapType}
 @return The highest {@link Block} at (x, z) that matches the specified heightmap's conditions.
 @throws UnsupportedOperationException If the heightmap type is not supported.
 @deprecated Upstream has added support for this, use {@link World#getHighestBlockAt(int, int, HeightMap)}
 @see com.destroystokyo.paper.HeightmapType]]>
      </doc>
    </method>
    <method name="getHighestBlockAt" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Upstream has added support for this, use {@link World#getHighestBlockAt(Location, HeightMap)}">
      <param name="location" type="org.bukkit.Location"/>
      <param name="heightmap" type="com.destroystokyo.paper.HeightmapType"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Returns the highest {@link Block} at the specified block coordinates that match the specified heightmap's conditions.
 Note that the y-coordinate of the specified location is ignored.
 <p>
 <b>implNote:</b> Implementations are recommended to use an iterative search as a fallback before resorting to
 throwing an {@code UnsupportedOperationException}.
 </p>
 @param location The specified block coordinates.
 @param heightmap The specified heightmap to use. See {@link com.destroystokyo.paper.HeightmapType}
 @return The highest {@link Block} at {@code location} that matches the specified heightmap's conditions.
 @throws UnsupportedOperationException If the heightmap type is not supported.
 @deprecated Upstream has added support for this, use {@link World#getHighestBlockAt(Location, HeightMap)}
 @see com.destroystokyo.paper.HeightmapType]]>
      </doc>
    </method>
    <method name="getHighestBlockYAt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="heightMap" type="org.bukkit.HeightMap"/>
      <doc>
      <![CDATA[Gets the highest coordinate corresponding to the {@link HeightMap} at the
 given coordinates.

 @param x X-coordinate of the blocks
 @param z Z-coordinate of the blocks
 @param heightMap the heightMap that is used to determine the highest
 point

 @return Y-coordinate of the highest block corresponding to the
 {@link HeightMap}]]>
      </doc>
    </method>
    <method name="getHighestBlockYAt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="heightMap" type="org.bukkit.HeightMap"/>
      <doc>
      <![CDATA[Gets the highest coordinate corresponding to the {@link HeightMap} at the
 given {@link Location}.

 @param location Location of the blocks
 @param heightMap the heightMap that is used to determine the highest
 point
 @return Y-coordinate of the highest block corresponding to the
 {@link HeightMap}]]>
      </doc>
    </method>
    <method name="getHighestBlockAt" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="heightMap" type="org.bukkit.HeightMap"/>
      <doc>
      <![CDATA[Gets the highest block corresponding to the {@link HeightMap} at the
 given coordinates.

 @param x X-coordinate of the block
 @param z Z-coordinate of the block
 @param heightMap the heightMap that is used to determine the highest
 point
 @return Highest block corresponding to the {@link HeightMap}]]>
      </doc>
    </method>
    <method name="getHighestBlockAt" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="heightMap" type="org.bukkit.HeightMap"/>
      <doc>
      <![CDATA[Gets the highest block corresponding to the {@link HeightMap} at the
 given coordinates.

 @param location Coordinates to get the highest block
 @param heightMap the heightMap that is used to determine the highest
 point
 @return Highest block corresponding to the {@link HeightMap}]]>
      </doc>
    </method>
    <method name="getChunkAt" return="org.bukkit.Chunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the {@link Chunk} at the given coordinates

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return Chunk at the given coordinates]]>
      </doc>
    </method>
    <method name="getChunkAt" return="org.bukkit.Chunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Gets the {@link Chunk} at the given {@link Location}

 @param location Location of the chunk
 @return Chunk at the given location]]>
      </doc>
    </method>
    <method name="getChunkAt" return="org.bukkit.Chunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <doc>
      <![CDATA[Gets the {@link Chunk} that contains the given {@link Block}

 @param block Block to get the containing chunk from
 @return The chunk that contains the given block]]>
      </doc>
    </method>
    <method name="getChunkAt" return="org.bukkit.Chunk"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chunkKey" type="long"/>
      <doc>
      <![CDATA[Gets the chunk at the specified chunk key, which is the X and Z packed into a long.

 See {@link Chunk#getChunkKey()} for easy access to the key, or you may calculate it as:
 long chunkKey = (long) chunkX &amp; 0xffffffffL | ((long) chunkZ &amp; 0xffffffffL) &gt;&gt; 32;

 @param chunkKey The Chunk Key to look up the chunk by
 @return The chunk at the specified key]]>
      </doc>
    </method>
    <method name="isChunkGenerated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chunkKey" type="long"/>
      <doc>
      <![CDATA[Checks if a {@link Chunk} has been generated at the specified chunk key,
 which is the X and Z packed into a long.

 @param chunkKey The Chunk Key to look up the chunk by
 @return true if the chunk has been generated, otherwise false]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use either the Future or the Consumer based methods">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="cb" type="org.bukkit.World.ChunkLoadCallback"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link ChunkLoadCallback} will always be executed synchronously
 on the main Server Thread.

 @deprecated Use either the Future or the Consumer based methods
 @param x Chunk X-coordinate of the chunk - (world coordinate / 16)
 @param z Chunk Z-coordinate of the chunk - (world coordinate / 16)
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use either the Future or the Consumer based methods">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="cb" type="org.bukkit.World.ChunkLoadCallback"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given {@link Location}

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link ChunkLoadCallback} will always be executed synchronously
 on the main Server Thread.

 @deprecated Use either the Future or the Consumer based methods
 @param loc Location of the chunk
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use either the Future or the Consumer based methods">
      <param name="block" type="org.bukkit.block.Block"/>
      <param name="cb" type="org.bukkit.World.ChunkLoadCallback"/>
      <doc>
      <![CDATA[Requests {@link Chunk} to be loaded that contains the given {@link Block}

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link ChunkLoadCallback} will always be executed synchronously
 on the main Server Thread.

 @deprecated Use either the Future or the Consumer based methods
 @param block Block to get the containing chunk from
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="cb" type="java.util.function.Consumer&lt;org.bukkit.Chunk&gt;"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link java.util.function.Consumer} will always be executed synchronously
 on the main Server Thread.

 @param x Chunk X-coordinate of the chunk - (world coordinate / 16)
 @param z Chunk Z-coordinate of the chunk - (world coordinate / 16)
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="gen" type="boolean"/>
      <param name="cb" type="java.util.function.Consumer&lt;org.bukkit.Chunk&gt;"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link java.util.function.Consumer} will always be executed synchronously
 on the main Server Thread.

 @param x Chunk X-coordinate of the chunk - (world coordinate / 16)
 @param z Chunk Z-coordinate of the chunk - (world coordinate / 16)
 @param gen Should we generate a chunk if it doesn't exists or not
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="cb" type="java.util.function.Consumer&lt;org.bukkit.Chunk&gt;"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given {@link Location}

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link java.util.function.Consumer} will always be executed synchronously
 on the main Server Thread.

 @param loc Location of the chunk
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="gen" type="boolean"/>
      <param name="cb" type="java.util.function.Consumer&lt;org.bukkit.Chunk&gt;"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given {@link Location}

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link java.util.function.Consumer} will always be executed synchronously
 on the main Server Thread.

 @param loc Location of the chunk
 @param gen Should the chunk generate
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <param name="cb" type="java.util.function.Consumer&lt;org.bukkit.Chunk&gt;"/>
      <doc>
      <![CDATA[Requests {@link Chunk} to be loaded that contains the given {@link Block}

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link java.util.function.Consumer} will always be executed synchronously
 on the main Server Thread.

 @param block Block to get the containing chunk from
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <param name="gen" type="boolean"/>
      <param name="cb" type="java.util.function.Consumer&lt;org.bukkit.Chunk&gt;"/>
      <doc>
      <![CDATA[Requests {@link Chunk} to be loaded that contains the given {@link Block}

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The {@link java.util.function.Consumer} will always be executed synchronously
 on the main Server Thread.

 @param block Block to get the containing chunk from
 @param gen Should the chunk generate
 @param cb Callback to receive the chunk when it is loaded.
           will be executed synchronously]]>
      </doc>
    </method>
    <method name="getChunkAtAsync" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.
 @param loc Location to load the corresponding chunk from
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsync" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="gen" type="boolean"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.
 @param loc Location to load the corresponding chunk from
 @param gen Should the chunk generate
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsync" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.
 @param block Block to load the corresponding chunk from
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsync" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <param name="gen" type="boolean"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.
 @param block Block to load the corresponding chunk from
 @param gen Should the chunk generate
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsync" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.

 @param x X Coord
 @param z Z Coord
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsync" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="gen" type="boolean"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.

 @param x Chunk X-coordinate of the chunk - (world coordinate / 16)
 @param z Chunk Z-coordinate of the chunk - (world coordinate / 16)
 @param gen Should we generate a chunk if it doesn't exists or not
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsyncUrgently" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.
 @param loc Location to load the corresponding chunk from
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsyncUrgently" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="gen" type="boolean"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.
 @param loc Location to load the corresponding chunk from
 @param gen Should the chunk generate
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsyncUrgently" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.
 @param block Block to load the corresponding chunk from
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsyncUrgently" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <param name="gen" type="boolean"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.
 @param block Block to load the corresponding chunk from
 @param gen Should the chunk generate
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsyncUrgently" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Requests a {@link Chunk} to be loaded at the given coordinates

 This method makes no guarantee on how fast the chunk will load,
 and will return the chunk to the callback at a later time.

 You should use this method if you need a chunk but do not need it
 immediately, and you wish to let the server control the speed
 of chunk loads, keeping performance in mind.

 The future will always be executed synchronously
 on the main Server Thread.

 @param x X Coord
 @param z Z Coord
 @return Future that will resolve when the chunk is loaded]]>
      </doc>
    </method>
    <method name="getChunkAtAsync" return="java.util.concurrent.CompletableFuture&lt;org.bukkit.Chunk&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="gen" type="boolean"/>
      <param name="urgent" type="boolean"/>
    </method>
    <method name="isChunkLoaded" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chunk" type="org.bukkit.Chunk"/>
      <doc>
      <![CDATA[Checks if the specified {@link Chunk} is loaded

 @param chunk The chunk to check
 @return true if the chunk is loaded, otherwise false]]>
      </doc>
    </method>
    <method name="getLoadedChunks" return="org.bukkit.Chunk[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an array of all loaded {@link Chunk}s

 @return Chunk[] containing all loaded chunks]]>
      </doc>
    </method>
    <method name="loadChunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chunk" type="org.bukkit.Chunk"/>
      <doc>
      <![CDATA[Loads the specified {@link Chunk}.
 <p>
 <b>This method will keep the specified chunk loaded until one of the
 unload methods is manually called. Callers are advised to instead use
 getChunkAt which will only temporarily load the requested chunk.</b>

 @param chunk The chunk to load]]>
      </doc>
    </method>
    <method name="isChunkLoaded" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Checks if the {@link Chunk} at the specified coordinates is loaded

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return true if the chunk is loaded, otherwise false]]>
      </doc>
    </method>
    <method name="isChunkGenerated" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Checks if the {@link Chunk} at the specified coordinates is generated

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return true if the chunk is generated, otherwise false]]>
      </doc>
    </method>
    <method name="isChunkInUse" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method was added to facilitate chunk garbage collection.
     As of the current Minecraft version chunks are now strictly managed and
     will not be loaded for more than 1 tick unless they are in use.">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Checks if the {@link Chunk} at the specified coordinates is loaded and
 in use by one or more players

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return true if the chunk is loaded and in use by one or more players,
     otherwise false
 @deprecated This method was added to facilitate chunk garbage collection.
     As of the current Minecraft version chunks are now strictly managed and
     will not be loaded for more than 1 tick unless they are in use.]]>
      </doc>
    </method>
    <method name="loadChunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Loads the {@link Chunk} at the specified coordinates.
 <p>
 <b>This method will keep the specified chunk loaded until one of the
 unload methods is manually called. Callers are advised to instead use
 getChunkAt which will only temporarily load the requested chunk.</b>
 <p>
 If the chunk does not exist, it will be generated.
 <p>
 This method is analogous to {@link #loadChunk(int, int, boolean)} where
 generate is true.

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk]]>
      </doc>
    </method>
    <method name="loadChunk" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="generate" type="boolean"/>
      <doc>
      <![CDATA[Loads the {@link Chunk} at the specified coordinates.
 <p>
 <b>This method will keep the specified chunk loaded until one of the
 unload methods is manually called. Callers are advised to instead use
 getChunkAt which will only temporarily load the requested chunk.</b>

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @param generate Whether or not to generate a chunk if it doesn't
     already exist
 @return true if the chunk has loaded successfully, otherwise false]]>
      </doc>
    </method>
    <method name="unloadChunk" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chunk" type="org.bukkit.Chunk"/>
      <doc>
      <![CDATA[Safely unloads and saves the {@link Chunk} at the specified coordinates
 <p>
 This method is analogous to {@link #unloadChunk(int, int, boolean)}
 where save is true.

 @param chunk the chunk to unload
 @return true if the chunk has unloaded successfully, otherwise false]]>
      </doc>
    </method>
    <method name="unloadChunk" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Safely unloads and saves the {@link Chunk} at the specified coordinates
 <p>
 This method is analogous to {@link #unloadChunk(int, int, boolean)}
 where save is true.

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return true if the chunk has unloaded successfully, otherwise false]]>
      </doc>
    </method>
    <method name="unloadChunk" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="save" type="boolean"/>
      <doc>
      <![CDATA[Safely unloads and optionally saves the {@link Chunk} at the specified
 coordinates.

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @param save Whether or not to save the chunk
 @return true if the chunk has unloaded successfully, otherwise false]]>
      </doc>
    </method>
    <method name="unloadChunkRequest" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Safely queues the {@link Chunk} at the specified coordinates for
 unloading.

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return true is the queue attempt was successful, otherwise false]]>
      </doc>
    </method>
    <method name="regenerateChunk" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="regenerating a single chunk is not likely to produce the same
 chunk as before as terrain decoration may be spread across chunks. Use of
 this method should be avoided as it is known to produce buggy results.">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Regenerates the {@link Chunk} at the specified coordinates

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return Whether the chunk was actually regenerated

 @deprecated regenerating a single chunk is not likely to produce the same
 chunk as before as terrain decoration may be spread across chunks. Use of
 this method should be avoided as it is known to produce buggy results.]]>
      </doc>
    </method>
    <method name="refreshChunk" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method is not guaranteed to work suitably across all client implementations.">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Resends the {@link Chunk} to all clients

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return Whether the chunk was actually refreshed

 @deprecated This method is not guaranteed to work suitably across all client implementations.]]>
      </doc>
    </method>
    <method name="isChunkForceLoaded" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets whether the chunk at the specified chunk coordinates is force
 loaded.
 <p>
 A force loaded chunk will not be unloaded due to lack of player activity.

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return force load status]]>
      </doc>
    </method>
    <method name="setChunkForceLoaded"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="forced" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the chunk at the specified chunk coordinates is force
 loaded.
 <p>
 A force loaded chunk will not be unloaded due to lack of player activity.

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @param forced force load status]]>
      </doc>
    </method>
    <method name="getForceLoadedChunks" return="java.util.Collection&lt;org.bukkit.Chunk&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all force loaded chunks in this world.
 <p>
 A force loaded chunk will not be unloaded due to lack of player activity.

 @return unmodifiable collection of force loaded chunks]]>
      </doc>
    </method>
    <method name="addPluginChunkTicket" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Adds a plugin ticket for the specified chunk, loading the chunk if it is
 not already loaded.
 <p>
 A plugin ticket will prevent a chunk from unloading until it is
 explicitly removed. A plugin instance may only have one ticket per chunk,
 but each chunk can have multiple plugin tickets.
 </p>

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @param plugin Plugin which owns the ticket
 @return {@code true} if a plugin ticket was added, {@code false} if the
 ticket already exists for the plugin
 @throws IllegalStateException If the specified plugin is not enabled
 @see #removePluginChunkTicket(int, int, Plugin)]]>
      </doc>
    </method>
    <method name="removePluginChunkTicket" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Removes the specified plugin's ticket for the specified chunk
 <p>
 A plugin ticket will prevent a chunk from unloading until it is
 explicitly removed. A plugin instance may only have one ticket per chunk,
 but each chunk can have multiple plugin tickets.
 </p>

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @param plugin Plugin which owns the ticket
 @return {@code true} if the plugin ticket was removed, {@code false} if
 there is no plugin ticket for the chunk
 @see #addPluginChunkTicket(int, int, Plugin)]]>
      </doc>
    </method>
    <method name="removePluginChunkTickets"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Removes all plugin tickets for the specified plugin
 <p>
 A plugin ticket will prevent a chunk from unloading until it is
 explicitly removed. A plugin instance may only have one ticket per chunk,
 but each chunk can have multiple plugin tickets.
 </p>

 @param plugin Specified plugin
 @see #addPluginChunkTicket(int, int, Plugin)
 @see #removePluginChunkTicket(int, int, Plugin)]]>
      </doc>
    </method>
    <method name="getPluginChunkTickets" return="java.util.Collection&lt;org.bukkit.plugin.Plugin&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Retrieves a collection specifying which plugins have tickets for the
 specified chunk. This collection is not updated when plugin tickets are
 added or removed to the chunk.
 <p>
 A plugin ticket will prevent a chunk from unloading until it is
 explicitly removed. A plugin instance may only have one ticket per chunk,
 but each chunk can have multiple plugin tickets.
 </p>

 @param x X-coordinate of the chunk
 @param z Z-coordinate of the chunk
 @return unmodifiable collection containing which plugins have tickets for
 the chunk
 @see #addPluginChunkTicket(int, int, Plugin)
 @see #removePluginChunkTicket(int, int, Plugin)]]>
      </doc>
    </method>
    <method name="getPluginChunkTickets" return="java.util.Map&lt;org.bukkit.plugin.Plugin, java.util.Collection&lt;org.bukkit.Chunk&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map of which plugins have tickets for what chunks. The returned
 map is not updated when plugin tickets are added or removed to chunks. If
 a plugin has no tickets, it will be absent from the map.
 <p>
 A plugin ticket will prevent a chunk from unloading until it is
 explicitly removed. A plugin instance may only have one ticket per chunk,
 but each chunk can have multiple plugin tickets.
 </p>

 @return unmodifiable map containing which plugins have tickets for what
 chunks
 @see #addPluginChunkTicket(int, int, Plugin)
 @see #removePluginChunkTicket(int, int, Plugin)]]>
      </doc>
    </method>
    <method name="dropItem" return="org.bukkit.entity.Item"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Drops an item at the specified {@link Location}

 @param location Location to drop the item
 @param item ItemStack to drop
 @return ItemDrop entity created as a result of this method]]>
      </doc>
    </method>
    <method name="dropItemNaturally" return="org.bukkit.entity.Item"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Drops an item at the specified {@link Location} with a random offset

 @param location Location to drop the item
 @param item ItemStack to drop
 @return ItemDrop entity created as a result of this method]]>
      </doc>
    </method>
    <method name="spawnArrow" return="org.bukkit.entity.Arrow"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="speed" type="float"/>
      <param name="spread" type="float"/>
      <doc>
      <![CDATA[Creates an {@link Arrow} entity at the given {@link Location}

 @param location Location to spawn the arrow
 @param direction Direction to shoot the arrow in
 @param speed Speed of the arrow. A recommend speed is 0.6
 @param spread Spread of the arrow. A recommend spread is 12
 @return Arrow entity spawned as a result of this method]]>
      </doc>
    </method>
    <method name="spawnArrow" return="T extends org.bukkit.entity.AbstractArrow"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="speed" type="float"/>
      <param name="spread" type="float"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates an arrow entity of the given class at the given {@link Location}

 @param <T> type of arrow to spawn
 @param location Location to spawn the arrow
 @param direction Direction to shoot the arrow in
 @param speed Speed of the arrow. A recommend speed is 0.6
 @param spread Spread of the arrow. A recommend spread is 12
 @param clazz the Entity class for the arrow
 {@link org.bukkit.entity.SpectralArrow},{@link org.bukkit.entity.Arrow},{@link org.bukkit.entity.TippedArrow}
 @return Arrow entity spawned as a result of this method]]>
      </doc>
    </method>
    <method name="generateTree" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="type" type="org.bukkit.TreeType"/>
      <doc>
      <![CDATA[Creates a tree at the given {@link Location}

 @param location Location to spawn the tree
 @param type Type of the tree to create
 @return true if the tree was created successfully, otherwise false]]>
      </doc>
    </method>
    <method name="generateTree" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="type" type="org.bukkit.TreeType"/>
      <param name="delegate" type="org.bukkit.BlockChangeDelegate"/>
      <doc>
      <![CDATA[Creates a tree at the given {@link Location}

 @param loc Location to spawn the tree
 @param type Type of the tree to create
 @param delegate A class to call for each block changed as a result of
     this method
 @return true if the tree was created successfully, otherwise false]]>
      </doc>
    </method>
    <method name="spawnEntity" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="type" type="org.bukkit.entity.EntityType"/>
      <doc>
      <![CDATA[Creates a entity at the given {@link Location}

 @param loc The location to spawn the entity
 @param type The entity to spawn
 @return Resulting Entity of this method, or null if it was unsuccessful]]>
      </doc>
    </method>
    <method name="strikeLightning" return="org.bukkit.entity.LightningStrike"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Strikes lightning at the given {@link Location}

 @param loc The location to strike lightning
 @return The lightning entity.]]>
      </doc>
    </method>
    <method name="strikeLightningEffect" return="org.bukkit.entity.LightningStrike"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Strikes lightning at the given {@link Location} without doing damage

 @param loc The location to strike lightning
 @return The lightning entity.]]>
      </doc>
    </method>
    <method name="getEntities" return="java.util.List&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of all entities in this World

 @return A List of all Entities currently residing in this world]]>
      </doc>
    </method>
    <method name="getLivingEntities" return="java.util.List&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of all living entities in this World

 @return A List of all LivingEntities currently residing in this world]]>
      </doc>
    </method>
    <method name="getEntitiesByClass" return="java.util.Collection&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Get a collection of all entities in this World matching the given
 class/interface

 @param <T> an entity subclass
 @param classes The classes representing the types of entity to match
 @return A List of all Entities currently residing in this world that
     match the given class/interface]]>
      </doc>
    </method>
    <method name="getEntitiesByClass" return="java.util.Collection&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cls" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Get a collection of all entities in this World matching the given
 class/interface

 @param <T> an entity subclass
 @param cls The class representing the type of entity to match
 @return A List of all Entities currently residing in this world that
     match the given class/interface]]>
      </doc>
    </method>
    <method name="getEntitiesByClasses" return="java.util.Collection&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Get a collection of all entities in this World matching any of the
 given classes/interfaces

 @param classes The classes representing the types of entity to match
 @return A List of all Entities currently residing in this world that
     match one or more of the given classes/interfaces]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="radius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param radius Radius
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param xzRadius X/Z Radius
 @param yRadius Y Radius
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z radius
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="radius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.LivingEntity&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param radius X Radius
 @param predicate a predicate used to filter results
 @return the collection of living entities near location. This will always be a non-null collection]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.LivingEntity&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param xzRadius X/Z Radius
 @param yRadius Y Radius
 @param predicate a predicate used to filter results
 @return the collection of living entities near location. This will always be a non-null collection]]>
      </doc>
    </method>
    <method name="getNearbyLivingEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.LivingEntity&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z radius
 @param predicate a predicate used to filter results
 @return the collection of living entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="radius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param radius X/Y/Z Radius
 @return the collection of living entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param xzRadius X/Z Radius
 @param yRadius Y Radius
 @return the collection of living entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z Radius
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="radius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.Player&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param radius X/Y/Z Radius
 @param predicate a predicate used to filter results
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.Player&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param xzRadius X/Z Radius
 @param yRadius Y Radius
 @param predicate a predicate used to filter results
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyPlayers" return="java.util.Collection&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;org.bukkit.entity.Player&gt;"/>
      <doc>
      <![CDATA[Gets nearby players within the specified radius (bounding box)
 @param loc Center location
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z Radius
 @param predicate a predicate used to filter results
 @return the collection of players near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="radius" type="double"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius (bounding box)
 @param clazz Type to filter by
 @param loc Center location
 @param radius X/Y/Z radius to search within
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius, with x and x radius matching (bounding box)
 @param clazz Type to filter by
 @param loc Center location
 @param xzRadius X/Z radius to search within
 @param yRadius Y radius to search within
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius (bounding box)
 @param clazz Type to filter by
 @param loc Center location
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z Radius
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="radius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius (bounding box)
 @param clazz Type to filter by
 @param loc Center location
 @param radius X/Y/Z radius to search within
 @param predicate a predicate used to filter results
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xzRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius, with x and x radius matching (bounding box)
 @param clazz Type to filter by
 @param loc Center location
 @param xzRadius X/Z radius to search within
 @param yRadius Y radius to search within
 @param predicate a predicate used to filter results
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntitiesByType" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends org.bukkit.entity.Entity&gt;"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="xRadius" type="double"/>
      <param name="yRadius" type="double"/>
      <param name="zRadius" type="double"/>
      <param name="predicate" type="java.util.function.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets all nearby entities of the specified type, within the specified radius (bounding box)
 @param clazz Type to filter by
 @param loc Center location
 @param xRadius X Radius
 @param yRadius Y Radius
 @param zRadius Z Radius
 @param predicate a predicate used to filter results
 @param <T> the entity type
 @return the collection of entities near location. This will always be a non-null collection.]]>
      </doc>
    </method>
    <method name="getPlayers" return="java.util.List&lt;org.bukkit.entity.Player&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of all players in this World

 @return A list of all Players currently residing in this world]]>
      </doc>
    </method>
    <method name="getNearbyEntities" return="java.util.Collection&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Returns a list of entities within a bounding box centered around a
 Location.
 <p>
 This may not consider entities in currently unloaded chunks. Some
 implementations may impose artificial restrictions on the size of the
 search bounding box.

 @param location The center of the bounding box
 @param x 1/2 the size of the box along x axis
 @param y 1/2 the size of the box along y axis
 @param z 1/2 the size of the box along z axis
 @return the collection of entities near location. This will always be a
      non-null collection.]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Gets an entity in this world by its UUID

 @param uuid the UUID of the entity
 @return the entity with the given UUID, or null if it isn't found]]>
      </doc>
    </method>
    <method name="getNearbyEntities" return="java.util.Collection&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="filter" type="java.util.function.Predicate&lt;org.bukkit.entity.Entity&gt;"/>
      <doc>
      <![CDATA[Returns a list of entities within a bounding box centered around a
 Location.
 <p>
 This may not consider entities in currently unloaded chunks. Some
 implementations may impose artificial restrictions on the size of the
 search bounding box.

 @param location The center of the bounding box
 @param x 1/2 the size of the box along x axis
 @param y 1/2 the size of the box along y axis
 @param z 1/2 the size of the box along z axis
 @param filter only entities that fulfill this predicate are considered,
     or <code>null</code> to consider all entities
 @return the collection of entities near location. This will always be a
     non-null collection.]]>
      </doc>
    </method>
    <method name="getNearbyEntities" return="java.util.Collection&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="boundingBox" type="org.bukkit.util.BoundingBox"/>
      <doc>
      <![CDATA[Returns a list of entities within the given bounding box.
 <p>
 This may not consider entities in currently unloaded chunks. Some
 implementations may impose artificial restrictions on the size of the
 search bounding box.

 @param boundingBox the bounding box
 @return the collection of entities within the bounding box, will always
     be a non-null collection]]>
      </doc>
    </method>
    <method name="getNearbyEntities" return="java.util.Collection&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="boundingBox" type="org.bukkit.util.BoundingBox"/>
      <param name="filter" type="java.util.function.Predicate&lt;org.bukkit.entity.Entity&gt;"/>
      <doc>
      <![CDATA[Returns a list of entities within the given bounding box.
 <p>
 This may not consider entities in currently unloaded chunks. Some
 implementations may impose artificial restrictions on the size of the
 search bounding box.

 @param boundingBox the bounding box
 @param filter only entities that fulfill this predicate are considered,
     or <code>null</code> to consider all entities
 @return the collection of entities within the bounding box, will always
     be a non-null collection]]>
      </doc>
    </method>
    <method name="rayTraceEntities" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for entity collisions.
 <p>
 This may not consider entities in currently unloaded chunks. Some
 implementations may impose artificial restrictions on the maximum
 distance.

 @param start the start position
 @param direction the ray direction
 @param maxDistance the maximum distance
 @return the closest ray trace hit result, or <code>null</code> if there
     is no hit
 @see #rayTraceEntities(Location, Vector, double, double, Predicate)]]>
      </doc>
    </method>
    <method name="rayTraceEntities" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <param name="raySize" type="double"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for entity collisions.
 <p>
 This may not consider entities in currently unloaded chunks. Some
 implementations may impose artificial restrictions on the maximum
 distance.

 @param start the start position
 @param direction the ray direction
 @param maxDistance the maximum distance
 @param raySize entity bounding boxes will be uniformly expanded (or
     shrinked) by this value before doing collision checks
 @return the closest ray trace hit result, or <code>null</code> if there
     is no hit
 @see #rayTraceEntities(Location, Vector, double, double, Predicate)]]>
      </doc>
    </method>
    <method name="rayTraceEntities" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <param name="filter" type="java.util.function.Predicate&lt;org.bukkit.entity.Entity&gt;"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for entity collisions.
 <p>
 This may not consider entities in currently unloaded chunks. Some
 implementations may impose artificial restrictions on the maximum
 distance.

 @param start the start position
 @param direction the ray direction
 @param maxDistance the maximum distance
 @param filter only entities that fulfill this predicate are considered,
     or <code>null</code> to consider all entities
 @return the closest ray trace hit result, or <code>null</code> if there
     is no hit
 @see #rayTraceEntities(Location, Vector, double, double, Predicate)]]>
      </doc>
    </method>
    <method name="rayTraceEntities" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <param name="raySize" type="double"/>
      <param name="filter" type="java.util.function.Predicate&lt;org.bukkit.entity.Entity&gt;"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for entity collisions.
 <p>
 This may not consider entities in currently unloaded chunks. Some
 implementations may impose artificial restrictions on the maximum
 distance.

 @param start the start position
 @param direction the ray direction
 @param maxDistance the maximum distance
 @param raySize entity bounding boxes will be uniformly expanded (or
     shrinked) by this value before doing collision checks
 @param filter only entities that fulfill this predicate are considered,
     or <code>null</code> to consider all entities
 @return the closest ray trace hit result, or <code>null</code> if there
     is no hit]]>
      </doc>
    </method>
    <method name="rayTraceBlocks" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for block collisions using the blocks'
 precise collision shapes.
 <p>
 This takes collisions with passable blocks into account, but ignores
 fluids.
 <p>
 This may cause loading of chunks! Some implementations may impose
 artificial restrictions on the maximum distance.

 @param start the start location
 @param direction the ray direction
 @param maxDistance the maximum distance
 @return the ray trace hit result, or <code>null</code> if there is no hit
 @see #rayTraceBlocks(Location, Vector, double, FluidCollisionMode, boolean)]]>
      </doc>
    </method>
    <method name="rayTraceBlocks" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <param name="fluidCollisionMode" type="org.bukkit.FluidCollisionMode"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for block collisions using the blocks'
 precise collision shapes.
 <p>
 This takes collisions with passable blocks into account.
 <p>
 This may cause loading of chunks! Some implementations may impose
 artificial restrictions on the maximum distance.

 @param start the start location
 @param direction the ray direction
 @param maxDistance the maximum distance
 @param fluidCollisionMode the fluid collision mode
 @return the ray trace hit result, or <code>null</code> if there is no hit
 @see #rayTraceBlocks(Location, Vector, double, FluidCollisionMode, boolean)]]>
      </doc>
    </method>
    <method name="rayTraceBlocks" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <param name="fluidCollisionMode" type="org.bukkit.FluidCollisionMode"/>
      <param name="ignorePassableBlocks" type="boolean"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for block collisions using the blocks'
 precise collision shapes.
 <p>
 If collisions with passable blocks are ignored, fluid collisions are
 ignored as well regardless of the fluid collision mode.
 <p>
 Portal blocks are only considered passable if the ray starts within
 them. Apart from that collisions with portal blocks will be considered
 even if collisions with passable blocks are otherwise ignored.
 <p>
 This may cause loading of chunks! Some implementations may impose
 artificial restrictions on the maximum distance.

 @param start the start location
 @param direction the ray direction
 @param maxDistance the maximum distance
 @param fluidCollisionMode the fluid collision mode
 @param ignorePassableBlocks whether to ignore passable but collidable
     blocks (ex. tall grass, signs, fluids, ..)
 @return the ray trace hit result, or <code>null</code> if there is no hit]]>
      </doc>
    </method>
    <method name="rayTrace" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <param name="fluidCollisionMode" type="org.bukkit.FluidCollisionMode"/>
      <param name="ignorePassableBlocks" type="boolean"/>
      <param name="raySize" type="double"/>
      <param name="filter" type="java.util.function.Predicate&lt;org.bukkit.entity.Entity&gt;"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for both block and entity collisions.
 <p>
 Block collisions use the blocks' precise collision shapes. The
 <code>raySize</code> parameter is only taken into account for entity
 collision checks.
 <p>
 If collisions with passable blocks are ignored, fluid collisions are
 ignored as well regardless of the fluid collision mode.
 <p>
 Portal blocks are only considered passable if the ray starts within them.
 Apart from that collisions with portal blocks will be considered even if
 collisions with passable blocks are otherwise ignored.
 <p>
 This may cause loading of chunks! Some implementations may impose
 artificial restrictions on the maximum distance.

 @param start the start location
 @param direction the ray direction
 @param maxDistance the maximum distance
 @param fluidCollisionMode the fluid collision mode
 @param ignorePassableBlocks whether to ignore passable but collidable
     blocks (ex. tall grass, signs, fluids, ..)
 @param raySize entity bounding boxes will be uniformly expanded (or
     shrinked) by this value before doing collision checks
 @param filter only entities that fulfill this predicate are considered,
     or <code>null</code> to consider all entities
 @return the closest ray trace hit result with either a block or an
     entity, or <code>null</code> if there is no hit]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the unique name of this world

 @return Name of this world]]>
      </doc>
    </method>
    <method name="getUID" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Unique ID of this world

 @return Unique ID of this world.]]>
      </doc>
    </method>
    <method name="getSpawnLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default spawn {@link Location} of this world

 @return The spawn location of this world]]>
      </doc>
    </method>
    <method name="setSpawnLocation" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the spawn location of the world.
 <br>
 The location provided must be equal to this world.

 @param location The {@link Location} to set the spawn for this world at.
 @return True if it was successfully set.]]>
      </doc>
    </method>
    <method name="setSpawnLocation" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <param name="angle" type="float"/>
      <doc>
      <![CDATA[Sets the spawn location of the world

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @param angle the angle
 @return True if it was successfully set.]]>
      </doc>
    </method>
    <method name="setSpawnLocation" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Sets the spawn location of the world

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @return True if it was successfully set.]]>
      </doc>
    </method>
    <method name="getTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the relative in-game time of this world.
 <p>
 The relative time is analogous to hours * 1000

 @return The current relative time
 @see #getFullTime() Returns an absolute time of this world]]>
      </doc>
    </method>
    <method name="setTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <doc>
      <![CDATA[Sets the relative in-game time on the server.
 <p>
 The relative time is analogous to hours * 1000
 <p>
 Note that setting the relative time below the current relative time
 will actually move the clock forward a day. If you require to rewind
 time, please see {@link #setFullTime(long)}

 @param time The new relative time to set the in-game time to (in
     hours*1000)
 @see #setFullTime(long) Sets the absolute time of this world]]>
      </doc>
    </method>
    <method name="getFullTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the full in-game time on this world

 @return The current absolute time
 @see #getTime() Returns a relative time of this world]]>
      </doc>
    </method>
    <method name="setFullTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <doc>
      <![CDATA[Sets the in-game time on the server
 <p>
 Note that this sets the full time of the world, which may cause adverse
 effects such as breaking redstone clocks and any scheduled events

 @param time The new absolute time to set this world to
 @see #setTime(long) Sets the relative time of this world]]>
      </doc>
    </method>
    <method name="isDayTime" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if it is currently daytime in this world

 @return True if it is daytime]]>
      </doc>
    </method>
    <method name="hasStorm" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the world has an ongoing storm.

 @return Whether there is an ongoing storm]]>
      </doc>
    </method>
    <method name="setStorm"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hasStorm" type="boolean"/>
      <doc>
      <![CDATA[Set whether there is a storm. A duration will be set for the new
 current conditions.

 @param hasStorm Whether there is rain and snow]]>
      </doc>
    </method>
    <method name="getWeatherDuration" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the remaining time in ticks of the current conditions.

 @return Time in ticks]]>
      </doc>
    </method>
    <method name="setWeatherDuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="int"/>
      <doc>
      <![CDATA[Set the remaining time in ticks of the current conditions.

 @param duration Time in ticks]]>
      </doc>
    </method>
    <method name="isThundering" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether there is thunder.

 @return Whether there is thunder]]>
      </doc>
    </method>
    <method name="setThundering"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thundering" type="boolean"/>
      <doc>
      <![CDATA[Set whether it is thundering.

 @param thundering Whether it is thundering]]>
      </doc>
    </method>
    <method name="getThunderDuration" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the thundering duration.

 @return Duration in ticks]]>
      </doc>
    </method>
    <method name="setThunderDuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="int"/>
      <doc>
      <![CDATA[Set the thundering duration.

 @param duration Duration in ticks]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="power" type="float"/>
      <doc>
      <![CDATA[Creates explosion at given coordinates with given power

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @param power The power of explosion, where 4F is TNT
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at given coordinates with given power and optionally
 setting blocks on fire.

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <param name="breakBlocks" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at given coordinates with given power and optionally
 setting blocks on fire or breaking blocks.

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @param breakBlocks Whether or not to have blocks be destroyed
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <param name="breakBlocks" type="boolean"/>
      <param name="source" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Creates explosion at given coordinates with given power and optionally
 setting blocks on fire or breaking blocks.

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @param breakBlocks Whether or not to have blocks be destroyed
 @param source the source entity, used for tracking damage
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="power" type="float"/>
      <doc>
      <![CDATA[Creates explosion at given coordinates with given power

 @param loc Location to blow up
 @param power The power of explosion, where 4F is TNT
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at given coordinates with given power and optionally
 setting blocks on fire.

 @param loc Location to blow up
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <param name="breakBlocks" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at given location with given power and optionally
 setting blocks on fire, with the specified entity as the source.

 @param source The source entity of the explosion
 @param loc Location to blow up
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @param breakBlocks Whether or not to have blocks be destroyed
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at given location with given power and optionally
 setting blocks on fire, with the specified entity as the source.

 Will destroy other blocks

 @param source The source entity of the explosion
 @param loc Location to blow up
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="loc" type="org.bukkit.Location"/>
      <param name="power" type="float"/>
      <doc>
      <![CDATA[Creates explosion at given location with given power, with the specified entity as the source.
 Will set blocks on fire and destroy blocks.

 @param source The source entity of the explosion
 @param loc Location to blow up
 @param power The power of explosion, where 4F is TNT
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <param name="breakBlocks" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at given entities location with given power and optionally
 setting blocks on fire, with the specified entity as the source.

 @param source The source entity of the explosion
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @param breakBlocks Whether or not to have blocks be destroyed
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at given entities location with given power and optionally
 setting blocks on fire, with the specified entity as the source.

 Will destroy blocks.

 @param source The source entity of the explosion
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Entity"/>
      <param name="power" type="float"/>
      <doc>
      <![CDATA[Creates explosion at given entities location with given power and optionally
 setting blocks on fire, with the specified entity as the source.

 @param source The source entity of the explosion
 @param power The power of explosion, where 4F is TNT
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <param name="breakBlocks" type="boolean"/>
      <doc>
      <![CDATA[Creates explosion at given coordinates with given power and optionally
 setting blocks on fire or breaking blocks.

 @param loc Location to blow up
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @param breakBlocks Whether or not to have blocks be destroyed
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="createExplosion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="power" type="float"/>
      <param name="setFire" type="boolean"/>
      <param name="breakBlocks" type="boolean"/>
      <param name="source" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Creates explosion at given coordinates with given power and optionally
 setting blocks on fire or breaking blocks.

 @param loc Location to blow up
 @param power The power of explosion, where 4F is TNT
 @param setFire Whether or not to set blocks on fire
 @param breakBlocks Whether or not to have blocks be destroyed
 @param source the source entity, used for tracking damage
 @return false if explosion was canceled, otherwise true]]>
      </doc>
    </method>
    <method name="getEnvironment" return="org.bukkit.World.Environment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link Environment} type of this world

 @return This worlds Environment type]]>
      </doc>
    </method>
    <method name="getSeed" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Seed for this world.

 @return This worlds Seed]]>
      </doc>
    </method>
    <method name="getPVP" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current PVP setting for this world.

 @return True if PVP is enabled]]>
      </doc>
    </method>
    <method name="setPVP"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pvp" type="boolean"/>
      <doc>
      <![CDATA[Sets the PVP setting for this world.

 @param pvp True/False whether PVP should be Enabled.]]>
      </doc>
    </method>
    <method name="getGenerator" return="org.bukkit.generator.ChunkGenerator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chunk generator for this world

 @return ChunkGenerator associated with this world]]>
      </doc>
    </method>
    <method name="save"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Saves world to disk]]>
      </doc>
    </method>
    <method name="getPopulators" return="java.util.List&lt;org.bukkit.generator.BlockPopulator&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of all applied {@link BlockPopulator}s for this World

 @return List containing any or none BlockPopulators]]>
      </doc>
    </method>
    <method name="spawn" return="T extends org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Spawn an entity of a specific class at the given {@link Location}

 @param location the {@link Location} to spawn the entity at
 @param clazz the class of the {@link Entity} to spawn
 @param <T> the class of the {@link Entity} to spawn
 @return an instance of the spawned {@link Entity}
 @throws IllegalArgumentException if either parameter is null or the
     {@link Entity} requested cannot be spawned]]>
      </doc>
    </method>
    <method name="spawn" return="T extends org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <param name="reason" type="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
    </method>
    <method name="spawn" return="T extends org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <param name="function" type="org.bukkit.util.Consumer&lt;T&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Spawn an entity of a specific class at the given {@link Location}, with
 the supplied function run before the entity is added to the world.
 <br>
 Note that when the function is run, the entity will not be actually in
 the world. Any operation involving such as teleporting the entity is undefined
 until after this function returns.

 @param location the {@link Location} to spawn the entity at
 @param clazz the class of the {@link Entity} to spawn
 @param function the function to be run before the entity is spawned.
 @param <T> the class of the {@link Entity} to spawn
 @return an instance of the spawned {@link Entity}
 @throws IllegalArgumentException if either parameter is null or the
     {@link Entity} requested cannot be spawned]]>
      </doc>
    </method>
    <method name="spawn" return="T extends org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <param name="reason" type="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"/>
      <param name="function" type="org.bukkit.util.Consumer&lt;T&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
    </method>
    <method name="spawnEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="type" type="org.bukkit.entity.EntityType"/>
      <param name="reason" type="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"/>
    </method>
    <method name="spawnEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="type" type="org.bukkit.entity.EntityType"/>
      <param name="reason" type="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"/>
      <param name="function" type="org.bukkit.util.Consumer&lt;org.bukkit.entity.Entity&gt;"/>
    </method>
    <method name="spawn" return="T extends org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <param name="function" type="org.bukkit.util.Consumer&lt;T&gt;"/>
      <param name="reason" type="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
    </method>
    <method name="spawnFallingBlock" return="org.bukkit.entity.FallingBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="data" type="org.bukkit.material.MaterialData"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Spawn a {@link FallingBlock} entity at the given {@link Location} of
 the specified {@link Material}. The material dictates what is falling.
 When the FallingBlock hits the ground, it will place that block.
 <p>
 The Material must be a block type, check with {@link Material#isBlock()
 material.isBlock()}. The Material may not be air.

 @param location The {@link Location} to spawn the FallingBlock
 @param data The block data
 @return The spawned {@link FallingBlock} instance
 @throws IllegalArgumentException if {@link Location} or {@link
     MaterialData} are null or {@link Material} of the {@link MaterialData} is not a block]]>
      </doc>
    </method>
    <method name="spawnFallingBlock" return="org.bukkit.entity.FallingBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="data" type="org.bukkit.block.data.BlockData"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Spawn a {@link FallingBlock} entity at the given {@link Location} of
 the specified {@link Material}. The material dictates what is falling.
 When the FallingBlock hits the ground, it will place that block.
 <p>
 The Material must be a block type, check with {@link Material#isBlock()
 material.isBlock()}. The Material may not be air.

 @param location The {@link Location} to spawn the FallingBlock
 @param data The block data
 @return The spawned {@link FallingBlock} instance
 @throws IllegalArgumentException if {@link Location} or {@link
     BlockData} are null]]>
      </doc>
    </method>
    <method name="spawnFallingBlock" return="org.bukkit.entity.FallingBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="location" type="org.bukkit.Location"/>
      <param name="material" type="org.bukkit.Material"/>
      <param name="data" type="byte"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Spawn a {@link FallingBlock} entity at the given {@link Location} of the
 specified {@link Material}. The material dictates what is falling.
 When the FallingBlock hits the ground, it will place that block.
 <p>
 The Material must be a block type, check with {@link Material#isBlock()
 material.isBlock()}. The Material may not be air.

 @param location The {@link Location} to spawn the FallingBlock
 @param material The block {@link Material} type
 @param data The block data
 @return The spawned {@link FallingBlock} instance
 @throws IllegalArgumentException if {@link Location} or {@link
     Material} are null or {@link Material} is not a block
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="playEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="effect" type="org.bukkit.Effect"/>
      <param name="data" type="int"/>
      <doc>
      <![CDATA[Plays an effect to all players within a default radius around a given
 location.

 @param location the {@link Location} around which players must be to
     hear the sound
 @param effect the {@link Effect}
 @param data a data bit needed for some effects]]>
      </doc>
    </method>
    <method name="playEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="effect" type="org.bukkit.Effect"/>
      <param name="data" type="int"/>
      <param name="radius" type="int"/>
      <doc>
      <![CDATA[Plays an effect to all players within a given radius around a location.

 @param location the {@link Location} around which players must be to
     hear the effect
 @param effect the {@link Effect}
 @param data a data bit needed for some effects
 @param radius the radius around the location]]>
      </doc>
    </method>
    <method name="playEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="effect" type="org.bukkit.Effect"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Plays an effect to all players within a default radius around a given
 location.

 @param <T> data dependant on the type of effect
 @param location the {@link Location} around which players must be to
     hear the sound
 @param effect the {@link Effect}
 @param data a data bit needed for some effects]]>
      </doc>
    </method>
    <method name="playEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="effect" type="org.bukkit.Effect"/>
      <param name="data" type="T"/>
      <param name="radius" type="int"/>
      <doc>
      <![CDATA[Plays an effect to all players within a given radius around a location.

 @param <T> data dependant on the type of effect
 @param location the {@link Location} around which players must be to
     hear the effect
 @param effect the {@link Effect}
 @param data a data bit needed for some effects
 @param radius the radius around the location]]>
      </doc>
    </method>
    <method name="getEmptyChunkSnapshot" return="org.bukkit.ChunkSnapshot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="includeBiome" type="boolean"/>
      <param name="includeBiomeTemp" type="boolean"/>
      <doc>
      <![CDATA[Get empty chunk snapshot (equivalent to all air blocks), optionally
 including valid biome data. Used for representing an ungenerated chunk,
 or for fetching only biome data without loading a chunk.

 @param x - chunk x coordinate
 @param z - chunk z coordinate
 @param includeBiome - if true, snapshot includes per-coordinate biome
     type
 @param includeBiomeTemp - if true, snapshot includes per-coordinate
     raw biome temperature
 @return The empty snapshot.]]>
      </doc>
    </method>
    <method name="setSpawnFlags"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allowMonsters" type="boolean"/>
      <param name="allowAnimals" type="boolean"/>
      <doc>
      <![CDATA[Sets the spawn flags for this.

 @param allowMonsters - if true, monsters are allowed to spawn in this
     world.
 @param allowAnimals - if true, animals are allowed to spawn in this
     world.]]>
      </doc>
    </method>
    <method name="getAllowAnimals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether animals can spawn in this world.

 @return whether animals can spawn in this world.]]>
      </doc>
    </method>
    <method name="getAllowMonsters" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether monsters can spawn in this world.

 @return whether monsters can spawn in this world.]]>
      </doc>
    </method>
    <method name="getBiome" return="org.bukkit.block.Biome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="biomes are now 3-dimensional">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the biome for the given block coordinates.

 @param x X coordinate of the block
 @param z Z coordinate of the block
 @return Biome of the requested block
 @deprecated biomes are now 3-dimensional]]>
      </doc>
    </method>
    <method name="getBiome" return="org.bukkit.block.Biome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the biome for the given block coordinates.

 @param x X coordinate of the block
 @param y Y coordinate of the block
 @param z Z coordinate of the block
 @return Biome of the requested block]]>
      </doc>
    </method>
    <method name="setBiome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="biomes are now 3-dimensional">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="bio" type="org.bukkit.block.Biome"/>
      <doc>
      <![CDATA[Sets the biome for the given block coordinates

 @param x X coordinate of the block
 @param z Z coordinate of the block
 @param bio new Biome type for this block
 @deprecated biomes are now 3-dimensional]]>
      </doc>
    </method>
    <method name="setBiome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <param name="bio" type="org.bukkit.block.Biome"/>
      <doc>
      <![CDATA[Sets the biome for the given block coordinates

 @param x X coordinate of the block
 @param y Y coordinate of the block
 @param z Z coordinate of the block
 @param bio new Biome type for this block]]>
      </doc>
    </method>
    <method name="getTemperature" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="biomes are now 3-dimensional">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the temperature for the given block coordinates.
 <p>
 It is safe to run this method when the block does not exist, it will
 not create the block.
 <p>
 This method will return the raw temperature without adjusting for block
 height effects.

 @param x X coordinate of the block
 @param z Z coordinate of the block
 @return Temperature of the requested block
 @deprecated biomes are now 3-dimensional]]>
      </doc>
    </method>
    <method name="getTemperature" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the temperature for the given block coordinates.
 <p>
 It is safe to run this method when the block does not exist, it will
 not create the block.
 <p>
 This method will return the raw temperature without adjusting for block
 height effects.

 @param x X coordinate of the block
 @param y Y coordinate of the block
 @param z Z coordinate of the block
 @return Temperature of the requested block]]>
      </doc>
    </method>
    <method name="getHumidity" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="biomes are now 3-dimensional">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the humidity for the given block coordinates.
 <p>
 It is safe to run this method when the block does not exist, it will
 not create the block.

 @param x X coordinate of the block
 @param z Z coordinate of the block
 @return Humidity of the requested block
 @deprecated biomes are now 3-dimensional]]>
      </doc>
    </method>
    <method name="getHumidity" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Gets the humidity for the given block coordinates.
 <p>
 It is safe to run this method when the block does not exist, it will
 not create the block.

 @param x X coordinate of the block
 @param y Y coordinate of the block
 @param z Z coordinate of the block
 @return Humidity of the requested block]]>
      </doc>
    </method>
    <method name="getMaxHeight" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum height of this world.
 <p>
 If the max height is 100, there are only blocks from y=0 to y=99.

 @return Maximum height of the world]]>
      </doc>
    </method>
    <method name="getSeaLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the sea level for this world.
 <p>
 This is often half of {@link #getMaxHeight()}

 @return Sea level]]>
      </doc>
    </method>
    <method name="getKeepSpawnInMemory" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the world's spawn area should be kept loaded into memory
 or not.

 @return true if the world's spawn area will be kept loaded into memory.]]>
      </doc>
    </method>
    <method name="setKeepSpawnInMemory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keepLoaded" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the world's spawn area should be kept loaded into memory
 or not.

 @param keepLoaded if true then the world's spawn area will be kept
     loaded into memory.]]>
      </doc>
    </method>
    <method name="isAutoSave" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the world will automatically save

 @return true if the world will automatically save, otherwise false]]>
      </doc>
    </method>
    <method name="setAutoSave"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not the world will automatically save

 @param value true if the world should automatically save, otherwise
     false]]>
      </doc>
    </method>
    <method name="setDifficulty"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="difficulty" type="org.bukkit.Difficulty"/>
      <doc>
      <![CDATA[Sets the Difficulty of the world.

 @param difficulty the new difficulty you want to set the world to]]>
      </doc>
    </method>
    <method name="getDifficulty" return="org.bukkit.Difficulty"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Difficulty of the world.

 @return The difficulty of the world.]]>
      </doc>
    </method>
    <method name="getWorldFolder" return="java.io.File"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the folder of this world on disk.

 @return The folder of this world.]]>
      </doc>
    </method>
    <method name="getWorldType" return="org.bukkit.WorldType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="world type is only used to select the default word generation
 settings and is not stored in Vanilla worlds, making it impossible for
 this method to always return the correct value.">
      <doc>
      <![CDATA[Gets the type of this world.

 @return Type of this world.
 @deprecated world type is only used to select the default word generation
 settings and is not stored in Vanilla worlds, making it impossible for
 this method to always return the correct value.]]>
      </doc>
    </method>
    <method name="canGenerateStructures" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not structures are being generated.

 @return True if structures are being generated.]]>
      </doc>
    </method>
    <method name="isHardcore" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the world is hardcore or not.

 In a hardcore world the difficulty is locked to hard.

 @return hardcore status]]>
      </doc>
    </method>
    <method name="setHardcore"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hardcore" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the world is hardcore or not.

 In a hardcore world the difficulty is locked to hard.

 @param hardcore Whether the world is hardcore]]>
      </doc>
    </method>
    <method name="getTicksPerAnimalSpawns" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world's ticks per animal spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn animals.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn animals in
     this world every tick.
 <li>A value of 400 will mean the server will attempt to spawn animals
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, animal spawning will be disabled for this world. We
 recommend using {@link #setSpawnFlags(boolean, boolean)} to control
 this instead.
 <p>
 Minecraft default: 400.

 @return The world's ticks per animal spawns value]]>
      </doc>
    </method>
    <method name="setTicksPerAnimalSpawns"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticksPerAnimalSpawns" type="int"/>
      <doc>
      <![CDATA[Sets the world's ticks per animal spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn animals.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn animals in
     this world every tick.
 <li>A value of 400 will mean the server will attempt to spawn animals
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, animal spawning will be disabled for this world. We
 recommend using {@link #setSpawnFlags(boolean, boolean)} to control
 this instead.
 <p>
 Minecraft default: 400.

 @param ticksPerAnimalSpawns the ticks per animal spawns value you want
     to set the world to]]>
      </doc>
    </method>
    <method name="getTicksPerMonsterSpawns" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world's ticks per monster spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn monsters.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn monsters in
     this world every tick.
 <li>A value of 400 will mean the server will attempt to spawn monsters
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, monsters spawning will be disabled for this world. We
 recommend using {@link #setSpawnFlags(boolean, boolean)} to control
 this instead.
 <p>
 Minecraft default: 1.

 @return The world's ticks per monster spawns value]]>
      </doc>
    </method>
    <method name="setTicksPerMonsterSpawns"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticksPerMonsterSpawns" type="int"/>
      <doc>
      <![CDATA[Sets the world's ticks per monster spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn monsters.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn monsters in
     this world on every tick.
 <li>A value of 400 will mean the server will attempt to spawn monsters
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, monsters spawning will be disabled for this world. We
 recommend using {@link #setSpawnFlags(boolean, boolean)} to control
 this instead.
 <p>
 Minecraft default: 1.

 @param ticksPerMonsterSpawns the ticks per monster spawns value you
     want to set the world to]]>
      </doc>
    </method>
    <method name="getTicksPerWaterSpawns" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world's ticks per water mob spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn water mobs.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn water mobs in
     this world every tick.
 <li>A value of 400 will mean the server will attempt to spawn water mobs
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, water mobs spawning will be disabled for this world.
 <p>
 Minecraft default: 1.

 @return The world's ticks per water mob spawns value]]>
      </doc>
    </method>
    <method name="setTicksPerWaterSpawns"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticksPerWaterSpawns" type="int"/>
      <doc>
      <![CDATA[Sets the world's ticks per water mob spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn water mobs.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn water mobs in
     this world on every tick.
 <li>A value of 400 will mean the server will attempt to spawn water mobs
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, water mobs spawning will be disabled for this world.
 <p>
 Minecraft default: 1.

 @param ticksPerWaterSpawns the ticks per water mob spawns value you
     want to set the world to]]>
      </doc>
    </method>
    <method name="getTicksPerWaterAmbientSpawns" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default ticks per water ambient mob spawns value.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn water ambient mobs
     every tick.
 <li>A value of 400 will mean the server will attempt to spawn water ambient mobs
     every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b> If set to 0, ambient mobs spawning will be disabled.
 <p>
 Minecraft default: 1.

 @return the default ticks per water ambient mobs spawn value]]>
      </doc>
    </method>
    <method name="setTicksPerWaterAmbientSpawns"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticksPerAmbientSpawns" type="int"/>
      <doc>
      <![CDATA[Sets the world's ticks per water ambient mob spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn water ambient mobs.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn water ambient mobs in
     this world on every tick.
 <li>A value of 400 will mean the server will attempt to spawn weater ambient mobs
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, water ambient mobs spawning will be disabled for this world.
 <p>
 Minecraft default: 1.

 @param ticksPerAmbientSpawns the ticks per water ambient mob spawns value you
     want to set the world to]]>
      </doc>
    </method>
    <method name="getTicksPerAmbientSpawns" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world's ticks per ambient mob spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn ambient mobs.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn ambient mobs in
     this world every tick.
 <li>A value of 400 will mean the server will attempt to spawn ambient mobs
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, ambient mobs spawning will be disabled for this world.
 <p>
 Minecraft default: 1.

 @return The world's ticks per ambient mob spawns value]]>
      </doc>
    </method>
    <method name="setTicksPerAmbientSpawns"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticksPerAmbientSpawns" type="int"/>
      <doc>
      <![CDATA[Sets the world's ticks per ambient mob spawns value
 <p>
 This value determines how many ticks there are between attempts to
 spawn ambient mobs.
 <p>
 <b>Example Usage:</b>
 <ul>
 <li>A value of 1 will mean the server will attempt to spawn ambient mobs in
     this world on every tick.
 <li>A value of 400 will mean the server will attempt to spawn ambient mobs
     in this world every 400th tick.
 <li>A value below 0 will be reset back to Minecraft's default.
 </ul>
 <p>
 <b>Note:</b>
 If set to 0, ambient mobs spawning will be disabled for this world.
 <p>
 Minecraft default: 1.

 @param ticksPerAmbientSpawns the ticks per ambient mob spawns value you
     want to set the world to]]>
      </doc>
    </method>
    <method name="getMonsterSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets limit for number of monsters that can spawn in a chunk in this
 world

 @return The monster spawn limit]]>
      </doc>
    </method>
    <method name="setMonsterSpawnLimit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
      <doc>
      <![CDATA[Sets the limit for number of monsters that can spawn in a chunk in this
 world
 <p>
 <b>Note:</b> If set to a negative number the world will use the
 server-wide spawn limit instead.

 @param limit the new mob limit]]>
      </doc>
    </method>
    <method name="getAnimalSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the limit for number of animals that can spawn in a chunk in this
 world

 @return The animal spawn limit]]>
      </doc>
    </method>
    <method name="setAnimalSpawnLimit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
      <doc>
      <![CDATA[Sets the limit for number of animals that can spawn in a chunk in this
 world
 <p>
 <b>Note:</b> If set to a negative number the world will use the
 server-wide spawn limit instead.

 @param limit the new mob limit]]>
      </doc>
    </method>
    <method name="getWaterAnimalSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the limit for number of water animals that can spawn in a chunk in
 this world

 @return The water animal spawn limit]]>
      </doc>
    </method>
    <method name="setWaterAnimalSpawnLimit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
      <doc>
      <![CDATA[Sets the limit for number of water animals that can spawn in a chunk in
 this world
 <p>
 <b>Note:</b> If set to a negative number the world will use the
 server-wide spawn limit instead.

 @param limit the new mob limit]]>
      </doc>
    </method>
    <method name="getWaterAmbientSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets user-specified limit for number of water ambient mobs that can spawn
 in a chunk.

 @return the water ambient spawn limit]]>
      </doc>
    </method>
    <method name="setWaterAmbientSpawnLimit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
      <doc>
      <![CDATA[Sets the limit for number of water ambient mobs that can spawn in a chunk
 in this world
 <p>
 <b>Note:</b> If set to a negative number the world will use the
 server-wide spawn limit instead.

 @param limit the new mob limit]]>
      </doc>
    </method>
    <method name="getAmbientSpawnLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the limit for number of ambient mobs that can spawn in a chunk in
 this world

 @return The ambient spawn limit]]>
      </doc>
    </method>
    <method name="setAmbientSpawnLimit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
      <doc>
      <![CDATA[Sets the limit for number of ambient mobs that can spawn in a chunk in
 this world
 <p>
 <b>Note:</b> If set to a negative number the world will use the
 server-wide spawn limit instead.

 @param limit the new mob limit]]>
      </doc>
    </method>
    <method name="playSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="sound" type="org.bukkit.Sound"/>
      <param name="volume" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Play a Sound at the provided Location in the World
 <p>
 This function will fail silently if Location or Sound are null.

 @param location The location to play the sound
 @param sound The sound to play
 @param volume The volume of the sound
 @param pitch The pitch of the sound]]>
      </doc>
    </method>
    <method name="playSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="sound" type="java.lang.String"/>
      <param name="volume" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Play a Sound at the provided Location in the World.
 <p>
 This function will fail silently if Location or Sound are null. No
 sound will be heard by the players if their clients do not have the
 respective sound for the value passed.

 @param location the location to play the sound
 @param sound the internal sound name to play
 @param volume the volume of the sound
 @param pitch the pitch of the sound]]>
      </doc>
    </method>
    <method name="playSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="sound" type="org.bukkit.Sound"/>
      <param name="category" type="org.bukkit.SoundCategory"/>
      <param name="volume" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Play a Sound at the provided Location in the World.
 <p>
 This function will fail silently if Location or Sound are null.

 @param location The location to play the sound
 @param sound The sound to play
 @param category the category of the sound
 @param volume The volume of the sound
 @param pitch The pitch of the sound]]>
      </doc>
    </method>
    <method name="playSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="sound" type="java.lang.String"/>
      <param name="category" type="org.bukkit.SoundCategory"/>
      <param name="volume" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Play a Sound at the provided Location in the World.
 <p>
 This function will fail silently if Location or Sound are null. No sound
 will be heard by the players if their clients do not have the respective
 sound for the value passed.

 @param location the location to play the sound
 @param sound the internal sound name to play
 @param category the category of the sound
 @param volume the volume of the sound
 @param pitch the pitch of the sound]]>
      </doc>
    </method>
    <method name="getGameRules" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an array containing the names of all the {@link GameRule}s.

 @return An array of {@link GameRule} names.]]>
      </doc>
    </method>
    <method name="getGameRuleValue" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getGameRuleValue(GameRule)} instead">
      <param name="rule" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the current state of the specified rule
 <p>
 Will return null if rule passed is null

 @param rule Rule to look up value of
 @return String value of rule
 @deprecated use {@link #getGameRuleValue(GameRule)} instead]]>
      </doc>
    </method>
    <method name="setGameRuleValue" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #setGameRule(GameRule, Object)} instead.">
      <param name="rule" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the specified gamerule to specified value.
 <p>
 The rule may attempt to validate the value passed, will return true if
 value was set.
 <p>
 If rule is null, the function will return false.

 @param rule Rule to set
 @param value Value to set rule to
 @return True if rule was set
 @deprecated use {@link #setGameRule(GameRule, Object)} instead.]]>
      </doc>
    </method>
    <method name="isGameRule" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rule" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if string is a valid game rule

 @param rule Rule to check
 @return True if rule exists]]>
      </doc>
    </method>
    <method name="getGameRuleValue" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rule" type="org.bukkit.GameRule&lt;T&gt;"/>
      <doc>
      <![CDATA[Get the current value for a given {@link GameRule}.

 @param rule the GameRule to check
 @param <T> the GameRule's type
 @return the current value]]>
      </doc>
    </method>
    <method name="getGameRuleDefault" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rule" type="org.bukkit.GameRule&lt;T&gt;"/>
      <doc>
      <![CDATA[Get the default value for a given {@link GameRule}. This value is not
 guaranteed to match the current value.

 @param rule the rule to return a default value for
 @param <T> the type of GameRule
 @return the default value]]>
      </doc>
    </method>
    <method name="setGameRule" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rule" type="org.bukkit.GameRule&lt;T&gt;"/>
      <param name="newValue" type="T"/>
      <doc>
      <![CDATA[Set the given {@link GameRule}'s new value.

 @param rule the GameRule to update
 @param newValue the new value
 @param <T> the value type of the GameRule
 @return true if the value was successfully set]]>
      </doc>
    </method>
    <method name="getWorldBorder" return="org.bukkit.WorldBorder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world border for this world.

 @return The world border for this world.]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location.

 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location.

 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="receivers" type="java.util.List&lt;org.bukkit.entity.Player&gt;"/>
      <param name="source" type="org.bukkit.entity.Player"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param receivers List of players to receive the particles, or null for all in world
 @param source Source of the particles to be used in visibility checks, or null if no player source
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="receivers" type="java.util.List&lt;org.bukkit.entity.Player&gt;"/>
      <param name="source" type="org.bukkit.entity.Player"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <param name="data" type="T"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param receivers List of players to receive the particles, or null for all in world
 @param source Source of the particles to be used in visibility checks, or null if no player source
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type
 @param force allows the particle to be seen further away from the player
              and shows to players using any vanilla client particle settings]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <param name="data" type="T"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param force whether to send the particle to players within an extended
              range and encourage their client to render it regardless of
              settings
 @param <T> Particle data type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <param name="data" type="T"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param force whether to send the particle to players within an extended
              range and encourage their client to render it regardless of
              settings
 @param <T> Particle data type]]>
      </doc>
    </method>
    <method name="locateNearestStructure" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="origin" type="org.bukkit.Location"/>
      <param name="structureType" type="org.bukkit.StructureType"/>
      <param name="radius" type="int"/>
      <param name="findUnexplored" type="boolean"/>
      <doc>
      <![CDATA[Find the closest nearby structure of a given {@link StructureType}.
 Finding unexplored structures can, and will, block if the world is
 looking in chunks that gave not generated yet. This can lead to the world
 temporarily freezing while locating an unexplored structure.
 <p>
 The {@code radius} is not a rigid square radius. Each structure may alter
 how many chunks to check for each iteration. Do not assume that only a
 radius x radius chunk area will be checked. For example,
 {@link StructureType#WOODLAND_MANSION} can potentially check up to 20,000
 blocks away (or more) regardless of the radius used.
 <p>
 This will <i>not</i> load or generate chunks. This can also lead to
 instances where the server can hang if you are only looking for
 unexplored structures. This is because it will keep looking further and
 further out in order to find the structure.

 @param origin where to start looking for a structure
 @param structureType the type of structure to find
 @param radius the radius, in chunks, around which to search
 @param findUnexplored true to only find unexplored structures
 @return the closest {@link Location}, or null if no structure of the
 specified type exists.]]>
      </doc>
    </method>
    <method name="getViewDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the view distance used for this world.

 @return the view distance used for this world]]>
      </doc>
    </method>
    <method name="setViewDistance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="viewDistance" type="int"/>
      <doc>
      <![CDATA[Sets the view distance for this world.
 @param viewDistance view distance in [2, 32]]]>
      </doc>
    </method>
    <method name="getNoTickViewDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the no-tick view distance for this world.
 <p>
 No-tick view distance is the view distance where chunks will load, however the chunks and their entities will not
 be set to tick.
 </p>
 @return The no-tick view distance for this world.]]>
      </doc>
    </method>
    <method name="setNoTickViewDistance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="viewDistance" type="int"/>
      <doc>
      <![CDATA[Sets the no-tick view distance for this world.
 <p>
 No-tick view distance is the view distance where chunks will load, however the chunks and their entities will not
 be set to tick.
 </p>
 @param viewDistance view distance in [2, 32]]]>
      </doc>
    </method>
    <method name="spigot" return="org.bukkit.World.Spigot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="locateNearestRaid" return="org.bukkit.Raid"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="radius" type="int"/>
      <doc>
      <![CDATA[Finds the nearest raid close to the given location.

 @param location the origin location
 @param radius the radius
 @return the closest {@link Raid}, or null if no raids were found]]>
      </doc>
    </method>
    <method name="getRaids" return="java.util.List&lt;org.bukkit.Raid&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all raids that are going on over this world.

 @return the list of all active raids]]>
      </doc>
    </method>
    <method name="getEnderDragonBattle" return="org.bukkit.boss.DragonBattle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link DragonBattle} associated with this world.

 If this world's environment is not {@link Environment#THE_END}, null will
 be returned.
 <p>
 If an end world, a dragon battle instance will be returned regardless of
 whether or not a dragon is present in the world or a fight sequence has
 been activated. The dragon battle instance acts as a state holder.

 @return the dragon battle instance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a world, which may contain entities, chunks and blocks]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.World -->
  <!-- start interface org.bukkit.World.ChunkLoadCallback -->
  <interface name="World.ChunkLoadCallback"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="Use either the Future or the Consumer based methods">
    <implements name="java.util.function.Consumer&lt;org.bukkit.Chunk&gt;"/>
    <method name="onLoad"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chunk" type="org.bukkit.Chunk"/>
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chunk" type="org.bukkit.Chunk"/>
    </method>
    <doc>
    <![CDATA[This is the Legacy API before Java 8 was supported. Java 8 Consumer is provided,
 as well as future support

 Used by {@link World#getChunkAtAsync(Location,ChunkLoadCallback)} methods
 to request a {@link Chunk} to be loaded, with this callback receiving
 the chunk when it is finished.

 This callback will be executed on synchronously on the main thread.

 Timing and order this callback is fired is intentionally not defined and
 and subject to change.

 @deprecated Use either the Future or the Consumer based methods]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.World.ChunkLoadCallback -->
  <!-- start class org.bukkit.World.Environment -->
  <class name="World.Environment" extends="java.lang.Enum&lt;org.bukkit.World.Environment&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.World.Environment[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.World.Environment"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the dimension ID of this environment

 @return dimension ID
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getEnvironment" return="org.bukkit.World.Environment"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Get an environment by ID

 @param id The ID of the environment
 @return The environment
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents various map environment types that a world may be]]>
    </doc>
  </class>
  <!-- end class org.bukkit.World.Environment -->
  <!-- start class org.bukkit.World.Spigot -->
  <class name="World.Spigot" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spigot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="strikeLightning" return="org.bukkit.entity.LightningStrike"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="isSilent" type="boolean"/>
      <doc>
      <![CDATA[Strikes lightning at the given {@link Location} and possibly without sound

 @param loc The location to strike lightning
 @param isSilent Whether this strike makes no sound
 @return The lightning entity.]]>
      </doc>
    </method>
    <method name="strikeLightningEffect" return="org.bukkit.entity.LightningStrike"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="isSilent" type="boolean"/>
      <doc>
      <![CDATA[Strikes lightning at the given {@link Location} without doing damage and possibly without sound

 @param loc The location to strike lightning
 @param isSilent Whether this strike makes no sound
 @return The lightning entity.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.World.Spigot -->
  <!-- start interface org.bukkit.WorldBorder -->
  <interface name="WorldBorder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="reset"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the border to default values.]]>
      </doc>
    </method>
    <method name="getSize" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current side length of the border.

 @return The current side length of the border.]]>
      </doc>
    </method>
    <method name="setSize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newSize" type="double"/>
      <doc>
      <![CDATA[Sets the border to a square region with the specified side length in blocks.

 @param newSize The new size of the border.]]>
      </doc>
    </method>
    <method name="setSize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newSize" type="double"/>
      <param name="seconds" type="long"/>
      <doc>
      <![CDATA[Sets the border to a square region with the specified side length in blocks.

 @param newSize The new side length of the border.
 @param seconds The time in seconds in which the border grows or shrinks from the previous size to that being set.]]>
      </doc>
    </method>
    <method name="getCenter" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current border center.

 @return The current border center.]]>
      </doc>
    </method>
    <method name="setCenter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Sets the new border center.

 @param x The new center x-coordinate.
 @param z The new center z-coordinate.]]>
      </doc>
    </method>
    <method name="setCenter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the new border center.

 @param location The new location of the border center. (Only x/z used)]]>
      </doc>
    </method>
    <method name="getDamageBuffer" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current border damage buffer.

 @return The current border damage buffer.]]>
      </doc>
    </method>
    <method name="setDamageBuffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blocks" type="double"/>
      <doc>
      <![CDATA[Sets the amount of blocks a player may safely be outside the border before taking damage.

 @param blocks The amount of blocks. (The default is 5 blocks.)]]>
      </doc>
    </method>
    <method name="getDamageAmount" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current border damage amount.

 @return The current border damage amount.]]>
      </doc>
    </method>
    <method name="setDamageAmount"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="double"/>
      <doc>
      <![CDATA[Sets the amount of damage a player takes when outside the border plus the border buffer.

 @param damage The amount of damage. (The default is 0.2 damage per second per block.)]]>
      </doc>
    </method>
    <method name="getWarningTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current border warning time in seconds.

 @return The current border warning time in seconds.]]>
      </doc>
    </method>
    <method name="setWarningTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seconds" type="int"/>
      <doc>
      <![CDATA[Sets the warning time that causes the screen to be tinted red when a contracting border will reach the player within the specified time.

 @param seconds The amount of time in seconds. (The default is 15 seconds.)]]>
      </doc>
    </method>
    <method name="getWarningDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current border warning distance.

 @return The current border warning distance.]]>
      </doc>
    </method>
    <method name="setWarningDistance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Sets the warning distance that causes the screen to be tinted red when the player is within the specified number of blocks from the border.

 @param distance The distance in blocks. (The default is 5 blocks.)]]>
      </doc>
    </method>
    <method name="isInside" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Check if the specified location is inside this border.

 @param location the location to check
 @return if this location is inside the border or not]]>
      </doc>
    </method>
    <method name="isInBounds" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #isInside(Location)} for an upstream compatible replacement">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Checks if the location is within the boundaries of this border.
 
 @param location specific location to check
 @return true if the location is within the bounds of this border, false otherwise.
 @deprecated use {@link #isInside(Location)} for an upstream compatible replacement]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.WorldBorder -->
  <!-- start class org.bukkit.WorldCreator -->
  <class name="WorldCreator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WorldCreator" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty WorldCreationOptions for the given world name

 @param name Name of the world that will be created]]>
      </doc>
    </constructor>
    <method name="copy" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Copies the options from the specified world

 @param world World to copy options from
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="copy" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="creator" type="org.bukkit.WorldCreator"/>
      <doc>
      <![CDATA[Copies the options from the specified {@link WorldCreator}

 @param creator World creator to copy options from
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of the world that is to be loaded or created.

 @return World name]]>
      </doc>
    </method>
    <method name="seed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the seed that will be used to create this world

 @return World seed]]>
      </doc>
    </method>
    <method name="seed" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="long"/>
      <doc>
      <![CDATA[Sets the seed that will be used to create this world

 @param seed World seed
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="environment" return="org.bukkit.World.Environment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the environment that will be used to create or load the world

 @return World environment]]>
      </doc>
    </method>
    <method name="environment" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="env" type="org.bukkit.World.Environment"/>
      <doc>
      <![CDATA[Sets the environment that will be used to create or load the world

 @param env World environment
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="type" return="org.bukkit.WorldType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of the world that will be created or loaded

 @return World type]]>
      </doc>
    </method>
    <method name="type" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.WorldType"/>
      <doc>
      <![CDATA[Sets the type of the world that will be created or loaded

 @param type World type
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="generator" return="org.bukkit.generator.ChunkGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the generator that will be used to create or load the world.
 <p>
 This may be null, in which case the "natural" generator for this
 environment will be used.

 @return Chunk generator]]>
      </doc>
    </method>
    <method name="generator" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="generator" type="org.bukkit.generator.ChunkGenerator"/>
      <doc>
      <![CDATA[Sets the generator that will be used to create or load the world.
 <p>
 This may be null, in which case the "natural" generator for this
 environment will be used.

 @param generator Chunk generator
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="generator" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="generator" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the generator that will be used to create or load the world.
 <p>
 This may be null, in which case the "natural" generator for this
 environment will be used.
 <p>
 If the generator cannot be found for the given name, the natural
 environment generator will be used instead and a warning will be
 printed to the console.

 @param generator Name of the generator to use, in "plugin:id" notation
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="generator" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="generator" type="java.lang.String"/>
      <param name="output" type="org.bukkit.command.CommandSender"/>
      <doc>
      <![CDATA[Sets the generator that will be used to create or load the world.
 <p>
 This may be null, in which case the "natural" generator for this
 environment will be used.
 <p>
 If the generator cannot be found for the given name, the natural
 environment generator will be used instead and a warning will be
 printed to the specified output

 @param generator Name of the generator to use, in "plugin:id" notation
 @param output {@link CommandSender} that will receive any error
     messages
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="generatorSettings" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="generatorSettings" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the generator settings of the world that will be created or loaded.
 <p>
 Currently only {@link WorldType#FLAT} uses these settings, and expects
 them to be in JSON format with a valid biome AND structures (1.16 and
 above) defined. Note the occurrence of "structures" twice (nested
 compound may be empty, both must exist.). An example valid configuration
 is as follows:
 <code>{"structures": {"structures": {"village": {"salt": 8015723, "spacing": 32, "separation": 8}}}, "layers": [{"block": "stone", "height": 1}, {"block": "grass", "height": 1}], "biome":"plains"}</code>

 @see <a href="https://minecraft.gamepedia.com/Custom_dimension">Custom
 dimension</a> (scroll to "When the generator ID type is
 <code>minecraft:flat</code>)"
 @param generatorSettings The settings that should be used by the
 generator
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="generatorSettings" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the generator settings of the world that will be created or loaded.

 @return The settings that should be used by the generator
 @see #generatorSettings(java.lang.String)]]>
      </doc>
    </method>
    <method name="generateStructures" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="generate" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not worlds created or loaded with this creator will
 have structures.

 @param generate Whether to generate structures
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="generateStructures" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not structures will be generated in the world.

 @return True if structures will be generated]]>
      </doc>
    </method>
    <method name="hardcore" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hardcore" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the world will be hardcore or not.

 In a hardcore world the difficulty will be locked to hard.

 @param hardcore Whether the world will be hardcore
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="hardcore" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the world will be hardcore or not.

 In a hardcore world the difficulty will be locked to hard.

 @return hardcore status]]>
      </doc>
    </method>
    <method name="createWorld" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a world with the specified options.
 <p>
 If the world already exists, it will be loaded from disk and some
 options may be ignored.

 @return Newly created or loaded world]]>
      </doc>
    </method>
    <method name="name" return="org.bukkit.WorldCreator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a new {@link WorldCreator} for the given world name

 @param name Name of the world to load or create
 @return Resulting WorldCreator]]>
      </doc>
    </method>
    <method name="getGeneratorForName" return="org.bukkit.generator.ChunkGenerator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="output" type="org.bukkit.command.CommandSender"/>
      <doc>
      <![CDATA[Attempts to get the {@link ChunkGenerator} with the given name.
 <p>
 If the generator is not found, null will be returned and a message will
 be printed to the specified {@link CommandSender} explaining why.
 <p>
 The name must be in the "plugin:id" notation, or optionally just
 "plugin", where "plugin" is the safe-name of a plugin and "id" is an
 optional unique identifier for the generator you wish to request from
 the plugin.

 @param world Name of the world this will be used for
 @param name Name of the generator to retrieve
 @param output Where to output if errors are present
 @return Resulting generator, or null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents various types of options that may be used to create a world.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.WorldCreator -->
  <!-- start class org.bukkit.WorldType -->
  <class name="WorldType" extends="java.lang.Enum&lt;org.bukkit.WorldType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.WorldType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.WorldType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of this WorldType

 @return Name of this type]]>
      </doc>
    </method>
    <method name="getByName" return="org.bukkit.WorldType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a WorldType by its name

 @param name Name of the WorldType to get
 @return Requested WorldType, or null if not found]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents various types of worlds that may exist]]>
    </doc>
  </class>
  <!-- end class org.bukkit.WorldType -->
</package>
<package name="org.bukkit.advancement">
  <!-- start interface org.bukkit.advancement.Advancement -->
  <interface name="Advancement"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="getCriteria" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all the criteria present in this advancement.

 @return a unmodifiable copy of all criteria]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an advancement that may be awarded to a player. This class is not
 reference safe as the underlying advancement may be reloaded.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.advancement.Advancement -->
  <!-- start interface org.bukkit.advancement.AdvancementProgress -->
  <interface name="AdvancementProgress"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAdvancement" return="org.bukkit.advancement.Advancement"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The advancement this progress is concerning.

 @return the relevant advancement]]>
      </doc>
    </method>
    <method name="isDone" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if all criteria for this advancement have been met.

 @return true if this advancement is done]]>
      </doc>
    </method>
    <method name="awardCriteria" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="criteria" type="java.lang.String"/>
      <doc>
      <![CDATA[Mark the specified criteria as awarded at the current time.

 @param criteria the criteria to mark
 @return true if awarded, false if criteria does not exist or already
 awarded.]]>
      </doc>
    </method>
    <method name="revokeCriteria" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="criteria" type="java.lang.String"/>
      <doc>
      <![CDATA[Mark the specified criteria as uncompleted.

 @param criteria the criteria to mark
 @return true if removed, false if criteria does not exist or not awarded]]>
      </doc>
    </method>
    <method name="getDateAwarded" return="java.util.Date"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="criteria" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the date the specified criteria was awarded.

 @param criteria the criteria to check
 @return date awarded or null if unawarded or criteria does not exist]]>
      </doc>
    </method>
    <method name="getRemainingCriteria" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the criteria which have not been awarded.

 @return unmodifiable copy of criteria remaining]]>
      </doc>
    </method>
    <method name="getAwardedCriteria" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the criteria which have been awarded.

 @return unmodifiable copy of criteria awarded]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The individual status of an advancement for a player. This class is not
 reference safe as the underlying advancement may be reloaded.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.advancement.AdvancementProgress -->
</package>
<package name="org.bukkit.attribute">
  <!-- start interface org.bukkit.attribute.Attributable -->
  <interface name="Attributable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAttribute" return="org.bukkit.attribute.AttributeInstance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="org.bukkit.attribute.Attribute"/>
      <doc>
      <![CDATA[Gets the specified attribute instance from the object. This instance will
 be backed directly to the object and any changes will be visible at once.

 @param attribute the attribute to get
 @return the attribute instance or null if not applicable to this object]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an object which may contain attributes.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.attribute.Attributable -->
  <!-- start class org.bukkit.attribute.Attribute -->
  <class name="Attribute" extends="java.lang.Enum&lt;org.bukkit.attribute.Attribute&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.attribute.Attribute[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.attribute.Attribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Types of attributes which may be present on an {@link Attributable}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.attribute.Attribute -->
  <!-- start interface org.bukkit.attribute.AttributeInstance -->
  <interface name="AttributeInstance"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAttribute" return="org.bukkit.attribute.Attribute"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The attribute pertaining to this instance.

 @return the attribute]]>
      </doc>
    </method>
    <method name="getBaseValue" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Base value of this instance before modifiers are applied.

 @return base value]]>
      </doc>
    </method>
    <method name="setBaseValue"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Set the base value of this instance.

 @param value new base value]]>
      </doc>
    </method>
    <method name="getModifiers" return="java.util.Collection&lt;org.bukkit.attribute.AttributeModifier&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all modifiers present on this instance.

 @return a copied collection of all modifiers]]>
      </doc>
    </method>
    <method name="addModifier"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modifier" type="org.bukkit.attribute.AttributeModifier"/>
      <doc>
      <![CDATA[Add a modifier to this instance.

 @param modifier to add]]>
      </doc>
    </method>
    <method name="removeModifier"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modifier" type="org.bukkit.attribute.AttributeModifier"/>
      <doc>
      <![CDATA[Remove a modifier from this instance.

 @param modifier to remove]]>
      </doc>
    </method>
    <method name="getValue" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the value of this instance after all associated modifiers have been
 applied.

 @return the total attribute value]]>
      </doc>
    </method>
    <method name="getDefaultValue" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default value of the Attribute attached to this instance.

 @return server default value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a mutable instance of an attribute and its associated modifiers
 and values.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.attribute.AttributeInstance -->
  <!-- start class org.bukkit.attribute.AttributeModifier -->
  <class name="AttributeModifier" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <constructor name="AttributeModifier" type="java.lang.String, double, org.bukkit.attribute.AttributeModifier.Operation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AttributeModifier" type="java.util.UUID, java.lang.String, double, org.bukkit.attribute.AttributeModifier.Operation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AttributeModifier" type="java.util.UUID, java.lang.String, double, org.bukkit.attribute.AttributeModifier.Operation, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUniqueId" return="java.util.UUID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the unique ID for this modifier.

 @return unique id]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of this modifier.

 @return name]]>
      </doc>
    </method>
    <method name="getAmount" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount by which this modifier will apply its {@link Operation}.

 @return modification amount]]>
      </doc>
    </method>
    <method name="getOperation" return="org.bukkit.attribute.AttributeModifier.Operation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the operation this modifier will apply.

 @return operation]]>
      </doc>
    </method>
    <method name="getSlot" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link EquipmentSlot} this AttributeModifier is active on,
 or null if this modifier is applicable for any slot.

 @return the slot]]>
      </doc>
    </method>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="deserialize" return="org.bukkit.attribute.AttributeModifier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <doc>
    <![CDATA[Concrete implementation of an attribute modifier.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.attribute.AttributeModifier -->
  <!-- start class org.bukkit.attribute.AttributeModifier.Operation -->
  <class name="AttributeModifier.Operation" extends="java.lang.Enum&lt;org.bukkit.attribute.AttributeModifier.Operation&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.attribute.AttributeModifier.Operation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.attribute.AttributeModifier.Operation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Enumerable operation to be applied.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.attribute.AttributeModifier.Operation -->
</package>
<package name="org.bukkit.block">
  <!-- start interface org.bukkit.block.Banner -->
  <interface name="Banner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="getBaseColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the base color for this banner

 @return the base color]]>
      </doc>
    </method>
    <method name="setBaseColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the base color for this banner.
 <b>Only valid for shield pseudo banners, otherwise base depends on block
 type</b>

 @param color the base color]]>
      </doc>
    </method>
    <method name="getPatterns" return="java.util.List&lt;org.bukkit.block.banner.Pattern&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of patterns on this banner

 @return the patterns]]>
      </doc>
    </method>
    <method name="setPatterns"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="patterns" type="java.util.List&lt;org.bukkit.block.banner.Pattern&gt;"/>
      <doc>
      <![CDATA[Sets the patterns used on this banner

 @param patterns the new list of patterns]]>
      </doc>
    </method>
    <method name="addPattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="org.bukkit.block.banner.Pattern"/>
      <doc>
      <![CDATA[Adds a new pattern on top of the existing
 patterns

 @param pattern the new pattern to add]]>
      </doc>
    </method>
    <method name="getPattern" return="org.bukkit.block.banner.Pattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Returns the pattern at the specified index

 @param i the index
 @return the pattern]]>
      </doc>
    </method>
    <method name="removePattern" return="org.bukkit.block.banner.Pattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Removes the pattern at the specified index

 @param i the index
 @return the removed pattern]]>
      </doc>
    </method>
    <method name="setPattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="pattern" type="org.bukkit.block.banner.Pattern"/>
      <doc>
      <![CDATA[Sets the pattern at the specified index

 @param i       the index
 @param pattern the new pattern]]>
      </doc>
    </method>
    <method name="numberOfPatterns" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of patterns on this
 banner

 @return the number of patterns]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a banner.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Banner -->
  <!-- start interface org.bukkit.block.Barrel -->
  <interface name="Barrel"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Container"/>
    <implements name="org.bukkit.loot.Lootable"/>
    <implements name="org.bukkit.block.Lidded"/>
    <doc>
    <![CDATA[Represents a captured state of a Barrel.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Barrel -->
  <!-- start interface org.bukkit.block.Beacon -->
  <interface name="Beacon"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <implements name="org.bukkit.block.Lockable"/>
    <implements name="org.bukkit.Nameable"/>
    <method name="getEntitiesInRange" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the list of players within the beacon's range of effect.
 <p>
 This will return an empty list if the block represented by this state is
 no longer a beacon.

 @return the players in range
 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <method name="getTier" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the tier of the beacon pyramid (0-4). The tier refers to the
 beacon's power level, based on how many layers of blocks are in the
 pyramid. Tier 1 refers to a beacon with one layer of 9 blocks under it.

 @return the beacon tier]]>
      </doc>
    </method>
    <method name="getPrimaryEffect" return="org.bukkit.potion.PotionEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the primary effect set on the beacon

 @return the primary effect or null if not set]]>
      </doc>
    </method>
    <method name="setPrimaryEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Set the primary effect on this beacon, or null to clear.

 @param effect new primary effect]]>
      </doc>
    </method>
    <method name="getSecondaryEffect" return="org.bukkit.potion.PotionEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the secondary effect set on the beacon.

 @return the secondary effect or null if no secondary effect]]>
      </doc>
    </method>
    <method name="setSecondaryEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Set the secondary effect on this beacon, or null to clear. Note that tier
 must be &gt;= 4 for this effect to be active.

 @param effect desired secondary effect]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a beacon.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Beacon -->
  <!-- start interface org.bukkit.block.Bed -->
  <interface name="Bed"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="does not provide useful information beyond the material itself">
    <implements name="org.bukkit.block.TileState"/>
    <implements name="org.bukkit.material.Colorable"/>
    <doc>
    <![CDATA[Represents a captured state of a bed.
 @deprecated does not provide useful information beyond the material itself]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Bed -->
  <!-- start interface org.bukkit.block.Beehive -->
  <interface name="Beehive"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.EntityBlockStorage&lt;org.bukkit.entity.Bee&gt;"/>
    <method name="getFlower" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the hive's flower location.

 @return flower location or null]]>
      </doc>
    </method>
    <method name="setFlower"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Set the hive's flower location.

 @param location or null]]>
      </doc>
    </method>
    <method name="isSedated" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the hive is sedated due to smoke from a nearby campfire.

 @return True if hive is sedated]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a bee hive.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Beehive -->
  <!-- start interface org.bukkit.block.Bell -->
  <interface name="Bell"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <doc>
    <![CDATA[Represents a captured state of Bell.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Bell -->
  <!-- start class org.bukkit.block.Biome -->
  <class name="Biome" extends="java.lang.Enum&lt;org.bukkit.block.Biome&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.block.Biome[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.Biome"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Holds all accepted Biomes in the default server]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.Biome -->
  <!-- start interface org.bukkit.block.BlastFurnace -->
  <interface name="BlastFurnace"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Furnace"/>
    <doc>
    <![CDATA[Represents a captured state of a blast furnace.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.BlastFurnace -->
  <!-- start interface org.bukkit.block.Block -->
  <interface name="Block"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.metadata.Metadatable"/>
    <method name="getData" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the metadata for this block

 @return block specific metadata
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the complete block data for this block

 @return block specific data]]>
      </doc>
    </method>
    <method name="getRelative" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modX" type="int"/>
      <param name="modY" type="int"/>
      <param name="modZ" type="int"/>
      <doc>
      <![CDATA[Gets the block at the given offsets

 @param modX X-coordinate offset
 @param modY Y-coordinate offset
 @param modZ Z-coordinate offset
 @return Block at the given offsets]]>
      </doc>
    </method>
    <method name="getRelative" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Gets the block at the given face
 <p>
 This method is equal to getRelative(face, 1)

 @param face Face of this block to return
 @return Block at the given face
 @see #getRelative(BlockFace, int)]]>
      </doc>
    </method>
    <method name="getRelative" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Gets the block at the given distance of the given face
 <p>
 For example, the following method places water at 100,102,100; two
 blocks above 100,100,100.

 <pre>
 Block block = world.getBlockAt(100, 100, 100);
 Block shower = block.getRelative(BlockFace.UP, 2);
 shower.setType(Material.WATER);
 </pre>

 @param face Face of this block to return
 @param distance Distance to get the block at
 @return Block at the given face]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of this block

 @return block type]]>
      </doc>
    </method>
    <method name="getLightLevel" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the light level between 0-15

 @return light level]]>
      </doc>
    </method>
    <method name="getLightFromSky" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of light at this block from the sky.
 <p>
 Any light given from other sources (such as blocks like torches) will
 be ignored.

 @return Sky light level]]>
      </doc>
    </method>
    <method name="getLightFromBlocks" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of light at this block from nearby blocks.
 <p>
 Any light given from other sources (such as the sun) will be ignored.

 @return Block light level]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world which contains this Block

 @return World containing this block]]>
      </doc>
    </method>
    <method name="getX" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the x-coordinate of this block

 @return x-coordinate]]>
      </doc>
    </method>
    <method name="getY" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the y-coordinate of this block

 @return y-coordinate]]>
      </doc>
    </method>
    <method name="getZ" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the z-coordinate of this block

 @return z-coordinate]]>
      </doc>
    </method>
    <method name="getBlockKey" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this block's coordinates packed into a long value.
 Computed via: {@code Block.getBlockKey(this.getX(), this.getY(), this.getZ())}
 @see Block#getBlockKey(int, int, int)
 @return This block's x, y, and z coordinates packed into a long value]]>
      </doc>
    </method>
    <method name="getBlockKey" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Returns the specified block coordinates packed into a long value
 <p>
 The return value can be computed as follows:
 <br>
 {@code long value = ((long)x & 0x7FFFFFF) | (((long)z & 0x7FFFFFF) << 27) | ((long)y << 54);}
 </p>

 <p>
 And may be unpacked as follows:
 <br>
 {@code int x = (int) ((packed << 37) >> 37);}
 <br>
 {@code int y = (int) (packed >>> 54);}
 <br>
 {@code int z = (int) ((packed << 10) >> 37);}
 </p>

 @return This block's x, y, and z coordinates packed into a long value]]>
      </doc>
    </method>
    <method name="getBlockKeyX" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packed" type="long"/>
      <doc>
      <![CDATA[Returns the x component from the packed value.
 @param packed The packed value, as computed by {@link Block#getBlockKey(int, int, int)}
 @see Block#getBlockKey(int, int, int)
 @return The x component from the packed value.]]>
      </doc>
    </method>
    <method name="getBlockKeyY" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packed" type="long"/>
      <doc>
      <![CDATA[Returns the y component from the packed value.
 @param packed The packed value, as computed by {@link Block#getBlockKey(int, int, int)}
 @see Block#getBlockKey(int, int, int)
 @return The y component from the packed value.]]>
      </doc>
    </method>
    <method name="getBlockKeyZ" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packed" type="long"/>
      <doc>
      <![CDATA[Returns the z component from the packed value.
 @param packed The packed value, as computed by {@link Block#getBlockKey(int, int, int)}
 @see Block#getBlockKey(int, int, int)
 @return The z component from the packed value.]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Location of the block

 @return Location of block]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Stores the location of the block in the provided Location object.
 <p>
 If the provided Location is null this method does nothing and returns
 null.

 @param loc the location to copy into
 @return The Location object provided or null]]>
      </doc>
    </method>
    <method name="getChunk" return="org.bukkit.Chunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chunk which contains this block

 @return Containing Chunk]]>
      </doc>
    </method>
    <method name="setBlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Sets the complete data for this block

 @param data new block specific data]]>
      </doc>
    </method>
    <method name="setBlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.block.data.BlockData"/>
      <param name="applyPhysics" type="boolean"/>
      <doc>
      <![CDATA[Sets the complete data for this block

 <br>
 Note that applyPhysics = false is not in general safe. It should only be
 used when you need to avoid triggering a physics update of neighboring
 blocks, for example when creating a {@link Bisected} block. If you are
 using a custom populator, then this parameter may also be required to
 prevent triggering infinite chunk loads on border blocks. This method
 should NOT be used to "hack" physics by placing blocks in impossible
 locations. Such blocks are liable to be removed on various events such as
 world upgrades. Furthermore setting large amounts of such blocks in close
 proximity may overload the server physics engine if an update is
 triggered at a later point. If this occurs, the resulting behavior is
 undefined.

 @param data new block specific data
 @param applyPhysics false to cancel physics from the changed block]]>
      </doc>
    </method>
    <method name="setType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Sets the type of this block

 @param type Material to change this block to]]>
      </doc>
    </method>
    <method name="setType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.Material"/>
      <param name="applyPhysics" type="boolean"/>
      <doc>
      <![CDATA[Sets the type of this block

 <br>
 Note that applyPhysics = false is not in general safe. It should only be
 used when you need to avoid triggering a physics update of neighboring
 blocks, for example when creating a {@link Bisected} block. If you are
 using a custom populator, then this parameter may also be required to
 prevent triggering infinite chunk loads on border blocks. This method
 should NOT be used to "hack" physics by placing blocks in impossible
 locations. Such blocks are liable to be removed on various events such as
 world upgrades. Furthermore setting large amounts of such blocks in close
 proximity may overload the server physics engine if an update is
 triggered at a later point. If this occurs, the resulting behavior is
 undefined.

 @param type Material to change this block to
 @param applyPhysics False to cancel physics on the changed block.]]>
      </doc>
    </method>
    <method name="getFace" return="org.bukkit.block.BlockFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <doc>
      <![CDATA[Gets the face relation of this block compared to the given block.
 <p>
 For example:
 <pre>{@code
 Block current = world.getBlockAt(100, 100, 100);
 Block target = world.getBlockAt(100, 101, 100);

 current.getFace(target) == BlockFace.Up;
 }</pre>
 <br>
 If the given block is not connected to this block, null may be returned

 @param block Block to compare against this block
 @return BlockFace of this block which has the requested block, or null]]>
      </doc>
    </method>
    <method name="getState" return="org.bukkit.block.BlockState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Captures the current state of this block. You may then cast that state
 into any accepted type, such as Furnace or Sign.
 <p>
 The returned object will never be updated, and you are not guaranteed
 that (for example) a sign is still a sign after you capture its state.

 @return BlockState with the current state of this block.]]>
      </doc>
    </method>
    <method name="getState" return="org.bukkit.block.BlockState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="useSnapshot" type="boolean"/>
      <doc>
      <![CDATA[@see #getState() optionally disables use of snapshot, to operate on real block data
 @param useSnapshot if this block is a TE, should we create a fully copy of the TileEntity
 @return BlockState with the current state of this block]]>
      </doc>
    </method>
    <method name="getBiome" return="org.bukkit.block.Biome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the biome that this block resides in

 @return Biome type containing this block]]>
      </doc>
    </method>
    <method name="setBiome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bio" type="org.bukkit.block.Biome"/>
      <doc>
      <![CDATA[Sets the biome that this block resides in

 @param bio new Biome type for this block]]>
      </doc>
    </method>
    <method name="isBlockPowered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the block is being powered by Redstone.

 @return True if the block is powered.]]>
      </doc>
    </method>
    <method name="isBlockIndirectlyPowered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the block is being indirectly powered by Redstone.

 @return True if the block is indirectly powered.]]>
      </doc>
    </method>
    <method name="isBlockFacePowered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Returns true if the block face is being powered by Redstone.

 @param face The block face
 @return True if the block face is powered.]]>
      </doc>
    </method>
    <method name="isBlockFaceIndirectlyPowered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Returns true if the block face is being indirectly powered by Redstone.

 @param face The block face
 @return True if the block face is indirectly powered.]]>
      </doc>
    </method>
    <method name="getBlockPower" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Returns the redstone power being provided to this block face

 @param face the face of the block to query or BlockFace.SELF for the
     block itself
 @return The power level.]]>
      </doc>
    </method>
    <method name="getBlockPower" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the redstone power being provided to this block

 @return The power level.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this block is empty.
 <p>
 A block is considered empty when {@link #getType()} returns {@link
 Material#AIR}.

 @return true if this block is empty]]>
      </doc>
    </method>
    <method name="isLiquid" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this block is liquid.
 <p>
 A block is considered liquid when {@link #getType()} returns {@link
 Material#WATER} or {@link Material#LAVA}.

 @return true if this block is liquid]]>
      </doc>
    </method>
    <method name="getTemperature" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the temperature of this block.
 <p>
 If the raw biome temperature without adjusting for height effects is
 required then please use {@link World#getTemperature(int, int)}.

 @return Temperature of this block]]>
      </doc>
    </method>
    <method name="getHumidity" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the humidity of the biome of this block

 @return Humidity of this block]]>
      </doc>
    </method>
    <method name="getPistonMoveReaction" return="org.bukkit.block.PistonMoveReaction"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the reaction of the block when moved by a piston

 @return reaction]]>
      </doc>
    </method>
    <method name="breakNaturally" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Breaks the block and spawns items as if a player had digged it regardless
 of the tool.

 @return true if the block was destroyed]]>
      </doc>
    </method>
    <method name="breakNaturally" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tool" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Breaks the block and spawns items as if a player had digged it with a
 specific tool

 @param tool The tool or item in hand used for digging
 @return true if the block was destroyed]]>
      </doc>
    </method>
    <method name="breakNaturally" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tool" type="org.bukkit.inventory.ItemStack"/>
      <param name="triggerEffect" type="boolean"/>
      <doc>
      <![CDATA[Breaks the block and spawns items as if a player had digged it with a
 specific tool

 @param tool The tool or item in hand used for digging
 @param triggerEffect Play the block break particle effect and sound
 @return true if the block was destroyed]]>
      </doc>
    </method>
    <method name="applyBoneMeal" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Simulate bone meal application to this block (if possible).

 @param face the face on which bonemeal should be applied

 @return true if the block was bonemealed, false otherwise]]>
      </doc>
    </method>
    <method name="getDrops" return="java.util.Collection&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of items which would drop by destroying this block

 @return a list of dropped items for this type of block]]>
      </doc>
    </method>
    <method name="getDrops" return="java.util.Collection&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tool" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Returns a list of items which would drop by destroying this block with
 a specific tool

 @param tool The tool or item in hand used for digging
 @return a list of dropped items for this type of block]]>
      </doc>
    </method>
    <method name="getDrops" return="java.util.Collection&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tool" type="org.bukkit.inventory.ItemStack"/>
      <param name="entity" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Returns a list of items which would drop by the entity destroying this
 block with a specific tool

 @param tool The tool or item in hand used for digging
 @param entity the entity destroying the block
 @return a list of dropped items for this type of block]]>
      </doc>
    </method>
    <method name="isPassable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this block is passable.
 <p>
 A block is passable if it has no colliding parts that would prevent
 players from moving through it.
 <p>
 Examples: Tall grass, flowers, signs, etc. are passable, but open doors,
 fence gates, trap doors, etc. are not because they still have parts that
 can be collided with.

 @return <code>true</code> if passable]]>
      </doc>
    </method>
    <method name="rayTrace" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.Location"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <param name="fluidCollisionMode" type="org.bukkit.FluidCollisionMode"/>
      <doc>
      <![CDATA[Performs a ray trace that checks for collision with this specific block
 in its current state using its precise collision shape.

 @param start the start location
 @param direction the ray direction
 @param maxDistance the maximum distance
 @param fluidCollisionMode the fluid collision mode
 @return the ray trace hit result, or <code>null</code> if there is no hit]]>
      </doc>
    </method>
    <method name="getBoundingBox" return="org.bukkit.util.BoundingBox"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the approximate bounding box for this block.
 <p>
 This isn't exact as some blocks {@link org.bukkit.block.data.type.Stairs}
 contain many bounding boxes to establish their complete form.

 Also, the box may not be exactly the same as the collision shape (such as
 cactus, which is 16/16 of a block with 15/16 collisional bounds).

 This method will return an empty bounding box if the geometric shape of
 the block is empty (such as air blocks).

 @return the approximate bounding box of the block]]>
      </doc>
    </method>
    <method name="getSoundGroup" return="com.destroystokyo.paper.block.BlockSoundGroup"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link com.destroystokyo.paper.block.BlockSoundGroup} for this block.
 <p>
 This object contains the block, step, place, hit, and fall sounds.

 @return the sound group for this block]]>
      </doc>
    </method>
    <method name="getTranslationKey" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the translation key for the Block, so the client can translate it into the active
 locale when using a TranslatableComponent.
 @return the translation key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a block. This is a live object, and only one Block may exist for
 any given location in a world. The state of the block may change
 concurrently to your own handling of it; use block.getState() to get a
 snapshot state of a block which will not be modified.

 <br>
 Note that parts of this class which require access to the world at large
 (i.e. lighting and power) may not be able to be safely accessed during world
 generation when used in cases like BlockPhysicsEvent!!!!]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Block -->
  <!-- start class org.bukkit.block.BlockFace -->
  <class name="BlockFace" extends="java.lang.Enum&lt;org.bukkit.block.BlockFace&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.BlockFace[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getModX" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of X-coordinates to modify to get the represented block

 @return Amount of X-coordinates to modify]]>
      </doc>
    </method>
    <method name="getModY" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of Y-coordinates to modify to get the represented block

 @return Amount of Y-coordinates to modify]]>
      </doc>
    </method>
    <method name="getModZ" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of Z-coordinates to modify to get the represented block

 @return Amount of Z-coordinates to modify]]>
      </doc>
    </method>
    <method name="getDirection" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the normal vector corresponding to this block face.

 @return the normal vector]]>
      </doc>
    </method>
    <method name="getOppositeFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the face of a block]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.BlockFace -->
  <!-- start interface org.bukkit.block.BlockState -->
  <interface name="BlockState"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.metadata.Metadatable"/>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block represented by this block state.

 @return the block represented by this block state
 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <method name="getData" return="org.bukkit.material.MaterialData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the metadata for this block state.

 @return block specific metadata]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the data for this block state.

 @return block specific data]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of this block state.

 @return block type]]>
      </doc>
    </method>
    <method name="getLightLevel" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current light level of the block represented by this block state.

 @return the light level between 0-15
 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world which contains the block represented by this block state.

 @return the world containing the block represented by this block state
 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <method name="getX" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the x-coordinate of this block state.

 @return x-coordinate]]>
      </doc>
    </method>
    <method name="getY" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the y-coordinate of this block state.

 @return y-coordinate]]>
      </doc>
    </method>
    <method name="getZ" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the z-coordinate of this block state.

 @return z-coordinate]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location of this block state.
 <p>
 If this block state is not placed the location's world will be null!

 @return the location]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Stores the location of this block state in the provided Location object.
 <p>
 If the provided Location is null this method does nothing and returns
 null.
 <p>
 If this block state is not placed the location's world will be null!

 @param loc the location to copy into
 @return The Location object provided or null]]>
      </doc>
    </method>
    <method name="getChunk" return="org.bukkit.Chunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chunk which contains the block represented by this block state.

 @return the containing Chunk
 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <method name="setData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Sets the metadata for this block state.

 @param data New block specific metadata]]>
      </doc>
    </method>
    <method name="setBlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Sets the data for this block state.

 @param data New block specific data]]>
      </doc>
    </method>
    <method name="setType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Sets the type of this block state.

 @param type Material to change this block state to]]>
      </doc>
    </method>
    <method name="update" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to update the block represented by this state, setting it to
 the new values as defined by this state.
 <p>
 This has the same effect as calling update(false). That is to say,
 this will not modify the state of a block if it is no longer the same
 type as it was when this state was taken. It will return false in this
 eventuality.

 @return true if the update was successful, otherwise false
 @see #update(boolean)]]>
      </doc>
    </method>
    <method name="update" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Attempts to update the block represented by this state, setting it to
 the new values as defined by this state.
 <p>
 This has the same effect as calling update(force, true). That is to
 say, this will trigger a physics update to surrounding blocks.

 @param force true to forcefully set the state
 @return true if the update was successful, otherwise false]]>
      </doc>
    </method>
    <method name="update" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="force" type="boolean"/>
      <param name="applyPhysics" type="boolean"/>
      <doc>
      <![CDATA[Attempts to update the block represented by this state, setting it to
 the new values as defined by this state.
 <p>
 If this state is not placed, this will have no effect and return true.
 <p>
 Unless force is true, this will not modify the state of a block if it
 is no longer the same type as it was when this state was taken. It will
 return false in this eventuality.
 <p>
 If force is true, it will set the type of the block to match the new
 state, set the state data and then return true.
 <p>
 If applyPhysics is true, it will trigger a physics update on
 surrounding blocks which could cause them to update or disappear.

 @param force true to forcefully set the state
 @param applyPhysics false to cancel updating physics on surrounding
     blocks
 @return true if the update was successful, otherwise false]]>
      </doc>
    </method>
    <method name="getRawData" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@return The data as a raw byte.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setRawData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[@param data The new data value for the block.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="isPlaced" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this state is placed in the world.
 <p>
 Some methods will not work if the block state isn't
 placed in the world.

 @return whether the state is placed in the world
         or 'virtual' (e.g. on an itemstack)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a block, which will not change
 automatically.
 <p>
 Unlike Block, which only one object can exist per coordinate, BlockState
 can exist multiple times for any given Block. Note that another plugin may
 change the state of the block and you will not know, or they may change the
 block to another type entirely, causing your BlockState to become invalid.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.BlockState -->
  <!-- start interface org.bukkit.block.BrewingStand -->
  <interface name="BrewingStand"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Container"/>
    <method name="getBrewingTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[How much time is left in the brewing cycle.

 @return Brew Time]]>
      </doc>
    </method>
    <method name="setBrewingTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="brewTime" type="int"/>
      <doc>
      <![CDATA[Set the time left before brewing completes.

 @param brewTime Brewing time]]>
      </doc>
    </method>
    <method name="getFuelLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the level of current fuel for brewing.

 @return The fuel level]]>
      </doc>
    </method>
    <method name="setFuelLevel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Set the level of current fuel for brewing.

 @param level fuel level]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.BrewerInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSnapshotInventory" return="org.bukkit.inventory.BrewerInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a captured state of a brewing stand.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.BrewingStand -->
  <!-- start interface org.bukkit.block.Campfire -->
  <interface name="Campfire"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="getSize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The size of the inventory
 @see Inventory#getSize()]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[@param index The index of the Slot's ItemStack to return
 @return The ItemStack in the slot
 @see Inventory#getItem(int)]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[@param index The index where to put the ItemStack
 @param item The ItemStack to set
 @see Inventory#setItem(int, org.bukkit.inventory.ItemStack)]]>
      </doc>
    </method>
    <method name="getCookTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Get cook time.

 This is the amount of time the item has been cooking for.

 @param index item slot index
 @return Cook time]]>
      </doc>
    </method>
    <method name="setCookTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="cookTime" type="int"/>
      <doc>
      <![CDATA[Set cook time.

 This is the amount of time the item has been cooking for.

 @param index item slot index
 @param cookTime Cook time]]>
      </doc>
    </method>
    <method name="getCookTimeTotal" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Get cook time total.

 This is the amount of time the item is required to cook for.

 @param index item slot index
 @return Cook time total]]>
      </doc>
    </method>
    <method name="setCookTimeTotal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="cookTimeTotal" type="int"/>
      <doc>
      <![CDATA[Set cook time.

 This is the amount of time the item is required to cook for.

 @param index item slot index
 @param cookTimeTotal Cook time total]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a campfire.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Campfire -->
  <!-- start interface org.bukkit.block.Chest -->
  <interface name="Chest"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Container"/>
    <implements name="com.destroystokyo.paper.loottable.LootableBlockInventory"/>
    <implements name="org.bukkit.block.Lidded"/>
    <method name="getBlockInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the inventory of the chest block represented by this block state.
 <p>
 If the chest is a double chest, it returns just the portion of the
 inventory linked to the half of the chest corresponding to this block state.
 <p>
 If the block was changed to a different type in the meantime, the
 returned inventory might no longer be valid.
 <p>
 If this block state is not placed this will return the captured
 inventory snapshot instead.

 @return the inventory]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a chest.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Chest -->
  <!-- start interface org.bukkit.block.CommandBlock -->
  <interface name="CommandBlock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="getCommand" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the command that this CommandBlock will run when powered.
 This will never return null.  If the CommandBlock does not have a
 command, an empty String will be returned instead.

 @return Command that this CommandBlock will run when powered.]]>
      </doc>
    </method>
    <method name="setCommand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the command that this CommandBlock will run when powered.
 Setting the command to null is the same as setting it to an empty
 String.

 @param command Command that this CommandBlock will run when powered.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of this CommandBlock.  The name is used with commands
 that this CommandBlock executes.  This name will never be null, and
 by default is "@".

 @return Name of this CommandBlock.]]>
      </doc>
    </method>
    <method name="setName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the name of this CommandBlock.  The name is used with commands
 that this CommandBlock executes.  Setting the name to null is the
 same as setting it to "@".

 @param name New name for this CommandBlock.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a command block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.CommandBlock -->
  <!-- start interface org.bukkit.block.Comparator -->
  <interface name="Comparator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <doc>
    <![CDATA[Represents a captured state of an on / off comparator.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Comparator -->
  <!-- start interface org.bukkit.block.Conduit -->
  <interface name="Conduit"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <doc>
    <![CDATA[Represents a captured state of a conduit.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Conduit -->
  <!-- start interface org.bukkit.block.Container -->
  <interface name="Container"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <implements name="org.bukkit.inventory.BlockInventoryHolder"/>
    <implements name="org.bukkit.block.Lockable"/>
    <implements name="org.bukkit.Nameable"/>
    <method name="getInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the inventory of the block represented by this block state.
 <p>
 If the block was changed to a different type in the meantime, the
 returned inventory might no longer be valid.
 <p>
 If this block state is not placed this will return the captured inventory
 snapshot instead.

 @return the inventory]]>
      </doc>
    </method>
    <method name="getSnapshotInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the captured inventory snapshot of this container.
 <p>
 The returned inventory is not linked to any block. Any modifications to
 the returned inventory will not be applied to the block represented by
 this block state up until {@link #update(boolean, boolean)} has been
 called.

 @return the captured inventory snapshot]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a container block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Container -->
  <!-- start interface org.bukkit.block.CreatureSpawner -->
  <interface name="CreatureSpawner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="getSpawnedType" return="org.bukkit.entity.EntityType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the spawner's creature type.

 @return The creature type.]]>
      </doc>
    </method>
    <method name="setSpawnedType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="creatureType" type="org.bukkit.entity.EntityType"/>
      <doc>
      <![CDATA[Set the spawner's creature type.

 @param creatureType The creature type.]]>
      </doc>
    </method>
    <method name="setCreatureTypeByName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="magic value, use
 {@link #setSpawnedType(org.bukkit.entity.EntityType)}.">
      <param name="creatureType" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the spawner mob type.

 @param creatureType The creature type's name.
 @deprecated magic value, use
 {@link #setSpawnedType(org.bukkit.entity.EntityType)}.]]>
      </doc>
    </method>
    <method name="getCreatureTypeName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="magic value, use {@link #getSpawnedType()}.">
      <doc>
      <![CDATA[Get the spawner's creature type.

 @return The creature type's name.
 @deprecated magic value, use {@link #getSpawnedType()}.]]>
      </doc>
    </method>
    <method name="getDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the spawner's delay.
 <br>
 This is the delay, in ticks, until the spawner will spawn its next mob.

 @return The delay.]]>
      </doc>
    </method>
    <method name="setDelay"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="int"/>
      <doc>
      <![CDATA[Set the spawner's delay.
 <br>
 If set to -1, the spawn delay will be reset to a random value between
 {@link #getMinSpawnDelay} and {@link #getMaxSpawnDelay()}.

 @param delay The delay.]]>
      </doc>
    </method>
    <method name="getMinSpawnDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The minimum spawn delay amount (in ticks).
 <br>
 This value is used when the spawner resets its delay (for any reason).
 It will choose a random number between {@link #getMinSpawnDelay()}
 and {@link #getMaxSpawnDelay()} for its next {@link #getDelay()}.

 Default value is 200 ticks.

 @return the minimum spawn delay amount]]>
      </doc>
    </method>
    <method name="setMinSpawnDelay"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="int"/>
      <doc>
      <![CDATA[Set the minimum spawn delay amount (in ticks).

 @param delay the minimum spawn delay amount
 @see #getMinSpawnDelay()]]>
      </doc>
    </method>
    <method name="getMaxSpawnDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The maximum spawn delay amount (in ticks).
 <br>
 This value is used when the spawner resets its delay (for any reason).
 It will choose a random number between {@link #getMinSpawnDelay()}
 and {@link #getMaxSpawnDelay()} for its next {@link #getDelay()}.
 <br>
 This value <b>must</b> be greater than 0 and less than or equal to
 {@link #getMaxSpawnDelay()}.

 Default value is 800 ticks.

 @return the maximum spawn delay amount]]>
      </doc>
    </method>
    <method name="setMaxSpawnDelay"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="int"/>
      <doc>
      <![CDATA[Set the maximum spawn delay amount (in ticks).
 <br>
 This value <b>must</b> be greater than 0, as well as greater than or
 equal to {@link #getMinSpawnDelay()}

 @param delay the new maximum spawn delay amount
 @see #getMaxSpawnDelay()]]>
      </doc>
    </method>
    <method name="getSpawnCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get how many mobs attempt to spawn.
 <br>
 Default value is 4.

 @return the current spawn count]]>
      </doc>
    </method>
    <method name="setSpawnCount"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spawnCount" type="int"/>
      <doc>
      <![CDATA[Set how many mobs attempt to spawn.

 @param spawnCount the new spawn count]]>
      </doc>
    </method>
    <method name="getMaxNearbyEntities" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set the new maximum amount of similar entities that are allowed to be
 within spawning range of this spawner.
 <br>
 If more than the maximum number of entities are within range, the spawner
 will not spawn and try again with a new {@link #getDelay()}.
 <br>
 Default value is 16.

 @return the maximum number of nearby, similar, entities]]>
      </doc>
    </method>
    <method name="setMaxNearbyEntities"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxNearbyEntities" type="int"/>
      <doc>
      <![CDATA[Set the maximum number of similar entities that are allowed to be within
 spawning range of this spawner.
 <br>
 Similar entities are entities that are of the same {@link EntityType}

 @param maxNearbyEntities the maximum number of nearby, similar, entities]]>
      </doc>
    </method>
    <method name="getRequiredPlayerRange" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum distance(squared) a player can be in order for this
 spawner to be active.
 <br>
 If this value is less than or equal to 0, this spawner is always active
 (given that there are players online).
 <br>
 Default value is 16.

 @return the maximum distance(squared) a player can be in order for this
 spawner to be active.]]>
      </doc>
    </method>
    <method name="setRequiredPlayerRange"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="requiredPlayerRange" type="int"/>
      <doc>
      <![CDATA[Set the maximum distance (squared) a player can be in order for this
 spawner to be active.
 <br>
 Setting this value to less than or equal to 0 will make this spawner
 always active (given that there are players online).

 @param requiredPlayerRange the maximum distance (squared) a player can be
 in order for this spawner to be active.]]>
      </doc>
    </method>
    <method name="getSpawnRange" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the radius around which the spawner will attempt to spawn mobs in.
 <br>
 This area is square, includes the block the spawner is in, and is
 centered on the spawner's x,z coordinates - not the spawner itself.
 <br>
 It is 2 blocks high, centered on the spawner's y-coordinate (its bottom);
 thus allowing mobs to spawn as high as its top surface and as low
 as 1 block below its bottom surface.
 <br>
 Default value is 4.

 @return the spawn range]]>
      </doc>
    </method>
    <method name="setSpawnRange"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spawnRange" type="int"/>
      <doc>
      <![CDATA[Set the new spawn range.
 <br>

 @param spawnRange the new spawn range
 @see #getSpawnRange()]]>
      </doc>
    </method>
    <method name="isActivated" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if spawner is activated (a player is close enough)

 @return True if a player is close enough to activate it]]>
      </doc>
    </method>
    <method name="resetTimer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the spawn delay timer within the min/max range]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a creature spawner.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.CreatureSpawner -->
  <!-- start interface org.bukkit.block.DaylightDetector -->
  <interface name="DaylightDetector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <doc>
    <![CDATA[Represents a captured state of a (possibly inverted) daylight detector.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.DaylightDetector -->
  <!-- start interface org.bukkit.block.Dispenser -->
  <interface name="Dispenser"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Container"/>
    <implements name="org.bukkit.Nameable"/>
    <implements name="com.destroystokyo.paper.loottable.LootableBlockInventory"/>
    <method name="getBlockProjectileSource" return="org.bukkit.projectiles.BlockProjectileSource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the BlockProjectileSource object for the dispenser.
 <p>
 If the block represented by this state is no longer a dispenser, this
 will return null.

 @return a BlockProjectileSource if valid, otherwise null
 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <method name="dispense" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to dispense the contents of the dispenser.
 <p>
 If the block represented by this state is no longer a dispenser, this
 will return false.

 @return true if successful, otherwise false
 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a dispenser.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Dispenser -->
  <!-- start class org.bukkit.block.DoubleChest -->
  <class name="DoubleChest" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.InventoryHolder"/>
    <constructor name="DoubleChest" type="org.bukkit.inventory.DoubleChestInventory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLeftSide" return="org.bukkit.inventory.InventoryHolder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRightSide" return="org.bukkit.inventory.InventoryHolder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLeftSide" return="org.bukkit.inventory.InventoryHolder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="useSnapshot" type="boolean"/>
    </method>
    <method name="getRightSide" return="org.bukkit.inventory.InventoryHolder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="useSnapshot" type="boolean"/>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getY" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a double chest.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.DoubleChest -->
  <!-- start interface org.bukkit.block.Dropper -->
  <interface name="Dropper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Container"/>
    <implements name="com.destroystokyo.paper.loottable.LootableBlockInventory"/>
    <method name="drop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tries to drop a randomly selected item from the dropper's inventory,
 following the normal behavior of a dropper.
 <p>
 Normal behavior of a dropper is as follows:
 <p>
 If the block that the dropper is facing is an InventoryHolder,
 the randomly selected ItemStack is placed within that
 Inventory in the first slot that's available, starting with 0 and
 counting up.  If the inventory is full, nothing happens.
 <p>
 If the block that the dropper is facing is not an InventoryHolder,
 the randomly selected ItemStack is dropped on
 the ground in the form of an {@link org.bukkit.entity.Item Item}.
 <p>
 If the block represented by this state is no longer a dropper, this will
 do nothing.

 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a dropper.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Dropper -->
  <!-- start interface org.bukkit.block.EnchantingTable -->
  <interface name="EnchantingTable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <implements name="org.bukkit.Nameable"/>
    <doc>
    <![CDATA[Represents a captured state of an enchanting table.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.EnchantingTable -->
  <!-- start interface org.bukkit.block.EnderChest -->
  <interface name="EnderChest"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <doc>
    <![CDATA[Represents a captured state of an ender chest.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.EnderChest -->
  <!-- start interface org.bukkit.block.EndGateway -->
  <interface name="EndGateway"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="getExitLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location that entities are teleported to when
 entering the gateway portal.
 <p>
 If this block state is not placed the location's world will be null.

 @return the gateway exit location]]>
      </doc>
    </method>
    <method name="setExitLocation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the exit location that entities are teleported to when
 they enter the gateway portal.
 <p>
 If this block state is not placed the location's world has to be null.

 @param location the new exit location
 @throws IllegalArgumentException for differing worlds]]>
      </doc>
    </method>
    <method name="isExactTeleport" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this gateway will teleport entities directly to
 the exit location instead of finding a nearby location.

 @return true if the gateway is teleporting to the exact location]]>
      </doc>
    </method>
    <method name="setExactTeleport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exact" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this gateway will teleport entities directly to
 the exit location instead of finding a nearby location.

 @param exact whether to teleport to the exact location]]>
      </doc>
    </method>
    <method name="getAge" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the age in ticks of the gateway.
 <br>
 If the age is less than 200 ticks a magenta beam will be emitted, whilst
 if it is a multiple of 2400 ticks a purple beam will be emitted.

 @return age in ticks]]>
      </doc>
    </method>
    <method name="setAge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="age" type="long"/>
      <doc>
      <![CDATA[Sets the age in ticks of the gateway.
 <br>
 If the age is less than 200 ticks a magenta beam will be emitted, whilst
 if it is a multiple of 2400 ticks a purple beam will be emitted.

 @param age new age in ticks]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of an end gateway.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.EndGateway -->
  <!-- start interface org.bukkit.block.EntityBlockStorage -->
  <interface name="EntityBlockStorage"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="isFull" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the block is completely full of entities.

 @return True if block is full]]>
      </doc>
    </method>
    <method name="getEntityCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of entities currently in this block.

 @return Amount of entities currently in this block]]>
      </doc>
    </method>
    <method name="getMaxEntities" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum amount of entities this block can hold.

 @return Maximum amount of entities this block can hold]]>
      </doc>
    </method>
    <method name="setMaxEntities"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="max" type="int"/>
      <doc>
      <![CDATA[Set the maximum amount of entities this block can hold.

 @param max Maximum amount of entities this block can hold]]>
      </doc>
    </method>
    <method name="releaseEntities" return="java.util.List&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Release all the entities currently stored in the block.

 @return List of all entities which were released]]>
      </doc>
    </method>
    <method name="addEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="T extends org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Add an entity to the block.

 @param entity Entity to add to the block]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a block which stores entities.

 @param <T> Entity this block can store]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.EntityBlockStorage -->
  <!-- start interface org.bukkit.block.Furnace -->
  <interface name="Furnace"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Container"/>
    <method name="getBurnTime" return="short"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get burn time.

 @return Burn time]]>
      </doc>
    </method>
    <method name="setBurnTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="burnTime" type="short"/>
      <doc>
      <![CDATA[Set burn time.

 A burn time greater than 0 will cause this block to be lit, whilst a time
 less than 0 will extinguish it.

 @param burnTime Burn time]]>
      </doc>
    </method>
    <method name="getCookTime" return="short"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get cook time.

 This is the amount of time the item has been cooking for.

 @return Cook time]]>
      </doc>
    </method>
    <method name="setCookTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cookTime" type="short"/>
      <doc>
      <![CDATA[Set cook time.

 This is the amount of time the item has been cooking for.

 @param cookTime Cook time]]>
      </doc>
    </method>
    <method name="getCookTimeTotal" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get cook time total.

 This is the amount of time the item is required to cook for.

 @return Cook time total]]>
      </doc>
    </method>
    <method name="setCookTimeTotal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cookTimeTotal" type="int"/>
      <doc>
      <![CDATA[Set cook time.

 This is the amount of time the item is required to cook for.

 @param cookTimeTotal Cook time total]]>
      </doc>
    </method>
    <method name="getCookSpeedMultiplier" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cook speed multiplier that this {@link Furnace} will cook
 compared to vanilla.

 @return the multiplier, a value between 0 and 200]]>
      </doc>
    </method>
    <method name="setCookSpeedMultiplier"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiplier" type="double"/>
      <doc>
      <![CDATA[Sets the speed multiplier that this {@link Furnace} will cook
 compared to vanilla.

 @param multiplier the multiplier to set, a value between 0 and 200
 @throws IllegalArgumentException if value is less than 0
 @throws IllegalArgumentException if value is more than 200]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.FurnaceInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSnapshotInventory" return="org.bukkit.inventory.FurnaceInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a captured state of a furnace.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Furnace -->
  <!-- start interface org.bukkit.block.Hopper -->
  <interface name="Hopper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Container"/>
    <implements name="com.destroystokyo.paper.loottable.LootableBlockInventory"/>
    <doc>
    <![CDATA[Represents a captured state of a hopper.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Hopper -->
  <!-- start interface org.bukkit.block.Jigsaw -->
  <interface name="Jigsaw"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <doc>
    <![CDATA[Represents a captured state of a jigsaw.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Jigsaw -->
  <!-- start interface org.bukkit.block.Jukebox -->
  <interface name="Jukebox"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="getPlaying" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the record inserted into the jukebox.

 @return The record Material, or AIR if none is inserted]]>
      </doc>
    </method>
    <method name="setPlaying"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Sets the record being played.

 @param record The record Material, or null/AIR to stop playing]]>
      </doc>
    </method>
    <method name="getRecord" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the record item inserted into the jukebox.

 @return a copy of the inserted record, or an air stack if none]]>
      </doc>
    </method>
    <method name="setRecord"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the record being played.

 @param record the record to insert or null/AIR to empty]]>
      </doc>
    </method>
    <method name="isPlaying" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the jukebox is playing a record.

 @return True if there is a record playing]]>
      </doc>
    </method>
    <method name="stopPlaying"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops the jukebox playing without ejecting the record.]]>
      </doc>
    </method>
    <method name="eject" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops the jukebox playing and ejects the current record.
 <p>
 If the block represented by this state is no longer a jukebox, this will
 do nothing and return false.

 @return True if a record was ejected; false if there was none playing
 @throws IllegalStateException if this block state is not placed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a jukebox.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Jukebox -->
  <!-- start interface org.bukkit.block.Lectern -->
  <interface name="Lectern"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <implements name="org.bukkit.inventory.BlockInventoryHolder"/>
    <method name="getPage" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current lectern page.

 @return current page]]>
      </doc>
    </method>
    <method name="setPage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="page" type="int"/>
      <doc>
      <![CDATA[Set the current lectern page.

 If the page is greater than the number of pages of the book currently in
 the inventory, then behavior is undefined.

 @param page new page]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Container#getInventory()

 @return inventory]]>
      </doc>
    </method>
    <method name="getSnapshotInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Container#getSnapshotInventory()

 @return snapshot inventory]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a lectern.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Lectern -->
  <!-- start interface org.bukkit.block.Lidded -->
  <interface name="Lidded"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="open"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the block's animated state to open and prevents it from being closed
 until {@link #close()} is called.]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the block's animated state to closed even if a player is currently
 viewing this block.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.block.Lidded -->
  <!-- start interface org.bukkit.block.Lockable -->
  <interface name="Lockable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isLocked" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the container has a valid (non empty) key.

 @return true if the key is valid.]]>
      </doc>
    </method>
    <method name="getLock" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key needed to access the container.

 @return the key needed.]]>
      </doc>
    </method>
    <method name="setLock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the key required to access this container. Set to null (or empty
 string) to remove key.

 @param key the key required to access the container.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a block (usually a container) that may be locked. When a lock is
 active an item with a name corresponding to the key will be required to open
 this block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Lockable -->
  <!-- start class org.bukkit.block.PistonMoveReaction -->
  <class name="PistonMoveReaction" extends="java.lang.Enum&lt;org.bukkit.block.PistonMoveReaction&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.PistonMoveReaction[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.PistonMoveReaction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@return The ID of the move reaction
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getById" return="org.bukkit.block.PistonMoveReaction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[@param id An ID
 @return The move reaction with that ID
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents how a block or entity will react when interacting with a piston
 when it is extending or retracting.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.PistonMoveReaction -->
  <!-- start interface org.bukkit.block.ShulkerBox -->
  <interface name="ShulkerBox"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Container"/>
    <implements name="com.destroystokyo.paper.loottable.LootableBlockInventory"/>
    <implements name="org.bukkit.block.Lidded"/>
    <method name="getColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link DyeColor} corresponding to this ShulkerBox

 @return the {@link DyeColor} of this ShulkerBox]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a ShulkerBox.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.ShulkerBox -->
  <!-- start interface org.bukkit.block.Sign -->
  <interface name="Sign"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <implements name="org.bukkit.material.Colorable"/>
    <method name="getLines" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all the lines of text currently on this sign.

 @return Array of Strings containing each line of text]]>
      </doc>
    </method>
    <method name="getLine" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <exception name="IndexOutOfBoundsException" type="java.lang.IndexOutOfBoundsException"/>
      <doc>
      <![CDATA[Gets the line of text at the specified index.
 <p>
 For example, getLine(0) will return the first line of text.

 @param index Line number to get the text from, starting at 0
 @throws IndexOutOfBoundsException Thrown when the line does not exist
 @return Text on the given line]]>
      </doc>
    </method>
    <method name="setLine"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="line" type="java.lang.String"/>
      <exception name="IndexOutOfBoundsException" type="java.lang.IndexOutOfBoundsException"/>
      <doc>
      <![CDATA[Sets the line of text at the specified index.
 <p>
 For example, setLine(0, "Line One") will set the first line of text to
 "Line One".

 @param index Line number to set the text at, starting from 0
 @param line New text to set at the specified index
 @throws IndexOutOfBoundsException If the index is out of the range 0..3]]>
      </doc>
    </method>
    <method name="isEditable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Marks whether this sign can be edited by players.
 <br>
 This is a special value, which is not persisted. It should only be set if
 a placed sign is manipulated during the BlockPlaceEvent. Behaviour
 outside of this event is undefined.

 @return if this sign is currently editable]]>
      </doc>
    </method>
    <method name="setEditable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="editable" type="boolean"/>
      <doc>
      <![CDATA[Marks whether this sign can be edited by players.
 <br>
 This is a special value, which is not persisted. It should only be set if
 a placed sign is manipulated during the BlockPlaceEvent. Behaviour
 outside of this event is undefined.

 @param editable if this sign is currently editable]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of either a SignPost or a WallSign.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Sign -->
  <!-- start interface org.bukkit.block.Skull -->
  <interface name="Skull"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="hasOwner" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if the skull has an owner

 @return true if the skull has an owner]]>
      </doc>
    </method>
    <method name="getOwner" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="See {@link #getOwningPlayer()}.">
      <doc>
      <![CDATA[Gets the owner of the skull, if one exists

 @return the owner of the skull or null if the skull does not have an owner
 @deprecated See {@link #getOwningPlayer()}.]]>
      </doc>
    </method>
    <method name="setOwner" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link #setOwningPlayer(org.bukkit.OfflinePlayer)}.">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the owner of the skull
 <p>
 Involves a potentially blocking web request to acquire the profile data for
 the provided name.

 @param name the new owner of the skull
 @return true if the owner was successfully set
 @deprecated see {@link #setOwningPlayer(org.bukkit.OfflinePlayer)}.]]>
      </doc>
    </method>
    <method name="getOwningPlayer" return="org.bukkit.OfflinePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the player which owns the skull. This player may appear as the
 texture depending on skull type.

 @return owning player]]>
      </doc>
    </method>
    <method name="setOwningPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.OfflinePlayer"/>
      <doc>
      <![CDATA[Set the player which owns the skull. This player may appear as the
 texture depending on skull type.

 @param player the owning player]]>
      </doc>
    </method>
    <method name="setPlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profile" type="com.destroystokyo.paper.profile.PlayerProfile"/>
      <doc>
      <![CDATA[Sets this skull to use the supplied Player Profile, which can include textures already prefilled.
 @param profile The profile to set this Skull to use, may not be null]]>
      </doc>
    </method>
    <method name="getPlayerProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the skull has an owner, per {@link #hasOwner()}, return the owners {@link PlayerProfile}
 @return The profile of the owner, if set]]>
      </doc>
    </method>
    <method name="getRotation" return="org.bukkit.block.BlockFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link BlockData}">
      <doc>
      <![CDATA[Gets the rotation of the skull in the world (or facing direction if this
 is a wall mounted skull).

 @return the rotation of the skull
 @deprecated use {@link BlockData}]]>
      </doc>
    </method>
    <method name="setRotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link BlockData}">
      <param name="rotation" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the rotation of the skull in the world (or facing direction if this
 is a wall mounted skull).

 @param rotation the rotation of the skull
 @deprecated use {@link BlockData}]]>
      </doc>
    </method>
    <method name="getSkullType" return="org.bukkit.SkullType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="check {@link Material} instead">
      <doc>
      <![CDATA[Gets the type of skull

 @return the type of skull
 @deprecated check {@link Material} instead]]>
      </doc>
    </method>
    <method name="setSkullType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="check {@link Material} instead">
      <param name="skullType" type="org.bukkit.SkullType"/>
      <doc>
      <![CDATA[Sets the type of skull

 @param skullType the type of skull
 @deprecated check {@link Material} instead]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a captured state of a skull block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Skull -->
  <!-- start interface org.bukkit.block.Smoker -->
  <interface name="Smoker"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.Furnace"/>
    <doc>
    <![CDATA[Represents a captured state of a smoker.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Smoker -->
  <!-- start interface org.bukkit.block.Structure -->
  <interface name="Structure"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.TileState"/>
    <method name="getStructureName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name of this structure.

 @return structure name]]>
      </doc>
    </method>
    <method name="setStructureName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the name of this structure. This is case-sensitive. The name of the
 structure in the {@link UsageMode#SAVE} structure block MUST match the
 name within the {@link UsageMode#CORNER} block or the size calculation
 will fail.

 @param name the case-sensitive name of this structure]]>
      </doc>
    </method>
    <method name="getAuthor" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of who created this structure.

 @return the name of whoever created this structure.]]>
      </doc>
    </method>
    <method name="setAuthor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="author" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the name of whoever created this structure.

 @param author whoever created this structure (not empty)]]>
      </doc>
    </method>
    <method name="setAuthor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="livingEntity" type="org.bukkit.entity.LivingEntity"/>
      <doc>
      <![CDATA[Set the name of whoever created this structure using a
 {@link LivingEntity}.

 @param livingEntity the entity who created this structure]]>
      </doc>
    </method>
    <method name="getRelativePosition" return="org.bukkit.util.BlockVector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The relative position of the structure outline based on the position of
 the structure block. Maximum allowed distance is 48 blocks in any
 direction.

 @return a Location which contains the relative distance this structure is
 from the structure block.]]>
      </doc>
    </method>
    <method name="setRelativePosition"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vector" type="org.bukkit.util.BlockVector"/>
      <doc>
      <![CDATA[Set the relative position from the structure block. Maximum allowed
 distance is 48 blocks in any direction.

 @param vector the {@link BlockVector} containing the relative origin
 coordinates of this structure.]]>
      </doc>
    </method>
    <method name="getStructureSize" return="org.bukkit.util.BlockVector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The distance to the opposite corner of this structure. The maximum
 structure size is 48x48x48. When a structure has successfully been
 calculated (i.e. it is within the maximum allowed distance) a white
 border surrounds the structure.

 @return a {@link BlockVector} which contains the total size of the
 structure.]]>
      </doc>
    </method>
    <method name="setStructureSize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vector" type="org.bukkit.util.BlockVector"/>
      <doc>
      <![CDATA[Set the maximum size of this structure from the origin point. Maximum
 allowed size is 48x48x48.

 @param vector the {@link BlockVector} containing the size of this
 structure, based off of the origin coordinates.]]>
      </doc>
    </method>
    <method name="setMirror"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mirror" type="org.bukkit.block.structure.Mirror"/>
      <doc>
      <![CDATA[Sets the mirroring of the structure.

 @param mirror the new mirroring method]]>
      </doc>
    </method>
    <method name="getMirror" return="org.bukkit.block.structure.Mirror"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[How this structure is mirrored.

 @return the current mirroring method]]>
      </doc>
    </method>
    <method name="setRotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rotation" type="org.bukkit.block.structure.StructureRotation"/>
      <doc>
      <![CDATA[Set how this structure is rotated.

 @param rotation the new rotation]]>
      </doc>
    </method>
    <method name="getRotation" return="org.bukkit.block.structure.StructureRotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get how this structure is rotated.

 @return the new rotation]]>
      </doc>
    </method>
    <method name="setUsageMode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="org.bukkit.block.structure.UsageMode"/>
      <doc>
      <![CDATA[Set the {@link UsageMode} of this structure block.

 @param mode the new mode to set.]]>
      </doc>
    </method>
    <method name="getUsageMode" return="org.bukkit.block.structure.UsageMode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link UsageMode} of this structure block.

 @return the mode this block is currently in.]]>
      </doc>
    </method>
    <method name="setIgnoreEntities"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignoreEntities" type="boolean"/>
      <doc>
      <![CDATA[While in {@link UsageMode#SAVE} mode, this will ignore any entities when
 saving the structure.
 <br>
 While in {@link UsageMode#LOAD} mode this will ignore any entities that
 were saved to file.

 @param ignoreEntities the flag to set]]>
      </doc>
    </method>
    <method name="isIgnoreEntities" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if this structure block should ignore entities.

 @return true if the appropriate {@link UsageMode} should ignore entities.]]>
      </doc>
    </method>
    <method name="setShowAir"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="showAir" type="boolean"/>
      <doc>
      <![CDATA[Set if the structure outline should show air blocks.

 @param showAir if the structure block should show air blocks]]>
      </doc>
    </method>
    <method name="isShowAir" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this structure block is currently showing all air blocks

 @return true if the structure block is showing all air blocks]]>
      </doc>
    </method>
    <method name="setBoundingBoxVisible"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="showBoundingBox" type="boolean"/>
      <doc>
      <![CDATA[Set if this structure box should show the bounding box.

 @param showBoundingBox if the structure box should be shown]]>
      </doc>
    </method>
    <method name="isBoundingBoxVisible" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if this structure block is currently showing the bounding box.

 @return true if the bounding box is shown]]>
      </doc>
    </method>
    <method name="setIntegrity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="integrity" type="float"/>
      <doc>
      <![CDATA[Set the integrity of the structure. Integrity must be between 0.0 and 1.0
 Lower integrity values will result in more blocks being removed when
 loading a structure. Integrity and {@link #getSeed()} are used together
 to determine which blocks are randomly removed to mimic "decay."

 @param integrity the integrity of this structure]]>
      </doc>
    </method>
    <method name="getIntegrity" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the integrity of this structure.

 @return the integrity of this structure]]>
      </doc>
    </method>
    <method name="setSeed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="long"/>
      <doc>
      <![CDATA[The seed used to determine which blocks will be removed upon loading.
 {@link #getIntegrity()} and seed are used together to determine which
 blocks are randomly removed to mimic "decay."

 @param seed the seed used to determine how many blocks will be removed]]>
      </doc>
    </method>
    <method name="getSeed" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The seed used to determine how many blocks are removed upon loading of
 this structure.

 @return the seed used]]>
      </doc>
    </method>
    <method name="setMetadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadata" type="java.lang.String"/>
      <doc>
      <![CDATA[Only applicable while in {@link UsageMode#DATA}. Metadata are specific
 functions that can be applied to the structure location. Consult the
 <a href="https://minecraft.gamepedia.com/Structure_Block#Data">Minecraft
 wiki</a> for more information.

 @param metadata the function to perform on the selected location]]>
      </doc>
    </method>
    <method name="getMetadata" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the metadata function this structure block will perform when
 activated. Consult the
 <a href="https://minecraft.gamepedia.com/Structure_Block#Data">Minecraft
 Wiki</a> for more information.

 @return the function that will be performed when this block is activated]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a structure block that can save and load blocks from a file. They
 can only be used by OPs, and are not obtainable in survival.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.Structure -->
  <!-- start interface org.bukkit.block.TileState -->
  <interface name="TileState"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.BlockState"/>
    <implements name="org.bukkit.persistence.PersistentDataHolder"/>
    <method name="getPersistentDataContainer" return="org.bukkit.persistence.PersistentDataContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a custom tag container capable of storing tags on the object.

 Note that the tags stored on this container are all stored under their
 own custom namespace therefore modifying default tags using this
 {@link PersistentDataHolder} is impossible.
 <p>
 This {@link PersistentDataHolder} is only linked to the snapshot instance
 stored by the {@link BlockState}.

 When storing changes on the {@link PersistentDataHolder}, the updated
 content will only be applied to the actual tile entity after one of the
 {@link #update()} methods is called.

 @return the custom tag container]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a block state that also hosts a tile entity at the given location.

 This interface alone is merely a marker that does not provide any data.

 Data about the tile entities is provided by the respective interface for each
 tile entity type.

 After modifying the data provided by a TileState, {@link #update()} needs to
 be called to store the data.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.TileState -->
</package>
<package name="org.bukkit.block.banner">
  <!-- start class org.bukkit.block.banner.Pattern -->
  <class name="Pattern" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <constructor name="Pattern" type="org.bukkit.DyeColor, org.bukkit.block.banner.PatternType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new pattern from the specified color and
 pattern type

 @param color   the pattern color
 @param pattern the pattern type]]>
      </doc>
    </constructor>
    <constructor name="Pattern" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for deserialization.

 @param map the map to deserialize from]]>
      </doc>
    </constructor>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getColor" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the color of the pattern

 @return the color of the pattern]]>
      </doc>
    </method>
    <method name="getPattern" return="org.bukkit.block.banner.PatternType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of pattern

 @return the pattern type]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class org.bukkit.block.banner.Pattern -->
  <!-- start class org.bukkit.block.banner.PatternType -->
  <class name="PatternType" extends="java.lang.Enum&lt;org.bukkit.block.banner.PatternType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.banner.PatternType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.banner.PatternType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getIdentifier" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the identifier used to represent
 this pattern type

 @return the pattern's identifier]]>
      </doc>
    </method>
    <method name="getByIdentifier" return="org.bukkit.block.banner.PatternType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="identifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the pattern type which matches the passed
 identifier or null if no matches are found

 @param identifier the identifier
 @return the matched pattern type or null]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.block.banner.PatternType -->
</package>
<package name="org.bukkit.block.data">
  <!-- start interface org.bukkit.block.data.Ageable -->
  <interface name="Ageable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getAge" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'age' property.

 @return the 'age' value]]>
      </doc>
    </method>
    <method name="setAge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="age" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'age' property.

 @param age the new 'age' value]]>
      </doc>
    </method>
    <method name="getMaximumAge" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'age' property.

 @return the maximum 'age' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['age' represents the different growth stages that a crop-like block can go
 through.
 <br>
 A value of 0 indicates that the crop was freshly planted, whilst a value
 equal to {@link #getMaximumAge()} indicates that the crop is ripe and ready
 to be harvested.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Ageable -->
  <!-- start interface org.bukkit.block.data.AnaloguePowerable -->
  <interface name="AnaloguePowerable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getPower" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'power' property.

 @return the 'power' value]]>
      </doc>
    </method>
    <method name="setPower"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="power" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'power' property.

 @param power the new 'power' value]]>
      </doc>
    </method>
    <method name="getMaximumPower" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'power' property.

 @return the maximum 'power' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['power' represents the redstone power level currently being emitted or
 transmitted via this block.
 <br>
 May not be over 9000 or {@link #getMaximumPower()} (usually 15).]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.AnaloguePowerable -->
  <!-- start interface org.bukkit.block.data.Attachable -->
  <interface name="Attachable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isAttached" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'attached' property.

 @return the 'attached' value]]>
      </doc>
    </method>
    <method name="setAttached"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attached" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'attached' property.

 @param attached the new 'attached' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['attached' denotes whether a tripwire hook or string forms a complete
 tripwire circuit and is ready to trigger.
 <br>
 Updating the property on a tripwire hook will change the texture to indicate
 a connected string, but will not have any effect when used on the tripwire
 string itself. It may however still be used to check whether the string forms
 a circuit.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Attachable -->
  <!-- start interface org.bukkit.block.data.Bisected -->
  <interface name="Bisected"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getHalf" return="org.bukkit.block.data.Bisected.Half"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'half' property.

 @return the 'half' value]]>
      </doc>
    </method>
    <method name="setHalf"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="half" type="org.bukkit.block.data.Bisected.Half"/>
      <doc>
      <![CDATA[Sets the value of the 'half' property.

 @param half the new 'half' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['half' denotes which half of a two block tall material this block is.
 <br>
 In game it may be referred to as either (top, bottom) or (upper, lower).]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Bisected -->
  <!-- start class org.bukkit.block.data.Bisected.Half -->
  <class name="Bisected.Half" extends="java.lang.Enum&lt;org.bukkit.block.data.Bisected.Half&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.Bisected.Half[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.Bisected.Half"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The half of a vertically bisected block.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.Bisected.Half -->
  <!-- start interface org.bukkit.block.data.BlockData -->
  <interface name="BlockData"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Material represented by this block data.

 @return the material]]>
      </doc>
    </method>
    <method name="getAsString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a string, which when passed into a method such as
 {@link Server#createBlockData(java.lang.String)} will unambiguously
 recreate this instance.

 @return serialized data string for this block]]>
      </doc>
    </method>
    <method name="getAsString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hideUnspecified" type="boolean"/>
      <doc>
      <![CDATA[Gets a string, which when passed into a method such as
 {@link Server#createBlockData(java.lang.String)} will recreate this or a
 similar instance where unspecified states (if any) may be optionally
 omitted. If this instance was parsed and states are omitted, this exact
 instance will be creatable when parsed again, else their equality cannot
 be guaranteed.
 <p>
 This method will only take effect for BlockData instances created by
 methods such as {@link Server#createBlockData(String)} or any similar
 method whereby states are optionally defined. If otherwise, the result of
 {@link #getAsString()} will be returned. The following behaviour would be
 expected:
 <pre>{@code
 String dataString = "minecraft:chest[waterlogged=true]"
 BlockData data = Bukkit.createBlockData(dataString);
 dataString.equals(data.getAsString(true)); // This would return true
 dataString.equals(data.getAsString(false)); // This would return false as all states are present
 dataString.equals(data.getAsString()); // This is equivalent to the above, "getAsString(false)"
 }</pre>

 @param hideUnspecified true if unspecified states should be omitted,
 false if they are to be shown as performed by {@link #getAsString()}.

 @return serialized data string for this block]]>
      </doc>
    </method>
    <method name="merge" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Merges all explicitly set states from the given data with this BlockData.
 <br>
 Note that the given data MUST have been created from one of the String
 parse methods, e.g. {@link Server#createBlockData(java.lang.String)} and
 not have been subsequently modified.
 <br>
 Note also that the block types must match identically.

 @param data the data to merge from
 @return a new instance of this blockdata with the merged data]]>
      </doc>
    </method>
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Checks if the specified BlockData matches this block data.
 <br>
 The semantics of this method are such that for manually created or
 modified BlockData it has the same effect as
 {@link Object#equals(java.lang.Object)}, whilst for parsed data (that to
 which {@link #merge(org.bukkit.block.data.BlockData)} applies, it will
 return true when the type and all explicitly set states match.
 <br>
 <b>Note that these semantics mean that a.matches(b) may not be the same
 as b.matches(a)</b>

 @param data the data to match against (normally a parsed constant)
 @return if there is a match]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a copy of this BlockData.

 @return a copy of the block data]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.block.data.BlockData -->
  <!-- start interface org.bukkit.block.data.Directional -->
  <interface name="Directional"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'facing' property.

 @return the 'facing' value]]>
      </doc>
    </method>
    <method name="setFacing"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="facing" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the value of the 'facing' property.

 @param facing the new 'facing' value]]>
      </doc>
    </method>
    <method name="getFaces" return="java.util.Set&lt;org.bukkit.block.BlockFace&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the faces which are applicable to this block.

 @return the allowed 'facing' values]]>
      </doc>
    </method>
    <doc>
    <![CDATA['facing' represents the face towards which the block is pointing.
 <br>
 Some blocks may not be able to face in all directions, use
 {@link #getFaces()} to get all possible directions for this block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Directional -->
  <!-- start interface org.bukkit.block.data.FaceAttachable -->
  <interface name="FaceAttachable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getAttachedFace" return="org.bukkit.block.data.FaceAttachable.AttachedFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'face' property.

 @return the 'face' value]]>
      </doc>
    </method>
    <method name="setAttachedFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.data.FaceAttachable.AttachedFace"/>
      <doc>
      <![CDATA[Sets the value of the 'face' property.

 @param face the new 'face' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['face' represents the face to which a lever or button is stuck.
 <br>
 This is used in conjunction with {@link Directional} to compute the
 orientation of these blocks.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.FaceAttachable -->
  <!-- start class org.bukkit.block.data.FaceAttachable.AttachedFace -->
  <class name="FaceAttachable.AttachedFace" extends="java.lang.Enum&lt;org.bukkit.block.data.FaceAttachable.AttachedFace&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.FaceAttachable.AttachedFace[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.FaceAttachable.AttachedFace"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The face to which a switch type block is stuck.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.FaceAttachable.AttachedFace -->
  <!-- start interface org.bukkit.block.data.Levelled -->
  <interface name="Levelled"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'level' property.

 @return the 'level' value]]>
      </doc>
    </method>
    <method name="setLevel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'level' property.

 @param level the new 'level' value]]>
      </doc>
    </method>
    <method name="getMaximumLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'level' property.

 @return the maximum 'level' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['level' represents the amount of fluid contained within this block, either by
 itself or inside a cauldron.
 <br>
 In the case of water and lava blocks the levels have special meanings: a
 level of 0 corresponds to a source block, 1-7 regular fluid heights, and 8-15
 to "falling" fluids. All falling fluids have the same behaviour, but the
 level corresponds to that of the block above them, equal to
 <code>this.level - 8</code>
 <b>Note that counterintuitively, an adjusted level of 1 is the highest level,
 whilst 7 is the lowest.</b>
 <br>
 May not be higher than {@link #getMaximumLevel()}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Levelled -->
  <!-- start interface org.bukkit.block.data.Lightable -->
  <interface name="Lightable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isLit" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'lit' property.

 @return the 'lit' value]]>
      </doc>
    </method>
    <method name="setLit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lit" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'lit' property.

 @param lit the new 'lit' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['lit' denotes whether this block (either a redstone torch or furnace) is
 currently lit - that is not burned out.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Lightable -->
  <!-- start interface org.bukkit.block.data.MultipleFacing -->
  <interface name="MultipleFacing"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="hasFace" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Checks if this block has the specified face enabled.

 @param face to check
 @return if face is enabled]]>
      </doc>
    </method>
    <method name="setFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <param name="has" type="boolean"/>
      <doc>
      <![CDATA[Set whether this block has the specified face enabled.

 @param face to set
 @param has the face]]>
      </doc>
    </method>
    <method name="getFaces" return="java.util.Set&lt;org.bukkit.block.BlockFace&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all of the faces which are enabled on this block.

 @return all faces enabled]]>
      </doc>
    </method>
    <method name="getAllowedFaces" return="java.util.Set&lt;org.bukkit.block.BlockFace&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all of this faces which may be set on this block.

 @return all allowed faces]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class encompasses the 'north', 'east', 'south', 'west', 'up', 'down'
 boolean flags which are used to set which faces of the block textures are
 displayed on.
 <br>
 Some blocks may not be able to have faces on all directions, use
 {@link #getAllowedFaces()} to get all possible faces for this block. It is
 not valid to call any methods on non-allowed faces.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.MultipleFacing -->
  <!-- start interface org.bukkit.block.data.Openable -->
  <interface name="Openable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isOpen" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'open' property.

 @return the 'open' value]]>
      </doc>
    </method>
    <method name="setOpen"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="open" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'open' property.

 @param open the new 'open' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['open' denotes whether this door-like block is currently opened.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Openable -->
  <!-- start interface org.bukkit.block.data.Orientable -->
  <interface name="Orientable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getAxis" return="org.bukkit.Axis"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'axis' property.

 @return the 'axis' value]]>
      </doc>
    </method>
    <method name="setAxis"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="axis" type="org.bukkit.Axis"/>
      <doc>
      <![CDATA[Sets the value of the 'axis' property.

 @param axis the new 'axis' value]]>
      </doc>
    </method>
    <method name="getAxes" return="java.util.Set&lt;org.bukkit.Axis&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the axes which are applicable to this block.

 @return the allowed 'axis' values]]>
      </doc>
    </method>
    <doc>
    <![CDATA['axis' represents the axis along whilst this block is oriented.
 <br>
 Some blocks such as the portal block may not be able to be placed in all
 orientations, use {@link #getAxes()} to retrieve all possible such
 orientations.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Orientable -->
  <!-- start interface org.bukkit.block.data.Powerable -->
  <interface name="Powerable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isPowered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'powered' property.

 @return the 'powered' value]]>
      </doc>
    </method>
    <method name="setPowered"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="powered" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'powered' property.

 @param powered the new 'powered' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['powered' indicates whether this block is in the powered state or not, i.e.
 receiving a redstone current of power &gt; 0.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Powerable -->
  <!-- start interface org.bukkit.block.data.Rail -->
  <interface name="Rail"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getShape" return="org.bukkit.block.data.Rail.Shape"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'shape' property.

 @return the 'shape' value]]>
      </doc>
    </method>
    <method name="setShape"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shape" type="org.bukkit.block.data.Rail.Shape"/>
      <doc>
      <![CDATA[Sets the value of the 'shape' property.

 @param shape the new 'shape' value]]>
      </doc>
    </method>
    <method name="getShapes" return="java.util.Set&lt;org.bukkit.block.data.Rail.Shape&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the shapes which are applicable to this block.

 @return the allowed 'shape' values]]>
      </doc>
    </method>
    <doc>
    <![CDATA['shape' represents the current layout of a minecart rail.
 <br>
 Some types of rail may not be able to be laid out in all shapes, use
 {@link #getShapes()} to get those applicable to this block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Rail -->
  <!-- start class org.bukkit.block.data.Rail.Shape -->
  <class name="Rail.Shape" extends="java.lang.Enum&lt;org.bukkit.block.data.Rail.Shape&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.Rail.Shape[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.Rail.Shape"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The different types of shapes a rail block can occupy.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.Rail.Shape -->
  <!-- start interface org.bukkit.block.data.Rotatable -->
  <interface name="Rotatable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getRotation" return="org.bukkit.block.BlockFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'rotation' property.

 @return the 'rotation' value]]>
      </doc>
    </method>
    <method name="setRotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rotation" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the value of the 'rotation' property.

 @param rotation the new 'rotation' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['rotation' represents the current rotation of this block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Rotatable -->
  <!-- start interface org.bukkit.block.data.Snowable -->
  <interface name="Snowable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isSnowy" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'snowy' property.

 @return the 'snowy' value]]>
      </doc>
    </method>
    <method name="setSnowy"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="snowy" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'snowy' property.

 @param snowy the new 'snowy' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['snowy' denotes whether this block has a snow covered side and top texture
 (normally because the block above is snow).]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Snowable -->
  <!-- start interface org.bukkit.block.data.Waterlogged -->
  <interface name="Waterlogged"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isWaterlogged" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'waterlogged' property.

 @return the 'waterlogged' value]]>
      </doc>
    </method>
    <method name="setWaterlogged"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="waterlogged" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'waterlogged' property.

 @param waterlogged the new 'waterlogged' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['waterlogged' denotes whether this block has fluid in it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.Waterlogged -->
</package>
<package name="org.bukkit.block.data.type">
  <!-- start interface org.bukkit.block.data.type.Bamboo -->
  <interface name="Bamboo"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Ageable"/>
    <implements name="org.bukkit.block.data.type.Sapling"/>
    <method name="getLeaves" return="org.bukkit.block.data.type.Bamboo.Leaves"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'leaves' property.

 @return the 'leaves' value]]>
      </doc>
    </method>
    <method name="setLeaves"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leaves" type="org.bukkit.block.data.type.Bamboo.Leaves"/>
      <doc>
      <![CDATA[Sets the value of the 'leaves' property.

 @param leaves the new 'leaves' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['leaves' represents the size of the leaves on this bamboo block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Bamboo -->
  <!-- start class org.bukkit.block.data.type.Bamboo.Leaves -->
  <class name="Bamboo.Leaves" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Bamboo.Leaves&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Bamboo.Leaves[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Bamboo.Leaves"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Bamboo leaf size.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Bamboo.Leaves -->
  <!-- start interface org.bukkit.block.data.type.Bed -->
  <interface name="Bed"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <method name="getPart" return="org.bukkit.block.data.type.Bed.Part"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'part' property.

 @return the 'part' value]]>
      </doc>
    </method>
    <method name="setPart"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="part" type="org.bukkit.block.data.type.Bed.Part"/>
      <doc>
      <![CDATA[Sets the value of the 'part' property.

 @param part the new 'part' value]]>
      </doc>
    </method>
    <method name="isOccupied" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'occupied' property.

 @return the 'occupied' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Similar to {@link Bisected}, 'part' denotes which half of the bed this block
 corresponds to.
 <br>
 'occupied' property is a quick flag to check if a player is currently
 sleeping in this bed block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Bed -->
  <!-- start class org.bukkit.block.data.type.Bed.Part -->
  <class name="Bed.Part" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Bed.Part&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Bed.Part[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Bed.Part"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Horizontal half of a bed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Bed.Part -->
  <!-- start interface org.bukkit.block.data.type.Beehive -->
  <interface name="Beehive"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <method name="getHoneyLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'honey_level' property.

 @return the 'honey_level' value]]>
      </doc>
    </method>
    <method name="setHoneyLevel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="honeyLevel" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'honey_level' property.

 @param honeyLevel the new 'honey_level' value]]>
      </doc>
    </method>
    <method name="getMaximumHoneyLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'honey_level' property.

 @return the maximum 'honey_level' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['honey_level' represents the amount of honey stored in the hive.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Beehive -->
  <!-- start interface org.bukkit.block.data.type.Bell -->
  <interface name="Bell"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="getAttachment" return="org.bukkit.block.data.type.Bell.Attachment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'attachment' property.

 @return the 'attachment' value]]>
      </doc>
    </method>
    <method name="setAttachment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attachment" type="org.bukkit.block.data.type.Bell.Attachment"/>
      <doc>
      <![CDATA[Sets the value of the 'attachment' property.

 @param attachment the new 'attachment' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['attachment' denotes how the bell is attached to its block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Bell -->
  <!-- start class org.bukkit.block.data.type.Bell.Attachment -->
  <class name="Bell.Attachment" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Bell.Attachment&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Bell.Attachment[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Bell.Attachment"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[What the bell is attached to.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Bell.Attachment -->
  <!-- start interface org.bukkit.block.data.type.BrewingStand -->
  <interface name="BrewingStand"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="hasBottle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bottle" type="int"/>
      <doc>
      <![CDATA[Checks if the stand has the following bottle

 @param bottle to check
 @return if bottle is present]]>
      </doc>
    </method>
    <method name="setBottle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bottle" type="int"/>
      <param name="has" type="boolean"/>
      <doc>
      <![CDATA[Set whether the stand has this bottle present.

 @param bottle to set
 @param has bottle]]>
      </doc>
    </method>
    <method name="getBottles" return="java.util.Set&lt;java.lang.Integer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the indexes of all the bottles present on this block.

 @return set of all bottles]]>
      </doc>
    </method>
    <method name="getMaximumBottles" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum amount of bottles present on this stand.

 @return maximum bottle count]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the 'has_bottle_0', 'has_bottle_1', 'has_bottle_2' flags on a
 brewing stand which indicate which bottles are rendered on the outside.
 <br>
 Stand may have 0, 1... {@link #getMaximumBottles()}-1 bottles.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.BrewingStand -->
  <!-- start interface org.bukkit.block.data.type.BubbleColumn -->
  <interface name="BubbleColumn"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isDrag" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'drag' property.

 @return the 'part' value]]>
      </doc>
    </method>
    <method name="setDrag"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="drag" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'drag' property.

 @param drag the new 'drag' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['drag' indicates whether a force will be applied on entities moving through
 this block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.BubbleColumn -->
  <!-- start interface org.bukkit.block.data.type.Cake -->
  <interface name="Cake"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getBites" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'bites' property.

 @return the 'bites' value]]>
      </doc>
    </method>
    <method name="setBites"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bites" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'bites' property.

 @param bites the new 'bites' value]]>
      </doc>
    </method>
    <method name="getMaximumBites" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'bites' property.

 @return the maximum 'bites' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['bites' represents the amount of bites which have been taken from this slice
 of cake.
 <br>
 A value of 0 indicates that the cake has not been eaten, whilst a value of
 {@link #getMaximumBites()} indicates that it is all gone :(]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Cake -->
  <!-- start interface org.bukkit.block.data.type.Campfire -->
  <interface name="Campfire"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Lightable"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
    <method name="isSignalFire" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'signal_fire' property.

 @return the 'signal_fire' value]]>
      </doc>
    </method>
    <method name="setSignalFire"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signalFire" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'signal_fire' property.

 @param signalFire the new 'signal_fire' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['signal_fire' denotes whether the fire is extra smokey due to having a hay
 bale placed beneath it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Campfire -->
  <!-- start interface org.bukkit.block.data.type.Chain -->
  <interface name="Chain"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Orientable"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Chain -->
  <!-- start interface org.bukkit.block.data.type.Chest -->
  <interface name="Chest"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
    <method name="getType" return="org.bukkit.block.data.type.Chest.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'type' property.

 @return the 'type' value]]>
      </doc>
    </method>
    <method name="setType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.block.data.type.Chest.Type"/>
      <doc>
      <![CDATA[Sets the value of the 'type' property.

 @param type the new 'type' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['type' represents which part of a double chest this block is, or if it is a
 single chest.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Chest -->
  <!-- start class org.bukkit.block.data.type.Chest.Type -->
  <class name="Chest.Type" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Chest.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Chest.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Chest.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Type of this chest block.
 <br>
 NB: Left and right are relative to the chest itself, i.e opposite to what
 a player placing the appropriate block would see.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Chest.Type -->
  <!-- start interface org.bukkit.block.data.type.Cocoa -->
  <interface name="Cocoa"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Ageable"/>
    <implements name="org.bukkit.block.data.Directional"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Cocoa -->
  <!-- start interface org.bukkit.block.data.type.CommandBlock -->
  <interface name="CommandBlock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <method name="isConditional" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'conditional' property.

 @return the 'conditional' value]]>
      </doc>
    </method>
    <method name="setConditional"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conditional" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'conditional' property.

 @param conditional the new 'conditional' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['conditional' denotes whether this command block is conditional or not, i.e.
 will only execute if the preceeding command block also executed successfully.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.CommandBlock -->
  <!-- start interface org.bukkit.block.data.type.Comparator -->
  <interface name="Comparator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="getMode" return="org.bukkit.block.data.type.Comparator.Mode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'mode' property.

 @return the 'mode' value]]>
      </doc>
    </method>
    <method name="setMode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="org.bukkit.block.data.type.Comparator.Mode"/>
      <doc>
      <![CDATA[Sets the value of the 'mode' property.

 @param mode the new 'mode' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['mode' indicates what mode this comparator will operate in.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Comparator -->
  <!-- start class org.bukkit.block.data.type.Comparator.Mode -->
  <class name="Comparator.Mode" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Comparator.Mode&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Comparator.Mode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Comparator.Mode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The mode in which a comparator will operate in.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Comparator.Mode -->
  <!-- start interface org.bukkit.block.data.type.CoralWallFan -->
  <interface name="CoralWallFan"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.CoralWallFan -->
  <!-- start interface org.bukkit.block.data.type.DaylightDetector -->
  <interface name="DaylightDetector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.AnaloguePowerable"/>
    <method name="isInverted" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'inverted' property.

 @return the 'inverted' value]]>
      </doc>
    </method>
    <method name="setInverted"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inverted" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'inverted' property.

 @param inverted the new 'inverted' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['inverted' denotes whether this daylight detector is in the inverted mode,
 i.e. activates in the absence of light rather than presence."]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.DaylightDetector -->
  <!-- start interface org.bukkit.block.data.type.Dispenser -->
  <interface name="Dispenser"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <method name="isTriggered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'triggered' property.

 @return the 'triggered' value]]>
      </doc>
    </method>
    <method name="setTriggered"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="triggered" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'triggered' property.

 @param triggered the new 'triggered' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Similar to {@link Powerable}, 'triggered' indicates whether or not the
 dispenser is currently activated.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Dispenser -->
  <!-- start interface org.bukkit.block.data.type.Door -->
  <interface name="Door"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Bisected"/>
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Openable"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="getHinge" return="org.bukkit.block.data.type.Door.Hinge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'hinge' property.

 @return the 'hinge' value]]>
      </doc>
    </method>
    <method name="setHinge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hinge" type="org.bukkit.block.data.type.Door.Hinge"/>
      <doc>
      <![CDATA[Sets the value of the 'hinge' property.

 @param hinge the new 'hinge' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['hinge' indicates which hinge this door is attached to and will rotate around
 when opened.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Door -->
  <!-- start class org.bukkit.block.data.type.Door.Hinge -->
  <class name="Door.Hinge" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Door.Hinge&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Door.Hinge[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Door.Hinge"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The hinge of a door.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Door.Hinge -->
  <!-- start interface org.bukkit.block.data.type.EnderChest -->
  <interface name="EnderChest"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.EnderChest -->
  <!-- start interface org.bukkit.block.data.type.EndPortalFrame -->
  <interface name="EndPortalFrame"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <method name="hasEye" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'eye' property.

 @return the 'eye' value]]>
      </doc>
    </method>
    <method name="setEye"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eye" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'eye' property.

 @param eye the new 'eye' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['eye' denotes whether this end portal frame has been activated by having an
 eye of ender placed in it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.EndPortalFrame -->
  <!-- start interface org.bukkit.block.data.type.Farmland -->
  <interface name="Farmland"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getMoisture" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'moisture' property.

 @return the 'moisture' value]]>
      </doc>
    </method>
    <method name="setMoisture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="moisture" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'moisture' property.

 @param moisture the new 'moisture' value]]>
      </doc>
    </method>
    <method name="getMaximumMoisture" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'moisture' property.

 @return the maximum 'moisture' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The 'moisture' level of farmland indicates how close it is to a water source
 (if any).
 <br>
 A higher moisture level leads, to faster growth of crops on this block, but
 cannot be higher than {@link #getMaximumMoisture()}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Farmland -->
  <!-- start interface org.bukkit.block.data.type.Fence -->
  <interface name="Fence"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.MultipleFacing"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Fence -->
  <!-- start interface org.bukkit.block.data.type.Fire -->
  <interface name="Fire"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Ageable"/>
    <implements name="org.bukkit.block.data.MultipleFacing"/>
    <doc>
    <![CDATA[md_5's mixtape.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Fire -->
  <!-- start interface org.bukkit.block.data.type.Furnace -->
  <interface name="Furnace"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Lightable"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Furnace -->
  <!-- start interface org.bukkit.block.data.type.Gate -->
  <interface name="Gate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Openable"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="isInWall" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'in_wall' property.

 @return the 'in_wall' value]]>
      </doc>
    </method>
    <method name="setInWall"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inWall" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'in_wall' property.

 @param inWall the new 'in_wall' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['in_wall" indicates if the fence gate is attached to a wall, and if true the
 texture is lowered by a small amount to blend in better.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Gate -->
  <!-- start interface org.bukkit.block.data.type.GlassPane -->
  <interface name="GlassPane"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.MultipleFacing"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.GlassPane -->
  <!-- start interface org.bukkit.block.data.type.Grindstone -->
  <interface name="Grindstone"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.FaceAttachable"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Grindstone -->
  <!-- start interface org.bukkit.block.data.type.Hopper -->
  <interface name="Hopper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <method name="isEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'enabled' property.

 @return the 'enabled' value]]>
      </doc>
    </method>
    <method name="setEnabled"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'enabled' property.

 @param enabled the new 'enabled' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Similar to {@link Powerable}, 'enabled' indicates whether or not the hopper
 is currently activated.
 <br>
 Unlike most other blocks, a hopper is only enabled when it is <b>not</b>
 receiving any power.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Hopper -->
  <!-- start interface org.bukkit.block.data.type.Jigsaw -->
  <interface name="Jigsaw"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getOrientation" return="org.bukkit.block.data.type.Jigsaw.Orientation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'orientation' property.

 @return the 'orientation' value]]>
      </doc>
    </method>
    <method name="setOrientation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="orientation" type="org.bukkit.block.data.type.Jigsaw.Orientation"/>
      <doc>
      <![CDATA[Sets the value of the 'orientation' property.

 @param orientation the new 'orientation' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['orientation' is the direction the block is facing.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Jigsaw -->
  <!-- start class org.bukkit.block.data.type.Jigsaw.Orientation -->
  <class name="Jigsaw.Orientation" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Jigsaw.Orientation&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Jigsaw.Orientation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Jigsaw.Orientation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The directions the Jigsaw can be oriented.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Jigsaw.Orientation -->
  <!-- start interface org.bukkit.block.data.type.Jukebox -->
  <interface name="Jukebox"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="hasRecord" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'has_record' property.

 @return the 'has_record' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['has_record' is a quick flag to check whether this jukebox has a record
 inside it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Jukebox -->
  <!-- start interface org.bukkit.block.data.type.Ladder -->
  <interface name="Ladder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Ladder -->
  <!-- start interface org.bukkit.block.data.type.Lantern -->
  <interface name="Lantern"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Waterlogged"/>
    <method name="isHanging" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'hanging' property.

 @return the 'hanging' value]]>
      </doc>
    </method>
    <method name="setHanging"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hanging" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'hanging' property.

 @param hanging the new 'hanging' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['hanging' denotes whether the lantern is hanging from a block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Lantern -->
  <!-- start interface org.bukkit.block.data.type.Leaves -->
  <interface name="Leaves"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isPersistent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'persistent' property.

 @return the persistent value]]>
      </doc>
    </method>
    <method name="setPersistent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="persistent" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'persistent' property.

 @param persistent the new 'persistent' value]]>
      </doc>
    </method>
    <method name="getDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'distance' property.

 @return the 'distance' value]]>
      </doc>
    </method>
    <method name="setDistance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'distance' property.

 @param distance the new 'distance' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['persistent' indicates whether or not leaves will be checked by the server to
 see if they are subject to decay or not.
 <br>
 'distance' denotes how far the block is from a tree and is used in
 conjunction with 'persistent' flag to determine if the leaves will decay or
 not.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Leaves -->
  <!-- start interface org.bukkit.block.data.type.Lectern -->
  <interface name="Lectern"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="hasBook" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'has_book' property.

 @return the 'has_book' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['has_book' is a quick flag to check whether this lectern has a book inside
 it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Lectern -->
  <!-- start interface org.bukkit.block.data.type.NoteBlock -->
  <interface name="NoteBlock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="getInstrument" return="org.bukkit.Instrument"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'instrument' property.

 @return the 'instrument' value]]>
      </doc>
    </method>
    <method name="setInstrument"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instrument" type="org.bukkit.Instrument"/>
      <doc>
      <![CDATA[Sets the value of the 'instrument' property.

 @param instrument the new 'instrument' value]]>
      </doc>
    </method>
    <method name="getNote" return="org.bukkit.Note"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'note' property.

 @return the 'note' value]]>
      </doc>
    </method>
    <method name="setNote"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="note" type="org.bukkit.Note"/>
      <doc>
      <![CDATA[Sets the value of the 'note' property.

 @param note the new 'note' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['instrument' is the type of sound made when this note block is activated.
 <br>
 'note' is the specified tuned pitch that the instrument will be played in.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.NoteBlock -->
  <!-- start interface org.bukkit.block.data.type.Observer -->
  <interface name="Observer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Powerable"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Observer -->
  <!-- start interface org.bukkit.block.data.type.Piston -->
  <interface name="Piston"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <method name="isExtended" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'extended' property.

 @return the 'extended' value]]>
      </doc>
    </method>
    <method name="setExtended"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extended" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'extended' property.

 @param extended the new 'extended' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['extended' denotes whether the piston head is currently extended or not.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Piston -->
  <!-- start interface org.bukkit.block.data.type.PistonHead -->
  <interface name="PistonHead"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.type.TechnicalPiston"/>
    <method name="isShort" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'short' property.

 @return the 'short' value]]>
      </doc>
    </method>
    <method name="setShort"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="_short" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'short' property.

 @param _short the new 'short' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['short' denotes this piston head is shorter than the usual amount because it
 is currently retracting.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.PistonHead -->
  <!-- start interface org.bukkit.block.data.type.RedstoneRail -->
  <interface name="RedstoneRail"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Powerable"/>
    <implements name="org.bukkit.block.data.Rail"/>
    <doc>
    <![CDATA[A type of minecart rail which interacts with redstone in one way or another.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.RedstoneRail -->
  <!-- start interface org.bukkit.block.data.type.RedstoneWallTorch -->
  <interface name="RedstoneWallTorch"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Lightable"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.RedstoneWallTorch -->
  <!-- start interface org.bukkit.block.data.type.RedstoneWire -->
  <interface name="RedstoneWire"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.AnaloguePowerable"/>
    <method name="getFace" return="org.bukkit.block.data.type.RedstoneWire.Connection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Checks the type of connection on the specified face.

 @param face to check
 @return connection type]]>
      </doc>
    </method>
    <method name="setFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <param name="connection" type="org.bukkit.block.data.type.RedstoneWire.Connection"/>
      <doc>
      <![CDATA[Sets the type of connection on the specified face.

 @param face to set
 @param connection the connection type]]>
      </doc>
    </method>
    <method name="getAllowedFaces" return="java.util.Set&lt;org.bukkit.block.BlockFace&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all of this faces which may be set on this block.

 @return all allowed faces]]>
      </doc>
    </method>
    <doc>
    <![CDATA['north', 'east', 'south', 'west' represent the types of connections this
 redstone wire has to adjacent blocks.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.RedstoneWire -->
  <!-- start class org.bukkit.block.data.type.RedstoneWire.Connection -->
  <class name="RedstoneWire.Connection" extends="java.lang.Enum&lt;org.bukkit.block.data.type.RedstoneWire.Connection&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.RedstoneWire.Connection[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.RedstoneWire.Connection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The way in which a redstone wire can connect to an adjacent block face.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.RedstoneWire.Connection -->
  <!-- start interface org.bukkit.block.data.type.Repeater -->
  <interface name="Repeater"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="getDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'delay' property.

 @return the 'delay' value]]>
      </doc>
    </method>
    <method name="setDelay"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'delay' property.

 @param delay the new 'delay' value]]>
      </doc>
    </method>
    <method name="getMinimumDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum allowed value of the 'delay' property.

 @return the minimum 'delay' value]]>
      </doc>
    </method>
    <method name="getMaximumDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'delay' property.

 @return the maximum 'delay' value]]>
      </doc>
    </method>
    <method name="isLocked" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'locked' property.

 @return the 'locked' value]]>
      </doc>
    </method>
    <method name="setLocked"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="locked" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'locked' property.

 @param locked the new 'locked' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['delay' is the propagation delay of a repeater, i.e. how many ticks before it
 will be activated from a current change and propagate it to the next block.
 <br>
 Delay may not be lower than {@link #getMinimumDelay()} or higher than
 {@link #getMaximumDelay()}.
 <br>
 'locked' denotes whether the repeater is in the locked state or not.
 <br>
 A locked repeater will not change its output until it is unlocked. In game, a
 locked repeater is created by having a constant current perpendicularly
 entering the block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Repeater -->
  <!-- start interface org.bukkit.block.data.type.RespawnAnchor -->
  <interface name="RespawnAnchor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getCharges" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'charges' property.

 @return the 'charges' value]]>
      </doc>
    </method>
    <method name="setCharges"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charges" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'charges' property.

 @param charges the new 'charges' value]]>
      </doc>
    </method>
    <method name="getMaximumCharges" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'charges' property.

 @return the maximum 'charges' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['charges' represents the amount of times the anchor may still be used.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.RespawnAnchor -->
  <!-- start interface org.bukkit.block.data.type.Sapling -->
  <interface name="Sapling"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getStage" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'stage' property.

 @return the 'stage' value]]>
      </doc>
    </method>
    <method name="setStage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'stage' property.

 @param stage the new 'stage' value]]>
      </doc>
    </method>
    <method name="getMaximumStage" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'stage' property.

 @return the maximum 'stage' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['stage' represents the growth stage of a sapling.
 <br>
 When the sapling reaches {@link #getMaximumStage()} it will attempt to grow
 into a tree as the next stage.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Sapling -->
  <!-- start interface org.bukkit.block.data.type.Scaffolding -->
  <interface name="Scaffolding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Waterlogged"/>
    <method name="isBottom" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'bottom' property.

 @return the 'bottom' value]]>
      </doc>
    </method>
    <method name="setBottom"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bottom" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'bottom' property.

 @param bottom the new 'bottom' value]]>
      </doc>
    </method>
    <method name="getDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'distance' property.

 @return the 'distance' value]]>
      </doc>
    </method>
    <method name="setDistance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'distance' property.

 @param distance the new 'distance' value]]>
      </doc>
    </method>
    <method name="getMaximumDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'distance' property.

 @return the maximum 'distance' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['bottom' indicates whether the scaffolding is floating or not.
 <br>
 'distance' indicates the distance from a scaffolding block placed above a
 'bottom' scaffold.
 <br>
 When 'distance' reaches {@link #getMaximumDistance()} the block will drop.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Scaffolding -->
  <!-- start interface org.bukkit.block.data.type.SeaPickle -->
  <interface name="SeaPickle"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Waterlogged"/>
    <method name="getPickles" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'pickles' property.

 @return the 'pickles' value]]>
      </doc>
    </method>
    <method name="setPickles"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pickles" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'pickles' property.

 @param pickles the new 'pickles' value]]>
      </doc>
    </method>
    <method name="getMinimumPickles" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum allowed value of the 'pickles' property.

 @return the minimum 'pickles' value]]>
      </doc>
    </method>
    <method name="getMaximumPickles" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'pickles' property.

 @return the maximum 'pickles' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['pickles' indicates the number of pickles in this block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.SeaPickle -->
  <!-- start interface org.bukkit.block.data.type.Sign -->
  <interface name="Sign"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Rotatable"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Sign -->
  <!-- start interface org.bukkit.block.data.type.Slab -->
  <interface name="Slab"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Waterlogged"/>
    <method name="getType" return="org.bukkit.block.data.type.Slab.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'type' property.

 @return the 'type' value]]>
      </doc>
    </method>
    <method name="setType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.block.data.type.Slab.Type"/>
      <doc>
      <![CDATA[Sets the value of the 'type' property.

 @param type the new 'type' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['type' represents what state the slab is in - either top, bottom, or a double
 slab occupying the full block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Slab -->
  <!-- start class org.bukkit.block.data.type.Slab.Type -->
  <class name="Slab.Type" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Slab.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Slab.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Slab.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The type of the slab.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Slab.Type -->
  <!-- start interface org.bukkit.block.data.type.Snow -->
  <interface name="Snow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getLayers" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'layers' property.

 @return the 'layers' value]]>
      </doc>
    </method>
    <method name="setLayers"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="layers" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'layers' property.

 @param layers the new 'layers' value]]>
      </doc>
    </method>
    <method name="getMinimumLayers" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum allowed value of the 'layers' property.

 @return the minimum 'layers' value]]>
      </doc>
    </method>
    <method name="getMaximumLayers" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'layers' property.

 @return the maximum 'layers' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['layers' represents the amount of layers of snow which are present in this
 block.
 <br>
 May not be lower than {@link #getMinimumLayers()} or higher than
 {@link #getMaximumLayers()}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Snow -->
  <!-- start interface org.bukkit.block.data.type.Stairs -->
  <interface name="Stairs"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Bisected"/>
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
    <method name="getShape" return="org.bukkit.block.data.type.Stairs.Shape"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'shape' property.

 @return the 'shape' value]]>
      </doc>
    </method>
    <method name="setShape"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shape" type="org.bukkit.block.data.type.Stairs.Shape"/>
      <doc>
      <![CDATA[Sets the value of the 'shape' property.

 @param shape the new 'shape' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['shape' represents the texture and bounding box shape of these stairs.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Stairs -->
  <!-- start class org.bukkit.block.data.type.Stairs.Shape -->
  <class name="Stairs.Shape" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Stairs.Shape&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Stairs.Shape[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Stairs.Shape"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The shape of a stair block - used for constructing corners.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Stairs.Shape -->
  <!-- start interface org.bukkit.block.data.type.StructureBlock -->
  <interface name="StructureBlock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getMode" return="org.bukkit.block.data.type.StructureBlock.Mode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'mode' property.

 @return the 'mode' value]]>
      </doc>
    </method>
    <method name="setMode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="org.bukkit.block.data.type.StructureBlock.Mode"/>
      <doc>
      <![CDATA[Sets the value of the 'mode' property.

 @param mode the new 'mode' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['mode' represents the different modes in which this structure block may
 operate.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.StructureBlock -->
  <!-- start class org.bukkit.block.data.type.StructureBlock.Mode -->
  <class name="StructureBlock.Mode" extends="java.lang.Enum&lt;org.bukkit.block.data.type.StructureBlock.Mode&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.StructureBlock.Mode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.StructureBlock.Mode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Operating mode of a structure block.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.StructureBlock.Mode -->
  <!-- start interface org.bukkit.block.data.type.Switch -->
  <interface name="Switch"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.FaceAttachable"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="getFace" return="org.bukkit.block.data.type.Switch.Face"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getAttachedFace()}">
      <doc>
      <![CDATA[Gets the value of the 'face' property.

 @return the 'face' value
 @deprecated use {@link #getAttachedFace()}]]>
      </doc>
    </method>
    <method name="setFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getAttachedFace()}">
      <param name="face" type="org.bukkit.block.data.type.Switch.Face"/>
      <doc>
      <![CDATA[Sets the value of the 'face' property.

 @param face the new 'face' value
 @deprecated use {@link #getAttachedFace()}]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Switch -->
  <!-- start class org.bukkit.block.data.type.Switch.Face -->
  <class name="Switch.Face" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Switch.Face&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="use {@link AttachedFace}">
    <method name="values" return="org.bukkit.block.data.type.Switch.Face[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Switch.Face"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The face to which a switch type block is stuck.

 @deprecated use {@link AttachedFace}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Switch.Face -->
  <!-- start interface org.bukkit.block.data.type.TechnicalPiston -->
  <interface name="TechnicalPiston"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <method name="getType" return="org.bukkit.block.data.type.TechnicalPiston.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'type' property.

 @return the 'type' value]]>
      </doc>
    </method>
    <method name="setType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.block.data.type.TechnicalPiston.Type"/>
      <doc>
      <![CDATA[Sets the value of the 'type' property.

 @param type the new 'type' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['type' represents the type of piston which this (technical) block corresponds
 to.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.TechnicalPiston -->
  <!-- start class org.bukkit.block.data.type.TechnicalPiston.Type -->
  <class name="TechnicalPiston.Type" extends="java.lang.Enum&lt;org.bukkit.block.data.type.TechnicalPiston.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.TechnicalPiston.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.TechnicalPiston.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Different piston variants.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.TechnicalPiston.Type -->
  <!-- start interface org.bukkit.block.data.type.TNT -->
  <interface name="TNT"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="isUnstable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'unstable' property.

 @return the 'unstable' value]]>
      </doc>
    </method>
    <method name="setUnstable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unstable" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'unstable' property.

 @param unstable the new 'unstable' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['unstable' indicates whether this TNT will explode on punching.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.TNT -->
  <!-- start interface org.bukkit.block.data.type.TrapDoor -->
  <interface name="TrapDoor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Bisected"/>
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Openable"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.TrapDoor -->
  <!-- start interface org.bukkit.block.data.type.Tripwire -->
  <interface name="Tripwire"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Attachable"/>
    <implements name="org.bukkit.block.data.MultipleFacing"/>
    <implements name="org.bukkit.block.data.Powerable"/>
    <method name="isDisarmed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'disarmed' property.

 @return the 'disarmed' value]]>
      </doc>
    </method>
    <method name="setDisarmed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="disarmed" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'disarmed' property.

 @param disarmed the new 'disarmed' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['disarmed' denotes that the tripwire was broken with shears and will not
 subsequently produce a current when destroyed.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Tripwire -->
  <!-- start interface org.bukkit.block.data.type.TripwireHook -->
  <interface name="TripwireHook"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Attachable"/>
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Powerable"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.TripwireHook -->
  <!-- start interface org.bukkit.block.data.type.TurtleEgg -->
  <interface name="TurtleEgg"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.BlockData"/>
    <method name="getEggs" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'eggs' property.

 @return the 'eggs' value]]>
      </doc>
    </method>
    <method name="setEggs"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eggs" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'eggs' property.

 @param eggs the new 'eggs' value]]>
      </doc>
    </method>
    <method name="getMinimumEggs" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum allowed value of the 'eggs' property.

 @return the minimum 'eggs' value]]>
      </doc>
    </method>
    <method name="getMaximumEggs" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'eggs' property.

 @return the maximum 'eggs' value]]>
      </doc>
    </method>
    <method name="getHatch" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'hatch' property.

 @return the 'hatch' value]]>
      </doc>
    </method>
    <method name="setHatch"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hatch" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'hatch' property.

 @param hatch the new 'hatch' value]]>
      </doc>
    </method>
    <method name="getMaximumHatch" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum allowed value of the 'hatch' property.

 @return the maximum 'hatch' value]]>
      </doc>
    </method>
    <doc>
    <![CDATA['hatch' is the number of turtles which may hatch from these eggs.
 <br>
 'eggs' is the number of eggs which appear in this block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.TurtleEgg -->
  <!-- start interface org.bukkit.block.data.type.Wall -->
  <interface name="Wall"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Waterlogged"/>
    <method name="isUp" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'up' property.

 @return the 'up' value]]>
      </doc>
    </method>
    <method name="setUp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="up" type="boolean"/>
      <doc>
      <![CDATA[Sets the value of the 'up' property.

 @param up the new 'up' value]]>
      </doc>
    </method>
    <method name="getHeight" return="org.bukkit.block.data.type.Wall.Height"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Gets the height of the specified face.

 @param face to check
 @return if face is enabled]]>
      </doc>
    </method>
    <method name="setHeight"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <param name="height" type="org.bukkit.block.data.type.Wall.Height"/>
      <doc>
      <![CDATA[Set the height of the specified face.

 @param face to set
 @param height the height]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class encompasses the 'north', 'east', 'south', 'west', height flags
 which are used to set the height of a wall.

 'up' denotes whether the well has a center post.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.block.data.type.Wall -->
  <!-- start class org.bukkit.block.data.type.Wall.Height -->
  <class name="Wall.Height" extends="java.lang.Enum&lt;org.bukkit.block.data.type.Wall.Height&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.data.type.Wall.Height[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.data.type.Wall.Height"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The different heights a face of a wall may have.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.data.type.Wall.Height -->
  <!-- start interface org.bukkit.block.data.type.WallSign -->
  <interface name="WallSign"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.block.data.Directional"/>
    <implements name="org.bukkit.block.data.Waterlogged"/>
  </interface>
  <!-- end interface org.bukkit.block.data.type.WallSign -->
</package>
<package name="org.bukkit.block.structure">
  <!-- start class org.bukkit.block.structure.Mirror -->
  <class name="Mirror" extends="java.lang.Enum&lt;org.bukkit.block.structure.Mirror&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.structure.Mirror[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.structure.Mirror"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents how a {@link org.bukkit.block.Structure} can be mirrored upon
 being loaded.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.structure.Mirror -->
  <!-- start class org.bukkit.block.structure.StructureRotation -->
  <class name="StructureRotation" extends="java.lang.Enum&lt;org.bukkit.block.structure.StructureRotation&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.structure.StructureRotation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.structure.StructureRotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents how a {@link org.bukkit.block.Structure} can be rotated.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.structure.StructureRotation -->
  <!-- start class org.bukkit.block.structure.UsageMode -->
  <class name="UsageMode" extends="java.lang.Enum&lt;org.bukkit.block.structure.UsageMode&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.block.structure.UsageMode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.block.structure.UsageMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents how a {@link org.bukkit.block.Structure} can be used.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.block.structure.UsageMode -->
</package>
<package name="org.bukkit.boss">
  <!-- start class org.bukkit.boss.BarColor -->
  <class name="BarColor" extends="java.lang.Enum&lt;org.bukkit.boss.BarColor&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.boss.BarColor[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.boss.BarColor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.boss.BarColor -->
  <!-- start class org.bukkit.boss.BarFlag -->
  <class name="BarFlag" extends="java.lang.Enum&lt;org.bukkit.boss.BarFlag&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.boss.BarFlag[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.boss.BarFlag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.boss.BarFlag -->
  <!-- start class org.bukkit.boss.BarStyle -->
  <class name="BarStyle" extends="java.lang.Enum&lt;org.bukkit.boss.BarStyle&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.boss.BarStyle[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.boss.BarStyle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.boss.BarStyle -->
  <!-- start interface org.bukkit.boss.BossBar -->
  <interface name="BossBar"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTitle" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the title of this boss bar

 @return the title of the bar]]>
      </doc>
    </method>
    <method name="setTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the title of this boss bar

 @param title the title of the bar]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.boss.BarColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the color of this boss bar

 @return the color of the bar]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.boss.BarColor"/>
      <doc>
      <![CDATA[Sets the color of this boss bar.

 @param color the color of the bar]]>
      </doc>
    </method>
    <method name="getStyle" return="org.bukkit.boss.BarStyle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the style of this boss bar

 @return the style of the bar]]>
      </doc>
    </method>
    <method name="setStyle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="style" type="org.bukkit.boss.BarStyle"/>
      <doc>
      <![CDATA[Sets the bar style of this boss bar

 @param style the style of the bar]]>
      </doc>
    </method>
    <method name="removeFlag"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="org.bukkit.boss.BarFlag"/>
      <doc>
      <![CDATA[Remove an existing flag on this boss bar

 @param flag the existing flag to remove]]>
      </doc>
    </method>
    <method name="addFlag"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="org.bukkit.boss.BarFlag"/>
      <doc>
      <![CDATA[Add an optional flag to this boss bar

 @param flag an optional flag to set on the boss bar]]>
      </doc>
    </method>
    <method name="hasFlag" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="org.bukkit.boss.BarFlag"/>
      <doc>
      <![CDATA[Returns whether this boss bar as the passed flag set

 @param flag the flag to check
 @return whether it has the flag]]>
      </doc>
    </method>
    <method name="setProgress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="progress" type="double"/>
      <doc>
      <![CDATA[Sets the progress of the bar. Values should be between 0.0 (empty) and
 1.0 (full)

 @param progress the progress of the bar]]>
      </doc>
    </method>
    <method name="getProgress" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the progress of the bar between 0.0 and 1.0

 @return the progress of the bar]]>
      </doc>
    </method>
    <method name="addPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Adds the player to this boss bar causing it to display on their screen.

 @param player the player to add]]>
      </doc>
    </method>
    <method name="removePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Removes the player from this boss bar causing it to be removed from their
 screen.

 @param player the player to remove]]>
      </doc>
    </method>
    <method name="removeAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all players from this boss bar

 @see #removePlayer(Player)]]>
      </doc>
    </method>
    <method name="getPlayers" return="java.util.List&lt;org.bukkit.entity.Player&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all players viewing this boss bar

 @return a immutable list of players]]>
      </doc>
    </method>
    <method name="setVisible"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visible" type="boolean"/>
      <doc>
      <![CDATA[Set if the boss bar is displayed to attached players.

 @param visible visible status]]>
      </doc>
    </method>
    <method name="isVisible" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return if the boss bar is displayed to attached players.

 @return visible status]]>
      </doc>
    </method>
    <method name="show"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="{@link #setVisible(boolean)}">
      <doc>
      <![CDATA[Shows the previously hidden boss bar to all attached players
 @deprecated {@link #setVisible(boolean)}]]>
      </doc>
    </method>
    <method name="hide"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="{@link #setVisible(boolean)}">
      <doc>
      <![CDATA[Hides this boss bar from all attached players
 @deprecated {@link #setVisible(boolean)}]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.boss.BossBar -->
  <!-- start interface org.bukkit.boss.DragonBattle -->
  <interface name="DragonBattle"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEnderDragon" return="org.bukkit.entity.EnderDragon"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link EnderDragon} active in this battle.

 Will return null if the dragon has been slain.

 @return the ender dragon. null if dead]]>
      </doc>
    </method>
    <method name="getBossBar" return="org.bukkit.boss.BossBar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the boss bar to be displayed for this dragon battle.

 @return the boss bar]]>
      </doc>
    </method>
    <method name="getEndPortalLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the location of the end portal.

 This location will be at the center of the base (bottom) of the portal.

 @return the end portal location or null if not generated]]>
      </doc>
    </method>
    <method name="generateEndPortal" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="withPortals" type="boolean"/>
      <doc>
      <![CDATA[Generate the end portal.

 @param withPortals whether or not end portal blocks should be generated

 @return true if generated, false if already present]]>
      </doc>
    </method>
    <method name="hasBeenPreviouslyKilled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check whether or not the first dragon has been killed already.

 @return true if killed before, false otherwise]]>
      </doc>
    </method>
    <method name="initiateRespawn"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiate a respawn sequence to summon the dragon as though a player has
 placed 4 end crystals on the portal.]]>
      </doc>
    </method>
    <method name="getRespawnPhase" return="org.bukkit.boss.DragonBattle.RespawnPhase"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get this battle's current respawn phase.

 @return the current respawn phase.]]>
      </doc>
    </method>
    <method name="setRespawnPhase" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="phase" type="org.bukkit.boss.DragonBattle.RespawnPhase"/>
      <doc>
      <![CDATA[Set the dragon's respawn phase.

 This method will is unsuccessful if a dragon respawn is not in progress.

 @param phase the phase to set

 @return true if successful, false otherwise

 @see #initiateRespawn()]]>
      </doc>
    </method>
    <method name="resetCrystals"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the crystals located on the obsidian pillars (remove their beam
 targets and invulnerability).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a dragon battle state for a world with an end environment.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.boss.DragonBattle -->
  <!-- start class org.bukkit.boss.DragonBattle.RespawnPhase -->
  <class name="DragonBattle.RespawnPhase" extends="java.lang.Enum&lt;org.bukkit.boss.DragonBattle.RespawnPhase&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.boss.DragonBattle.RespawnPhase[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.boss.DragonBattle.RespawnPhase"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents a phase in the dragon respawn process.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.boss.DragonBattle.RespawnPhase -->
  <!-- start interface org.bukkit.boss.KeyedBossBar -->
  <interface name="KeyedBossBar"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.boss.BossBar"/>
    <implements name="org.bukkit.Keyed"/>
    <doc>
    <![CDATA[Represents a custom {@link BossBar} that has a
 {@link org.bukkit.NamespacedKey}]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.boss.KeyedBossBar -->
</package>
<package name="org.bukkit.command">
  <!-- start interface org.bukkit.command.BlockCommandSender -->
  <interface name="BlockCommandSender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.CommandSender"/>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the block this command sender belongs to

 @return Block for the command sender]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.command.BlockCommandSender -->
  <!-- start class org.bukkit.command.BufferedCommandSender -->
  <class name="BufferedCommandSender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.MessageCommandSender"/>
    <constructor name="BufferedCommandSender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
    </method>
    <method name="getBuffer" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.command.BufferedCommandSender -->
  <!-- start class org.bukkit.command.Command -->
  <class name="Command" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Command" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Command" type="java.lang.String, java.lang.String, java.lang.String, java.util.List&lt;java.lang.String&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getTimingName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="execute" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="commandLabel" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Executes the command, returning its success

 @param sender Source object which is executing this command
 @param commandLabel The alias of the command used
 @param args All arguments passed to the command, split via ' '
 @return true if the command was successful, otherwise false]]>
      </doc>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Executed on tab completion for this command, returning a list of
 options the player can tab through.

 @param sender Source object which is executing this command
 @param alias the alias being used
 @param args All arguments passed to the command, split via ' '
 @return a list of tab-completions for the specified arguments. This
     will never be null. List may be immutable.
 @throws IllegalArgumentException if sender, alias, or args is null]]>
      </doc>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <param name="location" type="org.bukkit.Location"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Executed on tab completion for this command, returning a list of
 options the player can tab through.

 @param sender Source object which is executing this command
 @param alias the alias being used
 @param args All arguments passed to the command, split via ' '
 @param location The position looked at by the sender, or null if none
 @return a list of tab-completions for the specified arguments. This
     will never be null. List may be immutable.
 @throws IllegalArgumentException if sender, alias, or args is null]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this command

 @return Name of this command]]>
      </doc>
    </method>
    <method name="setName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the name of this command.
 <p>
 May only be used before registering the command.
 Will return true if the new name is set, and false
 if the command has already been registered.

 @param name New command name
 @return returns true if the name change happened instantly or false if
     the command was already registered]]>
      </doc>
    </method>
    <method name="getPermission" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the permission required by users to be able to perform this
 command

 @return Permission name, or null if none]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the permission required by users to be able to perform this
 command

 @param permission Permission name or null]]>
      </doc>
    </method>
    <method name="testPermission" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.command.CommandSender"/>
      <doc>
      <![CDATA[Tests the given {@link CommandSender} to see if they can perform this
 command.
 <p>
 If they do not have permission, they will be informed that they cannot
 do this.

 @param target User to test
 @return true if they can use it, otherwise false]]>
      </doc>
    </method>
    <method name="testPermissionSilent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.command.CommandSender"/>
      <doc>
      <![CDATA[Tests the given {@link CommandSender} to see if they can perform this
 command.
 <p>
 No error is sent to the sender.

 @param target User to test
 @return true if they can use it, otherwise false]]>
      </doc>
    </method>
    <method name="getLabel" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the label for this command

 @return Label of this command]]>
      </doc>
    </method>
    <method name="setLabel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the label of this command.
 <p>
 May only be used before registering the command.
 Will return true if the new name is set, and false
 if the command has already been registered.

 @param name The command's name
 @return returns true if the name change happened instantly or false if
     the command was already registered]]>
      </doc>
    </method>
    <method name="register" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="commandMap" type="org.bukkit.command.CommandMap"/>
      <doc>
      <![CDATA[Registers this command to a CommandMap.
 Once called it only allows changes the registered CommandMap

 @param commandMap the CommandMap to register this command to
 @return true if the registration was successful (the current registered
     CommandMap was the passed CommandMap or null) false otherwise]]>
      </doc>
    </method>
    <method name="unregister" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="commandMap" type="org.bukkit.command.CommandMap"/>
      <doc>
      <![CDATA[Unregisters this command from the passed CommandMap applying any
 outstanding changes

 @param commandMap the CommandMap to unregister
 @return true if the unregistration was successful (the current
     registered CommandMap was the passed CommandMap or null) false
     otherwise]]>
      </doc>
    </method>
    <method name="isRegistered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current registered state of this command

 @return true if this command is currently registered false otherwise]]>
      </doc>
    </method>
    <method name="getAliases" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of active aliases of this command

 @return List of aliases]]>
      </doc>
    </method>
    <method name="getPermissionMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a message to be displayed on a failed permission check for this
 command

 @return Permission check failed message]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a brief description of this command

 @return Description of this command]]>
      </doc>
    </method>
    <method name="getUsage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an example usage of this command

 @return One or more example usages]]>
      </doc>
    </method>
    <method name="setAliases" return="org.bukkit.command.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aliases" type="java.util.List&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Sets the list of aliases to request on registration for this command.
 This is not effective outside of defining aliases in the {@link
 PluginDescriptionFile#getCommands()} (under the
 `<code>aliases</code>' node) is equivalent to this method.

 @param aliases aliases to register to this command
 @return this command object, for chaining]]>
      </doc>
    </method>
    <method name="setDescription" return="org.bukkit.command.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="description" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets a brief description of this command. Defining a description in the
 {@link PluginDescriptionFile#getCommands()} (under the
 `<code>description</code>' node) is equivalent to this method.

 @param description new command description
 @return this command object, for chaining]]>
      </doc>
    </method>
    <method name="setPermissionMessage" return="org.bukkit.command.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permissionMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the message sent when a permission check fails

 @param permissionMessage new permission message, null to indicate
     default message, or an empty string to indicate no message
 @return this command object, for chaining]]>
      </doc>
    </method>
    <method name="setUsage" return="org.bukkit.command.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="usage" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the example usage of this command

 @param usage new example usage
 @return this command object, for chaining]]>
      </doc>
    </method>
    <method name="broadcastCommandMessage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.command.CommandSender"/>
      <param name="message" type="java.lang.String"/>
    </method>
    <method name="broadcastCommandMessage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.command.CommandSender"/>
      <param name="message" type="java.lang.String"/>
      <param name="sendToSource" type="boolean"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="description" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="usageMessage" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="timings" type="co.aikar.timings.Timing"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a Command, which executes various tasks upon user input]]>
    </doc>
  </class>
  <!-- end class org.bukkit.command.Command -->
  <!-- start class org.bukkit.command.CommandException -->
  <class name="CommandException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CommandException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of <code>CommandException</code> without detail
 message.]]>
      </doc>
    </constructor>
    <constructor name="CommandException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an instance of <code>CommandException</code> with the
 specified detail message.

 @param msg the detail message.]]>
      </doc>
    </constructor>
    <constructor name="CommandException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown when an unhandled exception occurs during the execution of a Command]]>
    </doc>
  </class>
  <!-- end class org.bukkit.command.CommandException -->
  <!-- start interface org.bukkit.command.CommandExecutor -->
  <interface name="CommandExecutor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onCommand" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <param name="label" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Executes the given command, returning its success.
 <br>
 If false is returned, then the "usage" plugin.yml entry for this command
 (if defined) will be sent to the player.

 @param sender Source of the command
 @param command Command which was executed
 @param label Alias of the command which was used
 @param args Passed command arguments
 @return true if a valid command, otherwise false]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a class which contains a single method for executing commands]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.command.CommandExecutor -->
  <!-- start interface org.bukkit.command.CommandMap -->
  <interface name="CommandMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="registerAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fallbackPrefix" type="java.lang.String"/>
      <param name="commands" type="java.util.List&lt;org.bukkit.command.Command&gt;"/>
      <doc>
      <![CDATA[Registers all the commands belonging to a certain plugin.
 <p>
 Caller can use:-
 <ul>
 <li>command.getName() to determine the label registered for this
     command
 <li>command.getAliases() to determine the aliases which where
     registered
 </ul>

 @param fallbackPrefix a prefix which is prepended to each command with
     a ':' one or more times to make the command unique
 @param commands a list of commands to register]]>
      </doc>
    </method>
    <method name="register" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <param name="fallbackPrefix" type="java.lang.String"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <doc>
      <![CDATA[Registers a command. Returns true on success; false if name is already
 taken and fallback had to be used.
 <p>
 Caller can use:-
 <ul>
 <li>command.getName() to determine the label registered for this
     command
 <li>command.getAliases() to determine the aliases which where
     registered
 </ul>

 @param label the label of the command, without the '/'-prefix.
 @param fallbackPrefix a prefix which is prepended to the command with a
     ':' one or more times to make the command unique
 @param command the command to register
 @return true if command was registered with the passed in label, false
     otherwise, which indicates the fallbackPrefix was used one or more
     times]]>
      </doc>
    </method>
    <method name="register" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fallbackPrefix" type="java.lang.String"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <doc>
      <![CDATA[Registers a command. Returns true on success; false if name is already
 taken and fallback had to be used.
 <p>
 Caller can use:-
 <ul>
 <li>command.getName() to determine the label registered for this
     command
 <li>command.getAliases() to determine the aliases which where
     registered
 </ul>

 @param fallbackPrefix a prefix which is prepended to the command with a
     ':' one or more times to make the command unique
 @param command the command to register, from which label is determined
     from the command name
 @return true if command was registered with the passed in label, false
     otherwise, which indicates the fallbackPrefix was used one or more
     times]]>
      </doc>
    </method>
    <method name="dispatch" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="cmdLine" type="java.lang.String"/>
      <exception name="CommandException" type="org.bukkit.command.CommandException"/>
      <doc>
      <![CDATA[Looks for the requested command and executes it if found.

 @param sender The command's sender
 @param cmdLine command + arguments. Example: "/test abc 123"
 @return returns false if no target is found, true otherwise.
 @throws CommandException Thrown when the executor for the given command
     fails with an unhandled exception]]>
      </doc>
    </method>
    <method name="clearCommands"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all registered commands.]]>
      </doc>
    </method>
    <method name="getCommand" return="org.bukkit.command.Command"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the command registered to the specified name

 @param name Name of the command to retrieve
 @return Command with the specified name or null if a command with that
     label doesn't exist]]>
      </doc>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="cmdLine" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Looks for the requested command and executes an appropriate
 tab-completer if found. This method will also tab-complete partial
 commands.

 @param sender The command's sender.
 @param cmdLine The entire command string to tab-complete, excluding
     initial slash.
 @return a list of possible tab-completions. This list may be immutable.
     Will be null if no matching command of which sender has permission.
 @throws CommandException Thrown when the tab-completer for the given
     command fails with an unhandled exception
 @throws IllegalArgumentException if either sender or cmdLine are null]]>
      </doc>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="cmdLine" type="java.lang.String"/>
      <param name="location" type="org.bukkit.Location"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Looks for the requested command and executes an appropriate
 tab-completer if found. This method will also tab-complete partial
 commands.

 @param sender The command's sender.
 @param cmdLine The entire command string to tab-complete, excluding
     initial slash.
 @param location The position looked at by the sender, or null if none
 @return a list of possible tab-completions. This list may be immutable.
     Will be null if no matching command of which sender has permission.
 @throws CommandException Thrown when the tab-completer for the given
     command fails with an unhandled exception
 @throws IllegalArgumentException if either sender or cmdLine are null]]>
      </doc>
    </method>
    <method name="getKnownCommands" return="java.util.Map&lt;java.lang.String, org.bukkit.command.Command&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a Map of known commands

 @return known commands]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.command.CommandMap -->
  <!-- start interface org.bukkit.command.CommandSender -->
  <interface name="CommandSender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.permissions.Permissible"/>
    <method name="sendMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sends this sender a message

 @param message Message to be displayed]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messages" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Sends this sender multiple messages

 @param messages An array of messages to be displayed]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="java.util.UUID"/>
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sends this sender a message

 @param message Message to be displayed
 @param sender The sender of this message]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="java.util.UUID"/>
      <param name="messages" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Sends this sender multiple messages

 @param messages An array of messages to be displayed
 @param sender The sender of this message]]>
      </doc>
    </method>
    <method name="getServer" return="org.bukkit.Server"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the server instance that this command is running on

 @return Server instance]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of this command sender

 @return Name of the sender]]>
      </doc>
    </method>
    <method name="spigot" return="org.bukkit.command.CommandSender.Spigot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Sends the component to the sender

 <p>If this sender does not support sending full components then
 the component will be sent as legacy text.</p>

 @param component the component to send]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an array of components as a single message to the sender

 <p>If this sender does not support sending full components then
 the components will be sent as legacy text.</p>

 @param components the components to send]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.command.CommandSender -->
  <!-- start class org.bukkit.command.CommandSender.Spigot -->
  <class name="CommandSender.Spigot" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spigot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Sends this sender a chat component.

 @param component the components to send]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an array of components as a single message to the sender.

 @param components the components to send]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.command.CommandSender.Spigot -->
  <!-- start interface org.bukkit.command.ConsoleCommandSender -->
  <interface name="ConsoleCommandSender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.CommandSender"/>
    <implements name="org.bukkit.conversations.Conversable"/>
  </interface>
  <!-- end interface org.bukkit.command.ConsoleCommandSender -->
  <!-- start class org.bukkit.command.FormattedCommandAlias -->
  <class name="FormattedCommandAlias" extends="org.bukkit.command.Command"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FormattedCommandAlias" type="java.lang.String, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="commandLabel" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="getTimingName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.command.FormattedCommandAlias -->
  <!-- start interface org.bukkit.command.MessageCommandSender -->
  <interface name="MessageCommandSender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.CommandSender"/>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messages" type="java.lang.String[]"/>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="java.util.UUID"/>
      <param name="message" type="java.lang.String"/>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="java.util.UUID"/>
      <param name="messages" type="java.lang.String[]"/>
    </method>
    <method name="getServer" return="org.bukkit.Server"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isOp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setOp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
    </method>
    <method name="isPermissionSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="isPermissionSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="hasPermission" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="hasPermission" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <param name="ticks" type="int"/>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="ticks" type="int"/>
    </method>
    <method name="removeAttachment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attachment" type="org.bukkit.permissions.PermissionAttachment"/>
    </method>
    <method name="recalculatePermissions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEffectivePermissions" return="java.util.Set&lt;org.bukkit.permissions.PermissionAttachmentInfo&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="spigot" return="org.bukkit.command.CommandSender.Spigot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[For when all you care about is just messaging]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.command.MessageCommandSender -->
  <!-- start class org.bukkit.command.MultipleCommandAlias -->
  <class name="MultipleCommandAlias" extends="org.bukkit.command.Command"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MultipleCommandAlias" type="java.lang.String, org.bukkit.command.Command[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCommands" return="org.bukkit.command.Command[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the commands associated with the multi-command alias.

 @return commands associated with alias]]>
      </doc>
    </method>
    <method name="execute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="commandLabel" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <doc>
    <![CDATA[Represents a command that delegates to one or more other commands]]>
    </doc>
  </class>
  <!-- end class org.bukkit.command.MultipleCommandAlias -->
  <!-- start class org.bukkit.command.PluginCommand -->
  <class name="PluginCommand" extends="org.bukkit.command.Command"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.PluginIdentifiableCommand"/>
    <constructor name="PluginCommand" type="java.lang.String, org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="commandLabel" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Executes the command, returning its success

 @param sender Source object which is executing this command
 @param commandLabel The alias of the command used
 @param args All arguments passed to the command, split via ' '
 @return true if the command was successful, otherwise false]]>
      </doc>
    </method>
    <method name="setExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="org.bukkit.command.CommandExecutor"/>
      <doc>
      <![CDATA[Sets the {@link CommandExecutor} to run when parsing this command

 @param executor New executor to run]]>
      </doc>
    </method>
    <method name="getExecutor" return="org.bukkit.command.CommandExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link CommandExecutor} associated with this command

 @return CommandExecutor object linked to this command]]>
      </doc>
    </method>
    <method name="setTabCompleter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="completer" type="org.bukkit.command.TabCompleter"/>
      <doc>
      <![CDATA[Sets the {@link TabCompleter} to run when tab-completing this command.
 <p>
 If no TabCompleter is specified, and the command's executor implements
 TabCompleter, then the executor will be used for tab completion.

 @param completer New tab completer]]>
      </doc>
    </method>
    <method name="getTabCompleter" return="org.bukkit.command.TabCompleter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link TabCompleter} associated with this command.

 @return TabCompleter object linked to this command]]>
      </doc>
    </method>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the owner of this PluginCommand

 @return Plugin that owns this command]]>
      </doc>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="CommandException" type="org.bukkit.command.CommandException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p>
 Delegates to the tab completer if present.
 <p>
 If it is not present or returns null, will delegate to the current
 command executor if it implements {@link TabCompleter}. If a non-null
 list has not been found, will default to standard player name
 completion in {@link
 Command#tabComplete(CommandSender, String, String[])}.
 <p>
 This method does not consider permissions.

 @throws CommandException if the completer or executor throw an
     exception during the process of tab-completing.
 @throws IllegalArgumentException if sender, alias, or args is null]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a {@link Command} belonging to a plugin]]>
    </doc>
  </class>
  <!-- end class org.bukkit.command.PluginCommand -->
  <!-- start class org.bukkit.command.PluginCommandYamlParser -->
  <class name="PluginCommandYamlParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginCommandYamlParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parse" return="java.util.List&lt;org.bukkit.command.Command&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
  </class>
  <!-- end class org.bukkit.command.PluginCommandYamlParser -->
  <!-- start interface org.bukkit.command.PluginIdentifiableCommand -->
  <interface name="PluginIdentifiableCommand"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the owner of this PluginIdentifiableCommand.

 @return Plugin that owns this PluginIdentifiableCommand.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface is used by the help system to group commands into
 sub-indexes based on the {@link Plugin} they are a part of. Custom command
 implementations will need to implement this interface to have a sub-index
 automatically generated on the plugin's behalf.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.command.PluginIdentifiableCommand -->
  <!-- start interface org.bukkit.command.ProxiedCommandSender -->
  <interface name="ProxiedCommandSender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.CommandSender"/>
    <method name="getCaller" return="org.bukkit.command.CommandSender"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the CommandSender which triggered this proxied command

 @return the caller which triggered the command]]>
      </doc>
    </method>
    <method name="getCallee" return="org.bukkit.command.CommandSender"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the CommandSender which is being used to call the command

 @return the caller which the command is being run as]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.command.ProxiedCommandSender -->
  <!-- start interface org.bukkit.command.RemoteConsoleCommandSender -->
  <interface name="RemoteConsoleCommandSender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.CommandSender"/>
  </interface>
  <!-- end interface org.bukkit.command.RemoteConsoleCommandSender -->
  <!-- start class org.bukkit.command.SimpleCommandMap -->
  <class name="SimpleCommandMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.CommandMap"/>
    <constructor name="SimpleCommandMap" type="org.bukkit.Server"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setFallbackCommands"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fallbackPrefix" type="java.lang.String"/>
      <param name="commands" type="java.util.List&lt;org.bukkit.command.Command&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="register" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fallbackPrefix" type="java.lang.String"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="register" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <param name="fallbackPrefix" type="java.lang.String"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="dispatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="commandLine" type="java.lang.String"/>
      <exception name="CommandException" type="org.bukkit.command.CommandException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="clearCommands"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCommand" return="org.bukkit.command.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="cmdLine" type="java.lang.String"/>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="cmdLine" type="java.lang.String"/>
      <param name="location" type="org.bukkit.Location"/>
    </method>
    <method name="getCommands" return="java.util.Collection&lt;org.bukkit.command.Command&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerServerAliases"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKnownCommands" return="java.util.Map&lt;java.lang.String, org.bukkit.command.Command&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="knownCommands" type="java.util.Map&lt;java.lang.String, org.bukkit.command.Command&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.bukkit.command.SimpleCommandMap -->
  <!-- start interface org.bukkit.command.TabCompleter -->
  <interface name="TabCompleter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onTabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Requests a list of possible completions for a command argument.

 @param sender Source of the command.  For players tab-completing a
     command inside of a command block, this will be the player, not
     the command block.
 @param command Command which was executed
 @param alias The alias used
 @param args The arguments passed to the command, including final
     partial argument to be completed and command label
 @return A List of possible completions for the final argument, or null
     to default to the command executor]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a class which can suggest tab completions for commands.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.command.TabCompleter -->
  <!-- start interface org.bukkit.command.TabExecutor -->
  <interface name="TabExecutor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.TabCompleter"/>
    <implements name="org.bukkit.command.CommandExecutor"/>
    <doc>
    <![CDATA[This class is provided as a convenience to implement both TabCompleter and
 CommandExecutor.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.command.TabExecutor -->
</package>
<package name="org.bukkit.command.defaults">
  <!-- start class org.bukkit.command.defaults.BukkitCommand -->
  <class name="BukkitCommand" extends="org.bukkit.command.Command"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BukkitCommand" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BukkitCommand" type="java.lang.String, java.lang.String, java.lang.String, java.util.List&lt;java.lang.String&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.bukkit.command.defaults.BukkitCommand -->
  <!-- start class org.bukkit.command.defaults.HelpCommand -->
  <class name="HelpCommand" extends="org.bukkit.command.defaults.BukkitCommand"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HelpCommand"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="currentAlias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="findPossibleMatches" return="org.bukkit.help.HelpTopic"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="searchString" type="java.lang.String"/>
    </method>
    <method name="damerauLevenshteinDistance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="s1" type="java.lang.String"/>
      <param name="s2" type="java.lang.String"/>
      <doc>
      <![CDATA[Computes the Dameraur-Levenshtein Distance between two strings. Adapted
 from the algorithm at <a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Wikipedia: Damerau�##Levenshtein distance</a>

 @param s1 The first string being compared.
 @param s2 The second string being compared.
 @return The number of substitutions, deletions, insertions, and
 transpositions required to get from s1 to s2.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.command.defaults.HelpCommand -->
  <!-- start class org.bukkit.command.defaults.PluginsCommand -->
  <class name="PluginsCommand" extends="org.bukkit.command.defaults.BukkitCommand"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginsCommand" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="currentAlias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
    </method>
  </class>
  <!-- end class org.bukkit.command.defaults.PluginsCommand -->
  <!-- start class org.bukkit.command.defaults.ReloadCommand -->
  <class name="ReloadCommand" extends="org.bukkit.command.defaults.BukkitCommand"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReloadCommand" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="currentAlias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
    </method>
  </class>
  <!-- end class org.bukkit.command.defaults.ReloadCommand -->
  <!-- start class org.bukkit.command.defaults.VersionCommand -->
  <class name="VersionCommand" extends="org.bukkit.command.defaults.BukkitCommand"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionCommand" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="currentAlias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="tabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
  </class>
  <!-- end class org.bukkit.command.defaults.VersionCommand -->
</package>
<package name="org.bukkit.configuration">
  <!-- start interface org.bukkit.configuration.Configuration -->
  <interface name="Configuration"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.configuration.ConfigurationSection"/>
    <method name="addDefault"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the default value of the given path as provided.
 <p>
 If no source {@link Configuration} was provided as a default
 collection, then a new {@link MemoryConfiguration} will be created to
 hold the new default value.
 <p>
 If value is null, the value will be removed from the default
 Configuration source.

 @param path Path of the value to set.
 @param value Value to set the default to.
 @throws IllegalArgumentException Thrown if path is null.]]>
      </doc>
    </method>
    <method name="addDefaults"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaults" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Sets the default values of the given paths as provided.
 <p>
 If no source {@link Configuration} was provided as a default
 collection, then a new {@link MemoryConfiguration} will be created to
 hold the new default values.

 @param defaults A map of Path{@literal ->}Values to add to defaults.
 @throws IllegalArgumentException Thrown if defaults is null.]]>
      </doc>
    </method>
    <method name="addDefaults"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaults" type="org.bukkit.configuration.Configuration"/>
      <doc>
      <![CDATA[Sets the default values of the given paths as provided.
 <p>
 If no source {@link Configuration} was provided as a default
 collection, then a new {@link MemoryConfiguration} will be created to
 hold the new default value.
 <p>
 This method will not hold a reference to the specified Configuration,
 nor will it automatically update if that Configuration ever changes. If
 you require this, you should set the default source with {@link
 #setDefaults(org.bukkit.configuration.Configuration)}.

 @param defaults A configuration holding a list of defaults to copy.
 @throws IllegalArgumentException Thrown if defaults is null or this.]]>
      </doc>
    </method>
    <method name="setDefaults"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaults" type="org.bukkit.configuration.Configuration"/>
      <doc>
      <![CDATA[Sets the source of all default values for this {@link Configuration}.
 <p>
 If a previous source was set, or previous default values were defined,
 then they will not be copied to the new source.

 @param defaults New source of default values for this configuration.
 @throws IllegalArgumentException Thrown if defaults is null or this.]]>
      </doc>
    </method>
    <method name="getDefaults" return="org.bukkit.configuration.Configuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source {@link Configuration} for this configuration.
 <p>
 If no configuration source was set, but default values were added, then
 a {@link MemoryConfiguration} will be returned. If no source was set
 and no defaults were set, then this method will return null.

 @return Configuration source for default values, or null if none exist.]]>
      </doc>
    </method>
    <method name="options" return="org.bukkit.configuration.ConfigurationOptions"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link ConfigurationOptions} for this {@link Configuration}.
 <p>
 All setters through this method are chainable.

 @return Options for this configuration]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a source of configurable options and settings]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.configuration.Configuration -->
  <!-- start class org.bukkit.configuration.ConfigurationOptions -->
  <class name="ConfigurationOptions" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationOptions" type="org.bukkit.configuration.Configuration"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="configuration" return="org.bukkit.configuration.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Configuration} that this object is responsible for.

 @return Parent configuration]]>
      </doc>
    </method>
    <method name="pathSeparator" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the char that will be used to separate {@link
 ConfigurationSection}s
 <p>
 This value does not affect how the {@link Configuration} is stored,
 only in how you access the data. The default value is '.'.

 @return Path separator]]>
      </doc>
    </method>
    <method name="pathSeparator" return="org.bukkit.configuration.ConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Sets the char that will be used to separate {@link
 ConfigurationSection}s
 <p>
 This value does not affect how the {@link Configuration} is stored,
 only in how you access the data. The default value is '.'.

 @param value Path separator
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="copyDefaults" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the {@link Configuration} should copy values from its default
 {@link Configuration} directly.
 <p>
 If this is true, all values in the default Configuration will be
 directly copied, making it impossible to distinguish between values
 that were set and values that are provided by default. As a result,
 {@link ConfigurationSection#contains(java.lang.String)} will always
 return the same value as {@link
 ConfigurationSection#isSet(java.lang.String)}. The default value is
 false.

 @return Whether or not defaults are directly copied]]>
      </doc>
    </method>
    <method name="copyDefaults" return="org.bukkit.configuration.ConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets if the {@link Configuration} should copy values from its default
 {@link Configuration} directly.
 <p>
 If this is true, all values in the default Configuration will be
 directly copied, making it impossible to distinguish between values
 that were set and values that are provided by default. As a result,
 {@link ConfigurationSection#contains(java.lang.String)} will always
 return the same value as {@link
 ConfigurationSection#isSet(java.lang.String)}. The default value is
 false.

 @param value Whether or not defaults are directly copied
 @return This object, for chaining]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Various settings for controlling the input and output of a {@link
 Configuration}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.ConfigurationOptions -->
  <!-- start interface org.bukkit.configuration.ConfigurationSection -->
  <interface name="ConfigurationSection"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKeys" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deep" type="boolean"/>
      <doc>
      <![CDATA[Gets a set containing all keys in this section.
 <p>
 If deep is set to true, then this will contain all the keys within any
 child {@link ConfigurationSection}s (and their children, etc). These
 will be in a valid path notation for you to use.
 <p>
 If deep is set to false, then this will contain only the keys of any
 direct children, and not their own children.

 @param deep Whether or not to get a deep list, as opposed to a shallow
     list.
 @return Set of keys contained within this ConfigurationSection.]]>
      </doc>
    </method>
    <method name="getValues" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deep" type="boolean"/>
      <doc>
      <![CDATA[Gets a Map containing all keys and their values for this section.
 <p>
 If deep is set to true, then this will contain all the keys and values
 within any child {@link ConfigurationSection}s (and their children,
 etc). These keys will be in a valid path notation for you to use.
 <p>
 If deep is set to false, then this will contain only the keys and
 values of any direct children, and not their own children.

 @param deep Whether or not to get a deep list, as opposed to a shallow
     list.
 @return Map of keys and values of this section.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if this {@link ConfigurationSection} contains the given path.
 <p>
 If the value for the requested path does not exist but a default value
 has been specified, this will return true.

 @param path Path to check for existence.
 @return True if this section contains the requested path, either via
     default or being set.
 @throws IllegalArgumentException Thrown when path is null.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="ignoreDefault" type="boolean"/>
      <doc>
      <![CDATA[Checks if this {@link ConfigurationSection} contains the given path.
 <p>
 If the value for the requested path does not exist, the boolean parameter
 of true has been specified, a default value for the path exists, this
 will return true.
 <p>
 If a boolean parameter of false has been specified, true will only be
 returned if there is a set value for the specified path.

 @param path Path to check for existence.
 @param ignoreDefault Whether or not to ignore if a default value for the
 specified path exists.
 @return True if this section contains the requested path, or if a default
 value exist and the boolean parameter for this method is true.
 @throws IllegalArgumentException Thrown when path is null.]]>
      </doc>
    </method>
    <method name="isSet" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if this {@link ConfigurationSection} has a value set for the
 given path.
 <p>
 If the value for the requested path does not exist but a default value
 has been specified, this will still return false.

 @param path Path to check for existence.
 @return True if this section contains the requested path, regardless of
     having a default.
 @throws IllegalArgumentException Thrown when path is null.]]>
      </doc>
    </method>
    <method name="getCurrentPath" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the path of this {@link ConfigurationSection} from its root {@link
 Configuration}
 <p>
 For any {@link Configuration} themselves, this will return an empty
 string.
 <p>
 If the section is no longer contained within its root for any reason,
 such as being replaced with a different value, this may return null.
 <p>
 To retrieve the single name of this section, that is, the final part of
 the path returned by this method, you may use {@link #getName()}.

 @return Path of this section relative to its root]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name of this individual {@link ConfigurationSection}, in the
 path.
 <p>
 This will always be the final part of {@link #getCurrentPath()}, unless
 the section is orphaned.

 @return Name of this section]]>
      </doc>
    </method>
    <method name="getRoot" return="org.bukkit.configuration.Configuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the root {@link Configuration} that contains this {@link
 ConfigurationSection}
 <p>
 For any {@link Configuration} themselves, this will return its own
 object.
 <p>
 If the section is no longer contained within its root for any reason,
 such as being replaced with a different value, this may return null.

 @return Root configuration containing this section.]]>
      </doc>
    </method>
    <method name="getParent" return="org.bukkit.configuration.ConfigurationSection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the parent {@link ConfigurationSection} that directly contains
 this {@link ConfigurationSection}.
 <p>
 For any {@link Configuration} themselves, this will return null.
 <p>
 If the section is no longer contained within its parent for any reason,
 such as being replaced with a different value, this may return null.

 @return Parent section containing this section.]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested Object by path.
 <p>
 If the Object does not exist but a default value has been specified,
 this will return the default value. If the Object does not exist and no
 default value was specified, this will return null.

 @param path Path of the Object to get.
 @return Requested Object.]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="java.lang.Object"/>
      <doc>
      <![CDATA[Gets the requested Object by path, returning a default value if not
 found.
 <p>
 If the Object does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the Object to get.
 @param def The default value to return if the path is not found.
 @return Requested Object.]]>
      </doc>
    </method>
    <method name="set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the specified path to the given value.
 <p>
 If value is null, the entry will be removed. Any existing entry will be
 replaced, regardless of what the new value is.
 <p>
 Some implementations may have limitations on what you may store. See
 their individual javadocs for details. No implementations should allow
 you to store {@link Configuration}s or {@link ConfigurationSection}s,
 please use {@link #createSection(java.lang.String)} for that.

 @param path Path of the object to set.
 @param value New value to set the path to.]]>
      </doc>
    </method>
    <method name="createSection" return="org.bukkit.configuration.ConfigurationSection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates an empty {@link ConfigurationSection} at the specified path.
 <p>
 Any value that was previously set at this path will be overwritten. If
 the previous value was itself a {@link ConfigurationSection}, it will
 be orphaned.

 @param path Path to create the section at.
 @return Newly created section]]>
      </doc>
    </method>
    <method name="createSection" return="org.bukkit.configuration.ConfigurationSection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Creates a {@link ConfigurationSection} at the specified path, with
 specified values.
 <p>
 Any value that was previously set at this path will be overwritten. If
 the previous value was itself a {@link ConfigurationSection}, it will
 be orphaned.

 @param path Path to create the section at.
 @param map The values to used.
 @return Newly created section]]>
      </doc>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested String by path.
 <p>
 If the String does not exist but a default value has been specified,
 this will return the default value. If the String does not exist and no
 default value was specified, this will return null.

 @param path Path of the String to get.
 @return Requested String.]]>
      </doc>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested String by path, returning a default value if not
 found.
 <p>
 If the String does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the String to get.
 @param def The default value to return if the path is not found or is
     not a String.
 @return Requested String.]]>
      </doc>
    </method>
    <method name="isString" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a String.
 <p>
 If the path exists but is not a String, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a String and return appropriately.

 @param path Path of the String to check.
 @return Whether or not the specified path is a String.]]>
      </doc>
    </method>
    <method name="getInt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested int by path.
 <p>
 If the int does not exist but a default value has been specified, this
 will return the default value. If the int does not exist and no default
 value was specified, this will return 0.

 @param path Path of the int to get.
 @return Requested int.]]>
      </doc>
    </method>
    <method name="getInt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="int"/>
      <doc>
      <![CDATA[Gets the requested int by path, returning a default value if not found.
 <p>
 If the int does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the int to get.
 @param def The default value to return if the path is not found or is
     not an int.
 @return Requested int.]]>
      </doc>
    </method>
    <method name="isInt" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is an int.
 <p>
 If the path exists but is not a int, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a int and return appropriately.

 @param path Path of the int to check.
 @return Whether or not the specified path is an int.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested boolean by path.
 <p>
 If the boolean does not exist but a default value has been specified,
 this will return the default value. If the boolean does not exist and
 no default value was specified, this will return false.

 @param path Path of the boolean to get.
 @return Requested boolean.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="boolean"/>
      <doc>
      <![CDATA[Gets the requested boolean by path, returning a default value if not
 found.
 <p>
 If the boolean does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the boolean to get.
 @param def The default value to return if the path is not found or is
     not a boolean.
 @return Requested boolean.]]>
      </doc>
    </method>
    <method name="isBoolean" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a boolean.
 <p>
 If the path exists but is not a boolean, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a boolean and return appropriately.

 @param path Path of the boolean to check.
 @return Whether or not the specified path is a boolean.]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested double by path.
 <p>
 If the double does not exist but a default value has been specified,
 this will return the default value. If the double does not exist and no
 default value was specified, this will return 0.

 @param path Path of the double to get.
 @return Requested double.]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="double"/>
      <doc>
      <![CDATA[Gets the requested double by path, returning a default value if not
 found.
 <p>
 If the double does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the double to get.
 @param def The default value to return if the path is not found or is
     not a double.
 @return Requested double.]]>
      </doc>
    </method>
    <method name="isDouble" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a double.
 <p>
 If the path exists but is not a double, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a double and return appropriately.

 @param path Path of the double to check.
 @return Whether or not the specified path is a double.]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested long by path.
 <p>
 If the long does not exist but a default value has been specified, this
 will return the default value. If the long does not exist and no
 default value was specified, this will return 0.

 @param path Path of the long to get.
 @return Requested long.]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="long"/>
      <doc>
      <![CDATA[Gets the requested long by path, returning a default value if not
 found.
 <p>
 If the long does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the long to get.
 @param def The default value to return if the path is not found or is
     not a long.
 @return Requested long.]]>
      </doc>
    </method>
    <method name="isLong" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a long.
 <p>
 If the path exists but is not a long, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a long and return appropriately.

 @param path Path of the long to check.
 @return Whether or not the specified path is a long.]]>
      </doc>
    </method>
    <method name="getList" return="java.util.List&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return null.

 @param path Path of the List to get.
 @return Requested List.]]>
      </doc>
    </method>
    <method name="getList" return="java.util.List&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="java.util.List&lt;?&gt;"/>
      <doc>
      <![CDATA[Gets the requested List by path, returning a default value if not
 found.
 <p>
 If the List does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the List to get.
 @param def The default value to return if the path is not found or is
     not a List.
 @return Requested List.]]>
      </doc>
    </method>
    <method name="isList" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a List.
 <p>
 If the path exists but is not a List, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a List and return appropriately.

 @param path Path of the List to check.
 @return Whether or not the specified path is a List.]]>
      </doc>
    </method>
    <method name="getStringList" return="java.util.List&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of String by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a String if possible,
 but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of String.]]>
      </doc>
    </method>
    <method name="getIntegerList" return="java.util.List&lt;java.lang.Integer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Integer by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Integer if possible,
 but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Integer.]]>
      </doc>
    </method>
    <method name="getBooleanList" return="java.util.List&lt;java.lang.Boolean&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Boolean by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Boolean if possible,
 but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Boolean.]]>
      </doc>
    </method>
    <method name="getDoubleList" return="java.util.List&lt;java.lang.Double&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Double by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Double if possible,
 but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Double.]]>
      </doc>
    </method>
    <method name="getFloatList" return="java.util.List&lt;java.lang.Float&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Float by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Float if possible,
 but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Float.]]>
      </doc>
    </method>
    <method name="getLongList" return="java.util.List&lt;java.lang.Long&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Long by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Long if possible,
 but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Long.]]>
      </doc>
    </method>
    <method name="getByteList" return="java.util.List&lt;java.lang.Byte&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Byte by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Byte if possible,
 but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Byte.]]>
      </doc>
    </method>
    <method name="getCharacterList" return="java.util.List&lt;java.lang.Character&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Character by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Character if
 possible, but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Character.]]>
      </doc>
    </method>
    <method name="getShortList" return="java.util.List&lt;java.lang.Short&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Short by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Short if possible,
 but may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Short.]]>
      </doc>
    </method>
    <method name="getMapList" return="java.util.List&lt;java.util.Map&lt;?, ?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested List of Maps by path.
 <p>
 If the List does not exist but a default value has been specified, this
 will return the default value. If the List does not exist and no
 default value was specified, this will return an empty List.
 <p>
 This method will attempt to cast any values into a Map if possible, but
 may miss any values out if they are not compatible.

 @param path Path of the List to get.
 @return Requested List of Maps.]]>
      </doc>
    </method>
    <method name="getObject" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets the requested object at the given path.

 If the Object does not exist but a default value has been specified, this
 will return the default value. If the Object does not exist and no
 default value was specified, this will return null.

 <b>Note:</b> For example #getObject(path, String.class) is <b>not</b>
 equivalent to {@link #getString(String) #getString(path)} because
 {@link #getString(String) #getString(path)} converts internally all
 Objects to Strings. However, #getObject(path, Boolean.class) is
 equivalent to {@link #getBoolean(String) #getBoolean(path)} for example.

 @param <T> the type of the requested object
 @param path the path to the object.
 @param clazz the type of the requested object
 @return Requested object]]>
      </doc>
    </method>
    <method name="getObject" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <param name="def" type="T"/>
      <doc>
      <![CDATA[Gets the requested object at the given path, returning a default value if
 not found

 If the Object does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 <b>Note:</b> For example #getObject(path, String.class, def) is
 <b>not</b> equivalent to
 {@link #getString(String, String) #getString(path, def)} because
 {@link #getString(String, String) #getString(path, def)} converts
 internally all Objects to Strings. However, #getObject(path,
 Boolean.class, def) is equivalent to {@link #getBoolean(String, boolean) #getBoolean(path,
 def)} for example.

 @param <T> the type of the requested object
 @param path the path to the object.
 @param clazz the type of the requested object
 @param def the default object to return if the object is not present at
 the path
 @return Requested object]]>
      </doc>
    </method>
    <method name="getSerializable" return="T extends org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets the requested {@link ConfigurationSerializable} object at the given
 path.

 If the Object does not exist but a default value has been specified, this
 will return the default value. If the Object does not exist and no
 default value was specified, this will return null.

 @param <T> the type of {@link ConfigurationSerializable}
 @param path the path to the object.
 @param clazz the type of {@link ConfigurationSerializable}
 @return Requested {@link ConfigurationSerializable} object]]>
      </doc>
    </method>
    <method name="getSerializable" return="T extends org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <param name="def" type="T extends org.bukkit.configuration.serialization.ConfigurationSerializable"/>
      <doc>
      <![CDATA[Gets the requested {@link ConfigurationSerializable} object at the given
 path, returning a default value if not found

 If the Object does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param <T> the type of {@link ConfigurationSerializable}
 @param path the path to the object.
 @param clazz the type of {@link ConfigurationSerializable}
 @param def the default object to return if the object is not present at
 the path
 @return Requested {@link ConfigurationSerializable} object]]>
      </doc>
    </method>
    <method name="getVector" return="org.bukkit.util.Vector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested Vector by path.
 <p>
 If the Vector does not exist but a default value has been specified,
 this will return the default value. If the Vector does not exist and no
 default value was specified, this will return null.

 @param path Path of the Vector to get.
 @return Requested Vector.]]>
      </doc>
    </method>
    <method name="getVector" return="org.bukkit.util.Vector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Gets the requested {@link Vector} by path, returning a default value if
 not found.
 <p>
 If the Vector does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the Vector to get.
 @param def The default value to return if the path is not found or is
     not a Vector.
 @return Requested Vector.]]>
      </doc>
    </method>
    <method name="isVector" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a Vector.
 <p>
 If the path exists but is not a Vector, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a Vector and return appropriately.

 @param path Path of the Vector to check.
 @return Whether or not the specified path is a Vector.]]>
      </doc>
    </method>
    <method name="getOfflinePlayer" return="org.bukkit.OfflinePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested OfflinePlayer by path.
 <p>
 If the OfflinePlayer does not exist but a default value has been
 specified, this will return the default value. If the OfflinePlayer
 does not exist and no default value was specified, this will return
 null.

 @param path Path of the OfflinePlayer to get.
 @return Requested OfflinePlayer.]]>
      </doc>
    </method>
    <method name="getOfflinePlayer" return="org.bukkit.OfflinePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.OfflinePlayer"/>
      <doc>
      <![CDATA[Gets the requested {@link OfflinePlayer} by path, returning a default
 value if not found.
 <p>
 If the OfflinePlayer does not exist then the specified default value
 will returned regardless of if a default has been identified in the
 root {@link Configuration}.

 @param path Path of the OfflinePlayer to get.
 @param def The default value to return if the path is not found or is
     not an OfflinePlayer.
 @return Requested OfflinePlayer.]]>
      </doc>
    </method>
    <method name="isOfflinePlayer" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is an OfflinePlayer.
 <p>
 If the path exists but is not a OfflinePlayer, this will return false.
 If the path does not exist, this will return false. If the path does
 not exist but a default value has been specified, this will check if
 that default value is a OfflinePlayer and return appropriately.

 @param path Path of the OfflinePlayer to check.
 @return Whether or not the specified path is an OfflinePlayer.]]>
      </doc>
    </method>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested ItemStack by path.
 <p>
 If the ItemStack does not exist but a default value has been specified,
 this will return the default value. If the ItemStack does not exist and
 no default value was specified, this will return null.

 @param path Path of the ItemStack to get.
 @return Requested ItemStack.]]>
      </doc>
    </method>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Gets the requested {@link ItemStack} by path, returning a default value
 if not found.
 <p>
 If the ItemStack does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the ItemStack to get.
 @param def The default value to return if the path is not found or is
     not an ItemStack.
 @return Requested ItemStack.]]>
      </doc>
    </method>
    <method name="isItemStack" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is an ItemStack.
 <p>
 If the path exists but is not a ItemStack, this will return false. If
 the path does not exist, this will return false. If the path does not
 exist but a default value has been specified, this will check if that
 default value is a ItemStack and return appropriately.

 @param path Path of the ItemStack to check.
 @return Whether or not the specified path is an ItemStack.]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested Color by path.
 <p>
 If the Color does not exist but a default value has been specified,
 this will return the default value. If the Color does not exist and no
 default value was specified, this will return null.

 @param path Path of the Color to get.
 @return Requested Color.]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Gets the requested {@link Color} by path, returning a default value if
 not found.
 <p>
 If the Color does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the Color to get.
 @param def The default value to return if the path is not found or is
     not a Color.
 @return Requested Color.]]>
      </doc>
    </method>
    <method name="isColor" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a Color.
 <p>
 If the path exists but is not a Color, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a Color and return appropriately.

 @param path Path of the Color to check.
 @return Whether or not the specified path is a Color.]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested Location by path.
 <p>
 If the Location does not exist but a default value has been specified,
 this will return the default value. If the Location does not exist and no
 default value was specified, this will return null.

 @param path Path of the Location to get.
 @return Requested Location.]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Gets the requested {@link Location} by path, returning a default value if
 not found.
 <p>
 If the Location does not exist then the specified default value will
 returned regardless of if a default has been identified in the root
 {@link Configuration}.

 @param path Path of the Location to get.
 @param def The default value to return if the path is not found or is not
 a Location.
 @return Requested Location.]]>
      </doc>
    </method>
    <method name="isLocation" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a Location.
 <p>
 If the path exists but is not a Location, this will return false. If the
 path does not exist, this will return false. If the path does not exist
 but a default value has been specified, this will check if that default
 value is a Location and return appropriately.

 @param path Path of the Location to check.
 @return Whether or not the specified path is a Location.]]>
      </doc>
    </method>
    <method name="getConfigurationSection" return="org.bukkit.configuration.ConfigurationSection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the requested ConfigurationSection by path.
 <p>
 If the ConfigurationSection does not exist but a default value has been
 specified, this will return the default value. If the
 ConfigurationSection does not exist and no default value was specified,
 this will return null.

 @param path Path of the ConfigurationSection to get.
 @return Requested ConfigurationSection.]]>
      </doc>
    </method>
    <method name="isConfigurationSection" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified path is a ConfigurationSection.
 <p>
 If the path exists but is not a ConfigurationSection, this will return
 false. If the path does not exist, this will return false. If the path
 does not exist but a default value has been specified, this will check
 if that default value is a ConfigurationSection and return
 appropriately.

 @param path Path of the ConfigurationSection to check.
 @return Whether or not the specified path is a ConfigurationSection.]]>
      </doc>
    </method>
    <method name="getDefaultSection" return="org.bukkit.configuration.ConfigurationSection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the equivalent {@link ConfigurationSection} from the default
 {@link Configuration} defined in {@link #getRoot()}.
 <p>
 If the root contains no defaults, or the defaults doesn't contain a
 value for this path, or the value at this path is not a {@link
 ConfigurationSection} then this will return null.

 @return Equivalent section in root configuration]]>
      </doc>
    </method>
    <method name="addDefault"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the default value in the root at the given path as provided.
 <p>
 If no source {@link Configuration} was provided as a default
 collection, then a new {@link MemoryConfiguration} will be created to
 hold the new default value.
 <p>
 If value is null, the value will be removed from the default
 Configuration source.
 <p>
 If the value as returned by {@link #getDefaultSection()} is null, then
 this will create a new section at the path, replacing anything that may
 have existed there previously.

 @param path Path of the value to set.
 @param value Value to set the default to.
 @throws IllegalArgumentException Thrown if path is null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a section of a {@link Configuration}]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.configuration.ConfigurationSection -->
  <!-- start class org.bukkit.configuration.InvalidConfigurationException -->
  <class name="InvalidConfigurationException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidConfigurationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of InvalidConfigurationException without a
 message or cause.]]>
      </doc>
    </constructor>
    <constructor name="InvalidConfigurationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an instance of InvalidConfigurationException with the
 specified message.

 @param msg The details of the exception.]]>
      </doc>
    </constructor>
    <constructor name="InvalidConfigurationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an instance of InvalidConfigurationException with the
 specified cause.

 @param cause The cause of the exception.]]>
      </doc>
    </constructor>
    <constructor name="InvalidConfigurationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an instance of InvalidConfigurationException with the
 specified message and cause.

 @param cause The cause of the exception.
 @param msg The details of the exception.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown when attempting to load an invalid {@link Configuration}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.InvalidConfigurationException -->
  <!-- start class org.bukkit.configuration.MemoryConfiguration -->
  <class name="MemoryConfiguration" extends="org.bukkit.configuration.MemorySection"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.configuration.Configuration"/>
    <constructor name="MemoryConfiguration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@link MemoryConfiguration} with no default values.]]>
      </doc>
    </constructor>
    <constructor name="MemoryConfiguration" type="org.bukkit.configuration.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@link MemoryConfiguration} using the specified {@link
 Configuration} as a source for all default values.

 @param defaults Default value provider
 @throws IllegalArgumentException Thrown if defaults is null]]>
      </doc>
    </constructor>
    <method name="addDefault"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="addDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaults" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <method name="addDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaults" type="org.bukkit.configuration.Configuration"/>
    </method>
    <method name="setDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaults" type="org.bukkit.configuration.Configuration"/>
    </method>
    <method name="getDefaults" return="org.bukkit.configuration.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getParent" return="org.bukkit.configuration.ConfigurationSection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="options" return="org.bukkit.configuration.MemoryConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="defaults" type="org.bukkit.configuration.Configuration"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="options" type="org.bukkit.configuration.MemoryConfigurationOptions"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This is a {@link Configuration} implementation that does not save or load
 from any source, and stores all values in memory only.
 This is useful for temporary Configurations for providing defaults.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.MemoryConfiguration -->
  <!-- start class org.bukkit.configuration.MemoryConfigurationOptions -->
  <class name="MemoryConfigurationOptions" extends="org.bukkit.configuration.ConfigurationOptions"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MemoryConfigurationOptions" type="org.bukkit.configuration.MemoryConfiguration"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="configuration" return="org.bukkit.configuration.MemoryConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copyDefaults" return="org.bukkit.configuration.MemoryConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
    </method>
    <method name="pathSeparator" return="org.bukkit.configuration.MemoryConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
    </method>
    <doc>
    <![CDATA[Various settings for controlling the input and output of a {@link
 MemoryConfiguration}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.MemoryConfigurationOptions -->
  <!-- start class org.bukkit.configuration.MemorySection -->
  <class name="MemorySection" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.configuration.ConfigurationSection"/>
    <constructor name="MemorySection"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty MemorySection for use as a root {@link Configuration}
 section.
 <p>
 Note that calling this without being yourself a {@link Configuration}
 will throw an exception!

 @throws IllegalStateException Thrown if this is not a {@link
     Configuration} root.]]>
      </doc>
    </constructor>
    <constructor name="MemorySection" type="org.bukkit.configuration.ConfigurationSection, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty MemorySection with the specified parent and path.

 @param parent Parent section that contains this own section.
 @param path Path that you may access this section from via the root
     {@link Configuration}.
 @throws IllegalArgumentException Thrown is parent or path is null, or
     if parent contains no root Configuration.]]>
      </doc>
    </constructor>
    <method name="getKeys" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deep" type="boolean"/>
    </method>
    <method name="getValues" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deep" type="boolean"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="ignoreDefault" type="boolean"/>
    </method>
    <method name="isSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getCurrentPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRoot" return="org.bukkit.configuration.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getParent" return="org.bukkit.configuration.ConfigurationSection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addDefault"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="getDefaultSection" return="org.bukkit.configuration.ConfigurationSection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="java.lang.Object"/>
    </method>
    <method name="createSection" return="org.bukkit.configuration.ConfigurationSection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="createSection" return="org.bukkit.configuration.ConfigurationSection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="java.lang.String"/>
    </method>
    <method name="isString" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="int"/>
    </method>
    <method name="isInt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="boolean"/>
    </method>
    <method name="isBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="double"/>
    </method>
    <method name="isDouble" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="long"/>
    </method>
    <method name="isLong" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getList" return="java.util.List&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getList" return="java.util.List&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="java.util.List&lt;?&gt;"/>
    </method>
    <method name="isList" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getStringList" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getIntegerList" return="java.util.List&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getBooleanList" return="java.util.List&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getDoubleList" return="java.util.List&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getFloatList" return="java.util.List&lt;java.lang.Float&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getLongList" return="java.util.List&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getByteList" return="java.util.List&lt;java.lang.Byte&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getCharacterList" return="java.util.List&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getShortList" return="java.util.List&lt;java.lang.Short&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getMapList" return="java.util.List&lt;java.util.Map&lt;?, ?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getObject" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getObject" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <param name="def" type="T"/>
    </method>
    <method name="getSerializable" return="T extends org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getSerializable" return="T extends org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <param name="def" type="T extends org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    </method>
    <method name="getVector" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getVector" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.util.Vector"/>
    </method>
    <method name="isVector" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getOfflinePlayer" return="org.bukkit.OfflinePlayer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getOfflinePlayer" return="org.bukkit.OfflinePlayer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.OfflinePlayer"/>
    </method>
    <method name="isOfflinePlayer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="isItemStack" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.Color"/>
    </method>
    <method name="isColor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="def" type="org.bukkit.Location"/>
    </method>
    <method name="isLocation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getConfigurationSection" return="org.bukkit.configuration.ConfigurationSection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="isConfigurationSection" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="isPrimitiveWrapper" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Object"/>
    </method>
    <method name="getDefault" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="mapChildrenKeys"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="output" type="java.util.Set&lt;java.lang.String&gt;"/>
      <param name="section" type="org.bukkit.configuration.ConfigurationSection"/>
      <param name="deep" type="boolean"/>
    </method>
    <method name="mapChildrenValues"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="output" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
      <param name="section" type="org.bukkit.configuration.ConfigurationSection"/>
      <param name="deep" type="boolean"/>
    </method>
    <method name="createPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="section" type="org.bukkit.configuration.ConfigurationSection"/>
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a full path to the given {@link ConfigurationSection} from its
 root {@link Configuration}.
 <p>
 You may use this method for any given {@link ConfigurationSection}, not
 only {@link MemorySection}.

 @param section Section to create a path for.
 @param key Name of the specified section.
 @return Full path of the section from its root.]]>
      </doc>
    </method>
    <method name="createPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="section" type="org.bukkit.configuration.ConfigurationSection"/>
      <param name="key" type="java.lang.String"/>
      <param name="relativeTo" type="org.bukkit.configuration.ConfigurationSection"/>
      <doc>
      <![CDATA[Creates a relative path to the given {@link ConfigurationSection} from
 the given relative section.
 <p>
 You may use this method for any given {@link ConfigurationSection}, not
 only {@link MemorySection}.

 @param section Section to create a path for.
 @param key Name of the specified section.
 @param relativeTo Section to create the path relative to.
 @return Full path of the section from its root.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="map" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A type of {@link ConfigurationSection} that is stored in memory.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.MemorySection -->
</package>
<package name="org.bukkit.configuration.file">
  <!-- start class org.bukkit.configuration.file.FileConfiguration -->
  <class name="FileConfiguration" extends="org.bukkit.configuration.MemoryConfiguration"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileConfiguration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@link FileConfiguration} with no default values.]]>
      </doc>
    </constructor>
    <constructor name="FileConfiguration" type="org.bukkit.configuration.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@link FileConfiguration} using the specified {@link
 Configuration} as a source for all default values.

 @param defaults Default value provider]]>
      </doc>
    </constructor>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Saves this {@link FileConfiguration} to the specified location.
 <p>
 If the file does not exist, it will be created. If already exists, it
 will be overwritten. If it cannot be overwritten or created, an
 exception will be thrown.
 <p>
 This method will save using the system default encoding, or possibly
 using UTF8.

 @param file File to save to.
 @throws IOException Thrown when the given file cannot be written to for
     any reason.
 @throws IllegalArgumentException Thrown when file is null.]]>
      </doc>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Saves this {@link FileConfiguration} to the specified location.
 <p>
 If the file does not exist, it will be created. If already exists, it
 will be overwritten. If it cannot be overwritten or created, an
 exception will be thrown.
 <p>
 This method will save using the system default encoding, or possibly
 using UTF8.

 @param file File to save to.
 @throws IOException Thrown when the given file cannot be written to for
     any reason.
 @throws IllegalArgumentException Thrown when file is null.]]>
      </doc>
    </method>
    <method name="saveToString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Saves this {@link FileConfiguration} to a string, and returns it.

 @return String containing this configuration.]]>
      </doc>
    </method>
    <method name="load"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InvalidConfigurationException" type="org.bukkit.configuration.InvalidConfigurationException"/>
      <doc>
      <![CDATA[Loads this {@link FileConfiguration} from the specified location.
 <p>
 All the values contained within this configuration will be removed,
 leaving only settings and defaults, and the new values will be loaded
 from the given file.
 <p>
 If the file cannot be loaded for any reason, an exception will be
 thrown.

 @param file File to load from.
 @throws FileNotFoundException Thrown when the given file cannot be
     opened.
 @throws IOException Thrown when the given file cannot be read.
 @throws InvalidConfigurationException Thrown when the given file is not
     a valid Configuration.
 @throws IllegalArgumentException Thrown when file is null.]]>
      </doc>
    </method>
    <method name="load"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InvalidConfigurationException" type="org.bukkit.configuration.InvalidConfigurationException"/>
      <doc>
      <![CDATA[Loads this {@link FileConfiguration} from the specified reader.
 <p>
 All the values contained within this configuration will be removed,
 leaving only settings and defaults, and the new values will be loaded
 from the given stream.

 @param reader the reader to load from
 @throws IOException thrown when underlying reader throws an IOException
 @throws InvalidConfigurationException thrown when the reader does not
      represent a valid Configuration
 @throws IllegalArgumentException thrown when reader is null]]>
      </doc>
    </method>
    <method name="load"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InvalidConfigurationException" type="org.bukkit.configuration.InvalidConfigurationException"/>
      <doc>
      <![CDATA[Loads this {@link FileConfiguration} from the specified location.
 <p>
 All the values contained within this configuration will be removed,
 leaving only settings and defaults, and the new values will be loaded
 from the given file.
 <p>
 If the file cannot be loaded for any reason, an exception will be
 thrown.

 @param file File to load from.
 @throws FileNotFoundException Thrown when the given file cannot be
     opened.
 @throws IOException Thrown when the given file cannot be read.
 @throws InvalidConfigurationException Thrown when the given file is not
     a valid Configuration.
 @throws IllegalArgumentException Thrown when file is null.]]>
      </doc>
    </method>
    <method name="loadFromString"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contents" type="java.lang.String"/>
      <exception name="InvalidConfigurationException" type="org.bukkit.configuration.InvalidConfigurationException"/>
      <doc>
      <![CDATA[Loads this {@link FileConfiguration} from the specified string, as
 opposed to from file.
 <p>
 All the values contained within this configuration will be removed,
 leaving only settings and defaults, and the new values will be loaded
 from the given string.
 <p>
 If the string is invalid in any way, an exception will be thrown.

 @param contents Contents of a Configuration to load.
 @throws InvalidConfigurationException Thrown if the specified string is
     invalid.
 @throws IllegalArgumentException Thrown if contents is null.]]>
      </doc>
    </method>
    <method name="buildHeader" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compiles the header for this {@link FileConfiguration} and returns the
 result.
 <p>
 This will use the header from {@link #options()} -&gt; {@link
 FileConfigurationOptions#header()}, respecting the rules of {@link
 FileConfigurationOptions#copyHeader()} if set.

 @return Compiled header]]>
      </doc>
    </method>
    <method name="options" return="org.bukkit.configuration.file.FileConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is a base class for all File based implementations of {@link
 Configuration}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.file.FileConfiguration -->
  <!-- start class org.bukkit.configuration.file.FileConfigurationOptions -->
  <class name="FileConfigurationOptions" extends="org.bukkit.configuration.MemoryConfigurationOptions"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileConfigurationOptions" type="org.bukkit.configuration.MemoryConfiguration"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="configuration" return="org.bukkit.configuration.file.FileConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copyDefaults" return="org.bukkit.configuration.file.FileConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
    </method>
    <method name="pathSeparator" return="org.bukkit.configuration.file.FileConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
    </method>
    <method name="header" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the header that will be applied to the top of the saved output.
 <p>
 This header will be commented out and applied directly at the top of
 the generated output of the {@link FileConfiguration}. It is not
 required to include a newline at the end of the header as it will
 automatically be applied, but you may include one if you wish for extra
 spacing.
 <p>
 Null is a valid value which will indicate that no header is to be
 applied. The default value is null.

 @return Header]]>
      </doc>
    </method>
    <method name="header" return="org.bukkit.configuration.file.FileConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the header that will be applied to the top of the saved output.
 <p>
 This header will be commented out and applied directly at the top of
 the generated output of the {@link FileConfiguration}. It is not
 required to include a newline at the end of the header as it will
 automatically be applied, but you may include one if you wish for extra
 spacing.
 <p>
 Null is a valid value which will indicate that no header is to be
 applied.

 @param value New header
 @return This object, for chaining]]>
      </doc>
    </method>
    <method name="copyHeader" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the header should be copied from a default source.
 <p>
 If this is true, if a default {@link FileConfiguration} is passed to
 {@link
 FileConfiguration#setDefaults(org.bukkit.configuration.Configuration)}
 then upon saving it will use the header from that config, instead of
 the one provided here.
 <p>
 If no default is set on the configuration, or the default is not of
 type FileConfiguration, or that config has no header ({@link #header()}
 returns null) then the header specified in this configuration will be
 used.
 <p>
 Defaults to true.

 @return Whether or not to copy the header]]>
      </doc>
    </method>
    <method name="copyHeader" return="org.bukkit.configuration.file.FileConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not the header should be copied from a default source.
 <p>
 If this is true, if a default {@link FileConfiguration} is passed to
 {@link
 FileConfiguration#setDefaults(org.bukkit.configuration.Configuration)}
 then upon saving it will use the header from that config, instead of
 the one provided here.
 <p>
 If no default is set on the configuration, or the default is not of
 type FileConfiguration, or that config has no header ({@link #header()}
 returns null) then the header specified in this configuration will be
 used.
 <p>
 Defaults to true.

 @param value Whether or not to copy the header
 @return This object, for chaining]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Various settings for controlling the input and output of a {@link
 FileConfiguration}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.file.FileConfigurationOptions -->
  <!-- start class org.bukkit.configuration.file.YamlConfiguration -->
  <class name="YamlConfiguration" extends="org.bukkit.configuration.file.FileConfiguration"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YamlConfiguration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="saveToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="loadFromString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contents" type="java.lang.String"/>
      <exception name="InvalidConfigurationException" type="org.bukkit.configuration.InvalidConfigurationException"/>
    </method>
    <method name="convertMapsToSections"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="input" type="java.util.Map&lt;?, ?&gt;"/>
      <param name="section" type="org.bukkit.configuration.ConfigurationSection"/>
    </method>
    <method name="parseHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="buildHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="options" return="org.bukkit.configuration.file.YamlConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="loadConfiguration" return="org.bukkit.configuration.file.YamlConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Creates a new {@link YamlConfiguration}, loading from the given file.
 <p>
 Any errors loading the Configuration will be logged and then ignored.
 If the specified input is not a valid config, a blank config will be
 returned.
 <p>
 The encoding used may follow the system dependent default.

 @param file Input file
 @return Resulting configuration
 @throws IllegalArgumentException Thrown if file is null]]>
      </doc>
    </method>
    <method name="loadConfiguration" return="org.bukkit.configuration.file.YamlConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <doc>
      <![CDATA[Creates a new {@link YamlConfiguration}, loading from the given reader.
 <p>
 Any errors loading the Configuration will be logged and then ignored.
 If the specified input is not a valid config, a blank config will be
 returned.

 @param reader input
 @return resulting configuration
 @throws IllegalArgumentException Thrown if stream is null]]>
      </doc>
    </method>
    <field name="COMMENT_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="BLANK_CONFIG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An implementation of {@link Configuration} which saves all files in Yaml.
 Note that this implementation is not synchronized.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.file.YamlConfiguration -->
  <!-- start class org.bukkit.configuration.file.YamlConfigurationOptions -->
  <class name="YamlConfigurationOptions" extends="org.bukkit.configuration.file.FileConfigurationOptions"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YamlConfigurationOptions" type="org.bukkit.configuration.file.YamlConfiguration"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="configuration" return="org.bukkit.configuration.file.YamlConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copyDefaults" return="org.bukkit.configuration.file.YamlConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
    </method>
    <method name="pathSeparator" return="org.bukkit.configuration.file.YamlConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
    </method>
    <method name="header" return="org.bukkit.configuration.file.YamlConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="copyHeader" return="org.bukkit.configuration.file.YamlConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
    </method>
    <method name="indent" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets how much spaces should be used to indent each line.
 <p>
 The minimum value this may be is 2, and the maximum is 9.

 @return How much to indent by]]>
      </doc>
    </method>
    <method name="indent" return="org.bukkit.configuration.file.YamlConfigurationOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets how much spaces should be used to indent each line.
 <p>
 The minimum value this may be is 2, and the maximum is 9.

 @param value New indent
 @return This object, for chaining]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Various settings for controlling the input and output of a {@link
 YamlConfiguration}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.file.YamlConfigurationOptions -->
  <!-- start class org.bukkit.configuration.file.YamlConstructor -->
  <class name="YamlConstructor" extends="SafeConstructor"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YamlConstructor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.bukkit.configuration.file.YamlConstructor -->
  <!-- start class org.bukkit.configuration.file.YamlRepresenter -->
  <class name="YamlRepresenter" extends="Representer"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YamlRepresenter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.bukkit.configuration.file.YamlRepresenter -->
</package>
<package name="org.bukkit.configuration.serialization">
  <!-- start interface org.bukkit.configuration.serialization.ConfigurationSerializable -->
  <interface name="ConfigurationSerializable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a Map representation of this class.
 <p>
 This class must provide a method to restore this class, as defined in
 the {@link ConfigurationSerializable} interface javadocs.

 @return Map containing the current state of this class]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an object that may be serialized.
 <p>
 These objects MUST implement one of the following, in addition to the
 methods as defined by this interface:
 <ul>
 <li>A static method "deserialize" that accepts a single {@link Map}&lt;
 {@link String}, {@link Object}&gt; and returns the class.</li>
 <li>A static method "valueOf" that accepts a single {@link Map}&lt;{@link
 String}, {@link Object}&gt; and returns the class.</li>
 <li>A constructor that accepts a single {@link Map}&lt;{@link String},
 {@link Object}&gt;.</li>
 </ul>
 In addition to implementing this interface, you must register the class
 with {@link ConfigurationSerialization#registerClass(Class)}.

 @see DelegateDeserialization
 @see SerializableAs]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.configuration.serialization.ConfigurationSerializable -->
  <!-- start class org.bukkit.configuration.serialization.ConfigurationSerialization -->
  <class name="ConfigurationSerialization" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationSerialization" type="java.lang.Class&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="isStatic" type="boolean"/>
    </method>
    <method name="getConstructor" return="java.lang.reflect.Constructor&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="deserializeViaMethod" return="org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="args" type="java.util.Map&lt;java.lang.String, ?&gt;"/>
    </method>
    <method name="deserializeViaCtor" return="org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="ctor" type="java.lang.reflect.Constructor&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"/>
      <param name="args" type="java.util.Map&lt;java.lang.String, ?&gt;"/>
    </method>
    <method name="deserialize" return="org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, ?&gt;"/>
    </method>
    <method name="deserializeObject" return="org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, ?&gt;"/>
      <param name="clazz" type="java.lang.Class&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"/>
      <doc>
      <![CDATA[Attempts to deserialize the given arguments into a new instance of the
 given class.
 <p>
 The class must implement {@link ConfigurationSerializable}, including
 the extra methods as specified in the javadoc of
 ConfigurationSerializable.
 <p>
 If a new instance could not be made, an example being the class not
 fully implementing the interface, null will be returned.

 @param args Arguments for deserialization
 @param clazz Class to deserialize into
 @return New instance of the specified class]]>
      </doc>
    </method>
    <method name="deserializeObject" return="org.bukkit.configuration.serialization.ConfigurationSerializable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, ?&gt;"/>
      <doc>
      <![CDATA[Attempts to deserialize the given arguments into a new instance of the
 given class.
 <p>
 The class must implement {@link ConfigurationSerializable}, including
 the extra methods as specified in the javadoc of
 ConfigurationSerializable.
 <p>
 If a new instance could not be made, an example being the class not
 fully implementing the interface, null will be returned.

 @param args Arguments for deserialization
 @return New instance of the specified class]]>
      </doc>
    </method>
    <method name="registerClass"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"/>
      <doc>
      <![CDATA[Registers the given {@link ConfigurationSerializable} class by its
 alias

 @param clazz Class to register]]>
      </doc>
    </method>
    <method name="registerClass"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"/>
      <param name="alias" type="java.lang.String"/>
      <doc>
      <![CDATA[Registers the given alias to the specified {@link
 ConfigurationSerializable} class

 @param clazz Class to register
 @param alias Alias to register as
 @see SerializableAs]]>
      </doc>
    </method>
    <method name="unregisterClass"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <doc>
      <![CDATA[Unregisters the specified alias to a {@link ConfigurationSerializable}

 @param alias Alias to unregister]]>
      </doc>
    </method>
    <method name="unregisterClass"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"/>
      <doc>
      <![CDATA[Unregisters any aliases for the specified {@link
 ConfigurationSerializable} class

 @param clazz Class to unregister]]>
      </doc>
    </method>
    <method name="getClassByAlias" return="java.lang.Class&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <doc>
      <![CDATA[Attempts to get a registered {@link ConfigurationSerializable} class by
 its alias

 @param alias Alias of the serializable
 @return Registered class, or null if not found]]>
      </doc>
    </method>
    <method name="getAlias" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;? extends org.bukkit.configuration.serialization.ConfigurationSerializable&gt;"/>
      <doc>
      <![CDATA[Gets the correct alias for the given {@link ConfigurationSerializable}
 class

 @param clazz Class to get alias for
 @return Alias to use for the class]]>
      </doc>
    </method>
    <field name="SERIALIZED_TYPE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility class for storing and retrieving classes for {@link Configuration}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.serialization.ConfigurationSerialization -->
  <!-- start class org.bukkit.configuration.serialization.DelegateDeserialization -->
  <class name="DelegateDeserialization"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Applies to a {@link ConfigurationSerializable} that will delegate all
 deserialization to another {@link ConfigurationSerializable}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.serialization.DelegateDeserialization -->
  <!-- start class org.bukkit.configuration.serialization.SerializableAs -->
  <class name="SerializableAs"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Represents an "alias" that a {@link ConfigurationSerializable} may be
 stored as.
 If this is not present on a {@link ConfigurationSerializable} class, it
 will use the fully qualified name of the class.
 <p>
 This value will be stored in the configuration so that the configuration
 deserialization can determine what type it is.
 <p>
 Using this annotation on any other class than a {@link
 ConfigurationSerializable} will have no effect.

 @see ConfigurationSerialization#registerClass(Class, String)]]>
    </doc>
  </class>
  <!-- end class org.bukkit.configuration.serialization.SerializableAs -->
</package>
<package name="org.bukkit.conversations">
  <!-- start class org.bukkit.conversations.BooleanPrompt -->
  <class name="BooleanPrompt" extends="org.bukkit.conversations.ValidatingPrompt"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BooleanPrompt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isInputValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="acceptValidatedInput" return="org.bukkit.conversations.Prompt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="acceptValidatedInput" return="org.bukkit.conversations.Prompt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="boolean"/>
      <doc>
      <![CDATA[Override this method to perform some action with the user's boolean
 response.

 @param context Context information about the conversation.
 @param input The user's boolean response.
 @return The next {@link Prompt} in the prompt graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[BooleanPrompt is the base class for any prompt that requires a boolean
 response from the user.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.BooleanPrompt -->
  <!-- start interface org.bukkit.conversations.Conversable -->
  <interface name="Conversable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isConversing" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tests to see of a Conversable object is actively engaged in a
 conversation.

 @return True if a conversation is in progress]]>
      </doc>
    </method>
    <method name="acceptConversationInput"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Accepts input into the active conversation. If no conversation is in
 progress, this method does nothing.

 @param input The input message into the conversation]]>
      </doc>
    </method>
    <method name="beginConversation" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conversation" type="org.bukkit.conversations.Conversation"/>
      <doc>
      <![CDATA[Enters into a dialog with a Conversation object.

 @param conversation The conversation to begin
 @return True if the conversation should proceed, false if it has been
     enqueued]]>
      </doc>
    </method>
    <method name="abandonConversation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conversation" type="org.bukkit.conversations.Conversation"/>
      <doc>
      <![CDATA[Abandons an active conversation.

 @param conversation The conversation to abandon]]>
      </doc>
    </method>
    <method name="abandonConversation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conversation" type="org.bukkit.conversations.Conversation"/>
      <param name="details" type="org.bukkit.conversations.ConversationAbandonedEvent"/>
      <doc>
      <![CDATA[Abandons an active conversation.

 @param conversation The conversation to abandon
 @param details Details about why the conversation was abandoned]]>
      </doc>
    </method>
    <method name="sendRawMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sends this sender a message raw

 @param message Message to be displayed]]>
      </doc>
    </method>
    <method name="sendRawMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="java.util.UUID"/>
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sends this sender a message raw

 @param message Message to be displayed
 @param sender The sender of this message]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The Conversable interface is used to indicate objects that can have
 conversations.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.conversations.Conversable -->
  <!-- start class org.bukkit.conversations.Conversation -->
  <class name="Conversation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Conversation" type="org.bukkit.plugin.Plugin, org.bukkit.conversations.Conversable, org.bukkit.conversations.Prompt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initializes a new Conversation.

 @param plugin The plugin that owns this conversation.
 @param forWhom The entity for whom this conversation is mediating.
 @param firstPrompt The first prompt in the conversation graph.]]>
      </doc>
    </constructor>
    <constructor name="Conversation" type="org.bukkit.plugin.Plugin, org.bukkit.conversations.Conversable, org.bukkit.conversations.Prompt, java.util.Map&lt;java.lang.Object, java.lang.Object&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initializes a new Conversation.

 @param plugin The plugin that owns this conversation.
 @param forWhom The entity for whom this conversation is mediating.
 @param firstPrompt The first prompt in the conversation graph.
 @param initialSessionData Any initial values to put in the conversation
     context sessionData map.]]>
      </doc>
    </constructor>
    <method name="getForWhom" return="org.bukkit.conversations.Conversable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity for whom this conversation is mediating.

 @return The entity.]]>
      </doc>
    </method>
    <method name="isModal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the modality of this conversation. If a conversation is modal, all
 messages directed to the player are suppressed for the duration of the
 conversation.

 @return The conversation modality.]]>
      </doc>
    </method>
    <method name="isLocalEchoEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the status of local echo for this conversation. If local echo is
 enabled, any text submitted to a conversation gets echoed back into the
 submitter's chat window.

 @return The status of local echo.]]>
      </doc>
    </method>
    <method name="setLocalEchoEnabled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localEchoEnabled" type="boolean"/>
      <doc>
      <![CDATA[Sets the status of local echo for this conversation. If local echo is
 enabled, any text submitted to a conversation gets echoed back into the
 submitter's chat window.

 @param localEchoEnabled The status of local echo.]]>
      </doc>
    </method>
    <method name="getPrefix" return="org.bukkit.conversations.ConversationPrefix"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link ConversationPrefix} that prepends all output from this
 conversation.

 @return The ConversationPrefix in use.]]>
      </doc>
    </method>
    <method name="getCancellers" return="java.util.List&lt;org.bukkit.conversations.ConversationCanceller&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the list of {@link ConversationCanceller}s

 @return The list.]]>
      </doc>
    </method>
    <method name="getContext" return="org.bukkit.conversations.ConversationContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Conversation's {@link ConversationContext}.

 @return The ConversationContext.]]>
      </doc>
    </method>
    <method name="begin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Displays the first prompt of this conversation and begins redirecting
 the user's chat responses.]]>
      </doc>
    </method>
    <method name="getState" return="org.bukkit.conversations.Conversation.ConversationState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns Returns the current state of the conversation.

 @return The current state of the conversation.]]>
      </doc>
    </method>
    <method name="acceptInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Passes player input into the current prompt. The next prompt (as
 determined by the current prompt) is then displayed to the user.

 @param input The user's chat text.]]>
      </doc>
    </method>
    <method name="addConversationAbandonedListener"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.conversations.ConversationAbandonedListener"/>
      <doc>
      <![CDATA[Adds a {@link ConversationAbandonedListener}.

 @param listener The listener to add.]]>
      </doc>
    </method>
    <method name="removeConversationAbandonedListener"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.conversations.ConversationAbandonedListener"/>
      <doc>
      <![CDATA[Removes a {@link ConversationAbandonedListener}.

 @param listener The listener to remove.]]>
      </doc>
    </method>
    <method name="abandon"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Abandons and resets the current conversation. Restores the user's
 normal chat behavior.]]>
      </doc>
    </method>
    <method name="abandon"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="details" type="org.bukkit.conversations.ConversationAbandonedEvent"/>
      <doc>
      <![CDATA[Abandons and resets the current conversation. Restores the user's
 normal chat behavior.

 @param details Details about why the conversation was abandoned]]>
      </doc>
    </method>
    <method name="outputNextPrompt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Displays the next user prompt and abandons the conversation if the next
 prompt is null.]]>
      </doc>
    </method>
    <field name="currentPrompt" type="org.bukkit.conversations.Prompt"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="context" type="org.bukkit.conversations.ConversationContext"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="modal" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="localEchoEnabled" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="prefix" type="org.bukkit.conversations.ConversationPrefix"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="cancellers" type="java.util.List&lt;org.bukkit.conversations.ConversationCanceller&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="abandonedListeners" type="java.util.List&lt;org.bukkit.conversations.ConversationAbandonedListener&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The Conversation class is responsible for tracking the current state of a
 conversation, displaying prompts to the user, and dispatching the user's
 response to the appropriate place. Conversation objects are not typically
 instantiated directly. Instead a {@link ConversationFactory} is used to
 construct identical conversations on demand.
 <p>
 Conversation flow consists of a directed graph of {@link Prompt} objects.
 Each time a prompt gets input from the user, it must return the next prompt
 in the graph. Since each Prompt chooses the next Prompt, complex
 conversation trees can be implemented where the nature of the player's
 response directs the flow of the conversation.
 <p>
 Each conversation has a {@link ConversationPrefix} that prepends all output
 from the conversation to the player. The ConversationPrefix can be used to
 display the plugin name or conversation status as the conversation evolves.
 <p>
 Each conversation has a timeout measured in the number of inactive seconds
 to wait before abandoning the conversation. If the inactivity timeout is
 reached, the conversation is abandoned and the user's incoming and outgoing
 chat is returned to normal.
 <p>
 You should not construct a conversation manually. Instead, use the {@link
 ConversationFactory} for access to all available options.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.Conversation -->
  <!-- start class org.bukkit.conversations.Conversation.ConversationState -->
  <class name="Conversation.ConversationState" extends="java.lang.Enum&lt;org.bukkit.conversations.Conversation.ConversationState&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.conversations.Conversation.ConversationState[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.conversations.Conversation.ConversationState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.conversations.Conversation.ConversationState -->
  <!-- start class org.bukkit.conversations.ConversationAbandonedEvent -->
  <class name="ConversationAbandonedEvent" extends="java.util.EventObject"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConversationAbandonedEvent" type="org.bukkit.conversations.Conversation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ConversationAbandonedEvent" type="org.bukkit.conversations.Conversation, org.bukkit.conversations.ConversationCanceller"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCanceller" return="org.bukkit.conversations.ConversationCanceller"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the object that caused the conversation to be abandoned.

 @return The object that abandoned the conversation.]]>
      </doc>
    </method>
    <method name="getContext" return="org.bukkit.conversations.ConversationContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the abandoned conversation's conversation context.

 @return The abandoned conversation's conversation context.]]>
      </doc>
    </method>
    <method name="gracefulExit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates how the conversation was abandoned - naturally as part of the
 prompt chain or prematurely via a {@link ConversationCanceller}.

 @return True if the conversation is abandoned gracefully by a {@link
     Prompt} returning null or the next prompt. False of the
     conversations is abandoned prematurely by a ConversationCanceller.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[ConversationAbandonedEvent contains information about an abandoned
 conversation.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.ConversationAbandonedEvent -->
  <!-- start interface org.bukkit.conversations.ConversationAbandonedListener -->
  <interface name="ConversationAbandonedListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.EventListener"/>
    <method name="conversationAbandoned"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="abandonedEvent" type="org.bukkit.conversations.ConversationAbandonedEvent"/>
      <doc>
      <![CDATA[Called whenever a {@link Conversation} is abandoned.

 @param abandonedEvent Contains details about the abandoned
     conversation.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.conversations.ConversationAbandonedListener -->
  <!-- start interface org.bukkit.conversations.ConversationCanceller -->
  <interface name="ConversationCanceller"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <method name="setConversation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conversation" type="org.bukkit.conversations.Conversation"/>
      <doc>
      <![CDATA[Sets the conversation this ConversationCanceller can optionally cancel.

 @param conversation A conversation.]]>
      </doc>
    </method>
    <method name="cancelBasedOnInput" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Cancels a conversation based on user input.

 @param context Context information about the conversation.
 @param input The input text from the user.
 @return True to cancel the conversation, False otherwise.]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.conversations.ConversationCanceller"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows the {@link ConversationFactory} to duplicate this
 ConversationCanceller when creating a new {@link Conversation}.
 <p>
 Implementing this method should reset any internal object state.

 @return A clone.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A ConversationCanceller is a class that cancels an active {@link
 Conversation}. A Conversation can have more than one ConversationCanceller.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.conversations.ConversationCanceller -->
  <!-- start class org.bukkit.conversations.ConversationContext -->
  <class name="ConversationContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConversationContext" type="org.bukkit.plugin.Plugin, org.bukkit.conversations.Conversable, java.util.Map&lt;java.lang.Object, java.lang.Object&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param plugin The owning plugin.
 @param forWhom The subject of the conversation.
 @param initialSessionData Any initial values to put in the sessionData
     map.]]>
      </doc>
    </constructor>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin that owns this conversation.

 @return The owning plugin.]]>
      </doc>
    </method>
    <method name="getForWhom" return="org.bukkit.conversations.Conversable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the subject of the conversation.

 @return The subject of the conversation.]]>
      </doc>
    </method>
    <method name="getAllSessionData" return="java.util.Map&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the underlying sessionData map.

 May be directly modified to manipulate session data.

 @return The full sessionData map.]]>
      </doc>
    </method>
    <method name="getSessionData" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Gets session data shared between all {@link Prompt} invocations. Use
 this as a way to pass data through each Prompt as the conversation
 develops.

 @param key The session data key.
 @return The requested session data.]]>
      </doc>
    </method>
    <method name="setSessionData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets session data shared between all {@link Prompt} invocations. Use
 this as a way to pass data through each prompt as the conversation
 develops.

 @param key The session data key.
 @param value The session data value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A ConversationContext provides continuity between nodes in the prompt graph
 by giving the developer access to the subject of the conversation and a
 generic map for storing values that are shared between all {@link Prompt}
 invocations.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.ConversationContext -->
  <!-- start class org.bukkit.conversations.ConversationFactory -->
  <class name="ConversationFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConversationFactory" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a ConversationFactory.

 @param plugin The plugin that owns the factory.]]>
      </doc>
    </constructor>
    <method name="withModality" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modal" type="boolean"/>
      <doc>
      <![CDATA[Sets the modality of all {@link Conversation}s created by this factory.
 If a conversation is modal, all messages directed to the player are
 suppressed for the duration of the conversation.
 <p>
 The default is True.

 @param modal The modality of all conversations to be created.
 @return This object.]]>
      </doc>
    </method>
    <method name="withLocalEcho" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localEchoEnabled" type="boolean"/>
      <doc>
      <![CDATA[Sets the local echo status for all {@link Conversation}s created by
 this factory. If local echo is enabled, any text submitted to a
 conversation gets echoed back into the submitter's chat window.

 @param localEchoEnabled The status of local echo.
 @return This object.]]>
      </doc>
    </method>
    <method name="withPrefix" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="org.bukkit.conversations.ConversationPrefix"/>
      <doc>
      <![CDATA[Sets the {@link ConversationPrefix} that prepends all output from all
 generated conversations.
 <p>
 The default is a {@link NullConversationPrefix};

 @param prefix The ConversationPrefix to use.
 @return This object.]]>
      </doc>
    </method>
    <method name="withTimeout" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="int"/>
      <doc>
      <![CDATA[Sets the number of inactive seconds to wait before automatically
 abandoning all generated conversations.
 <p>
 The default is 600 seconds (5 minutes).

 @param timeoutSeconds The number of seconds to wait.
 @return This object.]]>
      </doc>
    </method>
    <method name="withFirstPrompt" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="firstPrompt" type="org.bukkit.conversations.Prompt"/>
      <doc>
      <![CDATA[Sets the first prompt to use in all generated conversations.
 <p>
 The default is Prompt.END_OF_CONVERSATION.

 @param firstPrompt The first prompt.
 @return This object.]]>
      </doc>
    </method>
    <method name="withInitialSessionData" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialSessionData" type="java.util.Map&lt;java.lang.Object, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Sets any initial data with which to populate the conversation context
 sessionData map.

 @param initialSessionData The conversation context's initial
     sessionData.
 @return This object.]]>
      </doc>
    </method>
    <method name="withEscapeSequence" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="escapeSequence" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the player input that, when received, will immediately terminate
 the conversation.

 @param escapeSequence Input to terminate the conversation.
 @return This object.]]>
      </doc>
    </method>
    <method name="withConversationCanceller" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canceller" type="org.bukkit.conversations.ConversationCanceller"/>
      <doc>
      <![CDATA[Adds a {@link ConversationCanceller} to constructed conversations.

 @param canceller The {@link ConversationCanceller} to add.
 @return This object.]]>
      </doc>
    </method>
    <method name="thatExcludesNonPlayersWithMessage" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="playerOnlyMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Prevents this factory from creating a conversation for non-player
 {@link Conversable} objects.

 @param playerOnlyMessage The message to return to a non-play in lieu of
     starting a conversation.
 @return This object.]]>
      </doc>
    </method>
    <method name="addConversationAbandonedListener" return="org.bukkit.conversations.ConversationFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.conversations.ConversationAbandonedListener"/>
      <doc>
      <![CDATA[Adds a {@link ConversationAbandonedListener} to all conversations
 constructed by this factory.

 @param listener The listener to add.
 @return This object.]]>
      </doc>
    </method>
    <method name="buildConversation" return="org.bukkit.conversations.Conversation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhom" type="org.bukkit.conversations.Conversable"/>
      <doc>
      <![CDATA[Constructs a {@link Conversation} in accordance with the defaults set
 for this factory.

 @param forWhom The entity for whom the new conversation is mediating.
 @return A new conversation.]]>
      </doc>
    </method>
    <field name="plugin" type="org.bukkit.plugin.Plugin"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="isModal" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="localEchoEnabled" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="prefix" type="org.bukkit.conversations.ConversationPrefix"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="firstPrompt" type="org.bukkit.conversations.Prompt"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="initialSessionData" type="java.util.Map&lt;java.lang.Object, java.lang.Object&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="playerOnlyMessage" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="cancellers" type="java.util.List&lt;org.bukkit.conversations.ConversationCanceller&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="abandonedListeners" type="java.util.List&lt;org.bukkit.conversations.ConversationAbandonedListener&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A ConversationFactory is responsible for creating a {@link Conversation}
 from a predefined template. A ConversationFactory is typically created when
 a plugin is instantiated and builds a Conversation each time a user
 initiates a conversation with the plugin. Each Conversation maintains its
 own state and calls back as needed into the plugin.
 <p>
 The ConversationFactory implements a fluid API, allowing parameters to be
 set as an extension to the constructor.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.ConversationFactory -->
  <!-- start interface org.bukkit.conversations.ConversationPrefix -->
  <interface name="ConversationPrefix"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPrefix" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Gets the prefix to use before each message to the player.

 @param context Context information about the conversation.
 @return The prefix text.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A ConversationPrefix implementation prepends all output from the
 conversation to the player. The ConversationPrefix can be used to display
 the plugin name or conversation status as the conversation evolves.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.conversations.ConversationPrefix -->
  <!-- start class org.bukkit.conversations.ExactMatchConversationCanceller -->
  <class name="ExactMatchConversationCanceller" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.conversations.ConversationCanceller"/>
    <constructor name="ExactMatchConversationCanceller" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds an ExactMatchConversationCanceller.

 @param escapeSequence The string that, if entered by the user, will
     cancel the conversation.]]>
      </doc>
    </constructor>
    <method name="setConversation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conversation" type="org.bukkit.conversations.Conversation"/>
    </method>
    <method name="cancelBasedOnInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="clone" return="org.bukkit.conversations.ConversationCanceller"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An ExactMatchConversationCanceller cancels a conversation if the user
 enters an exact input string]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.ExactMatchConversationCanceller -->
  <!-- start class org.bukkit.conversations.FixedSetPrompt -->
  <class name="FixedSetPrompt" extends="org.bukkit.conversations.ValidatingPrompt"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FixedSetPrompt" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a FixedSetPrompt from a set of strings.
 <p>
 foo = new FixedSetPrompt("bar", "cheese", "panda");

 @param fixedSet A fixed set of strings, one of which the user must
     type.]]>
      </doc>
    </constructor>
    <method name="isInputValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="formatFixedSet" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Utility function to create a formatted string containing all the
 options declared in the constructor.

 @return the options formatted like "[bar, cheese, panda]" if bar,
     cheese, and panda were the options used]]>
      </doc>
    </method>
    <field name="fixedSet" type="java.util.List&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[FixedSetPrompt is the base class for any prompt that requires a fixed set
 response from the user.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.FixedSetPrompt -->
  <!-- start class org.bukkit.conversations.InactivityConversationCanceller -->
  <class name="InactivityConversationCanceller" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.conversations.ConversationCanceller"/>
    <constructor name="InactivityConversationCanceller" type="org.bukkit.plugin.Plugin, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an InactivityConversationCanceller.

 @param plugin The owning plugin.
 @param timeoutSeconds The number of seconds of inactivity to wait.]]>
      </doc>
    </constructor>
    <method name="setConversation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conversation" type="org.bukkit.conversations.Conversation"/>
    </method>
    <method name="cancelBasedOnInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="clone" return="org.bukkit.conversations.ConversationCanceller"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cancelling"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conversation" type="org.bukkit.conversations.Conversation"/>
      <doc>
      <![CDATA[Subclasses of InactivityConversationCanceller can override this method
 to take additional actions when the inactivity timer abandons the
 conversation.

 @param conversation The conversation being abandoned.]]>
      </doc>
    </method>
    <field name="plugin" type="org.bukkit.plugin.Plugin"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="timeoutSeconds" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="conversation" type="org.bukkit.conversations.Conversation"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An InactivityConversationCanceller will cancel a {@link Conversation} after
 a period of inactivity by the user.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.InactivityConversationCanceller -->
  <!-- start class org.bukkit.conversations.ManuallyAbandonedConversationCanceller -->
  <class name="ManuallyAbandonedConversationCanceller" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.conversations.ConversationCanceller"/>
    <constructor name="ManuallyAbandonedConversationCanceller"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConversation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conversation" type="org.bukkit.conversations.Conversation"/>
    </method>
    <method name="cancelBasedOnInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="clone" return="org.bukkit.conversations.ConversationCanceller"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The ManuallyAbandonedConversationCanceller is only used as part of a {@link
 ConversationAbandonedEvent} to indicate that the conversation was manually
 abandoned by programmatically calling the abandon() method on it.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.ManuallyAbandonedConversationCanceller -->
  <!-- start class org.bukkit.conversations.MessagePrompt -->
  <class name="MessagePrompt" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.conversations.Prompt"/>
    <constructor name="MessagePrompt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="blocksForInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Message prompts never wait for user input before continuing.

 @param context Context information about the conversation.
 @return Always false.]]>
      </doc>
    </method>
    <method name="acceptInput" return="org.bukkit.conversations.Prompt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Accepts and ignores any user input, returning the next prompt in the
 prompt graph instead.

 @param context Context information about the conversation.
 @param input Ignored.
 @return The next prompt in the prompt graph.]]>
      </doc>
    </method>
    <method name="getNextPrompt" return="org.bukkit.conversations.Prompt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Override this method to return the next prompt in the prompt graph.

 @param context Context information about the conversation.
 @return The next prompt in the prompt graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[MessagePrompt is the base class for any prompt that only displays a message
 to the user and requires no input.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.MessagePrompt -->
  <!-- start class org.bukkit.conversations.NullConversationPrefix -->
  <class name="NullConversationPrefix" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.conversations.ConversationPrefix"/>
    <constructor name="NullConversationPrefix"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Prepends each conversation message with an empty string.

 @param context Context information about the conversation.
 @return An empty string.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[NullConversationPrefix is a {@link ConversationPrefix} implementation that
 displays nothing in front of conversation output.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.NullConversationPrefix -->
  <!-- start class org.bukkit.conversations.NumericPrompt -->
  <class name="NumericPrompt" extends="org.bukkit.conversations.ValidatingPrompt"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NumericPrompt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isInputValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="isNumberValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.Number"/>
      <doc>
      <![CDATA[Override this method to do further validation on the numeric player
 input after the input has been determined to actually be a number.

 @param context Context information about the conversation.
 @param input The number the player provided.
 @return The validity of the player's input.]]>
      </doc>
    </method>
    <method name="acceptValidatedInput" return="org.bukkit.conversations.Prompt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="acceptValidatedInput" return="org.bukkit.conversations.Prompt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.Number"/>
      <doc>
      <![CDATA[Override this method to perform some action with the user's integer
 response.

 @param context Context information about the conversation.
 @param input The user's response as a {@link Number}.
 @return The next {@link Prompt} in the prompt graph.]]>
      </doc>
    </method>
    <method name="getFailedValidationText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="invalidInput" type="java.lang.String"/>
    </method>
    <method name="getInputNotNumericText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="invalidInput" type="java.lang.String"/>
      <doc>
      <![CDATA[Optionally override this method to display an additional message if the
 user enters an invalid number.

 @param context Context information about the conversation.
 @param invalidInput The invalid input provided by the user.
 @return A message explaining how to correct the input.]]>
      </doc>
    </method>
    <method name="getFailedValidationText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="invalidInput" type="java.lang.Number"/>
      <doc>
      <![CDATA[Optionally override this method to display an additional message if the
 user enters an invalid numeric input.

 @param context Context information about the conversation.
 @param invalidInput The invalid input provided by the user.
 @return A message explaining how to correct the input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[NumericPrompt is the base class for any prompt that requires a {@link
 Number} response from the user.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.NumericPrompt -->
  <!-- start class org.bukkit.conversations.PlayerNamePrompt -->
  <class name="PlayerNamePrompt" extends="org.bukkit.conversations.ValidatingPrompt"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerNamePrompt" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isInputValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="acceptValidatedInput" return="org.bukkit.conversations.Prompt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <method name="acceptValidatedInput" return="org.bukkit.conversations.Prompt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Override this method to perform some action with the user's player name
 response.

 @param context Context information about the conversation.
 @param input The user's player name response.
 @return The next {@link Prompt} in the prompt graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[PlayerNamePrompt is the base class for any prompt that requires the player
 to enter another player's name.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.PlayerNamePrompt -->
  <!-- start class org.bukkit.conversations.PluginNameConversationPrefix -->
  <class name="PluginNameConversationPrefix" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.conversations.ConversationPrefix"/>
    <constructor name="PluginNameConversationPrefix" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PluginNameConversationPrefix" type="org.bukkit.plugin.Plugin, java.lang.String, org.bukkit.ChatColor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Prepends each conversation message with the plugin name.

 @param context Context information about the conversation.
 @return An empty string.]]>
      </doc>
    </method>
    <field name="separator" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="prefixColor" type="org.bukkit.ChatColor"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="plugin" type="org.bukkit.plugin.Plugin"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[PluginNameConversationPrefix is a {@link ConversationPrefix} implementation
 that displays the plugin name in front of conversation output.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.PluginNameConversationPrefix -->
  <!-- start interface org.bukkit.conversations.Prompt -->
  <interface name="Prompt"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <method name="getPromptText" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Gets the text to display to the user when this prompt is first
 presented.

 @param context Context information about the conversation.
 @return The text to display.]]>
      </doc>
    </method>
    <method name="blocksForInput" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Checks to see if this prompt implementation should wait for user input
 or immediately display the next prompt.

 @param context Context information about the conversation.
 @return If true, the {@link Conversation} will wait for input before
     continuing. If false, {@link #acceptInput(ConversationContext, String)} will be called immediately with {@code null} input.]]>
      </doc>
    </method>
    <method name="acceptInput" return="org.bukkit.conversations.Prompt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Accepts and processes input from the user. Using the input, the next
 Prompt in the prompt graph is returned.

 @param context Context information about the conversation.
 @param input The input text from the user.
 @return The next Prompt in the prompt graph.]]>
      </doc>
    </method>
    <field name="END_OF_CONVERSATION" type="org.bukkit.conversations.Prompt"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A convenience constant for indicating the end of a conversation.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A Prompt is the main constituent of a {@link Conversation}. Each prompt
 displays text to the user and optionally waits for a user's response.
 Prompts are chained together into a directed graph that represents the
 conversation flow. To halt a conversation, END_OF_CONVERSATION is returned
 in liu of another Prompt object.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.conversations.Prompt -->
  <!-- start class org.bukkit.conversations.RegexPrompt -->
  <class name="RegexPrompt" extends="org.bukkit.conversations.ValidatingPrompt"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RegexPrompt" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RegexPrompt" type="java.util.regex.Pattern"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isInputValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[RegexPrompt is the base class for any prompt that requires an input
 validated by a regular expression.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.RegexPrompt -->
  <!-- start class org.bukkit.conversations.StringPrompt -->
  <class name="StringPrompt" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.conversations.Prompt"/>
    <constructor name="StringPrompt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="blocksForInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Ensures that the prompt waits for the user to provide input.

 @param context Context information about the conversation.
 @return True.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[StringPrompt is the base class for any prompt that accepts an arbitrary
 string from the user.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.StringPrompt -->
  <!-- start class org.bukkit.conversations.ValidatingPrompt -->
  <class name="ValidatingPrompt" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.conversations.Prompt"/>
    <constructor name="ValidatingPrompt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="acceptInput" return="org.bukkit.conversations.Prompt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Accepts and processes input from the user and validates it. If
 validation fails, this prompt is returned for re-execution, otherwise
 the next Prompt in the prompt graph is returned.

 @param context Context information about the conversation.
 @param input The input text from the user.
 @return This prompt or the next Prompt in the prompt graph.]]>
      </doc>
    </method>
    <method name="blocksForInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <doc>
      <![CDATA[Ensures that the prompt waits for the user to provide input.

 @param context Context information about the conversation.
 @return True.]]>
      </doc>
    </method>
    <method name="isInputValid" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Override this method to check the validity of the player's input.

 @param context Context information about the conversation.
 @param input The player's raw console input.
 @return True or false depending on the validity of the input.]]>
      </doc>
    </method>
    <method name="acceptValidatedInput" return="org.bukkit.conversations.Prompt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Override this method to accept and processes the validated input from
 the user. Using the input, the next Prompt in the prompt graph should
 be returned.

 @param context Context information about the conversation.
 @param input The validated input text from the user.
 @return The next Prompt in the prompt graph.]]>
      </doc>
    </method>
    <method name="getFailedValidationText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="org.bukkit.conversations.ConversationContext"/>
      <param name="invalidInput" type="java.lang.String"/>
      <doc>
      <![CDATA[Optionally override this method to display an additional message if the
 user enters an invalid input.

 @param context Context information about the conversation.
 @param invalidInput The invalid input provided by the user.
 @return A message explaining how to correct the input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[ValidatingPrompt is the base class for any prompt that requires validation.
 ValidatingPrompt will keep replaying the prompt text until the user enters
 a valid response.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.conversations.ValidatingPrompt -->
</package>
<package name="org.bukkit.enchantments">
  <!-- start class org.bukkit.enchantments.Enchantment -->
  <class name="Enchantment" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <constructor name="Enchantment" type="org.bukkit.NamespacedKey"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="enchantments are badly named, use {@link #getKey()}.">
      <doc>
      <![CDATA[Gets the unique name of this enchantment

 @return Unique name
 @deprecated enchantments are badly named, use {@link #getKey()}.]]>
      </doc>
    </method>
    <method name="getMaxLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum level that this Enchantment may become.

 @return Maximum level of the Enchantment]]>
      </doc>
    </method>
    <method name="getStartLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the level that this Enchantment should start at

 @return Starting level of the Enchantment]]>
      </doc>
    </method>
    <method name="getItemTarget" return="org.bukkit.enchantments.EnchantmentTarget"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of {@link ItemStack} that may fit this Enchantment.

 @return Target type of the Enchantment]]>
      </doc>
    </method>
    <method name="isTreasure" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this enchantment is a treasure enchantment.
 <br>
 Treasure enchantments can only be received via looting, trading, or
 fishing.

 @return true if the enchantment is a treasure enchantment]]>
      </doc>
    </method>
    <method name="isCursed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="cursed enchantments are no longer special. Will return true
 only for {@link Enchantment#BINDING_CURSE} and
 {@link Enchantment#VANISHING_CURSE}.">
      <doc>
      <![CDATA[Checks if this enchantment is a cursed enchantment
 <br>
 Cursed enchantments are found the same way treasure enchantments are

 @return true if the enchantment is cursed
 @deprecated cursed enchantments are no longer special. Will return true
 only for {@link Enchantment#BINDING_CURSE} and
 {@link Enchantment#VANISHING_CURSE}.]]>
      </doc>
    </method>
    <method name="conflictsWith" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Check if this enchantment conflicts with another enchantment.

 @param other The enchantment to check against
 @return True if there is a conflict.]]>
      </doc>
    </method>
    <method name="canEnchantItem" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Checks if this Enchantment may be applied to the given {@link
 ItemStack}.
 <p>
 This does not check if it conflicts with any enchantments already
 applied to the item.

 @param item Item to test
 @return True if the enchantment may be applied, otherwise False]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerEnchantment"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enchantment" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Registers an enchantment with the given ID and object.
 <p>
 Generally not to be used from within a plugin.

 @param enchantment Enchantment to register]]>
      </doc>
    </method>
    <method name="isAcceptingRegistrations" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this is accepting Enchantment registrations.

 @return True if the server Implementation may add enchantments]]>
      </doc>
    </method>
    <method name="stopAcceptingRegistrations"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops accepting any enchantment registrations]]>
      </doc>
    </method>
    <method name="getByKey" return="org.bukkit.enchantments.Enchantment"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Gets the Enchantment at the specified key

 @param key key to fetch
 @return Resulting Enchantment, or null if not found]]>
      </doc>
    </method>
    <method name="getByName" return="org.bukkit.enchantments.Enchantment"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="enchantments are badly named, use {@link #getByKey(org.bukkit.NamespacedKey)}.">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the Enchantment at the specified name

 @param name Name to fetch
 @return Resulting Enchantment, or null if not found
 @deprecated enchantments are badly named, use {@link #getByKey(org.bukkit.NamespacedKey)}.]]>
      </doc>
    </method>
    <method name="values" return="org.bukkit.enchantments.Enchantment[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an array of all the registered {@link Enchantment}s

 @return Array of enchantments]]>
      </doc>
    </method>
    <field name="PROTECTION_ENVIRONMENTAL" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides protection against environmental damage]]>
      </doc>
    </field>
    <field name="PROTECTION_FIRE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides protection against fire damage]]>
      </doc>
    </field>
    <field name="PROTECTION_FALL" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides protection against fall damage]]>
      </doc>
    </field>
    <field name="PROTECTION_EXPLOSIONS" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides protection against explosive damage]]>
      </doc>
    </field>
    <field name="PROTECTION_PROJECTILE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides protection against projectile damage]]>
      </doc>
    </field>
    <field name="OXYGEN" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decreases the rate of air loss whilst underwater]]>
      </doc>
    </field>
    <field name="WATER_WORKER" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases the speed at which a player may mine underwater]]>
      </doc>
    </field>
    <field name="THORNS" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Damages the attacker]]>
      </doc>
    </field>
    <field name="DEPTH_STRIDER" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases walking speed while in water]]>
      </doc>
    </field>
    <field name="FROST_WALKER" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Freezes any still water adjacent to ice / frost which player is walking on]]>
      </doc>
    </field>
    <field name="BINDING_CURSE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Item cannot be removed]]>
      </doc>
    </field>
    <field name="DAMAGE_ALL" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases damage against all targets]]>
      </doc>
    </field>
    <field name="DAMAGE_UNDEAD" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases damage against undead targets]]>
      </doc>
    </field>
    <field name="DAMAGE_ARTHROPODS" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases damage against arthropod targets]]>
      </doc>
    </field>
    <field name="KNOCKBACK" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All damage to other targets will knock them back when hit]]>
      </doc>
    </field>
    <field name="FIRE_ASPECT" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When attacking a target, has a chance to set them on fire]]>
      </doc>
    </field>
    <field name="LOOT_BONUS_MOBS" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides a chance of gaining extra loot when killing monsters]]>
      </doc>
    </field>
    <field name="SWEEPING_EDGE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases damage against targets when using a sweep attack]]>
      </doc>
    </field>
    <field name="DIG_SPEED" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases the rate at which you mine/dig]]>
      </doc>
    </field>
    <field name="SILK_TOUCH" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows blocks to drop themselves instead of fragments (for example,
 stone instead of cobblestone)]]>
      </doc>
    </field>
    <field name="DURABILITY" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decreases the rate at which a tool looses durability]]>
      </doc>
    </field>
    <field name="LOOT_BONUS_BLOCKS" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides a chance of gaining extra loot when destroying blocks]]>
      </doc>
    </field>
    <field name="ARROW_DAMAGE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides extra damage when shooting arrows from bows]]>
      </doc>
    </field>
    <field name="ARROW_KNOCKBACK" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides a knockback when an entity is hit by an arrow from a bow]]>
      </doc>
    </field>
    <field name="ARROW_FIRE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets entities on fire when hit by arrows shot from a bow]]>
      </doc>
    </field>
    <field name="ARROW_INFINITE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides infinite arrows when shooting a bow]]>
      </doc>
    </field>
    <field name="LUCK" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decreases odds of catching worthless junk]]>
      </doc>
    </field>
    <field name="LURE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases rate of fish biting your hook]]>
      </doc>
    </field>
    <field name="LOYALTY" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Causes a thrown trident to return to the player who threw it]]>
      </doc>
    </field>
    <field name="IMPALING" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Deals more damage to mobs that live in the ocean]]>
      </doc>
    </field>
    <field name="RIPTIDE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When it is rainy, launches the player in the direction their trident is thrown]]>
      </doc>
    </field>
    <field name="CHANNELING" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Strikes lightning when a mob is hit with a trident if conditions are
 stormy]]>
      </doc>
    </field>
    <field name="MULTISHOT" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shoot multiple arrows from crossbows]]>
      </doc>
    </field>
    <field name="QUICK_CHARGE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Charges crossbows quickly]]>
      </doc>
    </field>
    <field name="PIERCING" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Crossbow projectiles pierce entities]]>
      </doc>
    </field>
    <field name="MENDING" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows mending the item using experience orbs]]>
      </doc>
    </field>
    <field name="VANISHING_CURSE" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Item disappears instead of dropping]]>
      </doc>
    </field>
    <field name="SOUL_SPEED" type="org.bukkit.enchantments.Enchantment"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Walk quicker on soul blocks]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The various type of enchantments that may be added to armour or weapons]]>
    </doc>
  </class>
  <!-- end class org.bukkit.enchantments.Enchantment -->
  <!-- start class org.bukkit.enchantments.EnchantmentOffer -->
  <class name="EnchantmentOffer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EnchantmentOffer" type="org.bukkit.enchantments.Enchantment, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEnchantment" return="org.bukkit.enchantments.Enchantment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of the enchantment.

 @return type of enchantment]]>
      </doc>
    </method>
    <method name="setEnchantment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enchantment" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Sets the type of the enchantment.

 @param enchantment type of the enchantment]]>
      </doc>
    </method>
    <method name="getEnchantmentLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the level of the enchantment.

 @return level of the enchantment]]>
      </doc>
    </method>
    <method name="setEnchantmentLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enchantmentLevel" type="int"/>
      <doc>
      <![CDATA[Sets the level of the enchantment.

 @param enchantmentLevel level of the enchantment]]>
      </doc>
    </method>
    <method name="getCost" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cost (minimum level) which is displayed as a number on the right
 hand side of the enchantment offer.

 @return cost for this enchantment]]>
      </doc>
    </method>
    <method name="setCost"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cost" type="int"/>
      <doc>
      <![CDATA[Sets the cost (minimum level) which is displayed as a number on the right
 hand side of the enchantment offer.

 @param cost cost for this enchantment]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for the available enchantment offers in the enchantment table.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.enchantments.EnchantmentOffer -->
  <!-- start class org.bukkit.enchantments.EnchantmentTarget -->
  <class name="EnchantmentTarget" extends="java.lang.Enum&lt;org.bukkit.enchantments.EnchantmentTarget&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.enchantments.EnchantmentTarget[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.enchantments.EnchantmentTarget"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="includes" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Check whether this target includes the specified item.

 @param item The item to check
 @return True if the target includes the item]]>
      </doc>
    </method>
    <method name="includes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Check whether this target includes the specified item.

 @param item The item to check
 @return True if the target includes the item]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the applicable target for a {@link Enchantment}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.enchantments.EnchantmentTarget -->
  <!-- start class org.bukkit.enchantments.EnchantmentWrapper -->
  <class name="EnchantmentWrapper" extends="org.bukkit.enchantments.Enchantment"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EnchantmentWrapper" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEnchantment" return="org.bukkit.enchantments.Enchantment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the enchantment bound to this wrapper

 @return Enchantment]]>
      </doc>
    </method>
    <method name="getMaxLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStartLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getItemTarget" return="org.bukkit.enchantments.EnchantmentTarget"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="canEnchantItem" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTreasure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCursed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="conflictsWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.enchantments.Enchantment"/>
    </method>
    <doc>
    <![CDATA[A simple wrapper for ease of selecting {@link Enchantment}s]]>
    </doc>
  </class>
  <!-- end class org.bukkit.enchantments.EnchantmentWrapper -->
</package>
<package name="org.bukkit.entity">
  <!-- start interface org.bukkit.entity.AbstractArrow -->
  <interface name="AbstractArrow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Projectile"/>
    <method name="getKnockbackStrength" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the knockback strength for an arrow, which is the
 {@link org.bukkit.enchantments.Enchantment#KNOCKBACK KnockBack} level
 of the bow that shot it.

 @return the knockback strength value]]>
      </doc>
    </method>
    <method name="setKnockbackStrength"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="knockbackStrength" type="int"/>
      <doc>
      <![CDATA[Sets the knockback strength for an arrow.

 @param knockbackStrength the knockback strength value]]>
      </doc>
    </method>
    <method name="getDamage" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the base amount of damage this arrow will do.

 Defaults to 2.0 for a normal arrow with
 <code>0.5 * (1 + power level)</code> added for arrows fired from
 enchanted bows.

 @return base damage amount]]>
      </doc>
    </method>
    <method name="setDamage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="double"/>
      <doc>
      <![CDATA[Sets the base amount of damage this arrow will do.

 @param damage new damage amount]]>
      </doc>
    </method>
    <method name="getPierceLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of times this arrow can pierce through an entity.

 @return pierce level]]>
      </doc>
    </method>
    <method name="setPierceLevel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pierceLevel" type="int"/>
      <doc>
      <![CDATA[Sets the number of times this arrow can pierce through an entity.

 Must be between 0 and 127 times.

 @param pierceLevel new pierce level]]>
      </doc>
    </method>
    <method name="isCritical" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this arrow is critical.
 <p>
 Critical arrows have increased damage and cause particle effects.
 <p>
 Critical arrows generally occur when a player fully draws a bow before
 firing.

 @return true if it is critical]]>
      </doc>
    </method>
    <method name="setCritical"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="critical" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not this arrow should be critical.

 @param critical whether or not it should be critical]]>
      </doc>
    </method>
    <method name="isInBlock" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this arrow is in a block or not.
 <p>
 Arrows in a block are motionless and may be picked up by players.

 @return true if in a block]]>
      </doc>
    </method>
    <method name="getAttachedBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block to which this arrow is attached.

 @return the attached block or null if not attached]]>
      </doc>
    </method>
    <method name="getPickupStatus" return="org.bukkit.entity.AbstractArrow.PickupStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current pickup status of this arrow.

 @return the pickup status of this arrow.]]>
      </doc>
    </method>
    <method name="setPickupStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="status" type="org.bukkit.entity.AbstractArrow.PickupStatus"/>
      <doc>
      <![CDATA[Sets the current pickup status of this arrow.

 @param status new pickup status of this arrow.]]>
      </doc>
    </method>
    <method name="isShotFromCrossbow" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if this arrow was shot from a crossbow.

 @return if shot from a crossbow]]>
      </doc>
    </method>
    <method name="setShotFromCrossbow"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shotFromCrossbow" type="boolean"/>
      <doc>
      <![CDATA[Sets if this arrow was shot from a crossbow.

 @param shotFromCrossbow if shot from a crossbow]]>
      </doc>
    </method>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ItemStack for this arrow.

 @return The ItemStack, as if a player picked up the arrow]]>
      </doc>
    </method>
    <method name="getPickupRule" return="org.bukkit.entity.AbstractArrow.PickupRule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link Arrow#getPickupStatus()} as an upstream compatible replacement for this function">
      <doc>
      <![CDATA[Gets the {@link PickupRule} for this arrow.

 <p>This is generally {@link PickupRule#ALLOWED} only if the arrow was
 <b>not</b> fired from a bow with the infinity enchantment.</p>

 @return The pickup rule
 @deprecated Use {@link Arrow#getPickupStatus()} as an upstream compatible replacement for this function]]>
      </doc>
    </method>
    <method name="setPickupRule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link Arrow#setPickupStatus(PickupStatus)} with {@link PickupStatus} as an upstream compatible replacement for this function">
      <param name="rule" type="org.bukkit.entity.AbstractArrow.PickupRule"/>
      <doc>
      <![CDATA[Set the rule for which players can pickup this arrow as an item.

 @param rule The pickup rule
 @deprecated Use {@link Arrow#setPickupStatus(PickupStatus)} with {@link PickupStatus} as an upstream compatible replacement for this function]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an arrow.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.AbstractArrow -->
  <!-- start class org.bukkit.entity.AbstractArrow.PickupRule -->
  <class name="AbstractArrow.PickupRule" extends="java.lang.Enum&lt;org.bukkit.entity.AbstractArrow.PickupRule&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.AbstractArrow.PickupRule[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.AbstractArrow.PickupRule"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.entity.AbstractArrow.PickupRule -->
  <!-- start class org.bukkit.entity.AbstractArrow.PickupStatus -->
  <class name="AbstractArrow.PickupStatus" extends="java.lang.Enum&lt;org.bukkit.entity.AbstractArrow.PickupStatus&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.AbstractArrow.PickupStatus[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.AbstractArrow.PickupStatus"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the pickup status of this arrow.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.AbstractArrow.PickupStatus -->
  <!-- start interface org.bukkit.entity.AbstractHorse -->
  <interface name="AbstractHorse"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Vehicle"/>
    <implements name="org.bukkit.inventory.InventoryHolder"/>
    <implements name="org.bukkit.entity.Tameable"/>
    <method name="getVariant" return="org.bukkit.entity.Horse.Variant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="different variants are different classes">
      <doc>
      <![CDATA[Gets the horse's variant.
 <p>
 A horse's variant defines its physical appearance and capabilities.
 Whether a horse is a regular horse, donkey, mule, or other kind of horse
 is determined using the variant.

 @return a {@link Horse.Variant} representing the horse's variant
 @deprecated different variants are different classes]]>
      </doc>
    </method>
    <method name="setVariant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="you are required to spawn a different entity">
      <param name="variant" type="org.bukkit.entity.Horse.Variant"/>
      <doc>
      <![CDATA[@param variant variant
 @deprecated you are required to spawn a different entity]]>
      </doc>
    </method>
    <method name="getDomestication" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the domestication level of this horse.
 <p>
 A higher domestication level indicates that the horse is closer to
 becoming tame. As the domestication level gets closer to the max
 domestication level, the chance of the horse becoming tame increases.

 @return domestication level]]>
      </doc>
    </method>
    <method name="setDomestication"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the domestication level of this horse.
 <p>
 Setting the domestication level to a high value will increase the
 horse's chances of becoming tame.
 <p>
 Domestication level must be greater than zero and no greater than
 the max domestication level of the horse, determined with
 {@link #getMaxDomestication()}

 @param level domestication level]]>
      </doc>
    </method>
    <method name="getMaxDomestication" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum domestication level of this horse.
 <p>
 The higher this level is, the longer it will likely take
 for the horse to be tamed.

 @return the max domestication level]]>
      </doc>
    </method>
    <method name="setMaxDomestication"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the maximum domestication level of this horse.
 <p>
 Setting a higher max domestication will increase the amount of
 domesticating (feeding, riding, etc.) necessary in order to tame it,
 while setting a lower max value will have the opposite effect.
 <p>
 Maximum domestication must be greater than zero.

 @param level the max domestication level]]>
      </doc>
    </method>
    <method name="getJumpStrength" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the jump strength of this horse.
 <p>
 Jump strength defines how high the horse can jump. A higher jump strength
 increases how high a jump will go.

 @return the horse's jump strength]]>
      </doc>
    </method>
    <method name="setJumpStrength"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strength" type="double"/>
      <doc>
      <![CDATA[Sets the jump strength of this horse.
 <p>
 A higher jump strength increases how high a jump will go.
 Setting a jump strength to 0 will result in no jump.
 You cannot set a jump strength to a value below 0 or
 above 2.

 @param strength jump strength for this horse]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.AbstractHorseInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a Horse-like creature.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.AbstractHorse -->
  <!-- start interface org.bukkit.entity.AbstractVillager -->
  <interface name="AbstractVillager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Breedable"/>
    <implements name="org.bukkit.entity.NPC"/>
    <implements name="org.bukkit.inventory.InventoryHolder"/>
    <implements name="org.bukkit.inventory.Merchant"/>
    <method name="getInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets this villager's inventory.
 <br>
 Note that this inventory is not the Merchant inventory, rather, it is the
 items that a villager might have collected (from harvesting crops, etc.)

 {@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a villager NPC]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.AbstractVillager -->
  <!-- start interface org.bukkit.entity.Ageable -->
  <interface name="Ageable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Creature"/>
    <method name="getAge" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the age of this mob.

 @return Age]]>
      </doc>
    </method>
    <method name="setAge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="age" type="int"/>
      <doc>
      <![CDATA[Sets the age of this mob.

 @param age New age]]>
      </doc>
    </method>
    <method name="setAgeLock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Breedable#setAgeLock(boolean)}">
      <param name="lock" type="boolean"/>
      <doc>
      <![CDATA[Lock the age of the animal, setting this will prevent the animal from
 maturing or getting ready for mating.

 @param lock new lock
 @deprecated see {@link Breedable#setAgeLock(boolean)}]]>
      </doc>
    </method>
    <method name="getAgeLock" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Breedable#getAgeLock()}">
      <doc>
      <![CDATA[Gets the current agelock.

 @return the current agelock
 @deprecated see {@link Breedable#getAgeLock()}]]>
      </doc>
    </method>
    <method name="setBaby"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the age of the mob to a baby]]>
      </doc>
    </method>
    <method name="setAdult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the age of the mob to an adult]]>
      </doc>
    </method>
    <method name="isAdult" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the mob is an adult.

 @return return true if the mob is an adult]]>
      </doc>
    </method>
    <method name="canBreed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Breedable#canBreed()}">
      <doc>
      <![CDATA[Return the ability to breed of the animal.

 @return the ability to breed of the animal
 @deprecated see {@link Breedable#canBreed()}]]>
      </doc>
    </method>
    <method name="setBreed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Breedable#setBreed(boolean)}">
      <param name="breed" type="boolean"/>
      <doc>
      <![CDATA[Set breedability of the animal, if the animal is a baby and set to
 breed it will instantly grow up.

 @param breed breedability of the animal
 @deprecated see {@link Breedable#setBreed(boolean)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an entity that can age.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Ageable -->
  <!-- start interface org.bukkit.entity.Ambient -->
  <interface name="Ambient"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Mob"/>
    <doc>
    <![CDATA[Represents an ambient mob]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Ambient -->
  <!-- start interface org.bukkit.entity.Animals -->
  <interface name="Animals"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Breedable"/>
    <method name="getBreedCause" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the UUID of the entity that caused this entity to enter the
 {@link #canBreed()} state.

 @return uuid if set, or null]]>
      </doc>
    </method>
    <method name="setBreedCause"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Set the UUID of the entity that caused this entity to enter the
 {@link #canBreed()} state.

 @param uuid new uuid, or null]]>
      </doc>
    </method>
    <method name="isLoveMode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether or not this entity is in love mode and will produce
 offspring with another entity in love mode. Will return true if
 and only if {@link #getLoveModeTicks()} is greater than 0.

 @return true if in love mode, false otherwise]]>
      </doc>
    </method>
    <method name="getLoveModeTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of ticks remaining for this entity in love mode.
 If the entity is not in love mode, 0 will be returned.

 @return the remaining love mode ticks]]>
      </doc>
    </method>
    <method name="setLoveModeTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Set the amount of ticks for which this entity should be in love mode.
 Setting the love mode ticks to 600 is the equivalent of a player
 feeding the entity their breeding item of choice.

 @param ticks the love mode ticks. Must be positive]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Animal.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Animals -->
  <!-- start interface org.bukkit.entity.AnimalTamer -->
  <interface name="AnimalTamer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is the name of the specified AnimalTamer.

 @return The name to reference on tamed animals or null if a name cannot be obtained]]>
      </doc>
    </method>
    <method name="getUniqueId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is the UUID of the specified AnimalTamer.

 @return The UUID to reference on tamed animals]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.AnimalTamer -->
  <!-- start interface org.bukkit.entity.AreaEffectCloud -->
  <interface name="AreaEffectCloud"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getDuration" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the duration which this cloud will exist for (in ticks).

 @return cloud duration]]>
      </doc>
    </method>
    <method name="setDuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="int"/>
      <doc>
      <![CDATA[Sets the duration which this cloud will exist for (in ticks).

 @param duration cloud duration]]>
      </doc>
    </method>
    <method name="getWaitTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the time which an entity has to be exposed to the cloud before the
 effect is applied.

 @return wait time]]>
      </doc>
    </method>
    <method name="setWaitTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="waitTime" type="int"/>
      <doc>
      <![CDATA[Sets the time which an entity has to be exposed to the cloud before the
 effect is applied.

 @param waitTime wait time]]>
      </doc>
    </method>
    <method name="getReapplicationDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the time that an entity will be immune from subsequent exposure.

 @return reapplication delay]]>
      </doc>
    </method>
    <method name="setReapplicationDelay"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="int"/>
      <doc>
      <![CDATA[Sets the time that an entity will be immune from subsequent exposure.

 @param delay reapplication delay]]>
      </doc>
    </method>
    <method name="getDurationOnUse" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount that the duration of this cloud will decrease by when it
 applies an effect to an entity.

 @return duration on use delta]]>
      </doc>
    </method>
    <method name="setDurationOnUse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="int"/>
      <doc>
      <![CDATA[Sets the amount that the duration of this cloud will decrease by when it
 applies an effect to an entity.

 @param duration duration on use delta]]>
      </doc>
    </method>
    <method name="getRadius" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the initial radius of the cloud.

 @return radius]]>
      </doc>
    </method>
    <method name="setRadius"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="float"/>
      <doc>
      <![CDATA[Sets the initial radius of the cloud.

 @param radius radius]]>
      </doc>
    </method>
    <method name="getRadiusOnUse" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount that the radius of this cloud will decrease by when it
 applies an effect to an entity.

 @return radius on use delta]]>
      </doc>
    </method>
    <method name="setRadiusOnUse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="float"/>
      <doc>
      <![CDATA[Sets the amount that the radius of this cloud will decrease by when it
 applies an effect to an entity.

 @param radius radius on use delta]]>
      </doc>
    </method>
    <method name="getRadiusPerTick" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount that the radius of this cloud will decrease by each tick.

 @return radius per tick delta]]>
      </doc>
    </method>
    <method name="setRadiusPerTick"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="float"/>
      <doc>
      <![CDATA[Gets the amount that the radius of this cloud will decrease by each tick.

 @param radius per tick delta]]>
      </doc>
    </method>
    <method name="getParticle" return="org.bukkit.Particle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the particle which this cloud will be composed of

 @return particle the set particle type]]>
      </doc>
    </method>
    <method name="setParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <doc>
      <![CDATA[Sets the particle which this cloud will be composed of

 @param particle the new particle type]]>
      </doc>
    </method>
    <method name="setParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Sets the particle which this cloud will be composed of

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the new particle type
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> the particle data type // Paper]]>
      </doc>
    </method>
    <method name="setBasePotionData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.potion.PotionData"/>
      <doc>
      <![CDATA[Sets the underlying potion data

 @param data PotionData to set the base potion state to]]>
      </doc>
    </method>
    <method name="getBasePotionData" return="org.bukkit.potion.PotionData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the potion data about the base potion

 @return a PotionData object]]>
      </doc>
    </method>
    <method name="hasCustomEffects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the presence of custom potion effects.

 @return true if custom potion effects are applied]]>
      </doc>
    </method>
    <method name="getCustomEffects" return="java.util.List&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an immutable list containing all custom potion effects applied to
 this cloud.
 <p>
 Plugins should check that hasCustomEffects() returns true before calling
 this method.

 @return the immutable list of custom potion effects]]>
      </doc>
    </method>
    <method name="addCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.potion.PotionEffect"/>
      <param name="overwrite" type="boolean"/>
      <doc>
      <![CDATA[Adds a custom potion effect to this cloud.

 @param effect the potion effect to add
 @param overwrite true if any existing effect of the same type should be
 overwritten
 @return true if the effect was added as a result of this call]]>
      </doc>
    </method>
    <method name="removeCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Removes a custom potion effect from this cloud.

 @param type the potion effect type to remove
 @return true if the an effect was removed as a result of this call]]>
      </doc>
    </method>
    <method name="hasCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Checks for a specific custom potion effect type on this cloud.

 @param type the potion effect type to check for
 @return true if the potion has this effect]]>
      </doc>
    </method>
    <method name="clearCustomEffects"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all custom potion effects from this cloud.]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color of this cloud. Will be applied as a tint to its particles.

 @return cloud color]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Sets the color of this cloud. Will be applied as a tint to its particles.

 @param color cloud color]]>
      </doc>
    </method>
    <method name="getSource" return="org.bukkit.projectiles.ProjectileSource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve the original source of this cloud.

 @return the {@link ProjectileSource} that threw the LingeringPotion]]>
      </doc>
    </method>
    <method name="setSource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.projectiles.ProjectileSource"/>
      <doc>
      <![CDATA[Set the original source of this cloud.

 @param source the {@link ProjectileSource} that threw the LingeringPotion]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an area effect cloud which will imbue a potion effect onto
 entities which enter it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.AreaEffectCloud -->
  <!-- start interface org.bukkit.entity.ArmorStand -->
  <interface name="ArmorStand"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.LivingEntity"/>
    <method name="getItemInHand" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer {@link ArmorStand#getItem(EquipmentSlot)} // Paper">
      <doc>
      <![CDATA[Returns the item the armor stand is currently holding.

 @return the held item
 @deprecated prefer {@link ArmorStand#getItem(EquipmentSlot)} // Paper
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="setItemInHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer
 {@link ArmorStand#setItem(EquipmentSlot, ItemStack)} // Paper">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item the armor stand is currently holding.

 @param item the item to hold
 @deprecated prefer
 {@link ArmorStand#setItem(EquipmentSlot, ItemStack)} // Paper
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="getBoots" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer {@link EntityEquipment#getBoots()}">
      <doc>
      <![CDATA[Returns the item currently being worn by the armor stand on its feet.

 @return the worn item
 @deprecated prefer {@link EntityEquipment#getBoots()}
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="setBoots"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer
 {@link EntityEquipment#setBoots(org.bukkit.inventory.ItemStack)}">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item currently being worn by the armor stand on its feet.

 @param item the item to wear
 @deprecated prefer
 {@link EntityEquipment#setBoots(org.bukkit.inventory.ItemStack)}
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="getLeggings" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer {@link EntityEquipment#getLeggings()}">
      <doc>
      <![CDATA[Returns the item currently being worn by the armor stand on its legs.

 @return the worn item
 @deprecated prefer {@link EntityEquipment#getLeggings()}
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="setLeggings"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer
 {@link EntityEquipment#setLeggings(org.bukkit.inventory.ItemStack)}">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item currently being worn by the armor stand on its legs.

 @param item the item to wear
 @deprecated prefer
 {@link EntityEquipment#setLeggings(org.bukkit.inventory.ItemStack)}
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="getChestplate" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer {@link EntityEquipment#getChestplate()}">
      <doc>
      <![CDATA[Returns the item currently being worn by the armor stand on its chest.

 @return the worn item
 @deprecated prefer {@link EntityEquipment#getChestplate()}
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="setChestplate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer
 {@link EntityEquipment#setChestplate(org.bukkit.inventory.ItemStack)}">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item currently being worn by the armor stand on its chest.

 @param item the item to wear
 @deprecated prefer
 {@link EntityEquipment#setChestplate(org.bukkit.inventory.ItemStack)}
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="getHelmet" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer {@link EntityEquipment#getHelmet()}">
      <doc>
      <![CDATA[Returns the item currently being worn by the armor stand on its head.

 @return the worn item
 @deprecated prefer {@link EntityEquipment#getHelmet()}
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="setHelmet"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="prefer
 {@link EntityEquipment#setHelmet(org.bukkit.inventory.ItemStack)}">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item currently being worn by the armor stand on its head.

 @param item the item to wear
 @deprecated prefer
 {@link EntityEquipment#setHelmet(org.bukkit.inventory.ItemStack)}
 @see #getEquipment()]]>
      </doc>
    </method>
    <method name="getBodyPose" return="org.bukkit.util.EulerAngle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the armor stand's body's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @return the current pose]]>
      </doc>
    </method>
    <method name="setBodyPose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pose" type="org.bukkit.util.EulerAngle"/>
      <doc>
      <![CDATA[Sets the armor stand's body's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @param pose the current pose]]>
      </doc>
    </method>
    <method name="getLeftArmPose" return="org.bukkit.util.EulerAngle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the armor stand's left arm's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @return the current pose]]>
      </doc>
    </method>
    <method name="setLeftArmPose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pose" type="org.bukkit.util.EulerAngle"/>
      <doc>
      <![CDATA[Sets the armor stand's left arm's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @param pose the current pose]]>
      </doc>
    </method>
    <method name="getRightArmPose" return="org.bukkit.util.EulerAngle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the armor stand's right arm's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @return the current pose]]>
      </doc>
    </method>
    <method name="setRightArmPose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pose" type="org.bukkit.util.EulerAngle"/>
      <doc>
      <![CDATA[Sets the armor stand's right arm's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @param pose the current pose]]>
      </doc>
    </method>
    <method name="getLeftLegPose" return="org.bukkit.util.EulerAngle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the armor stand's left leg's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @return the current pose]]>
      </doc>
    </method>
    <method name="setLeftLegPose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pose" type="org.bukkit.util.EulerAngle"/>
      <doc>
      <![CDATA[Sets the armor stand's left leg's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @param pose the current pose]]>
      </doc>
    </method>
    <method name="getRightLegPose" return="org.bukkit.util.EulerAngle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the armor stand's right leg's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @return the current pose]]>
      </doc>
    </method>
    <method name="setRightLegPose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pose" type="org.bukkit.util.EulerAngle"/>
      <doc>
      <![CDATA[Sets the armor stand's right leg's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @param pose the current pose]]>
      </doc>
    </method>
    <method name="getHeadPose" return="org.bukkit.util.EulerAngle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the armor stand's head's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @return the current pose]]>
      </doc>
    </method>
    <method name="setHeadPose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pose" type="org.bukkit.util.EulerAngle"/>
      <doc>
      <![CDATA[Sets the armor stand's head's current pose as a
 {@link org.bukkit.util.EulerAngle}.

 @param pose the current pose]]>
      </doc>
    </method>
    <method name="hasBasePlate" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the armor stand has a base plate.

 @return whether it has a base plate]]>
      </doc>
    </method>
    <method name="setBasePlate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePlate" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the armor stand has a base plate.

 @param basePlate whether is has a base plate]]>
      </doc>
    </method>
    <method name="isVisible" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the armor stand should be visible or not.

 @return whether the stand is visible or not]]>
      </doc>
    </method>
    <method name="setVisible"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visible" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the armor stand should be visible or not.

 @param visible whether the stand is visible or not]]>
      </doc>
    </method>
    <method name="hasArms" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this armor stand has arms.

 @return whether this has arms or not]]>
      </doc>
    </method>
    <method name="setArms"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arms" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this armor stand has arms.

 @param arms whether this has arms or not]]>
      </doc>
    </method>
    <method name="isSmall" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this armor stand is scaled down.

 @return whether this is scaled down]]>
      </doc>
    </method>
    <method name="setSmall"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="small" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this armor stand is scaled down.

 @param small whether this is scaled down]]>
      </doc>
    </method>
    <method name="isMarker" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this armor stand is a marker, meaning it has a very small
 collision box.

 @return whether this is a marker]]>
      </doc>
    </method>
    <method name="setMarker"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this armor stand is a marker, meaning it has a very small
 collision box.

 @param marker whether this is a marker]]>
      </doc>
    </method>
    <method name="addEquipmentLock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <param name="lockType" type="org.bukkit.entity.ArmorStand.LockType"/>
      <doc>
      <![CDATA[Locks the equipment slot with the specified
 {@link LockType locking mechanism}.

 @param slot the equipment slot to lock
 @param lockType the LockType to lock the equipment slot with]]>
      </doc>
    </method>
    <method name="removeEquipmentLock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <param name="lockType" type="org.bukkit.entity.ArmorStand.LockType"/>
      <doc>
      <![CDATA[Remove a {@link LockType locking mechanism}.

 @param slot the equipment slot to change
 @param lockType the lockType to remove]]>
      </doc>
    </method>
    <method name="hasEquipmentLock" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <param name="lockType" type="org.bukkit.entity.ArmorStand.LockType"/>
      <doc>
      <![CDATA[Returns if the ArmorStand has the specified
 {@link LockType locking mechanism}.

 @param slot the EquipmentSlot to test
 @param lockType the LockType to test
 @return if the ArmnorStand has been locked with the parameters specified]]>
      </doc>
    </method>
    <method name="canMove" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tests if this armor stand can move.

 <p>The default value is {@code true}.</p>

 @return {@code true} if this armour stand can move, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="setCanMove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="move" type="boolean"/>
      <doc>
      <![CDATA[Sets if this armor stand can move.

 @param move {@code true} if this armour stand can move, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="canTick" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tests if this armor stand can tick.

 <p>The default value is defined in {@code paper.yml}.</p>

 @return {@code true} if this armour stand can tick, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="setCanTick"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tick" type="boolean"/>
      <doc>
      <![CDATA[Sets if this armor stand can tick.

 @param tick {@code true} if this armour stand can tick, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <doc>
      <![CDATA[Returns the item the armor stand has
 equip in the given equipment slot

 @param slot the equipment slot to get
 @return the ItemStack in the equipment slot]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item the armor stand has
 equip in the given equipment slot

 @param slot the equipment slot to set
 @param item the item to hold]]>
      </doc>
    </method>
    <method name="getDisabledSlots" return="java.util.Set&lt;org.bukkit.inventory.EquipmentSlot&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the list of disabled slots

 @return list of disabled slots]]>
      </doc>
    </method>
    <method name="setDisabledSlots"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slots" type="org.bukkit.inventory.EquipmentSlot[]"/>
      <doc>
      <![CDATA[Set the disabled slots

 This makes it so a player is unable to interact with the Armor Stand to place, remove, or replace an item in the given slot(s)
 Note: Once a slot is disabled, the only way to get an item back it to break the armor stand.

 @param slots var-arg array of slots to lock]]>
      </doc>
    </method>
    <method name="addDisabledSlots"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slots" type="org.bukkit.inventory.EquipmentSlot[]"/>
      <doc>
      <![CDATA[Disable specific slots, adding them
 to the currently disabled slots

 This makes it so a player is unable to interact with the Armor Stand to place, remove, or replace an item in the given slot(s)
 Note: Once a slot is disabled, the only way to get an item back it to break the armor stand.

 @param slots var-arg array of slots to lock]]>
      </doc>
    </method>
    <method name="removeDisabledSlots"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slots" type="org.bukkit.inventory.EquipmentSlot[]"/>
      <doc>
      <![CDATA[Remove the given slots from the disabled
 slots list, enabling them.

 This makes it so a player is able to interact with the Armor Stand to place, remove, or replace an item in the given slot(s)

 @param slots var-arg array of slots to unlock]]>
      </doc>
    </method>
    <method name="isSlotDisabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <doc>
      <![CDATA[Check if a specific slot is disabled

 @param slot The slot to check
 @return {@code true} if the slot is disabled, else {@code false}.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.ArmorStand -->
  <!-- start class org.bukkit.entity.ArmorStand.LockType -->
  <class name="ArmorStand.LockType" extends="java.lang.Enum&lt;org.bukkit.entity.ArmorStand.LockType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.ArmorStand.LockType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.ArmorStand.LockType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents types of locking mechanisms for ArmorStand equipment.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.ArmorStand.LockType -->
  <!-- start interface org.bukkit.entity.Arrow -->
  <interface name="Arrow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractArrow"/>
    <method name="setBasePotionData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.potion.PotionData"/>
      <doc>
      <![CDATA[Sets the underlying potion data

 @param data PotionData to set the base potion state to]]>
      </doc>
    </method>
    <method name="getBasePotionData" return="org.bukkit.potion.PotionData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the potion data about the base potion

 @return a PotionData object]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color of this arrow.

 @return arrow color]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Sets the color of this arrow. Will be applied as a tint to its particles.

 @param color arrow color]]>
      </doc>
    </method>
    <method name="hasCustomEffects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the presence of custom potion effects.

 @return true if custom potion effects are applied]]>
      </doc>
    </method>
    <method name="getCustomEffects" return="java.util.List&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an immutable list containing all custom potion effects applied to
 this arrow.
 <p>
 Plugins should check that hasCustomEffects() returns true before calling
 this method.

 @return the immutable list of custom potion effects]]>
      </doc>
    </method>
    <method name="addCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.potion.PotionEffect"/>
      <param name="overwrite" type="boolean"/>
      <doc>
      <![CDATA[Adds a custom potion effect to this arrow.

 @param effect the potion effect to add
 @param overwrite true if any existing effect of the same type should be
 overwritten
 @return true if the effect was added as a result of this call]]>
      </doc>
    </method>
    <method name="removeCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Removes a custom potion effect from this arrow.

 @param type the potion effect type to remove
 @return true if the an effect was removed as a result of this call
 @throws IllegalArgumentException if this operation would leave the Arrow
 in a state with no Custom Effects and PotionType.UNCRAFTABLE]]>
      </doc>
    </method>
    <method name="hasCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Checks for a specific custom potion effect type on this arrow.

 @param type the potion effect type to check for
 @return true if the potion has this effect]]>
      </doc>
    </method>
    <method name="clearCustomEffects"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all custom potion effects from this arrow.

 @throws IllegalArgumentException if this operation would leave the Arrow
 in a state with no Custom Effects and PotionType.UNCRAFTABLE]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.Arrow -->
  <!-- start interface org.bukkit.entity.Bat -->
  <interface name="Bat"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Ambient"/>
    <method name="isAwake" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks the current waking state of this bat.
 <p>
 This does not imply any persistence of state past the method call.

 @return true if the bat is awake or false if it is currently hanging
     from a block]]>
      </doc>
    </method>
    <method name="setAwake"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="boolean"/>
      <doc>
      <![CDATA[This method modifies the current waking state of this bat.
 <p>
 This does not prevent a bat from spontaneously awaking itself, or from
 reattaching itself to a block.

 @param state the new state]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Bat]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Bat -->
  <!-- start interface org.bukkit.entity.Bee -->
  <interface name="Bee"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <method name="getHive" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the bee's hive location.

 @return hive location or null]]>
      </doc>
    </method>
    <method name="setHive"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Set the bee's hive location.

 @param location or null]]>
      </doc>
    </method>
    <method name="getFlower" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the bee's flower location.

 @return flower location or null]]>
      </doc>
    </method>
    <method name="setFlower"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Set the bee's flower location.

 @param location or null]]>
      </doc>
    </method>
    <method name="hasNectar" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if the bee has nectar.

 @return nectar]]>
      </doc>
    </method>
    <method name="setHasNectar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nectar" type="boolean"/>
      <doc>
      <![CDATA[Set if the bee has nectar.

 @param nectar whether the entity has nectar]]>
      </doc>
    </method>
    <method name="hasStung" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if the bee has stung.

 @return has stung]]>
      </doc>
    </method>
    <method name="setHasStung"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stung" type="boolean"/>
      <doc>
      <![CDATA[Set if the bee has stung.

 @param stung has stung]]>
      </doc>
    </method>
    <method name="getAnger" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the bee's anger level.

 @return anger level]]>
      </doc>
    </method>
    <method name="setAnger"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="anger" type="int"/>
      <doc>
      <![CDATA[Set the bee's new anger level.

 @param anger new anger]]>
      </doc>
    </method>
    <method name="getCannotEnterHiveTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of ticks the bee cannot enter the hive for.

 @return Ticks the bee cannot enter a hive for]]>
      </doc>
    </method>
    <method name="setCannotEnterHiveTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Set the amount of ticks the bee cannot enter a hive for.

 @param ticks Ticks the bee cannot enter a hive for]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Bee.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Bee -->
  <!-- start interface org.bukkit.entity.Blaze -->
  <interface name="Blaze"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <doc>
    <![CDATA[Represents a Blaze monster]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Blaze -->
  <!-- start interface org.bukkit.entity.Boat -->
  <interface name="Boat"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Vehicle"/>
    <method name="getWoodType" return="org.bukkit.TreeSpecies"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the wood type of the boat.

 @return the wood type]]>
      </doc>
    </method>
    <method name="setWoodType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="species" type="org.bukkit.TreeSpecies"/>
      <doc>
      <![CDATA[Sets the wood type of the boat.

 @param species the new wood type]]>
      </doc>
    </method>
    <method name="getMaxSpeed" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="boats are complex and many of these methods do not work correctly across multiple versions.">
      <doc>
      <![CDATA[Gets the maximum speed of a boat. The speed is unrelated to the
 velocity.

 @return The max speed.
 @deprecated boats are complex and many of these methods do not work correctly across multiple versions.]]>
      </doc>
    </method>
    <method name="setMaxSpeed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="boats are complex and many of these methods do not work correctly across multiple versions.">
      <param name="speed" type="double"/>
      <doc>
      <![CDATA[Sets the maximum speed of a boat. Must be nonnegative. Default is 0.4D.

 @param speed The max speed.
 @deprecated boats are complex and many of these methods do not work correctly across multiple versions.]]>
      </doc>
    </method>
    <method name="getOccupiedDeceleration" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="boats are complex and many of these methods do not work correctly across multiple versions.">
      <doc>
      <![CDATA[Gets the deceleration rate (newSpeed = curSpeed * rate) of occupied
 boats. The default is 0.2.

 @return The rate of deceleration
 @deprecated boats are complex and many of these methods do not work correctly across multiple versions.]]>
      </doc>
    </method>
    <method name="setOccupiedDeceleration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="boats are complex and many of these methods do not work correctly across multiple versions.">
      <param name="rate" type="double"/>
      <doc>
      <![CDATA[Sets the deceleration rate (newSpeed = curSpeed * rate) of occupied
 boats. Setting this to a higher value allows for quicker acceleration.
 The default is 0.2.

 @param rate deceleration rate
 @deprecated boats are complex and many of these methods do not work correctly across multiple versions.]]>
      </doc>
    </method>
    <method name="getUnoccupiedDeceleration" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="boats are complex and many of these methods do not work correctly across multiple versions.">
      <doc>
      <![CDATA[Gets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied
 boats. The default is -1. Values below 0 indicate that no additional
 deceleration is imposed.

 @return The rate of deceleration
 @deprecated boats are complex and many of these methods do not work correctly across multiple versions.]]>
      </doc>
    </method>
    <method name="setUnoccupiedDeceleration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="boats are complex and many of these methods do not work correctly across multiple versions.">
      <param name="rate" type="double"/>
      <doc>
      <![CDATA[Sets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied
 boats. Setting this to a higher value allows for quicker deceleration
 of boats when a player disembarks. The default is -1. Values below 0
 indicate that no additional deceleration is imposed.

 @param rate deceleration rate
 @deprecated boats are complex and many of these methods do not work correctly across multiple versions.]]>
      </doc>
    </method>
    <method name="getWorkOnLand" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="boats are complex and many of these methods do not work correctly across multiple versions.">
      <doc>
      <![CDATA[Get whether boats can work on land.

 @return whether boats can work on land
 @deprecated boats are complex and many of these methods do not work correctly across multiple versions.]]>
      </doc>
    </method>
    <method name="setWorkOnLand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="boats are complex and many of these methods do not work correctly across multiple versions.">
      <param name="workOnLand" type="boolean"/>
      <doc>
      <![CDATA[Set whether boats can work on land.

 @param workOnLand whether boats can work on land
 @deprecated boats are complex and many of these methods do not work correctly across multiple versions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a boat entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Boat -->
  <!-- start interface org.bukkit.entity.Boss -->
  <interface name="Boss"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getBossBar" return="org.bukkit.boss.BossBar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link BossBar} of the {@link Boss}

 @return the {@link BossBar} of the entity]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the Boss Entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Boss -->
  <!-- start interface org.bukkit.entity.Breedable -->
  <interface name="Breedable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Ageable"/>
    <method name="setAgeLock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lock" type="boolean"/>
      <doc>
      <![CDATA[Lock the age of the animal, setting this will prevent the animal from
 maturing or getting ready for mating.

 @param lock new lock]]>
      </doc>
    </method>
    <method name="getAgeLock" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current agelock.

 @return the current agelock]]>
      </doc>
    </method>
    <method name="canBreed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the ability to breed of the animal.

 @return the ability to breed of the animal]]>
      </doc>
    </method>
    <method name="setBreed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="breed" type="boolean"/>
      <doc>
      <![CDATA[Set breedability of the animal, if the animal is a baby and set to
 breed it will instantly grow up.

 @param breed breedability of the animal]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an entity that can age and breed.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Breedable -->
  <!-- start interface org.bukkit.entity.Cat -->
  <interface name="Cat"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Tameable"/>
    <implements name="org.bukkit.entity.Sittable"/>
    <method name="getCatType" return="org.bukkit.entity.Cat.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current type of this cat.

 @return Type of the cat.]]>
      </doc>
    </method>
    <method name="setCatType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.entity.Cat.Type"/>
      <doc>
      <![CDATA[Sets the current type of this cat.

 @param type New type of this cat.]]>
      </doc>
    </method>
    <method name="getCollarColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the collar color of this cat

 @return the color of the collar]]>
      </doc>
    </method>
    <method name="setCollarColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Set the collar color of this cat

 @param color the color to apply]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Meow.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Cat -->
  <!-- start class org.bukkit.entity.Cat.Type -->
  <class name="Cat.Type" extends="java.lang.Enum&lt;org.bukkit.entity.Cat.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Cat.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Cat.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the various different cat types there are.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Cat.Type -->
  <!-- start interface org.bukkit.entity.CaveSpider -->
  <interface name="CaveSpider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Spider"/>
    <doc>
    <![CDATA[Represents a Spider.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.CaveSpider -->
  <!-- start interface org.bukkit.entity.ChestedHorse -->
  <interface name="ChestedHorse"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractHorse"/>
    <method name="isCarryingChest" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the horse has a chest equipped.

 @return true if the horse has chest storage]]>
      </doc>
    </method>
    <method name="setCarryingChest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chest" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the horse has a chest equipped. Removing a chest will also
 clear the chest's inventory.

 @param chest true if the horse should have a chest]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents Horse-like creatures which can carry an inventory.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ChestedHorse -->
  <!-- start interface org.bukkit.entity.Chicken -->
  <interface name="Chicken"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <doc>
    <![CDATA[Represents a Chicken.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Chicken -->
  <!-- start interface org.bukkit.entity.Cod -->
  <interface name="Cod"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Fish"/>
    <doc>
    <![CDATA[Represents a cod fish.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Cod -->
  <!-- start interface org.bukkit.entity.ComplexEntityPart -->
  <interface name="ComplexEntityPart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getParent" return="org.bukkit.entity.ComplexLivingEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the parent {@link ComplexLivingEntity} of this part.

 @return Parent complex entity]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a single part of a {@link ComplexLivingEntity}]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ComplexEntityPart -->
  <!-- start interface org.bukkit.entity.ComplexLivingEntity -->
  <interface name="ComplexLivingEntity"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.LivingEntity"/>
    <method name="getParts" return="java.util.Set&lt;org.bukkit.entity.ComplexEntityPart&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of parts that belong to this complex entity

 @return List of parts]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a complex living entity - one that is made up of various smaller
 parts]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ComplexLivingEntity -->
  <!-- start interface org.bukkit.entity.Cow -->
  <interface name="Cow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <doc>
    <![CDATA[Represents a Cow.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Cow -->
  <!-- start interface org.bukkit.entity.Creature -->
  <interface name="Creature"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Mob"/>
    <doc>
    <![CDATA[Represents a Creature. Creatures are non-intelligent monsters or animals
 which have very simple abilities.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Creature -->
  <!-- start interface org.bukkit.entity.Creeper -->
  <interface name="Creeper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <method name="isPowered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this Creeper is powered (Electrocuted)

 @return true if this creeper is powered]]>
      </doc>
    </method>
    <method name="setPowered"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets the Powered status of this Creeper

 @param value New Powered status]]>
      </doc>
    </method>
    <method name="setMaxFuseTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Set the maximum fuse ticks for this Creeper, where the maximum ticks
 is the amount of time in which a creeper is allowed to be in the
 primed state before exploding.

 @param ticks the new maximum fuse ticks]]>
      </doc>
    </method>
    <method name="getMaxFuseTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum fuse ticks for this Creeper, where the maximum ticks
 is the amount of time in which a creeper is allowed to be in the
 primed state before exploding.

 @return the maximum fuse ticks]]>
      </doc>
    </method>
    <method name="setExplosionRadius"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="int"/>
      <doc>
      <![CDATA[Set the explosion radius in which this Creeper's explosion will affect.

 @param radius the new explosion radius]]>
      </doc>
    </method>
    <method name="getExplosionRadius" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the explosion radius in which this Creeper's explosion will affect.

 @return the explosion radius]]>
      </doc>
    </method>
    <method name="explode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Makes this Creeper explode instantly.

 The resulting explosion can be cancelled by an
 {@link org.bukkit.event.entity.ExplosionPrimeEvent} and obeys the mob
 griefing gamerule.]]>
      </doc>
    </method>
    <method name="ignite"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ignites this Creeper, beginning its fuse.

 The amount of time the Creeper takes to explode will depend on what
 {@link #setMaxFuseTicks} is set as.

 The resulting explosion can be cancelled by an
 {@link org.bukkit.event.entity.ExplosionPrimeEvent} and obeys the mob
 griefing gamerule.]]>
      </doc>
    </method>
    <method name="setIgnited"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignited" type="boolean"/>
      <doc>
      <![CDATA[Set whether creeper is ignited or not (armed to explode)

 @param ignited New ignited state]]>
      </doc>
    </method>
    <method name="isIgnited" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if creeper is ignited or not (armed to explode)

 @return Ignited state]]>
      </doc>
    </method>
    <method name="getFuseTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of ticks this creeper has been ignited (armed to explode)

 @return Ticks creeper has been ignited]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Creeper]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Creeper -->
  <!-- start interface org.bukkit.entity.Damageable -->
  <interface name="Damageable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="damage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="double"/>
      <doc>
      <![CDATA[Deals the given amount of damage to this entity.

 @param amount Amount of damage to deal]]>
      </doc>
    </method>
    <method name="damage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="double"/>
      <param name="source" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Deals the given amount of damage to this entity, from a specified
 entity.

 @param amount Amount of damage to deal
 @param source Entity which to attribute this damage from]]>
      </doc>
    </method>
    <method name="getHealth" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity's health from 0 to {@link #getMaxHealth()}, where 0 is dead.

 @return Health represented from 0 to max]]>
      </doc>
    </method>
    <method name="setHealth"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="health" type="double"/>
      <doc>
      <![CDATA[Sets the entity's health from 0 to {@link #getMaxHealth()}, where 0 is
 dead.

 @param health New health represented from 0 to max
 @throws IllegalArgumentException Thrown if the health is {@literal < 0 or >}
     {@link #getMaxHealth()}]]>
      </doc>
    </method>
    <method name="getAbsorptionAmount" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity's absorption amount.

 @return absorption amount from 0]]>
      </doc>
    </method>
    <method name="setAbsorptionAmount"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="double"/>
      <doc>
      <![CDATA[Sets the entity's absorption amount.

 @param amount new absorption amount from 0
 @throws IllegalArgumentException thrown if health is {@literal < 0} or
 non-finite.]]>
      </doc>
    </method>
    <method name="getMaxHealth" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link Attribute#GENERIC_MAX_HEALTH}.">
      <doc>
      <![CDATA[Gets the maximum health this entity has.

 @return Maximum health
 @deprecated use {@link Attribute#GENERIC_MAX_HEALTH}.]]>
      </doc>
    </method>
    <method name="setMaxHealth"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link Attribute#GENERIC_MAX_HEALTH}.">
      <param name="health" type="double"/>
      <doc>
      <![CDATA[Sets the maximum health this entity can have.
 <p>
 If the health of the entity is above the value provided it will be set
 to that value.
 <p>
 Note: An entity with a health bar ({@link Player}, {@link EnderDragon},
 {@link Wither}, etc...} will have their bar scaled accordingly.

 @param health amount of health to set the maximum to
 @deprecated use {@link Attribute#GENERIC_MAX_HEALTH}.]]>
      </doc>
    </method>
    <method name="resetMaxHealth"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link Attribute#GENERIC_MAX_HEALTH}.">
      <doc>
      <![CDATA[Resets the max health to the original amount.
 @deprecated use {@link Attribute#GENERIC_MAX_HEALTH}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an {@link Entity} that has health and can take damage.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Damageable -->
  <!-- start interface org.bukkit.entity.Dolphin -->
  <interface name="Dolphin"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.WaterMob"/>
  </interface>
  <!-- end interface org.bukkit.entity.Dolphin -->
  <!-- start interface org.bukkit.entity.Donkey -->
  <interface name="Donkey"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ChestedHorse"/>
    <doc>
    <![CDATA[Represents a Donkey - variant of {@link ChestedHorse}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Donkey -->
  <!-- start interface org.bukkit.entity.DragonFireball -->
  <interface name="DragonFireball"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Fireball"/>
  </interface>
  <!-- end interface org.bukkit.entity.DragonFireball -->
  <!-- start interface org.bukkit.entity.Drowned -->
  <interface name="Drowned"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Zombie"/>
    <implements name="com.destroystokyo.paper.entity.RangedEntity"/>
    <doc>
    <![CDATA[Drowned zombie.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Drowned -->
  <!-- start interface org.bukkit.entity.Egg -->
  <interface name="Egg"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ThrowableProjectile"/>
    <doc>
    <![CDATA[Represents a thrown egg.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Egg -->
  <!-- start interface org.bukkit.entity.ElderGuardian -->
  <interface name="ElderGuardian"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Guardian"/>
    <doc>
    <![CDATA[Represents an ElderGuardian - variant of {@link Guardian}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ElderGuardian -->
  <!-- start interface org.bukkit.entity.EnderCrystal -->
  <interface name="EnderCrystal"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="isShowingBottom" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return whether or not this end crystal is showing the
 bedrock slate underneath it.

 @return true if the bottom is being shown]]>
      </doc>
    </method>
    <method name="setShowingBottom"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="showing" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not this end crystal is showing the
 bedrock slate underneath it.

 @param showing whether the bedrock slate should be shown]]>
      </doc>
    </method>
    <method name="getBeamTarget" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location that this end crystal is pointing its beam to.

 @return the location that the beam is pointed to, or null if the beam is not shown]]>
      </doc>
    </method>
    <method name="setBeamTarget"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the location that this end crystal is pointing to. Passing a null
 value will remove the current beam.

 @param location the location to point the beam to
 @throws IllegalArgumentException for differing worlds]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A crystal that heals nearby EnderDragons]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.EnderCrystal -->
  <!-- start interface org.bukkit.entity.EnderDragon -->
  <interface name="EnderDragon"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ComplexLivingEntity"/>
    <implements name="org.bukkit.entity.Boss"/>
    <implements name="org.bukkit.entity.Mob"/>
    <method name="getPhase" return="org.bukkit.entity.EnderDragon.Phase"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current phase that the dragon is performing.

 @return the current phase]]>
      </doc>
    </method>
    <method name="setPhase"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="phase" type="org.bukkit.entity.EnderDragon.Phase"/>
      <doc>
      <![CDATA[Sets the next phase for the dragon to perform.

 @param phase the next phase]]>
      </doc>
    </method>
    <method name="getDragonBattle" return="org.bukkit.boss.DragonBattle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link DragonBattle} associated with this EnderDragon.

 This will return null if the EnderDragon is not in the End dimension.

 @return the dragon battle

 @see World#getEnderDragonBattle()]]>
      </doc>
    </method>
    <method name="getDeathAnimationTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current time in ticks relative to the start of this dragon's
 death animation.

 If this dragon is alive, 0 will be returned. This value will never exceed
 200 (the length of the animation).

 @return this dragon's death animation ticks]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Ender Dragon]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.EnderDragon -->
  <!-- start class org.bukkit.entity.EnderDragon.Phase -->
  <class name="EnderDragon.Phase" extends="java.lang.Enum&lt;org.bukkit.entity.EnderDragon.Phase&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.EnderDragon.Phase[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.EnderDragon.Phase"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents a phase or action that an Ender Dragon can perform.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.EnderDragon.Phase -->
  <!-- start interface org.bukkit.entity.EnderDragonPart -->
  <interface name="EnderDragonPart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ComplexEntityPart"/>
    <implements name="org.bukkit.entity.Damageable"/>
    <method name="getParent" return="org.bukkit.entity.EnderDragon"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an ender dragon part]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.EnderDragonPart -->
  <!-- start interface org.bukkit.entity.Enderman -->
  <interface name="Enderman"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <method name="teleportRandomly" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Try to teleport the enderman to a random nearby location.

 May conditionally fail if the random location was not valid
 @return If the enderman teleported successfully or not]]>
      </doc>
    </method>
    <method name="getCarriedMaterial" return="org.bukkit.material.MaterialData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the id and data of the block that the Enderman is carrying.

 @return MaterialData containing the id and data of the block]]>
      </doc>
    </method>
    <method name="setCarriedMaterial"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Sets the id and data of the block that the Enderman is carrying.

 @param material data to set the carried block to]]>
      </doc>
    </method>
    <method name="getCarriedBlock" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the data of the block that the Enderman is carrying.

 @return BlockData containing the carried block, or null if none]]>
      </doc>
    </method>
    <method name="setCarriedBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blockData" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Sets the data of the block that the Enderman is carrying.

 @param blockData data to set the carried block to, or null to remove]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Enderman.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Enderman -->
  <!-- start interface org.bukkit.entity.Endermite -->
  <interface name="Endermite"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <method name="isPlayerSpawned" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this Endermite was spawned by a player.

 An Endermite spawned by a player will be attacked by nearby Enderman.

 @return player spawned status]]>
      </doc>
    </method>
    <method name="setPlayerSpawned"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="playerSpawned" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this Endermite was spawned by a player.

 An Endermite spawned by a player will be attacked by nearby Enderman.

 @param playerSpawned player spawned status]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.Endermite -->
  <!-- start interface org.bukkit.entity.EnderPearl -->
  <interface name="EnderPearl"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ThrowableProjectile"/>
    <doc>
    <![CDATA[Represents a thrown Ender Pearl entity]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.EnderPearl -->
  <!-- start interface org.bukkit.entity.EnderSignal -->
  <interface name="EnderSignal"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getTargetLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the location this EnderSignal is moving towards.

 @return the {@link Location} this EnderSignal is moving towards.]]>
      </doc>
    </method>
    <method name="setTargetLocation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Set the {@link Location} this EnderSignal is moving towards.
 <br>
 When setting a new target location, the {@link #getDropItem()} resets to
 a random value and the despawn timer gets set back to 0.

 @param location the new target location]]>
      </doc>
    </method>
    <method name="getDropItem" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the EnderSignal should drop an item on death.<br>
 If {@code true}, it will drop an item. If {@code false}, it will shatter.

 @return true if the EnderSignal will drop an item on death, or false if
 it will shatter]]>
      </doc>
    </method>
    <method name="setDropItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="drop" type="boolean"/>
      <doc>
      <![CDATA[Sets if the EnderSignal should drop an item on death; or if it should
 shatter.

 @param drop true if the EnderSignal should drop an item on death, or
 false if it should shatter.]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link ItemStack} to be displayed while in the air and to be
 dropped on death.

 @return the item stack]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the {@link ItemStack} to be displayed while in the air and to be
 dropped on death.

 @param item the item to set. If null, resets to the default eye of ender]]>
      </doc>
    </method>
    <method name="getDespawnTimer" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of time this entity has been alive (in ticks).
 <br>
 When this number is greater than 80, it will despawn on the next tick.

 @return the number of ticks this EnderSignal has been alive.]]>
      </doc>
    </method>
    <method name="setDespawnTimer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timer" type="int"/>
      <doc>
      <![CDATA[Set how long this entity has been alive (in ticks).
 <br>
 When this number is greater than 80, it will despawn on the next tick.

 @param timer how long (in ticks) this EnderSignal has been alive.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an EnderSignal, which is created upon throwing an ender eye.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.EnderSignal -->
  <!-- start interface org.bukkit.entity.Entity -->
  <interface name="Entity"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.metadata.Metadatable"/>
    <implements name="org.bukkit.command.CommandSender"/>
    <implements name="org.bukkit.Nameable"/>
    <implements name="org.bukkit.persistence.PersistentDataHolder"/>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Stores the entity's current position in the provided Location object.
 <p>
 If the provided Location is null this method does nothing and returns
 null.

 @param loc the location to copy into
 @return The Location object provided or null]]>
      </doc>
    </method>
    <method name="setVelocity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="velocity" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets this entity's velocity

 @param velocity New velocity to travel with]]>
      </doc>
    </method>
    <method name="getVelocity" return="org.bukkit.util.Vector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets this entity's current velocity

 @return Current traveling velocity of this entity]]>
      </doc>
    </method>
    <method name="getHeight" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity's height

 @return height of entity]]>
      </doc>
    </method>
    <method name="getWidth" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity's width

 @return width of entity]]>
      </doc>
    </method>
    <method name="getBoundingBox" return="org.bukkit.util.BoundingBox"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity's current bounding box.
 <p>
 The returned bounding box reflects the entity's current location and
 size.

 @return the entity's current bounding box]]>
      </doc>
    </method>
    <method name="isOnGround" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the entity is supported by a block. This value is a
 state updated by the server and is not recalculated unless the entity
 moves.

 @return True if entity is on ground.
 @see Player#isOnGround()]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current world this entity resides in

 @return World]]>
      </doc>
    </method>
    <method name="setRotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="yaw" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Sets the entity's rotation.
 <p>
 Note that if the entity is affected by AI, it may override this rotation.

 @param yaw the yaw
 @param pitch the pitch
 @throws UnsupportedOperationException if used for players]]>
      </doc>
    </method>
    <method name="teleport" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Teleports this entity to the given location. If this entity is riding a
 vehicle, it will be dismounted prior to teleportation.

 @param location New location to teleport this entity to
 @return <code>true</code> if the teleport was successful]]>
      </doc>
    </method>
    <method name="teleport" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="cause" type="org.bukkit.event.player.PlayerTeleportEvent.TeleportCause"/>
      <doc>
      <![CDATA[Teleports this entity to the given location. If this entity is riding a
 vehicle, it will be dismounted prior to teleportation.

 @param location New location to teleport this entity to
 @param cause The cause of this teleportation
 @return <code>true</code> if the teleport was successful]]>
      </doc>
    </method>
    <method name="teleport" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="destination" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Teleports this entity to the target Entity. If this entity is riding a
 vehicle, it will be dismounted prior to teleportation.

 @param destination Entity to teleport this entity to
 @return <code>true</code> if the teleport was successful]]>
      </doc>
    </method>
    <method name="teleport" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="destination" type="org.bukkit.entity.Entity"/>
      <param name="cause" type="org.bukkit.event.player.PlayerTeleportEvent.TeleportCause"/>
      <doc>
      <![CDATA[Teleports this entity to the target Entity. If this entity is riding a
 vehicle, it will be dismounted prior to teleportation.

 @param destination Entity to teleport this entity to
 @param cause The cause of this teleportation
 @return <code>true</code> if the teleport was successful]]>
      </doc>
    </method>
    <method name="teleportAsync" return="java.util.concurrent.CompletableFuture&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Loads/Generates(in 1.13+) the Chunk asynchronously, and then teleports the entity when the chunk is ready.
 @param loc Location to teleport to
 @return A future that will be completed with the result of the teleport]]>
      </doc>
    </method>
    <method name="teleportAsync" return="java.util.concurrent.CompletableFuture&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="cause" type="org.bukkit.event.player.PlayerTeleportEvent.TeleportCause"/>
      <doc>
      <![CDATA[Loads/Generates(in 1.13+) the Chunk asynchronously, and then teleports the entity when the chunk is ready.
 @param loc Location to teleport to
 @param cause Reason for teleport
 @return A future that will be completed with the result of the teleport]]>
      </doc>
    </method>
    <method name="getNearbyEntities" return="java.util.List&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Returns a list of entities within a bounding box centered around this
 entity

 @param x 1/2 the size of the box along x axis
 @param y 1/2 the size of the box along y axis
 @param z 1/2 the size of the box along z axis
 @return {@code List<Entity>} List of entities nearby]]>
      </doc>
    </method>
    <method name="getEntityId" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a unique id for this entity

 @return Entity id]]>
      </doc>
    </method>
    <method name="getFireTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entity's current fire ticks (ticks before the entity stops
 being on fire).

 @return int fireTicks]]>
      </doc>
    </method>
    <method name="getMaxFireTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entity's maximum fire ticks.

 @return int maxFireTicks]]>
      </doc>
    </method>
    <method name="setFireTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Sets the entity's current fire ticks (ticks before the entity stops
 being on fire).

 @param ticks Current ticks remaining]]>
      </doc>
    </method>
    <method name="remove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Mark the entity's removal.]]>
      </doc>
    </method>
    <method name="isDead" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this entity has been marked for removal.

 @return True if it is dead.]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns false if the entity has died or been despawned for some other
 reason.

 @return True if valid.]]>
      </doc>
    </method>
    <method name="getServer" return="org.bukkit.Server"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link Server} that contains this Entity

 @return Server instance running this Entity]]>
      </doc>
    </method>
    <method name="isPersistent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the entity gets persisted.
 <p>
 By default all entities are persistent. An entity will also not get
 persisted, if it is riding an entity that is not persistent.
 <p>
 The persistent flag on players controls whether or not to save their
 playerdata file when they quit. If a player is directly or indirectly
 riding a non-persistent entity, the vehicle at the root and all its
 passengers won't get persisted.
 <p>
 <b>This should not be confused with
 {@link LivingEntity#setRemoveWhenFarAway(boolean)} which controls
 despawning of living entities. </b>

 @return true if this entity is persistent]]>
      </doc>
    </method>
    <method name="setPersistent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="persistent" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not the entity gets persisted.

 @param persistent the persistence status
 @see #isPersistent()]]>
      </doc>
    </method>
    <method name="getPassenger" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="entities may have multiple passengers, use
 {@link #getPassengers()}">
      <doc>
      <![CDATA[Gets the primary passenger of a vehicle. For vehicles that could have
 multiple passengers, this will only return the primary passenger.

 @return an entity
 @deprecated entities may have multiple passengers, use
 {@link #getPassengers()}]]>
      </doc>
    </method>
    <method name="setPassenger" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="entities may have multiple passengers, use
 {@link #getPassengers()}">
      <param name="passenger" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Set the passenger of a vehicle.

 @param passenger The new passenger.
 @return false if it could not be done for whatever reason
 @deprecated entities may have multiple passengers, use
 {@link #getPassengers()}]]>
      </doc>
    </method>
    <method name="getPassengers" return="java.util.List&lt;org.bukkit.entity.Entity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of passengers of this vehicle.
 <p>
 The returned list will not be directly linked to the entity's current
 passengers, and no guarantees are made as to its mutability.

 @return list of entities corresponding to current passengers.]]>
      </doc>
    </method>
    <method name="addPassenger" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="passenger" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Add a passenger to the vehicle.

 @param passenger The passenger to add
 @return false if it could not be done for whatever reason]]>
      </doc>
    </method>
    <method name="removePassenger" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="passenger" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Remove a passenger from the vehicle.

 @param passenger The passenger to remove
 @return false if it could not be done for whatever reason]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if a vehicle has passengers.

 @return True if the vehicle has no passengers.]]>
      </doc>
    </method>
    <method name="eject" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Eject any passenger.

 @return True if there was a passenger.]]>
      </doc>
    </method>
    <method name="getFallDistance" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the distance this entity has fallen

 @return The distance.]]>
      </doc>
    </method>
    <method name="setFallDistance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distance" type="float"/>
      <doc>
      <![CDATA[Sets the fall distance for this entity

 @param distance The new distance.]]>
      </doc>
    </method>
    <method name="setLastDamageCause"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.bukkit.event.entity.EntityDamageEvent"/>
      <doc>
      <![CDATA[Record the last {@link EntityDamageEvent} inflicted on this entity

 @param event a {@link EntityDamageEvent}]]>
      </doc>
    </method>
    <method name="getLastDamageCause" return="org.bukkit.event.entity.EntityDamageEvent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve the last {@link EntityDamageEvent} inflicted on this entity.
 This event may have been cancelled.

 @return the last known {@link EntityDamageEvent} or null if hitherto
     unharmed]]>
      </doc>
    </method>
    <method name="getUniqueId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a unique and persistent id for this entity

 @return unique id]]>
      </doc>
    </method>
    <method name="getTicksLived" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of ticks this entity has lived for.
 <p>
 This is the equivalent to "age" in entities.

 @return Age of entity]]>
      </doc>
    </method>
    <method name="setTicksLived"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the amount of ticks this entity has lived for.
 <p>
 This is the equivalent to "age" in entities. May not be less than one
 tick.

 @param value Age of entity]]>
      </doc>
    </method>
    <method name="playEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.EntityEffect"/>
      <doc>
      <![CDATA[Performs the specified {@link EntityEffect} for this entity.
 <p>
 This will be viewable to all players near the entity.
 <p>
 If the effect is not applicable to this class of entity, it will not play.

 @param type Effect to play.]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.entity.EntityType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of the entity.

 @return The entity type.]]>
      </doc>
    </method>
    <method name="isInsideVehicle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this entity is inside a vehicle.

 @return True if the entity is in a vehicle.]]>
      </doc>
    </method>
    <method name="leaveVehicle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Leave the current vehicle. If the entity is currently in a vehicle (and
 is removed from it), true will be returned, otherwise false will be
 returned.

 @return True if the entity was in a vehicle.]]>
      </doc>
    </method>
    <method name="getVehicle" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the vehicle that this player is inside. If there is no vehicle,
 null will be returned.

 @return The current vehicle.]]>
      </doc>
    </method>
    <method name="setCustomNameVisible"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not to display the mob's custom name client side. The
 name will be displayed above the mob similarly to a player.
 <p>
 This value has no effect on players, they will always display their
 name.

 @param flag custom name or not]]>
      </doc>
    </method>
    <method name="isCustomNameVisible" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the mob's custom name is displayed client side.
 <p>
 This value has no effect on players, they will always display their
 name.

 @return if the custom name is displayed]]>
      </doc>
    </method>
    <method name="setGlowing"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the entity has a team colored (default: white) glow.

 <b>nb: this refers to the 'Glowing' entity property, not whether a
 glowing potion effect is applied</b>

 @param flag if the entity is glowing]]>
      </doc>
    </method>
    <method name="isGlowing" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the entity is glowing or not.

 <b>nb: this refers to the 'Glowing' entity property, not whether a
 glowing potion effect is applied</b>

 @return whether the entity is glowing]]>
      </doc>
    </method>
    <method name="setInvulnerable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the entity is invulnerable or not.
 <p>
 When an entity is invulnerable it can only be damaged by players in
 creative mode.

 @param flag if the entity is invulnerable]]>
      </doc>
    </method>
    <method name="isInvulnerable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the entity is invulnerable or not.

 @return whether the entity is]]>
      </doc>
    </method>
    <method name="isSilent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the entity is silent or not.

 @return whether the entity is silent.]]>
      </doc>
    </method>
    <method name="setSilent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the entity is silent or not.
 <p>
 When an entity is silent it will not produce any sound.

 @param flag if the entity is silent]]>
      </doc>
    </method>
    <method name="hasGravity" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether gravity applies to this entity.

 @return whether gravity applies]]>
      </doc>
    </method>
    <method name="setGravity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gravity" type="boolean"/>
      <doc>
      <![CDATA[Sets whether gravity applies to this entity.

 @param gravity whether gravity should apply]]>
      </doc>
    </method>
    <method name="getPortalCooldown" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the period of time (in ticks) before this entity can use a portal.

 @return portal cooldown ticks]]>
      </doc>
    </method>
    <method name="setPortalCooldown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cooldown" type="int"/>
      <doc>
      <![CDATA[Sets the period of time (in ticks) before this entity can use a portal.

 @param cooldown portal cooldown ticks]]>
      </doc>
    </method>
    <method name="getScoreboardTags" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of tags for this entity.
 <br>
 Entities can have no more than 1024 tags.

 @return a set of tags for this entity]]>
      </doc>
    </method>
    <method name="addScoreboardTag" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a tag to this entity.
 <br>
 Entities can have no more than 1024 tags.

 @param tag the tag to add
 @return true if the tag was successfully added]]>
      </doc>
    </method>
    <method name="removeScoreboardTag" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes a given tag from this entity.

 @param tag the tag to remove
 @return true if the tag was successfully removed]]>
      </doc>
    </method>
    <method name="getPistonMoveReaction" return="org.bukkit.block.PistonMoveReaction"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the reaction of the entity when moved by a piston.

 @return reaction]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the closest cardinal {@link BlockFace} direction an entity is
 currently facing.
 <br>
 This will not return any non-cardinal directions such as
 {@link BlockFace#UP} or {@link BlockFace#DOWN}.
 <br>
 {@link Hanging} entities will override this call and thus their behavior
 may be different.

 @return the entity's current cardinal facing.
 @see Hanging
 @see Directional#getFacing()]]>
      </doc>
    </method>
    <method name="getPose" return="org.bukkit.entity.Pose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity's current pose.

 <b>Note that the pose is only updated at the end of a tick, so may be
 inconsistent with other methods. eg {@link Player#isSneaking()} being
 true does not imply the current pose will be {@link Pose#SNEAKING}</b>

 @return current pose]]>
      </doc>
    </method>
    <method name="spigot" return="org.bukkit.entity.Entity.Spigot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOrigin" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location where this entity originates from.
 <p>
 This value can be null if the entity hasn't yet been added to the world.

 @return Location where entity originates or null if not yet added]]>
      </doc>
    </method>
    <method name="fromMobSpawner" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this entity was spawned from a mob spawner.

 @return True if entity spawned from a mob spawner]]>
      </doc>
    </method>
    <method name="getChunk" return="org.bukkit.Chunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the latest chunk an entity is currently or was in.

 @return The current, or most recent chunk if the entity is invalid (which may load the chunk)]]>
      </doc>
    </method>
    <method name="getEntitySpawnReason" return="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The {@link org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason} that initially spawned this entity. <!-- Paper - added "initially" to clarify that the SpawnReason doesn't change after the Entity was initially spawned" -->]]>
      </doc>
    </method>
    <method name="isInWater" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if entity is in water]]>
      </doc>
    </method>
    <method name="isInRain" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if entity is in rain]]>
      </doc>
    </method>
    <method name="isInBubbleColumn" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if entity is in bubble column]]>
      </doc>
    </method>
    <method name="isInWaterOrRain" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if entity is in water or rain]]>
      </doc>
    </method>
    <method name="isInWaterOrBubbleColumn" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if entity is in water or bubble column]]>
      </doc>
    </method>
    <method name="isInWaterOrRainOrBubbleColumn" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if entity is in water or rain or bubble column]]>
      </doc>
    </method>
    <method name="isInLava" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if entity is in lava]]>
      </doc>
    </method>
    <method name="isTicking" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if entity is inside a ticking chunk]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a base entity in the world]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Entity -->
  <!-- start class org.bukkit.entity.Entity.Spigot -->
  <class name="Entity.Spigot" extends="org.bukkit.command.CommandSender.Spigot"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spigot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.bukkit.entity.Entity.Spigot -->
  <!-- start class org.bukkit.entity.EntityCategory -->
  <class name="EntityCategory" extends="java.lang.Enum&lt;org.bukkit.entity.EntityCategory&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.EntityCategory[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.EntityCategory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A classification of entities which may behave differently than others or be
 affected uniquely by enchantments and potion effects among other things.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.EntityCategory -->
  <!-- start class org.bukkit.entity.EntityType -->
  <class name="EntityType" extends="java.lang.Enum&lt;org.bukkit.entity.EntityType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.entity.EntityType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the entity type name.

 @return the entity type's name
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntityClass" return="java.lang.Class&lt;? extends org.bukkit.entity.Entity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeId" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the entity type id.

 @return the raw type id
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="fromName" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets an entity type from its name.

 @param name the entity type's name
 @return the matching entity type or null
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="fromId" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Gets an entity from its id.

 @param id the raw type id
 @return the matching entity type or null
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="isSpawnable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Some entities cannot be spawned using {@link
 World#spawnEntity(Location, EntityType)} or {@link
 World#spawn(Location, Class)}, usually because they require additional
 information in order to spawn.

 @return False if the entity type cannot be spawned]]>
      </doc>
    </method>
    <method name="isAlive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.entity.EntityType -->
  <!-- start interface org.bukkit.entity.Evoker -->
  <interface name="Evoker"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Spellcaster"/>
    <method name="getCurrentSpell" return="org.bukkit.entity.Evoker.Spell"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="future versions of Minecraft have additional spell casting
 entities.">
      <doc>
      <![CDATA[Gets the {@link Spell} the Evoker is currently using.

 @return the current spell
 @deprecated future versions of Minecraft have additional spell casting
 entities.]]>
      </doc>
    </method>
    <method name="setCurrentSpell"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="future versions of Minecraft have additional spell casting
 entities.">
      <param name="spell" type="org.bukkit.entity.Evoker.Spell"/>
      <doc>
      <![CDATA[Sets the {@link Spell} the Evoker is currently using.

 @param spell the spell the evoker should be using
 @deprecated future versions of Minecraft have additional spell casting
 entities.]]>
      </doc>
    </method>
    <method name="getWololoTarget" return="org.bukkit.entity.Sheep"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the sheep being targeted by the {@link Spell#WOLOLO wololo spell}, or {@code null} if none]]>
      </doc>
    </method>
    <method name="setWololoTarget"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sheep" type="org.bukkit.entity.Sheep"/>
      <doc>
      <![CDATA[Set the sheep to be the target of the {@link Spell#WOLOLO wololo spell}, or {@code null} to clear.

 @param sheep new wololo target]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Evoker "Illager".]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Evoker -->
  <!-- start class org.bukkit.entity.Evoker.Spell -->
  <class name="Evoker.Spell" extends="java.lang.Enum&lt;org.bukkit.entity.Evoker.Spell&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="future versions of Minecraft have additional spell casting
 entities.">
    <method name="values" return="org.bukkit.entity.Evoker.Spell[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Evoker.Spell"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the current spell the Evoker is using.

 @deprecated future versions of Minecraft have additional spell casting
 entities.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Evoker.Spell -->
  <!-- start interface org.bukkit.entity.EvokerFangs -->
  <interface name="EvokerFangs"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getOwner" return="org.bukkit.entity.LivingEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link LivingEntity} which summoned the fangs.

 @return the {@link LivingEntity} which summoned the fangs]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.entity.LivingEntity"/>
      <doc>
      <![CDATA[Sets the {@link LivingEntity} which summoned the fangs.

 @param owner the {@link LivingEntity} which summoned the fangs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents Evoker Fangs.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.EvokerFangs -->
  <!-- start interface org.bukkit.entity.ExperienceOrb -->
  <interface name="ExperienceOrb"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getExperience" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets how much experience is contained within this orb

 @return Amount of experience]]>
      </doc>
    </method>
    <method name="setExperience"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets how much experience is contained within this orb

 @param value Amount of experience]]>
      </doc>
    </method>
    <method name="isFromBottle" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use getSpawnReason() == EXP_BOTTLE">
      <doc>
      <![CDATA[Check if this orb was spawned from a {@link ThrownExpBottle}

 @return if orb was spawned from a bottle
 @deprecated Use getSpawnReason() == EXP_BOTTLE]]>
      </doc>
    </method>
    <method name="getTriggerEntityId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this experience orb was triggered to be spawned by
 an entity such as a player, due to events such as killing entity,
 breaking blocks, smelting in a furnace, etc, this will return the UUID
 of the entity that triggered this orb to drop.

 In the case of an entity being killed, this will be the killers UUID.

 @return UUID of the player that triggered this orb to drop, or null if unknown/no triggering entity]]>
      </doc>
    </method>
    <method name="getSourceEntityId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this experience orb was spawned in relation to another
 entity, such as a player or other living entity death, or breeding,
 return the source entity UUID.

 In the case of breeding, this will be the new baby entities UUID.
 In the case of an entity being killed, this will be the dead entities UUID.

 @return The UUID of the entity that sourced this experience orb]]>
      </doc>
    </method>
    <method name="getSpawnReason" return="org.bukkit.entity.ExperienceOrb.SpawnReason"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason that this experience orb was spawned. For any case that we
 do not know, such as orbs spawned before this API was added, UNKNOWN is returned.
 @return The reason for this orb being spawned.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Experience Orb.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ExperienceOrb -->
  <!-- start class org.bukkit.entity.ExperienceOrb.SpawnReason -->
  <class name="ExperienceOrb.SpawnReason" extends="java.lang.Enum&lt;org.bukkit.entity.ExperienceOrb.SpawnReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.ExperienceOrb.SpawnReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.ExperienceOrb.SpawnReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Reasons for why this Experience Orb was spawned]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.ExperienceOrb.SpawnReason -->
  <!-- start interface org.bukkit.entity.Explosive -->
  <interface name="Explosive"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="setYield"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="yield" type="float"/>
      <doc>
      <![CDATA[Set the radius affected by this explosive's explosion

 @param yield The explosive yield]]>
      </doc>
    </method>
    <method name="getYield" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the radius or yield of this explosive's explosion

 @return the radius of blocks affected]]>
      </doc>
    </method>
    <method name="setIsIncendiary"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isIncendiary" type="boolean"/>
      <doc>
      <![CDATA[Set whether or not this explosive's explosion causes fire

 @param isIncendiary Whether it should cause fire]]>
      </doc>
    </method>
    <method name="isIncendiary" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return whether or not this explosive creates a fire when exploding

 @return true if the explosive creates fire, false otherwise]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A representation of an explosive entity]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Explosive -->
  <!-- start interface org.bukkit.entity.FallingBlock -->
  <interface name="FallingBlock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getBlockData()}">
      <doc>
      <![CDATA[Get the Material of the falling block

 @return Material of the block
 @deprecated use {@link #getBlockData()}]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the data for the falling block

 @return data of the block]]>
      </doc>
    </method>
    <method name="getDropItem" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if the falling block will break into an item if it cannot be placed

 @return true if the block will break into an item when obstructed]]>
      </doc>
    </method>
    <method name="setDropItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="drop" type="boolean"/>
      <doc>
      <![CDATA[Set if the falling block will break into an item if it cannot be placed

 @param drop true to break into an item when obstructed]]>
      </doc>
    </method>
    <method name="canHurtEntities" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the HurtEntities state of this block.

 @return whether entities will be damaged by this block.]]>
      </doc>
    </method>
    <method name="setHurtEntities"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hurtEntities" type="boolean"/>
      <doc>
      <![CDATA[Set the HurtEntities state of this block.

 @param hurtEntities whether entities will be damaged by this block.]]>
      </doc>
    </method>
    <method name="getSourceLoc" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="replaced by {@link Entity#getOrigin()}">
      <doc>
      <![CDATA[Gets the source block location of the FallingBlock

 @return the source block location the FallingBlock was spawned from
 @deprecated replaced by {@link Entity#getOrigin()}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a falling block]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.FallingBlock -->
  <!-- start interface org.bukkit.entity.Fireball -->
  <interface name="Fireball"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Projectile"/>
    <implements name="org.bukkit.entity.Explosive"/>
    <method name="setDirection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="direction" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Fireballs fly straight and do not take setVelocity(...) well.

 @param direction the direction this fireball is flying toward]]>
      </doc>
    </method>
    <method name="getDirection" return="org.bukkit.util.Vector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve the direction this fireball is heading toward

 @return the direction]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Fireball.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Fireball -->
  <!-- start interface org.bukkit.entity.Firework -->
  <interface name="Firework"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Projectile"/>
    <method name="getFireworkMeta" return="org.bukkit.inventory.meta.FireworkMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a copy of the fireworks meta

 @return A copy of the current Firework meta]]>
      </doc>
    </method>
    <method name="setFireworkMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="meta" type="org.bukkit.inventory.meta.FireworkMeta"/>
      <doc>
      <![CDATA[Apply the provided meta to the fireworks

 @param meta The FireworkMeta to apply]]>
      </doc>
    </method>
    <method name="detonate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Cause this firework to explode at earliest opportunity, as if it has no
 remaining fuse.]]>
      </doc>
    </method>
    <method name="isShotAtAngle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the firework was shot at an angle (i.e. from a crossbow).

 A firework which was not shot at an angle will fly straight upwards.

 @return shot at angle status]]>
      </doc>
    </method>
    <method name="setShotAtAngle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shotAtAngle" type="boolean"/>
      <doc>
      <![CDATA[Sets if the firework was shot at an angle (i.e. from a crossbow).

 A firework which was not shot at an angle will fly straight upwards.

 @param shotAtAngle the new shotAtAngle]]>
      </doc>
    </method>
    <method name="getSpawningEntity" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBoostedEntity" return="org.bukkit.entity.LivingEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this firework is boosting an entity, return it
 @return The entity being boosted]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.Firework -->
  <!-- start interface org.bukkit.entity.Fish -->
  <interface name="Fish"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.WaterMob"/>
    <doc>
    <![CDATA[Represents a fish entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Fish -->
  <!-- start interface org.bukkit.entity.FishHook -->
  <interface name="FishHook"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Projectile"/>
    <method name="getBiteChance" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="has no effect in newer Minecraft versions">
      <doc>
      <![CDATA[Gets the chance of a fish biting.
 <p>
 0.0 = No Chance.<br>
 1.0 = Instant catch.

 @return chance the bite chance
 @deprecated has no effect in newer Minecraft versions]]>
      </doc>
    </method>
    <method name="setBiteChance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="has no effect in newer Minecraft versions">
      <param name="chance" type="double"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the chance of a fish biting.
 <p>
 0.0 = No Chance.<br>
 1.0 = Instant catch.

 @param chance the bite chance
 @throws IllegalArgumentException if the bite chance is not between 0
     and 1
 @deprecated has no effect in newer Minecraft versions]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a fishing hook.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.FishHook -->
  <!-- start interface org.bukkit.entity.Flying -->
  <interface name="Flying"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Mob"/>
    <doc>
    <![CDATA[Represents a Flying Entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Flying -->
  <!-- start interface org.bukkit.entity.Fox -->
  <interface name="Fox"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <implements name="org.bukkit.entity.Sittable"/>
    <method name="getFoxType" return="org.bukkit.entity.Fox.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current type of this fox.

 @return Type of the fox.]]>
      </doc>
    </method>
    <method name="setFoxType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.entity.Fox.Type"/>
      <doc>
      <![CDATA[Sets the current type of this fox.

 @param type New type of this fox.]]>
      </doc>
    </method>
    <method name="isCrouching" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this animal is crouching

 @return true if crouching]]>
      </doc>
    </method>
    <method name="setCrouching"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="crouching" type="boolean"/>
      <doc>
      <![CDATA[Sets if this animal is crouching.

 @param crouching true if crouching]]>
      </doc>
    </method>
    <method name="setSleeping"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sleeping" type="boolean"/>
      <doc>
      <![CDATA[Sets if this animal is sleeping.

 @param sleeping true if sleeping]]>
      </doc>
    </method>
    <method name="getFirstTrustedPlayer" return="org.bukkit.entity.AnimalTamer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the first trusted player.

 @return the owning AnimalTamer, or null if not owned]]>
      </doc>
    </method>
    <method name="setFirstTrustedPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.AnimalTamer"/>
      <doc>
      <![CDATA[Set the first trusted player.
 <p>
 The first trusted player may only be removed after the second.

 @param player the AnimalTamer to be trusted]]>
      </doc>
    </method>
    <method name="getSecondTrustedPlayer" return="org.bukkit.entity.AnimalTamer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the second trusted player.

 @return the owning AnimalTamer, or null if not owned]]>
      </doc>
    </method>
    <method name="setSecondTrustedPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.AnimalTamer"/>
      <doc>
      <![CDATA[Set the second trusted player.
 <p>
 The second trusted player may only be added after the first.

 @param player the AnimalTamer to be trusted]]>
      </doc>
    </method>
    <doc>
    <![CDATA[What does the fox say?]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Fox -->
  <!-- start class org.bukkit.entity.Fox.Type -->
  <class name="Fox.Type" extends="java.lang.Enum&lt;org.bukkit.entity.Fox.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Fox.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Fox.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the various different fox types there are.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Fox.Type -->
  <!-- start interface org.bukkit.entity.Ghast -->
  <interface name="Ghast"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Flying"/>
    <doc>
    <![CDATA[Represents a Ghast.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Ghast -->
  <!-- start interface org.bukkit.entity.Giant -->
  <interface name="Giant"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <doc>
    <![CDATA[Represents a Giant.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Giant -->
  <!-- start interface org.bukkit.entity.Golem -->
  <interface name="Golem"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Creature"/>
    <doc>
    <![CDATA[A mechanical creature that may harm enemies.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Golem -->
  <!-- start interface org.bukkit.entity.Guardian -->
  <interface name="Guardian"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <method name="isElder" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="should check if instance of {@link ElderGuardian}.">
      <doc>
      <![CDATA[Check if the Guardian is an elder Guardian

 @return true if the Guardian is an Elder Guardian, false if not
 @deprecated should check if instance of {@link ElderGuardian}.]]>
      </doc>
    </method>
    <method name="setElder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Must spawn a new {@link ElderGuardian}.">
      <param name="shouldBeElder" type="boolean"/>
      <doc>
      <![CDATA[@param shouldBeElder shouldBeElder
 @deprecated Must spawn a new {@link ElderGuardian}.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.Guardian -->
  <!-- start interface org.bukkit.entity.Hanging -->
  <interface name="Hanging"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <implements name="org.bukkit.material.Attachable"/>
    <method name="setFacingDirection" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Sets the direction of the hanging entity, potentially overriding rules
 of placement. Note that if the result is not valid the object would
 normally drop as an item.

 @param face The new direction.
 @param force Whether to force it.
 @return False if force was false and there was no block for it to
     attach to in order to face the given direction.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Hanging entity]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Hanging -->
  <!-- start interface org.bukkit.entity.Hoglin -->
  <interface name="Hoglin"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <method name="isImmuneToZombification" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the hoglin is immune to zombification.

 @return Whether the hoglin is immune to zombification]]>
      </doc>
    </method>
    <method name="setImmuneToZombification"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the hoglin is immune to zombification.

 @param flag Whether the hoglin is immune to zombification]]>
      </doc>
    </method>
    <method name="isAbleToBeHunted" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether the hoglin is able to be hunted by piglins.

 @return Whether the hoglin is able to be hunted by piglins]]>
      </doc>
    </method>
    <method name="setIsAbleToBeHunted"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the hoglin is able to be hunted by piglins.

 @param flag Whether the hoglin is able to be hunted by piglins.]]>
      </doc>
    </method>
    <method name="getConversionTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of ticks until this entity will be converted to a Zoglin.

 When this reaches 300, the entity will be converted.

 @return conversion time
 @throws IllegalStateException if {@link #isConverting()} is false.]]>
      </doc>
    </method>
    <method name="setConversionTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="int"/>
      <doc>
      <![CDATA[Sets the amount of ticks until this entity will be converted to a Zoglin.

 When this reaches 0, the entity will be converted. A value of less than 0
 will stop the current conversion process without converting the current
 entity.

 @param time new conversion time]]>
      </doc>
    </method>
    <method name="isConverting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if this entity is in the process of converting to a Zoglin.

 @return conversion status]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Hoglin.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Hoglin -->
  <!-- start interface org.bukkit.entity.Horse -->
  <interface name="Horse"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractHorse"/>
    <method name="getColor" return="org.bukkit.entity.Horse.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the horse's color.
 <p>
 Colors only apply to horses, not to donkeys, mules, skeleton horses
 or undead horses.

 @return a {@link Color} representing the horse's group]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.entity.Horse.Color"/>
      <doc>
      <![CDATA[Sets the horse's color.
 <p>
 Attempting to set a color for any donkey, mule, skeleton horse or
 undead horse will not result in a change.

 @param color a {@link Color} for this horse]]>
      </doc>
    </method>
    <method name="getStyle" return="org.bukkit.entity.Horse.Style"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the horse's style.
 Styles determine what kind of markings or patterns a horse has.
 <p>
 Styles only apply to horses, not to donkeys, mules, skeleton horses
 or undead horses.

 @return a {@link Style} representing the horse's style]]>
      </doc>
    </method>
    <method name="setStyle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="style" type="org.bukkit.entity.Horse.Style"/>
      <doc>
      <![CDATA[Sets the style of this horse.
 Styles determine what kind of markings or patterns a horse has.
 <p>
 Attempting to set a style for any donkey, mule, skeleton horse or
 undead horse will not result in a change.

 @param style a {@link Style} for this horse]]>
      </doc>
    </method>
    <method name="isCarryingChest" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link ChestedHorse}">
      <doc>
      <![CDATA[@return carrying chest status
 @deprecated see {@link ChestedHorse}]]>
      </doc>
    </method>
    <method name="setCarryingChest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link ChestedHorse}">
      <param name="chest" type="boolean"/>
      <doc>
      <![CDATA[@param chest chest
 @deprecated see {@link ChestedHorse}]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.HorseInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a Horse.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Horse -->
  <!-- start class org.bukkit.entity.Horse.Color -->
  <class name="Horse.Color" extends="java.lang.Enum&lt;org.bukkit.entity.Horse.Color&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Horse.Color[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Horse.Color"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the base color that the horse has.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Horse.Color -->
  <!-- start class org.bukkit.entity.Horse.Style -->
  <class name="Horse.Style" extends="java.lang.Enum&lt;org.bukkit.entity.Horse.Style&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Horse.Style[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Horse.Style"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the style, or markings, that the horse has.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Horse.Style -->
  <!-- start class org.bukkit.entity.Horse.Variant -->
  <class name="Horse.Variant" extends="java.lang.Enum&lt;org.bukkit.entity.Horse.Variant&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="different variants are differing classes">
    <method name="values" return="org.bukkit.entity.Horse.Variant[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Horse.Variant"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[@deprecated different variants are differing classes]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Horse.Variant -->
  <!-- start interface org.bukkit.entity.HumanEntity -->
  <interface name="HumanEntity"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.LivingEntity"/>
    <implements name="org.bukkit.entity.AnimalTamer"/>
    <implements name="org.bukkit.inventory.InventoryHolder"/>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this player

 @return Player name]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.PlayerInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the player's inventory.

 @return The inventory of the player, this also contains the armor
     slots.]]>
      </doc>
    </method>
    <method name="getEnderChest" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the player's EnderChest inventory

 @return The EnderChest of the player]]>
      </doc>
    </method>
    <method name="getMainHand" return="org.bukkit.inventory.MainHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player's selected main hand

 @return the players main hand]]>
      </doc>
    </method>
    <method name="setWindowProperty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prop" type="org.bukkit.inventory.InventoryView.Property"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[If the player currently has an inventory window open, this method will
 set a property of that window, such as the state of a progress bar.

 @param prop The property.
 @param value The value to set the property to.
 @return True if the property was successfully set.]]>
      </doc>
    </method>
    <method name="getOpenInventory" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the inventory view the player is currently viewing. If they do not
 have an inventory window open, it returns their internal crafting view.

 @return The inventory view.]]>
      </doc>
    </method>
    <method name="openInventory" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inventory" type="org.bukkit.inventory.Inventory"/>
      <doc>
      <![CDATA[Opens an inventory window with the specified inventory on the top and
 the player's inventory on the bottom.

 @param inventory The inventory to open
 @return The newly opened inventory view]]>
      </doc>
    </method>
    <method name="openWorkbench" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Opens an empty workbench inventory window with the player's inventory
 on the bottom.

 @param location The location to attach it to. If null, the player's
     location is used.
 @param force If false, and there is no workbench block at the location,
     no inventory will be opened and null will be returned.
 @return The newly opened inventory view, or null if it could not be
     opened.]]>
      </doc>
    </method>
    <method name="openEnchanting" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Opens an empty enchanting inventory window with the player's inventory
 on the bottom.

 @param location The location to attach it to. If null, the player's
     location is used.
 @param force If false, and there is no enchanting table at the
     location, no inventory will be opened and null will be returned.
 @return The newly opened inventory view, or null if it could not be
     opened.]]>
      </doc>
    </method>
    <method name="openInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inventory" type="org.bukkit.inventory.InventoryView"/>
      <doc>
      <![CDATA[Opens an inventory window to the specified inventory view.

 @param inventory The view to open]]>
      </doc>
    </method>
    <method name="openMerchant" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trader" type="org.bukkit.entity.Villager"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Starts a trade between the player and the villager.

 Note that only one player may trade with a villager at once. You must use
 the force parameter for this.

 @param trader The merchant to trade with. Cannot be null.
 @param force whether to force the trade even if another player is trading
 @return The newly opened inventory view, or null if it could not be
 opened.]]>
      </doc>
    </method>
    <method name="openMerchant" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="merchant" type="org.bukkit.inventory.Merchant"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Starts a trade between the player and the merchant.

 Note that only one player may trade with a merchant at once. You must use
 the force parameter for this.

 @param merchant The merchant to trade with. Cannot be null.
 @param force whether to force the trade even if another player is trading
 @return The newly opened inventory view, or null if it could not be
 opened.]]>
      </doc>
    </method>
    <method name="openAnvil" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Opens an empty anvil inventory window with the player's inventory
 on the bottom.

 @param location The location to attach it to. If null, the player's
     location is used.
 @param force If false, and there is no anvil block at the location,
     no inventory will be opened and null will be returned.
 @return The newly opened inventory view, or null if it could not be
     opened.]]>
      </doc>
    </method>
    <method name="openCartographyTable" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Opens an empty cartography table inventory window with the player's inventory
 on the bottom.

 @param location The location to attach it to. If null, the player's
     location is used.
 @param force If false, and there is no cartography table block at the location,
     no inventory will be opened and null will be returned.
 @return The newly opened inventory view, or null if it could not be
     opened.]]>
      </doc>
    </method>
    <method name="openGrindstone" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Opens an empty grindstone inventory window with the player's inventory
 on the bottom.

 @param location The location to attach it to. If null, the player's
     location is used.
 @param force If false, and there is no grindstone block at the location,
     no inventory will be opened and null will be returned.
 @return The newly opened inventory view, or null if it could not be
     opened.]]>
      </doc>
    </method>
    <method name="openLoom" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Opens an empty loom inventory window with the player's inventory
 on the bottom.

 @param location The location to attach it to. If null, the player's
     location is used.
 @param force If false, and there is no loom block at the location,
     no inventory will be opened and null will be returned.
 @return The newly opened inventory view, or null if it could not be
     opened.]]>
      </doc>
    </method>
    <method name="openSmithingTable" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Opens an empty smithing table inventory window with the player's inventory
 on the bottom.

 @param location The location to attach it to. If null, the player's
     location is used.
 @param force If false, and there is no smithing table block at the location,
     no inventory will be opened and null will be returned.
 @return The newly opened inventory view, or null if it could not be
     opened.]]>
      </doc>
    </method>
    <method name="openStonecutter" return="org.bukkit.inventory.InventoryView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Opens an empty stonecutter inventory window with the player's inventory
 on the bottom.

 @param location The location to attach it to. If null, the player's
     location is used.
 @param force If false, and there is no stonecutter block at the location,
     no inventory will be opened and null will be returned.
 @return The newly opened inventory view, or null if it could not be
     opened.]]>
      </doc>
    </method>
    <method name="closeInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Force-closes the currently open inventory view for this player, if any.]]>
      </doc>
    </method>
    <method name="closeInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="org.bukkit.event.inventory.InventoryCloseEvent.Reason"/>
      <doc>
      <![CDATA[Force-closes the currently open inventory view for this player, if any.

 @param reason why the inventory is closing]]>
      </doc>
    </method>
    <method name="getItemInHand" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Humans may now dual wield in their off hand, use explicit
 methods in {@link PlayerInventory}.">
      <doc>
      <![CDATA[Returns the ItemStack currently in your hand, can be empty.

 @return The ItemStack of the item you are currently holding.
 @deprecated Humans may now dual wield in their off hand, use explicit
 methods in {@link PlayerInventory}.]]>
      </doc>
    </method>
    <method name="setItemInHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Humans may now dual wield in their off hand, use explicit
 methods in {@link PlayerInventory}.">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item to the given ItemStack, this will replace whatever the
 user was holding.

 @param item The ItemStack which will end up in the hand
 @deprecated Humans may now dual wield in their off hand, use explicit
 methods in {@link PlayerInventory}.]]>
      </doc>
    </method>
    <method name="getItemOnCursor" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ItemStack currently on your cursor, can be empty. Will
 always be empty if the player currently has no open window.

 @return The ItemStack of the item you are currently moving around.]]>
      </doc>
    </method>
    <method name="setItemOnCursor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item to the given ItemStack, this will replace whatever the
 user was moving. Will always be empty if the player currently has no
 open window.

 @param item The ItemStack which will end up in the hand]]>
      </doc>
    </method>
    <method name="hasCooldown" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Check whether a cooldown is active on the specified material.

 @param material the material to check
 @return if a cooldown is active on the material]]>
      </doc>
    </method>
    <method name="getCooldown" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Get the cooldown time in ticks remaining for the specified material.

 @param material the material to check
 @return the remaining cooldown time in ticks]]>
      </doc>
    </method>
    <method name="setCooldown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Set a cooldown on the specified material for a certain amount of ticks.
 ticks. 0 ticks will result in the removal of the cooldown.
 <p>
 Cooldowns are used by the server for items such as ender pearls and
 shields to prevent them from being used repeatedly.
 <p>
 Note that cooldowns will not by themselves stop an item from being used
 for attacking.

 @param material the material to set the cooldown for
 @param ticks the amount of ticks to set or 0 to remove]]>
      </doc>
    </method>
    <method name="getSleepTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the sleep ticks of the player. This value may be capped.

 @return slumber ticks]]>
      </doc>
    </method>
    <method name="getPotentialBedLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Location of the player's bed, null if they have not slept
 in one. This method will not attempt to validate if the current bed
 is still valid.

 @return Bed Location if has slept in one, otherwise null.]]>
      </doc>
    </method>
    <method name="sleep" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Attempts to make the entity sleep at the given location.
 <br>
 The location must be in the current world and have a bed placed at the
 location. The game may also enforce other requirements such as proximity
 to bed, monsters, and dimension type if force is not set.

 @param location the location of the bed
 @param force whether to try and sleep at the location even if not
 normally possible
 @return whether the sleep was successful]]>
      </doc>
    </method>
    <method name="wakeup"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="setSpawnLocation" type="boolean"/>
      <doc>
      <![CDATA[Causes the player to wakeup if they are currently sleeping.

 @param setSpawnLocation whether to set their spawn location to the bed
 they are currently sleeping in
 @throws IllegalStateException if not sleeping]]>
      </doc>
    </method>
    <method name="getBedLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location of the bed the player is currently sleeping in

 @return location
 @throws IllegalStateException if not sleeping]]>
      </doc>
    </method>
    <method name="getGameMode" return="org.bukkit.GameMode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets this human's current {@link GameMode}

 @return Current game mode]]>
      </doc>
    </method>
    <method name="setGameMode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="org.bukkit.GameMode"/>
      <doc>
      <![CDATA[Sets this human's current {@link GameMode}

 @param mode New game mode]]>
      </doc>
    </method>
    <method name="isBlocking" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the player is currently blocking (ie with a shield).

 @return Whether they are blocking.]]>
      </doc>
    </method>
    <method name="isHandRaised" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the player currently has their hand raised (ie about to begin
 blocking).

 @return Whether their hand is raised]]>
      </doc>
    </method>
    <method name="getExpToLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the total amount of experience required for the player to level

 @return Experience required to level up]]>
      </doc>
    </method>
    <method name="releaseLeftShoulderEntity" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If there is an Entity on this entities left shoulder, it will be released to the world and returned.
 If no Entity is released, null will be returned.

 @return The released entity, or null]]>
      </doc>
    </method>
    <method name="releaseRightShoulderEntity" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If there is an Entity on this entities left shoulder, it will be released to the world and returned.
 If no Entity is released, null will be returned.

 @return The released entity, or null]]>
      </doc>
    </method>
    <method name="getAttackCooldown" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current cooldown for a player's attack.

 This is used to calculate damage, with 1.0 representing a fully charged
 attack and 0.0 representing a non-charged attack

 @return A float between 0.0-1.0 representing the progress of the charge]]>
      </doc>
    </method>
    <method name="discoverRecipe" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipe" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Discover a recipe for this player such that it has not already been
 discovered. This method will add the key's associated recipe to the
 player's recipe book.

 @param recipe the key of the recipe to discover

 @return whether or not the recipe was newly discovered]]>
      </doc>
    </method>
    <method name="discoverRecipes" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipes" type="java.util.Collection&lt;org.bukkit.NamespacedKey&gt;"/>
      <doc>
      <![CDATA[Discover a collection of recipes for this player such that they have not
 already been discovered. This method will add the keys' associated
 recipes to the player's recipe book. If a recipe in the provided
 collection has already been discovered, it will be silently ignored.

 @param recipes the keys of the recipes to discover

 @return the amount of newly discovered recipes where 0 indicates that
 none were newly discovered and a number equal to {@code recipes.size()}
 indicates that all were new]]>
      </doc>
    </method>
    <method name="undiscoverRecipe" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipe" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Undiscover a recipe for this player such that it has already been
 discovered. This method will remove the key's associated recipe from the
 player's recipe book.

 @param recipe the key of the recipe to undiscover

 @return whether or not the recipe was successfully undiscovered (i.e. it
 was previously discovered)]]>
      </doc>
    </method>
    <method name="undiscoverRecipes" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipes" type="java.util.Collection&lt;org.bukkit.NamespacedKey&gt;"/>
      <doc>
      <![CDATA[Undiscover a collection of recipes for this player such that they have
 already been discovered. This method will remove the keys' associated
 recipes from the player's recipe book. If a recipe in the provided
 collection has not yet been discovered, it will be silently ignored.

 @param recipes the keys of the recipes to undiscover

 @return the amount of undiscovered recipes where 0 indicates that none
 were undiscovered and a number equal to {@code recipes.size()} indicates
 that all were undiscovered]]>
      </doc>
    </method>
    <method name="hasDiscoveredRecipe" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipe" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Check whether or not this entity has discovered the specified recipe.

 @param recipe the key of the recipe to check

 @return true if discovered, false otherwise]]>
      </doc>
    </method>
    <method name="getDiscoveredRecipes" return="java.util.Set&lt;org.bukkit.NamespacedKey&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an immutable set of recipes this entity has discovered.

 @return all discovered recipes]]>
      </doc>
    </method>
    <method name="getShoulderEntityLeft" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="There are currently no well defined semantics regarding
 serialized entities in Bukkit. Use with care.">
      <doc>
      <![CDATA[Gets the entity currently perched on the left shoulder or null if no
 entity.
 <br>
 The returned entity will not be spawned within the world, so most
 operations are invalid unless the entity is first spawned in.

 @return left shoulder entity
 @deprecated There are currently no well defined semantics regarding
 serialized entities in Bukkit. Use with care.]]>
      </doc>
    </method>
    <method name="setShoulderEntityLeft"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="There are currently no well defined semantics regarding
 serialized entities in Bukkit. Use with care.">
      <param name="entity" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Sets the entity currently perched on the left shoulder, or null to
 remove. This method will remove the entity from the world.
 <br>
 Note that only a copy of the entity will be set to display on the
 shoulder.
 <br>
 Also note that the client will currently only render {@link Parrot}
 entities.

 @param entity left shoulder entity
 @deprecated There are currently no well defined semantics regarding
 serialized entities in Bukkit. Use with care.]]>
      </doc>
    </method>
    <method name="getShoulderEntityRight" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="There are currently no well defined semantics regarding
 serialized entities in Bukkit. Use with care.">
      <doc>
      <![CDATA[Gets the entity currently perched on the right shoulder or null if no
 entity.
 <br>
 The returned entity will not be spawned within the world, so most
 operations are invalid unless the entity is first spawned in.

 @return right shoulder entity
 @deprecated There are currently no well defined semantics regarding
 serialized entities in Bukkit. Use with care.]]>
      </doc>
    </method>
    <method name="setShoulderEntityRight"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="There are currently no well defined semantics regarding
 serialized entities in Bukkit. Use with care.">
      <param name="entity" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Sets the entity currently perched on the right shoulder, or null to
 remove. This method will remove the entity from the world.
 <br>
 Note that only a copy of the entity will be set to display on the
 shoulder.
 <br>
 Also note that the client will currently only render {@link Parrot}
 entities.

 @param entity right shoulder entity
 @deprecated There are currently no well defined semantics regarding
 serialized entities in Bukkit. Use with care.]]>
      </doc>
    </method>
    <method name="openSign"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sign" type="org.bukkit.block.Sign"/>
      <doc>
      <![CDATA[Opens an editor window for the specified sign

 @param sign The sign to open]]>
      </doc>
    </method>
    <method name="dropItem" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropAll" type="boolean"/>
      <doc>
      <![CDATA[Make the entity drop the item in their hand.
 <br>
 This will force the entity to drop the item they are holding with
 an option to drop the entire {@link ItemStack} or just 1 of the items.

 @param dropAll True to drop entire stack, false to drop 1 of the stack
 @return True if item was dropped successfully]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a human entity, such as an NPC or a player]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.HumanEntity -->
  <!-- start interface org.bukkit.entity.Husk -->
  <interface name="Husk"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Zombie"/>
    <method name="isConverting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if this entity is in the process of converting to a Zombie as a
 result of being underwater.

 @return conversion status]]>
      </doc>
    </method>
    <method name="getConversionTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of ticks until this entity will be converted to a Zombie
 as a result of being underwater.

 When this reaches 0, the entity will be converted.

 @return conversion time
 @throws IllegalStateException if {@link #isConverting()} is false.]]>
      </doc>
    </method>
    <method name="setConversionTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="int"/>
      <doc>
      <![CDATA[Sets the amount of ticks until this entity will be converted to a Zombie
 as a result of being underwater.

 When this reaches 0, the entity will be converted. A value of less than 0
 will stop the current conversion process without converting the current
 entity.

 @param time new conversion time]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Husk - variant of {@link Zombie}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Husk -->
  <!-- start interface org.bukkit.entity.Illager -->
  <interface name="Illager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Raider"/>
    <doc>
    <![CDATA[Represents a type of "Illager".]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Illager -->
  <!-- start interface org.bukkit.entity.Illusioner -->
  <interface name="Illusioner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Spellcaster"/>
    <implements name="com.destroystokyo.paper.entity.RangedEntity"/>
    <doc>
    <![CDATA[Represents an Illusioner "Illager".]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Illusioner -->
  <!-- start interface org.bukkit.entity.IronGolem -->
  <interface name="IronGolem"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Golem"/>
    <method name="isPlayerCreated" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this iron golem was built by a player.

 @return Whether this iron golem was built by a player]]>
      </doc>
    </method>
    <method name="setPlayerCreated"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="playerCreated" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this iron golem was built by a player or not.

 @param playerCreated true if you want to set the iron golem as being
     player created, false if you want it to be a natural village golem.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iron Golem that protects Villages.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.IronGolem -->
  <!-- start interface org.bukkit.entity.Item -->
  <interface name="Item"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item stack associated with this item drop.

 @return An item stack.]]>
      </doc>
    </method>
    <method name="setItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item stack associated with this item drop.

 @param stack An item stack.]]>
      </doc>
    </method>
    <method name="getPickupDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the delay before this Item is available to be picked up by players

 @return Remaining delay]]>
      </doc>
    </method>
    <method name="setPickupDelay"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="int"/>
      <doc>
      <![CDATA[Sets the delay before this Item is available to be picked up by players

 @param delay New delay]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="java.util.UUID"/>
      <doc>
      <![CDATA[Sets the owner of this item.

 Other entities will not be able to pickup this item when an owner is set.

 @param owner UUID of new owner]]>
      </doc>
    </method>
    <method name="getOwner" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the owner of this item.

 @return UUID of owner]]>
      </doc>
    </method>
    <method name="setThrower"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uuid" type="java.util.UUID"/>
      <doc>
      <![CDATA[Set the thrower of this item.

 The thrower is the entity which dropped the item. This affects the
 trigger criteria for item pickups, for things such as advancements.

 @param uuid UUID of thrower]]>
      </doc>
    </method>
    <method name="getThrower" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the thrower of this item.

 The thrower is the entity which dropped the item.

 @return UUID of thrower]]>
      </doc>
    </method>
    <method name="canMobPickup" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if non-player entities can pick this Item up

 @return True if non-player entities can pickup]]>
      </doc>
    </method>
    <method name="setCanMobPickup"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canMobPickup" type="boolean"/>
      <doc>
      <![CDATA[Sets if non-player entities can pick this Item up

 @param canMobPickup True to allow non-player entity pickup]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a dropped item.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Item -->
  <!-- start interface org.bukkit.entity.ItemFrame -->
  <interface name="ItemFrame"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Hanging"/>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the item in this frame

 @return a defensive copy the item in this item frame]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the item in this frame

 @param item the new item]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <param name="playSound" type="boolean"/>
      <doc>
      <![CDATA[Set the item in this frame

 @param item the new item
 @param playSound whether or not to play the item placement sound]]>
      </doc>
    </method>
    <method name="getRotation" return="org.bukkit.Rotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the rotation of the frame's item

 @return the direction]]>
      </doc>
    </method>
    <method name="setRotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rotation" type="org.bukkit.Rotation"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Set the rotation of the frame's item

 @param rotation the new rotation
 @throws IllegalArgumentException if rotation is null]]>
      </doc>
    </method>
    <method name="isVisible" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the item frame is be visible or not.

 @return whether the item frame is visible or not]]>
      </doc>
    </method>
    <method name="setVisible"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visible" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the item frame should be visible or not.

 @param visible whether the item frame is visible or not]]>
      </doc>
    </method>
    <method name="isFixed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the item frame is "fixed" or not.

 When true it's not possible to destroy/move the frame (e.g. by damage,
 interaction, pistons, or missing supporting blocks), rotate the item or
 place/remove items.

 @return whether the item frame is fixed or not]]>
      </doc>
    </method>
    <method name="setFixed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visible" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the item frame should be fixed or not.

 When set to true it's not possible to destroy/move the frame (e.g. by
 damage, interaction, pistons, or missing supporting blocks), rotate the
 item or place/remove items.

 @param visible whether the item frame is fixed or not]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an Item Frame]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ItemFrame -->
  <!-- start interface org.bukkit.entity.LargeFireball -->
  <interface name="LargeFireball"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.SizedFireball"/>
    <doc>
    <![CDATA[Represents a large {@link Fireball}]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.LargeFireball -->
  <!-- start interface org.bukkit.entity.LeashHitch -->
  <interface name="LeashHitch"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Hanging"/>
    <doc>
    <![CDATA[Represents a Leash Hitch on a fence]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.LeashHitch -->
  <!-- start interface org.bukkit.entity.LightningStrike -->
  <interface name="LightningStrike"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="isEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the strike is an effect that does no damage.

 @return whether the strike is an effect]]>
      </doc>
    </method>
    <method name="spigot" return="org.bukkit.entity.LightningStrike.Spigot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an instance of a lightning strike. May or may not do damage.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.LightningStrike -->
  <!-- start class org.bukkit.entity.LightningStrike.Spigot -->
  <class name="LightningStrike.Spigot" extends="org.bukkit.entity.Entity.Spigot"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spigot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isSilent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.entity.LightningStrike.Spigot -->
  <!-- start interface org.bukkit.entity.LingeringPotion -->
  <interface name="LingeringPotion"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="lingering status depends on only on the potion item.">
    <implements name="org.bukkit.entity.ThrownPotion"/>
    <doc>
    <![CDATA[Represents a thrown lingering potion bottle

 @deprecated lingering status depends on only on the potion item.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.LingeringPotion -->
  <!-- start interface org.bukkit.entity.LivingEntity -->
  <interface name="LivingEntity"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.attribute.Attributable"/>
    <implements name="org.bukkit.entity.Damageable"/>
    <implements name="org.bukkit.projectiles.ProjectileSource"/>
    <method name="getEyeHeight" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the height of the living entity's eyes above its Location.

 @return height of the living entity's eyes above its location]]>
      </doc>
    </method>
    <method name="getEyeHeight" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignorePose" type="boolean"/>
      <doc>
      <![CDATA[Gets the height of the living entity's eyes above its Location.

 @param ignorePose if set to true, the effects of pose changes, eg
     sneaking and gliding will be ignored
 @return height of the living entity's eyes above its location]]>
      </doc>
    </method>
    <method name="getEyeLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a Location detailing the current eye position of the living entity.

 @return a location at the eyes of the living entity]]>
      </doc>
    </method>
    <method name="getLineOfSight" return="java.util.List&lt;org.bukkit.block.Block&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transparent" type="java.util.Set&lt;org.bukkit.Material&gt;"/>
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets all blocks along the living entity's line of sight.
 <p>
 This list contains all blocks from the living entity's eye position to
 target inclusive. This method considers all blocks as 1x1x1 in size.

 @param transparent Set containing all transparent block Materials (set to
     null for only air)
 @param maxDistance this is the maximum distance to scan (may be limited
     by server by at least 100 blocks, no less)
 @return list containing all blocks along the living entity's line of
     sight]]>
      </doc>
    </method>
    <method name="getTargetBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transparent" type="java.util.Set&lt;org.bukkit.Material&gt;"/>
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets the block that the living entity has targeted.
 <p>
 This method considers all blocks as 1x1x1 in size. To take exact block
 collision shapes into account, see {@link #getTargetBlockExact(int,
 FluidCollisionMode)}.

 @param transparent Set containing all transparent block Materials (set to
     null for only air)
 @param maxDistance this is the maximum distance to scan (may be limited
     by server by at least 100 blocks, no less)
 @return block that the living entity has targeted]]>
      </doc>
    </method>
    <method name="getTargetBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets the block that the living entity has targeted, ignoring fluids

 @param maxDistance this is the maximum distance to scan
 @return block that the living entity has targeted,
     or null if no block is within maxDistance]]>
      </doc>
    </method>
    <method name="getTargetBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <param name="fluidMode" type="com.destroystokyo.paper.block.TargetBlockInfo.FluidMode"/>
      <doc>
      <![CDATA[Gets the block that the living entity has targeted

 @param maxDistance this is the maximum distance to scan
 @param fluidMode whether to check fluids or not
 @return block that the living entity has targeted,
     or null if no block is within maxDistance]]>
      </doc>
    </method>
    <method name="getTargetBlockFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets the blockface of that block that the living entity has targeted, ignoring fluids

 @param maxDistance this is the maximum distance to scan
 @return blockface of the block that the living entity has targeted,
     or null if no block is targeted]]>
      </doc>
    </method>
    <method name="getTargetBlockFace" return="org.bukkit.block.BlockFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <param name="fluidMode" type="com.destroystokyo.paper.block.TargetBlockInfo.FluidMode"/>
      <doc>
      <![CDATA[Gets the blockface of that block that the living entity has targeted

 @param maxDistance this is the maximum distance to scan
 @param fluidMode whether to check fluids or not
 @return blockface of the block that the living entity has targeted,
     or null if no block is targeted]]>
      </doc>
    </method>
    <method name="getTargetBlockInfo" return="com.destroystokyo.paper.block.TargetBlockInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets information about the block the living entity has targeted, ignoring fluids

 @param maxDistance this is the maximum distance to scan
 @return TargetBlockInfo about the block the living entity has targeted,
     or null if no block is targeted]]>
      </doc>
    </method>
    <method name="getTargetBlockInfo" return="com.destroystokyo.paper.block.TargetBlockInfo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <param name="fluidMode" type="com.destroystokyo.paper.block.TargetBlockInfo.FluidMode"/>
      <doc>
      <![CDATA[Gets information about the block the living entity has targeted

 @param maxDistance this is the maximum distance to scan
 @param fluidMode whether to check fluids or not
 @return TargetBlockInfo about the block the living entity has targeted,
     or null if no block is targeted]]>
      </doc>
    </method>
    <method name="getTargetEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets information about the entity being targeted

 @param maxDistance this is the maximum distance to scan
 @return entity being targeted, or null if no entity is targeted]]>
      </doc>
    </method>
    <method name="getTargetEntity" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <param name="ignoreBlocks" type="boolean"/>
      <doc>
      <![CDATA[Gets information about the entity being targeted

 @param maxDistance this is the maximum distance to scan
 @param ignoreBlocks true to scan through blocks
 @return entity being targeted, or null if no entity is targeted]]>
      </doc>
    </method>
    <method name="getTargetEntityInfo" return="com.destroystokyo.paper.entity.TargetEntityInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets information about the entity being targeted

 @param maxDistance this is the maximum distance to scan
 @return TargetEntityInfo about the entity being targeted,
     or null if no entity is targeted]]>
      </doc>
    </method>
    <method name="getTargetEntityInfo" return="com.destroystokyo.paper.entity.TargetEntityInfo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <param name="ignoreBlocks" type="boolean"/>
      <doc>
      <![CDATA[Gets information about the entity being targeted

 @param maxDistance this is the maximum distance to scan
 @param ignoreBlocks true to scan through blocks
 @return TargetEntityInfo about the entity being targeted,
     or null if no entity is targeted]]>
      </doc>
    </method>
    <method name="getLastTwoTargetBlocks" return="java.util.List&lt;org.bukkit.block.Block&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transparent" type="java.util.Set&lt;org.bukkit.Material&gt;"/>
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets the last two blocks along the living entity's line of sight.
 <p>
 The target block will be the last block in the list. This method
 considers all blocks as 1x1x1 in size.

 @param transparent Set containing all transparent block Materials (set to
     null for only air)
 @param maxDistance this is the maximum distance to scan. This may be
     further limited by the server, but never to less than 100 blocks
 @return list containing the last 2 blocks along the living entity's
     line of sight]]>
      </doc>
    </method>
    <method name="getTargetBlockExact" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <doc>
      <![CDATA[Gets the block that the living entity has targeted.
 <p>
 This takes the blocks' precise collision shapes into account. Fluids are
 ignored.
 <p>
 This may cause loading of chunks! Some implementations may impose
 artificial restrictions on the maximum distance.

 @param maxDistance the maximum distance to scan
 @return block that the living entity has targeted
 @see #getTargetBlockExact(int, org.bukkit.FluidCollisionMode)]]>
      </doc>
    </method>
    <method name="getTargetBlockExact" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="int"/>
      <param name="fluidCollisionMode" type="org.bukkit.FluidCollisionMode"/>
      <doc>
      <![CDATA[Gets the block that the living entity has targeted.
 <p>
 This takes the blocks' precise collision shapes into account.
 <p>
 This may cause loading of chunks! Some implementations may impose
 artificial restrictions on the maximum distance.

 @param maxDistance the maximum distance to scan
 @param fluidCollisionMode the fluid collision mode
 @return block that the living entity has targeted
 @see #rayTraceBlocks(double, FluidCollisionMode)]]>
      </doc>
    </method>
    <method name="rayTraceBlocks" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="double"/>
      <doc>
      <![CDATA[Performs a ray trace that provides information on the targeted block.
 <p>
 This takes the blocks' precise collision shapes into account. Fluids are
 ignored.
 <p>
 This may cause loading of chunks! Some implementations may impose
 artificial restrictions on the maximum distance.

 @param maxDistance the maximum distance to scan
 @return information on the targeted block, or <code>null</code> if there
     is no targeted block in range
 @see #rayTraceBlocks(double, FluidCollisionMode)]]>
      </doc>
    </method>
    <method name="rayTraceBlocks" return="org.bukkit.util.RayTraceResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxDistance" type="double"/>
      <param name="fluidCollisionMode" type="org.bukkit.FluidCollisionMode"/>
      <doc>
      <![CDATA[Performs a ray trace that provides information on the targeted block.
 <p>
 This takes the blocks' precise collision shapes into account.
 <p>
 This may cause loading of chunks! Some implementations may impose
 artificial restrictions on the maximum distance.

 @param maxDistance the maximum distance to scan
 @param fluidCollisionMode the fluid collision mode
 @return information on the targeted block, or <code>null</code> if there
     is no targeted block in range
 @see World#rayTraceBlocks(Location, Vector, double, FluidCollisionMode)]]>
      </doc>
    </method>
    <method name="getRemainingAir" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the amount of air that the living entity has remaining, in
 ticks.

 @return amount of air remaining]]>
      </doc>
    </method>
    <method name="setRemainingAir"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Sets the amount of air that the living entity has remaining, in ticks.

 @param ticks amount of air remaining]]>
      </doc>
    </method>
    <method name="getMaximumAir" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the maximum amount of air the living entity can have, in ticks.

 @return maximum amount of air]]>
      </doc>
    </method>
    <method name="setMaximumAir"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Sets the maximum amount of air the living entity can have, in ticks.

 @param ticks maximum amount of air]]>
      </doc>
    </method>
    <method name="getArrowCooldown" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the time in ticks until the next arrow leaves the entity's body.

 @return ticks until arrow leaves]]>
      </doc>
    </method>
    <method name="setArrowCooldown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Sets the time in ticks until the next arrow leaves the entity's body.

 @param ticks time until arrow leaves]]>
      </doc>
    </method>
    <method name="getArrowsInBody" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of arrows in an entity's body.

 @return amount of arrows in body]]>
      </doc>
    </method>
    <method name="setArrowsInBody"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Set the amount of arrows in the entity's body.

 @param count amount of arrows in entity's body]]>
      </doc>
    </method>
    <method name="getMaximumNoDamageTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the living entity's current maximum no damage ticks.
 <p>
 This is the maximum duration in which the living entity will not take
 damage.

 @return maximum no damage ticks]]>
      </doc>
    </method>
    <method name="setMaximumNoDamageTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Sets the living entity's current maximum no damage ticks.

 @param ticks maximum amount of no damage ticks]]>
      </doc>
    </method>
    <method name="getLastDamage" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the living entity's last damage taken in the current no damage
 ticks time.
 <p>
 Only damage higher than this amount will further damage the living
 entity.

 @return damage taken since the last no damage ticks time period]]>
      </doc>
    </method>
    <method name="setLastDamage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="double"/>
      <doc>
      <![CDATA[Sets the damage dealt within the current no damage ticks time period.

 @param damage amount of damage]]>
      </doc>
    </method>
    <method name="getNoDamageTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the living entity's current no damage ticks.

 @return amount of no damage ticks]]>
      </doc>
    </method>
    <method name="setNoDamageTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Sets the living entity's current no damage ticks.

 @param ticks amount of no damage ticks]]>
      </doc>
    </method>
    <method name="getKiller" return="org.bukkit.entity.Player"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player identified as the killer of the living entity.
 <p>
 May be null.

 @return killer player, or null if none found]]>
      </doc>
    </method>
    <method name="setKiller"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="killer" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Sets the player identified as the killer of the living entity.

 @param killer player]]>
      </doc>
    </method>
    <method name="addPotionEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.potion.PotionEffect"/>
      <doc>
      <![CDATA[Adds the given {@link PotionEffect} to the living entity.

 @param effect PotionEffect to be added
 @return whether the effect could be added]]>
      </doc>
    </method>
    <method name="addPotionEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="no need to force since multiple effects of the same type are
 now supported.">
      <param name="effect" type="org.bukkit.potion.PotionEffect"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Adds the given {@link PotionEffect} to the living entity.
 <p>
 Only one potion effect can be present for a given {@link
 PotionEffectType}.

 @param effect PotionEffect to be added
 @param force whether conflicting effects should be removed
 @return whether the effect could be added
 @deprecated no need to force since multiple effects of the same type are
 now supported.]]>
      </doc>
    </method>
    <method name="addPotionEffects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effects" type="java.util.Collection&lt;org.bukkit.potion.PotionEffect&gt;"/>
      <doc>
      <![CDATA[Attempts to add all of the given {@link PotionEffect} to the living
 entity.

 @param effects the effects to add
 @return whether all of the effects could be added]]>
      </doc>
    </method>
    <method name="hasPotionEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Returns whether the living entity already has an existing effect of
 the given {@link PotionEffectType} applied to it.

 @param type the potion type to check
 @return whether the living entity has this potion effect active on them]]>
      </doc>
    </method>
    <method name="getPotionEffect" return="org.bukkit.potion.PotionEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Returns the active {@link PotionEffect} of the specified type.
 <p>
 If the effect is not present on the entity then null will be returned.

 @param type the potion type to check
 @return the effect active on this entity, or null if not active.]]>
      </doc>
    </method>
    <method name="removePotionEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Removes any effects present of the given {@link PotionEffectType}.

 @param type the potion type to remove]]>
      </doc>
    </method>
    <method name="getActivePotionEffects" return="java.util.Collection&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all currently active {@link PotionEffect}s on the living
 entity.

 @return a collection of {@link PotionEffect}s]]>
      </doc>
    </method>
    <method name="hasLineOfSight" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Checks whether the living entity has block line of sight to another.
 <p>
 This uses the same algorithm that hostile mobs use to find the closest
 player.

 @param other the entity to determine line of sight to
 @return true if there is a line of sight, false if not]]>
      </doc>
    </method>
    <method name="getRemoveWhenFarAway" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if the living entity despawns when away from players or not.
 <p>
 By default, animals are not removed while other mobs are.

 @return true if the living entity is removed when away from players]]>
      </doc>
    </method>
    <method name="setRemoveWhenFarAway"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="remove" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not the living entity despawns when away from players
 or not.

 @param remove the removal status]]>
      </doc>
    </method>
    <method name="getEquipment" return="org.bukkit.inventory.EntityEquipment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the inventory with the equipment worn by the living entity.

 @return the living entity's inventory]]>
      </doc>
    </method>
    <method name="setCanPickupItems"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pickup" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not the living entity can pick up items.

 @param pickup whether or not the living entity can pick up items]]>
      </doc>
    </method>
    <method name="getCanPickupItems" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the living entity can pick up items.

 @return whether or not the living entity can pick up items]]>
      </doc>
    </method>
    <method name="isLeashed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the entity is currently leashed.

 @return whether the entity is leashed]]>
      </doc>
    </method>
    <method name="getLeashHolder" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the entity that is currently leading this entity.

 @return the entity holding the leash
 @throws IllegalStateException if not currently leashed]]>
      </doc>
    </method>
    <method name="setLeashHolder" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="holder" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Sets the leash on this entity to be held by the supplied entity.
 <p>
 This method has no effect on EnderDragons, Withers, Players, or Bats.
 Non-living entities excluding leashes will not persist as leash
 holders.

 @param holder the entity to leash this entity to, or null to unleash
 @return whether the operation was successful]]>
      </doc>
    </method>
    <method name="isGliding" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if an entity is gliding, such as using an Elytra.
 @return True if this entity is gliding.]]>
      </doc>
    </method>
    <method name="setGliding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gliding" type="boolean"/>
      <doc>
      <![CDATA[Makes entity start or stop gliding. This will work even if an Elytra
 is not equipped, but will be reverted by the server immediately after
 unless an event-cancelling mechanism is put in place.
 @param gliding True if the entity is gliding.]]>
      </doc>
    </method>
    <method name="isSwimming" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if an entity is swimming.

 @return True if this entity is swimming.]]>
      </doc>
    </method>
    <method name="setSwimming"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="swimming" type="boolean"/>
      <doc>
      <![CDATA[Makes entity start or stop swimming.

 This may have unexpected results if the entity is not in water.

 @param swimming True if the entity is swimming.]]>
      </doc>
    </method>
    <method name="isRiptiding" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if an entity is currently using the Riptide enchantment.

 @return True if this entity is currently riptiding.]]>
      </doc>
    </method>
    <method name="isSleeping" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this entity is slumbering.

 @return slumber state]]>
      </doc>
    </method>
    <method name="setAI"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ai" type="boolean"/>
      <doc>
      <![CDATA[Sets whether an entity will have AI.

 The entity will be completely unable to move if it has no AI.

 @param ai whether the mob will have AI or not.]]>
      </doc>
    </method>
    <method name="hasAI" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether an entity has AI.

 The entity will be completely unable to move if it has no AI.

 @return true if the entity has AI, otherwise false.]]>
      </doc>
    </method>
    <method name="attack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Makes this entity attack the given entity with a melee attack.

 Attack damage is calculated by the server from the attributes and
 equipment of this mob, and knockback is applied to {@code target} as
 appropriate.

 @param target entity to attack.]]>
      </doc>
    </method>
    <method name="swingMainHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Makes this entity swing their main hand.

 This method does nothing if this entity does not have an animation for
 swinging their main hand.]]>
      </doc>
    </method>
    <method name="swingOffHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Makes this entity swing their off hand.

 This method does nothing if this entity does not have an animation for
 swinging their off hand.]]>
      </doc>
    </method>
    <method name="setCollidable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collidable" type="boolean"/>
      <doc>
      <![CDATA[Set if this entity will be subject to collisions with other entities.
 <p>
 Exemptions to this rule can be managed with
 {@link #getCollidableExemptions()}

 @param collidable collision status]]>
      </doc>
    </method>
    <method name="isCollidable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if this entity is subject to collisions with other entities.
 <p>
 Some entities might be exempted from the collidable rule of this entity.
 Use {@link #getCollidableExemptions()} to get these.
 <p>
 Please note that this method returns only the custom collidable state,
 not whether the entity is non-collidable for other reasons such as being
 dead.

 @return collision status]]>
      </doc>
    </method>
    <method name="getCollidableExemptions" return="java.util.Set&lt;java.util.UUID&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a mutable set of UUIDs of the entities which are exempt from the
 entity's collidable rule and which's collision with this entity will
 behave the opposite of it.
 <p>
 This set can be modified to add or remove exemptions.
 <p>
 For example if collidable is true and an entity is in the exemptions set
 then it will not collide with it. Similarly if collidable is false and an
 entity is in this set then it will still collide with it.
 <p>
 Note these exemptions are not (currently) persistent.

 @return the collidable exemption set]]>
      </doc>
    </method>
    <method name="getMemory" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="memoryKey" type="org.bukkit.entity.memory.MemoryKey&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the value of the memory specified.
 <p>
 Note that the value is null when the specific entity does not have that
 value by default.

 @param memoryKey memory to access
 @param <T> the type of the return value
 @return a instance of the memory section value or null if not present]]>
      </doc>
    </method>
    <method name="setMemory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="memoryKey" type="org.bukkit.entity.memory.MemoryKey&lt;T&gt;"/>
      <param name="memoryValue" type="T"/>
      <doc>
      <![CDATA[Sets the value of the memory specified.
 <p>
 Note that the value will not be persisted when the specific entity does
 not have that value by default.

 @param memoryKey the memory to access
 @param memoryValue a typed memory value
 @param <T> the type of the passed value]]>
      </doc>
    </method>
    <method name="getCategory" return="org.bukkit.entity.EntityCategory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the category to which this entity belongs.

 Categories may subject this entity to additional effects, benefits or
 debuffs.

 @return the entity category]]>
      </doc>
    </method>
    <method name="setInvisible"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="invisible" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the entity is invisible or not.

 @param invisible If the entity is invisible]]>
      </doc>
    </method>
    <method name="isInvisible" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the entity is invisible or not.

 @return Whether the entity is invisible]]>
      </doc>
    </method>
    <method name="getArrowsStuck" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of arrows stuck in this entity
 @return Number of arrows stuck]]>
      </doc>
    </method>
    <method name="setArrowsStuck"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrows" type="int"/>
      <doc>
      <![CDATA[Set the number of arrows stuck in this entity

 @param arrows Number of arrows to stick in this entity]]>
      </doc>
    </method>
    <method name="getShieldBlockingDelay" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the delay (in ticks) before blocking is effective for this entity

 @return Delay in ticks]]>
      </doc>
    </method>
    <method name="setShieldBlockingDelay"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="int"/>
      <doc>
      <![CDATA[Set the delay (in ticks) before blocking is effective for this entity

 @param delay Delay in ticks]]>
      </doc>
    </method>
    <method name="getActiveItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get's the item being actively "used" or consumed.
 @return The item. Will be null if no active item.]]>
      </doc>
    </method>
    <method name="getItemUseRemainingTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get's remaining time a player needs to keep hands raised with an item to finish using it.
 @return Remaining ticks to use the item]]>
      </doc>
    </method>
    <method name="getHandRaisedTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get how long the players hands have been raised (Charging Bow attack, using a potion, etc)

 @return Get how long the players hands have been raised (Charging Bow attack, using a potion, etc)]]>
      </doc>
    </method>
    <method name="isHandRaised" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether or not this entity is using or charging an attack (Bow pulled back, drinking potion, eating food)

 @return Whether or not this entity is using or charging an attack (Bow pulled back, drinking potion, eating food)]]>
      </doc>
    </method>
    <method name="isJumping" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get entity jump state.
 <p>
 Jump state will be true when the entity has been marked to jump.

 @return entity jump state.]]>
      </doc>
    </method>
    <method name="setJumping"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jumping" type="boolean"/>
      <doc>
      <![CDATA[Set entity jump state
 <p>
 Setting to true will mark the entity to jump.
 <p>
 Setting to false will unmark the entity to jump but will not stop a jump already in-progress.

 @param jumping entity jump state]]>
      </doc>
    </method>
    <method name="playPickupItemAnimation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.entity.Item"/>
      <doc>
      <![CDATA[Plays pickup item animation towards this entity.
 <p>
 <b>This will remove the item on the client.</b>
 <p>
 Quantity is inferred to be that of the {@link Item}.

 @param item item to pickup]]>
      </doc>
    </method>
    <method name="playPickupItemAnimation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.entity.Item"/>
      <param name="quantity" type="int"/>
      <doc>
      <![CDATA[Plays pickup item animation towards this entity.
 <p>
 <b>This will remove the item on the client.</b>

 @param item item to pickup
 @param quantity quantity of item]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a living entity, such as a monster or player]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.LivingEntity -->
  <!-- start interface org.bukkit.entity.Llama -->
  <interface name="Llama"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ChestedHorse"/>
    <implements name="com.destroystokyo.paper.entity.RangedEntity"/>
    <method name="getColor" return="org.bukkit.entity.Llama.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the llama's color.

 @return a {@link Color} representing the llama's color]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.entity.Llama.Color"/>
      <doc>
      <![CDATA[Sets the llama's color.

 @param color a {@link Color} for this llama]]>
      </doc>
    </method>
    <method name="getStrength" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the llama's strength. A higher strength llama will have more
 inventory slots and be more threatening to entities.

 @return llama strength [1,5]]]>
      </doc>
    </method>
    <method name="setStrength"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strength" type="int"/>
      <doc>
      <![CDATA[Sets the llama's strength. A higher strength llama will have more
 inventory slots and be more threatening to entities. Inventory slots are
 equal to strength * 3.

 @param strength llama strength [1,5]]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.LlamaInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a Llama.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Llama -->
  <!-- start class org.bukkit.entity.Llama.Color -->
  <class name="Llama.Color" extends="java.lang.Enum&lt;org.bukkit.entity.Llama.Color&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Llama.Color[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Llama.Color"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the base color that the llama has.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Llama.Color -->
  <!-- start interface org.bukkit.entity.LlamaSpit -->
  <interface name="LlamaSpit"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Projectile"/>
    <doc>
    <![CDATA[Represents Llama spit.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.LlamaSpit -->
  <!-- start interface org.bukkit.entity.MagmaCube -->
  <interface name="MagmaCube"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Slime"/>
    <doc>
    <![CDATA[Represents a MagmaCube.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.MagmaCube -->
  <!-- start interface org.bukkit.entity.Minecart -->
  <interface name="Minecart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Vehicle"/>
    <method name="setDamage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="double"/>
      <doc>
      <![CDATA[Sets a minecart's damage.

 @param damage over 40 to "kill" a minecart]]>
      </doc>
    </method>
    <method name="getDamage" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a minecart's damage.

 @return The damage]]>
      </doc>
    </method>
    <method name="getMaxSpeed" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum speed of a minecart. The speed is unrelated to the
 velocity.

 @return The max speed]]>
      </doc>
    </method>
    <method name="setMaxSpeed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="speed" type="double"/>
      <doc>
      <![CDATA[Sets the maximum speed of a minecart. Must be nonnegative. Default is
 0.4D.

 @param speed The max speed]]>
      </doc>
    </method>
    <method name="isSlowWhenEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this minecart will slow down faster without a passenger
 occupying it

 @return Whether it decelerates faster]]>
      </doc>
    </method>
    <method name="setSlowWhenEmpty"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slow" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this minecart will slow down faster without a passenger
 occupying it

 @param slow Whether it will decelerate faster]]>
      </doc>
    </method>
    <method name="getFlyingVelocityMod" return="org.bukkit.util.Vector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the flying velocity modifier. Used for minecarts that are in
 mid-air. A flying minecart's velocity is multiplied by this factor each
 tick.

 @return The vector factor]]>
      </doc>
    </method>
    <method name="setFlyingVelocityMod"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flying" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets the flying velocity modifier. Used for minecarts that are in
 mid-air. A flying minecart's velocity is multiplied by this factor each
 tick.

 @param flying velocity modifier vector]]>
      </doc>
    </method>
    <method name="getDerailedVelocityMod" return="org.bukkit.util.Vector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the derailed velocity modifier. Used for minecarts that are on the
 ground, but not on rails.
 <p>
 A derailed minecart's velocity is multiplied by this factor each tick.

 @return derailed visible speed]]>
      </doc>
    </method>
    <method name="setDerailedVelocityMod"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="derailed" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets the derailed velocity modifier. Used for minecarts that are on the
 ground, but not on rails. A derailed minecart's velocity is multiplied
 by this factor each tick.

 @param derailed visible speed]]>
      </doc>
    </method>
    <method name="setDisplayBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Sets the display block for this minecart.
 Passing a null value will set the minecart to have no display block.

 @param material the material to set as display block.]]>
      </doc>
    </method>
    <method name="getDisplayBlock" return="org.bukkit.material.MaterialData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the display block for this minecart.
 This function will return the type AIR if none is set.

 @return the block displayed by this minecart.]]>
      </doc>
    </method>
    <method name="setDisplayBlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blockData" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Sets the display block for this minecart.
 Passing a null value will set the minecart to have no display block.

 @param blockData the material to set as display block.]]>
      </doc>
    </method>
    <method name="getDisplayBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the display block for this minecart.
 This function will return the type AIR if none is set.

 @return the block displayed by this minecart.]]>
      </doc>
    </method>
    <method name="setDisplayBlockOffset"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="int"/>
      <doc>
      <![CDATA[Sets the offset of the display block.

 @param offset the block offset to set for this minecart.]]>
      </doc>
    </method>
    <method name="getDisplayBlockOffset" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the offset of the display block.

 @return the current block offset for this minecart.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a minecart entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Minecart -->
  <!-- start interface org.bukkit.entity.Mob -->
  <interface name="Mob"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.LivingEntity"/>
    <implements name="org.bukkit.loot.Lootable"/>
    <method name="getPathfinder" return="com.destroystokyo.paper.entity.Pathfinder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enables access to control the pathing of an Entity
 @return Pathfinding Manager for this entity]]>
      </doc>
    </method>
    <method name="isInDaylight" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this mob is exposed to daylight

 @return True if mob is exposed to daylight]]>
      </doc>
    </method>
    <method name="setTarget"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.LivingEntity"/>
      <doc>
      <![CDATA[Instructs this Mob to set the specified LivingEntity as its target.
 <p>
 Hostile creatures may attack their target, and friendly creatures may
 follow their target.

 @param target New LivingEntity to target, or null to clear the target]]>
      </doc>
    </method>
    <method name="getTarget" return="org.bukkit.entity.LivingEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current target of this Mob

 @return Current target of this creature, or null if none exists]]>
      </doc>
    </method>
    <method name="setAware"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aware" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this mob is aware of its surroundings.

 Unaware mobs will still move if pushed, attacked, etc. but will not move
 or perform any actions on their own. Unaware mobs may also have other
 unspecified behaviours disabled, such as drowning.

 @param aware whether the mob is aware]]>
      </doc>
    </method>
    <method name="isAware" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this mob is aware of its surroundings.

 Unaware mobs will still move if pushed, attacked, etc. but will not move
 or perform any actions on their own. Unaware mobs may also have other
 unspecified behaviours disabled, such as drowning.

 @return whether the mob is aware]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Mob. Mobs are living entities with simple AI.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Mob -->
  <!-- start interface org.bukkit.entity.Monster -->
  <interface name="Monster"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Creature"/>
    <doc>
    <![CDATA[Represents a Monster.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Monster -->
  <!-- start interface org.bukkit.entity.Mule -->
  <interface name="Mule"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ChestedHorse"/>
    <doc>
    <![CDATA[Represents a Mule - variant of {@link ChestedHorse}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Mule -->
  <!-- start interface org.bukkit.entity.MushroomCow -->
  <interface name="MushroomCow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Cow"/>
    <method name="getVariant" return="org.bukkit.entity.MushroomCow.Variant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the variant of this cow.

 @return cow variant]]>
      </doc>
    </method>
    <method name="setVariant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="variant" type="org.bukkit.entity.MushroomCow.Variant"/>
      <doc>
      <![CDATA[Set the variant of this cow.

 @param variant cow variant]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a mushroom {@link Cow}]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.MushroomCow -->
  <!-- start class org.bukkit.entity.MushroomCow.Variant -->
  <class name="MushroomCow.Variant" extends="java.lang.Enum&lt;org.bukkit.entity.MushroomCow.Variant&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.MushroomCow.Variant[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.MushroomCow.Variant"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the variant of a cow - ie its color.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.MushroomCow.Variant -->
  <!-- start interface org.bukkit.entity.NPC -->
  <interface name="NPC"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Creature"/>
    <doc>
    <![CDATA[Represents a non-player character]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.NPC -->
  <!-- start interface org.bukkit.entity.Ocelot -->
  <interface name="Ocelot"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <method name="getCatType" return="org.bukkit.entity.Ocelot.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current type of this cat.

 @return Type of the cat.]]>
      </doc>
    </method>
    <method name="setCatType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.entity.Ocelot.Type"/>
      <doc>
      <![CDATA[Sets the current type of this cat.

 @param type New type of this cat.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A wild tameable cat]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Ocelot -->
  <!-- start class org.bukkit.entity.Ocelot.Type -->
  <class name="Ocelot.Type" extends="java.lang.Enum&lt;org.bukkit.entity.Ocelot.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="Cats are now a separate entity.">
    <method name="values" return="org.bukkit.entity.Ocelot.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Ocelot.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the ID of this cat type.

 @return Type ID.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.entity.Ocelot.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Gets a cat type by its ID.

 @param id ID of the cat type to get.
 @return Resulting type, or null if not found.
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the various different cat types there are.

 @deprecated Cats are now a separate entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Ocelot.Type -->
  <!-- start interface org.bukkit.entity.Painting -->
  <interface name="Painting"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Hanging"/>
    <method name="getArt" return="org.bukkit.Art"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the art on this painting

 @return The art]]>
      </doc>
    </method>
    <method name="setArt" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="art" type="org.bukkit.Art"/>
      <doc>
      <![CDATA[Set the art on this painting

 @param art The new art
 @return False if the new art won't fit at the painting's current
     location]]>
      </doc>
    </method>
    <method name="setArt" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="art" type="org.bukkit.Art"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Set the art on this painting

 @param art The new art
 @param force If true, force the new art regardless of whether it fits
     at the current location. Note that forcing it where it can't fit
     normally causes it to drop as an item unless you override this by
     catching the {@link HangingBreakEvent}.
 @return False if force was false and the new art won't fit at the
     painting's current location]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Painting.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Painting -->
  <!-- start interface org.bukkit.entity.Panda -->
  <interface name="Panda"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <method name="getMainGene" return="org.bukkit.entity.Panda.Gene"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets this Panda's main gene.

 @return main gene]]>
      </doc>
    </method>
    <method name="setMainGene"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gene" type="org.bukkit.entity.Panda.Gene"/>
      <doc>
      <![CDATA[Sets this Panda's main gene.

 @param gene main gene]]>
      </doc>
    </method>
    <method name="getHiddenGene" return="org.bukkit.entity.Panda.Gene"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets this Panda's hidden gene.

 @return hidden gene]]>
      </doc>
    </method>
    <method name="setHiddenGene"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gene" type="org.bukkit.entity.Panda.Gene"/>
      <doc>
      <![CDATA[Sets this Panda's hidden gene.

 @param gene hidden gene]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Panda entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Panda -->
  <!-- start class org.bukkit.entity.Panda.Gene -->
  <class name="Panda.Gene" extends="java.lang.Enum&lt;org.bukkit.entity.Panda.Gene&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Panda.Gene[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Panda.Gene"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="isRecessive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this gene is recessive, i.e. required in both parents to
 propagate to children.

 @return recessive status]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.entity.Panda.Gene -->
  <!-- start interface org.bukkit.entity.Parrot -->
  <interface name="Parrot"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Tameable"/>
    <implements name="org.bukkit.entity.Sittable"/>
    <method name="getVariant" return="org.bukkit.entity.Parrot.Variant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the variant of this parrot.

 @return parrot variant]]>
      </doc>
    </method>
    <method name="setVariant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="variant" type="org.bukkit.entity.Parrot.Variant"/>
      <doc>
      <![CDATA[Set the variant of this parrot.

 @param variant parrot variant]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Parrot.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Parrot -->
  <!-- start class org.bukkit.entity.Parrot.Variant -->
  <class name="Parrot.Variant" extends="java.lang.Enum&lt;org.bukkit.entity.Parrot.Variant&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Parrot.Variant[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Parrot.Variant"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the variant of a parrot - ie its color.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Parrot.Variant -->
  <!-- start interface org.bukkit.entity.Phantom -->
  <interface name="Phantom"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Flying"/>
    <method name="getSize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The size of the phantom]]>
      </doc>
    </method>
    <method name="setSize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sz" type="int"/>
      <doc>
      <![CDATA[@param sz The new size of the phantom.]]>
      </doc>
    </method>
    <method name="getSpawningEntity" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the UUID of the entity that caused this phantom to spawn

 @return UUID]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a phantom.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Phantom -->
  <!-- start interface org.bukkit.entity.Pig -->
  <interface name="Pig"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Steerable"/>
    <implements name="org.bukkit.entity.Vehicle"/>
    <doc>
    <![CDATA[Represents a Pig.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Pig -->
  <!-- start interface org.bukkit.entity.Piglin -->
  <interface name="Piglin"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.PiglinAbstract"/>
    <method name="isAbleToHunt" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether the piglin is able to hunt hoglins.

 @return Whether the piglin is able to hunt hoglins]]>
      </doc>
    </method>
    <method name="setIsAbleToHunt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the piglin is able to hunt hoglins.

 @param flag Whether the piglin is able to hunt hoglins.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Piglin.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Piglin -->
  <!-- start interface org.bukkit.entity.PiglinAbstract -->
  <interface name="PiglinAbstract"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <implements name="org.bukkit.entity.Ageable"/>
    <method name="isImmuneToZombification" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the piglin is immune to zombification.

 @return Whether the piglin is immune to zombification]]>
      </doc>
    </method>
    <method name="setImmuneToZombification"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the piglin is immune to zombification.

 @param flag Whether the piglin is immune to zombification]]>
      </doc>
    </method>
    <method name="getConversionTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of ticks until this entity will be converted to a
 Zombified Piglin.

 When this reaches 300, the entity will be converted.

 @return conversion time
 @throws IllegalStateException if {@link #isConverting()} is false.]]>
      </doc>
    </method>
    <method name="setConversionTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="int"/>
      <doc>
      <![CDATA[Sets the amount of ticks until this entity will be converted to a
 Zombified Piglin.

 When this reaches 0, the entity will be converted. A value of less than 0
 will stop the current conversion process without converting the current
 entity.

 @param time new conversion time]]>
      </doc>
    </method>
    <method name="isConverting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if this entity is in the process of converting to a Zombified Piglin.

 @return conversion status]]>
      </doc>
    </method>
    <method name="isBaby" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Ageable#isAdult()}">
      <doc>
      <![CDATA[Gets whether the piglin is a baby

 @return Whether the piglin is a baby
 @deprecated see {@link Ageable#isAdult()}]]>
      </doc>
    </method>
    <method name="setBaby"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the piglin is a baby

 @param flag Whether the piglin is a baby
 @deprecated see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Piglin / Piglin Brute.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.PiglinAbstract -->
  <!-- start interface org.bukkit.entity.PiglinBrute -->
  <interface name="PiglinBrute"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.PiglinAbstract"/>
    <doc>
    <![CDATA[Represents a Piglin Brute.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.PiglinBrute -->
  <!-- start interface org.bukkit.entity.PigZombie -->
  <interface name="PigZombie"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Zombie"/>
    <method name="getAnger" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the pig zombie's current anger level.

 @return The anger level.]]>
      </doc>
    </method>
    <method name="setAnger"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Set the pig zombie's current anger level.

 @param level The anger level. Higher levels of anger take longer to
     wear off.]]>
      </doc>
    </method>
    <method name="setAngry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="angry" type="boolean"/>
      <doc>
      <![CDATA[Shorthand; sets to either 0 or the default level.

 @param angry Whether the zombie should be angry.]]>
      </doc>
    </method>
    <method name="isAngry" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shorthand; gets whether the zombie is angry.

 @return True if the zombie is angry, otherwise false.]]>
      </doc>
    </method>
    <method name="isConverting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<b>Not applicable to this entity</b>

 @return false]]>
      </doc>
    </method>
    <method name="getConversionTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<b>Not applicable to this entity</b>

 @return UnsuppotedOperationException]]>
      </doc>
    </method>
    <method name="setConversionTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="int"/>
      <doc>
      <![CDATA[<b>Not applicable to this entity</b>

 @param time unused]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Pig Zombie.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.PigZombie -->
  <!-- start interface org.bukkit.entity.Pillager -->
  <interface name="Pillager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Illager"/>
    <implements name="org.bukkit.inventory.InventoryHolder"/>
    <doc>
    <![CDATA[Illager entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Pillager -->
  <!-- start interface org.bukkit.entity.Player -->
  <interface name="Player"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.HumanEntity"/>
    <implements name="org.bukkit.conversations.Conversable"/>
    <implements name="org.bukkit.OfflinePlayer"/>
    <implements name="org.bukkit.plugin.messaging.PluginMessageRecipient"/>
    <implements name="com.destroystokyo.paper.network.NetworkClient"/>
    <method name="getDisplayName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the "friendly" name to display of this player. This may include
 color.
 <p>
 Note that this name will not be displayed in game, only in chat and
 places defined by plugins.

 @return the friendly name]]>
      </doc>
    </method>
    <method name="setDisplayName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the "friendly" name to display of this player. This may include
 color.
 <p>
 Note that this name will not be displayed in game, only in chat and
 places defined by plugins.

 @param name The new display name.]]>
      </doc>
    </method>
    <method name="getPlayerListName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the name that is shown on the player list.

 @return the player list name]]>
      </doc>
    </method>
    <method name="setPlayerListName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the name that is shown on the in-game player list.
 <p>
 If the value is null, the name will be identical to {@link #getName()}.

 @param name new player list name]]>
      </doc>
    </method>
    <method name="getPlayerListHeader" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the currently displayed player list header for this player.

 @return player list header or null]]>
      </doc>
    </method>
    <method name="getPlayerListFooter" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the currently displayed player list footer for this player.

 @return player list header or null]]>
      </doc>
    </method>
    <method name="setPlayerListHeader"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="header" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the currently displayed player list header for this player.

 @param header player list header, null for empty]]>
      </doc>
    </method>
    <method name="setPlayerListFooter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="footer" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the currently displayed player list footer for this player.

 @param footer player list footer, null for empty]]>
      </doc>
    </method>
    <method name="setPlayerListHeaderFooter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="header" type="java.lang.String"/>
      <param name="footer" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the currently displayed player list header and footer for this
 player.

 @param header player list header, null for empty
 @param footer player list footer, null for empty]]>
      </doc>
    </method>
    <method name="setCompassTarget"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Set the target of the player's compass.

 @param loc Location to point to]]>
      </doc>
    </method>
    <method name="getCompassTarget" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the previously set compass target.

 @return location of the target]]>
      </doc>
    </method>
    <method name="getAddress" return="java.net.InetSocketAddress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the socket address of this player

 @return the player's address]]>
      </doc>
    </method>
    <method name="sendRawMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sends this sender a message raw

 @param message Message to be displayed]]>
      </doc>
    </method>
    <method name="kickPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Kicks player with custom kick message.

 @param message kick message]]>
      </doc>
    </method>
    <method name="chat"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
      <doc>
      <![CDATA[Says a message (or runs a command).

 @param msg message to print]]>
      </doc>
    </method>
    <method name="performCommand" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String"/>
      <doc>
      <![CDATA[Makes the player perform the given command

 @param command Command to perform
 @return true if the command was successful, otherwise false]]>
      </doc>
    </method>
    <method name="isOnGround" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This value is controlled only by the client and is therefore
 unreliable and vulnerable to spoofing and/or desync depending on the
 context/time which it is accessed">
      <doc>
      <![CDATA[Returns true if the entity is supported by a block.

 This value is a state updated by the client after each movement.

 @return True if entity is on ground.
 @deprecated This value is controlled only by the client and is therefore
 unreliable and vulnerable to spoofing and/or desync depending on the
 context/time which it is accessed]]>
      </doc>
    </method>
    <method name="isSneaking" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if the player is in sneak mode

 @return true if player is in sneak mode]]>
      </doc>
    </method>
    <method name="setSneaking"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sneak" type="boolean"/>
      <doc>
      <![CDATA[Sets the sneak mode the player

 @param sneak true if player should appear sneaking]]>
      </doc>
    </method>
    <method name="isSprinting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the player is sprinting or not.

 @return true if player is sprinting.]]>
      </doc>
    </method>
    <method name="setSprinting"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sprinting" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the player is sprinting or not.

 @param sprinting true if the player should be sprinting]]>
      </doc>
    </method>
    <method name="saveData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Saves the players current location, health, inventory, motion, and
 other information into the username.dat file, in the world/player
 folder]]>
      </doc>
    </method>
    <method name="loadData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Loads the players current location, health, inventory, motion, and
 other information from the username.dat file, in the world/player
 folder.
 <p>
 Note: This will overwrite the players current inventory, health,
 motion, etc, with the state from the saved dat file.]]>
      </doc>
    </method>
    <method name="setSleepingIgnored"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isSleeping" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the player is ignored as not sleeping. If everyone is
 either sleeping or has this flag set, then time will advance to the
 next day. If everyone has this flag set but no one is actually in bed,
 then nothing will happen.

 @param isSleeping Whether to ignore.]]>
      </doc>
    </method>
    <method name="isSleepingIgnored" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the player is sleeping ignored.

 @return Whether player is ignoring sleep.]]>
      </doc>
    </method>
    <method name="getBedSpawnLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Location where the player will spawn at their bed, null if
 they have not slept in one or their current bed spawn is invalid.

 @return Bed Spawn Location if bed exists, otherwise null.]]>
      </doc>
    </method>
    <method name="setBedSpawnLocation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the Location where the player will spawn at their bed.

 @param location where to set the respawn location]]>
      </doc>
    </method>
    <method name="setBedSpawnLocation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="force" type="boolean"/>
      <doc>
      <![CDATA[Sets the Location where the player will spawn at their bed.

 @param location where to set the respawn location
 @param force whether to forcefully set the respawn location even if a
     valid bed is not present]]>
      </doc>
    </method>
    <method name="playNote"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="instrument" type="byte"/>
      <param name="note" type="byte"/>
      <doc>
      <![CDATA[Play a note for a player at a location. This requires a note block
 at the particular location (as far as the client is concerned). This
 will not work without a note block. This will not work with cake.

 @param loc The location of a note block.
 @param instrument The instrument ID.
 @param note The note ID.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="playNote"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="instrument" type="org.bukkit.Instrument"/>
      <param name="note" type="org.bukkit.Note"/>
      <doc>
      <![CDATA[Play a note for a player at a location. This requires a note block
 at the particular location (as far as the client is concerned). This
 will not work without a note block. This will not work with cake.

 @param loc The location of a note block
 @param instrument The instrument
 @param note The note]]>
      </doc>
    </method>
    <method name="playSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="sound" type="org.bukkit.Sound"/>
      <param name="volume" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Play a sound for a player at the location.
 <p>
 This function will fail silently if Location or Sound are null.

 @param location The location to play the sound
 @param sound The sound to play
 @param volume The volume of the sound
 @param pitch The pitch of the sound]]>
      </doc>
    </method>
    <method name="playSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="sound" type="java.lang.String"/>
      <param name="volume" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Play a sound for a player at the location.
 <p>
 This function will fail silently if Location or Sound are null. No
 sound will be heard by the player if their client does not have the
 respective sound for the value passed.

 @param location the location to play the sound
 @param sound the internal sound name to play
 @param volume the volume of the sound
 @param pitch the pitch of the sound]]>
      </doc>
    </method>
    <method name="playSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="sound" type="org.bukkit.Sound"/>
      <param name="category" type="org.bukkit.SoundCategory"/>
      <param name="volume" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Play a sound for a player at the location.
 <p>
 This function will fail silently if Location or Sound are null.

 @param location The location to play the sound
 @param sound The sound to play
 @param category The category of the sound
 @param volume The volume of the sound
 @param pitch The pitch of the sound]]>
      </doc>
    </method>
    <method name="playSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <param name="sound" type="java.lang.String"/>
      <param name="category" type="org.bukkit.SoundCategory"/>
      <param name="volume" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Play a sound for a player at the location.
 <p>
 This function will fail silently if Location or Sound are null. No sound
 will be heard by the player if their client does not have the respective
 sound for the value passed.

 @param location the location to play the sound
 @param sound the internal sound name to play
 @param category The category of the sound
 @param volume the volume of the sound
 @param pitch the pitch of the sound]]>
      </doc>
    </method>
    <method name="stopSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sound" type="org.bukkit.Sound"/>
      <doc>
      <![CDATA[Stop the specified sound from playing.

 @param sound the sound to stop]]>
      </doc>
    </method>
    <method name="stopSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sound" type="java.lang.String"/>
      <doc>
      <![CDATA[Stop the specified sound from playing.

 @param sound the sound to stop]]>
      </doc>
    </method>
    <method name="stopSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sound" type="org.bukkit.Sound"/>
      <param name="category" type="org.bukkit.SoundCategory"/>
      <doc>
      <![CDATA[Stop the specified sound from playing.

 @param sound the sound to stop
 @param category the category of the sound]]>
      </doc>
    </method>
    <method name="stopSound"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sound" type="java.lang.String"/>
      <param name="category" type="org.bukkit.SoundCategory"/>
      <doc>
      <![CDATA[Stop the specified sound from playing.

 @param sound the sound to stop
 @param category the category of the sound]]>
      </doc>
    </method>
    <method name="playEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="effect" type="org.bukkit.Effect"/>
      <param name="data" type="int"/>
      <doc>
      <![CDATA[Plays an effect to just this player.

 @param loc the location to play the effect at
 @param effect the {@link Effect}
 @param data a data bit needed for some effects
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="playEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="effect" type="org.bukkit.Effect"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Plays an effect to just this player.

 @param <T> the data based based on the type of the effect
 @param loc the location to play the effect at
 @param effect the {@link Effect}
 @param data a data bit needed for some effects]]>
      </doc>
    </method>
    <method name="sendBlockChange"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="material" type="org.bukkit.Material"/>
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Send a block change. This fakes a block change packet for a user at a
 certain location. This will not actually change the world in any way.

 @param loc The location of the changed block
 @param material The new block
 @param data The block data
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="sendBlockChange"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="block" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Send a block change. This fakes a block change packet for a user at a
 certain location. This will not actually change the world in any way.

 @param loc The location of the changed block
 @param block The new block]]>
      </doc>
    </method>
    <method name="sendChunkChange" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="sx" type="int"/>
      <param name="sy" type="int"/>
      <param name="sz" type="int"/>
      <param name="data" type="byte[]"/>
      <doc>
      <![CDATA[Send a chunk change. This fakes a chunk change packet for a user at a
 certain location. The updated cuboid must be entirely within a single
 chunk. This will not actually change the world in any way.
 <p>
 At least one of the dimensions of the cuboid must be even. The size of
 the data buffer must be 2.5*sx*sy*sz and formatted in accordance with
 the Packet51 format.

 @param loc The location of the cuboid
 @param sx The x size of the cuboid
 @param sy The y size of the cuboid
 @param sz The z size of the cuboid
 @param data The data to be sent
 @return true if the chunk change packet was sent
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="sendSignChange"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="lines" type="java.lang.String[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Send a sign change. This fakes a sign change packet for a user at
 a certain location. This will not actually change the world in any way.
 This method will use a sign at the location's block or a faked sign
 sent via
 {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
 <p>
 If the client does not have a sign at the given location it will
 display an error message to the user.

 @param loc the location of the sign
 @param lines the new text on the sign or null to clear it
 @throws IllegalArgumentException if location is null
 @throws IllegalArgumentException if lines is non-null and has a length less than 4]]>
      </doc>
    </method>
    <method name="sendSignChange"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="org.bukkit.Location"/>
      <param name="lines" type="java.lang.String[]"/>
      <param name="dyeColor" type="org.bukkit.DyeColor"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Send a sign change. This fakes a sign change packet for a user at
 a certain location. This will not actually change the world in any way.
 This method will use a sign at the location's block or a faked sign
 sent via
 {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
 <p>
 If the client does not have a sign at the given location it will
 display an error message to the user.

 @param loc the location of the sign
 @param lines the new text on the sign or null to clear it
 @param  dyeColor the color of the sign
 @throws IllegalArgumentException if location is null
 @throws IllegalArgumentException if dyeColor is null
 @throws IllegalArgumentException if lines is non-null and has a length less than 4]]>
      </doc>
    </method>
    <method name="sendMap"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="org.bukkit.map.MapView"/>
      <doc>
      <![CDATA[Render a map and send it to the player in its entirety. This may be
 used when streaming the map in the normal manner is not desirable.

 @param map The map to be sent]]>
      </doc>
    </method>
    <method name="banPlayerFull" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <doc>
      <![CDATA[Permanently Bans the Profile and IP address currently used by the player.

 @param reason Reason for ban
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerFull" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Permanently Bans the Profile and IP address currently used by the player.

 @param reason Reason for ban
 @param source Source of ban, or null for default
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerFull" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <doc>
      <![CDATA[Bans the Profile and IP address currently used by the player.

 @param reason Reason for Ban
 @param expires When to expire the ban
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerFull" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Bans the Profile and IP address currently used by the player.

 @param reason Reason for Ban
 @param expires When to expire the ban
 @param source Source of the ban, or null for default
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerIP" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="kickPlayer" type="boolean"/>
      <doc>
      <![CDATA[Permanently Bans the IP address currently used by the player.
 Does not ban the Profile, use {@link #banPlayerFull(String, Date, String)}

 @param reason Reason for ban
 @param kickPlayer Whether or not to kick the player afterwards
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerIP" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="source" type="java.lang.String"/>
      <param name="kickPlayer" type="boolean"/>
      <doc>
      <![CDATA[Permanently Bans the IP address currently used by the player.
 Does not ban the Profile, use {@link #banPlayerFull(String, Date, String)}
 @param reason Reason for ban
 @param source Source of ban, or null for default
 @param kickPlayer Whether or not to kick the player afterwards
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerIP" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <param name="kickPlayer" type="boolean"/>
      <doc>
      <![CDATA[Bans the IP address currently used by the player.
 Does not ban the Profile, use {@link #banPlayerFull(String, Date, String)}
 @param reason Reason for Ban
 @param expires When to expire the ban
 @param kickPlayer Whether or not to kick the player afterwards
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerIP" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <doc>
      <![CDATA[Permanently Bans the IP address currently used by the player.
 Does not ban the Profile, use {@link #banPlayerFull(String, Date, String)}

 @param reason Reason for ban
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerIP" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Permanently Bans the IP address currently used by the player.
 Does not ban the Profile, use {@link #banPlayerFull(String, Date, String)}
 @param reason Reason for ban
 @param source Source of ban, or null for default
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerIP" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <doc>
      <![CDATA[Bans the IP address currently used by the player.
 Does not ban the Profile, use {@link #banPlayerFull(String, Date, String)}
 @param reason Reason for Ban
 @param expires When to expire the ban
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerIP" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Bans the IP address currently used by the player.
 Does not ban the Profile, use {@link #banPlayerFull(String, Date, String)}
 @param reason Reason for Ban
 @param expires When to expire the ban
 @param source Source of the banm or null for default
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="banPlayerIP" return="org.bukkit.BanEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
      <param name="expires" type="java.util.Date"/>
      <param name="source" type="java.lang.String"/>
      <param name="kickPlayer" type="boolean"/>
      <doc>
      <![CDATA[Bans the IP address currently used by the player.
 Does not ban the Profile, use {@link #banPlayerFull(String, Date, String)}
 @param reason Reason for Ban
 @param expires When to expire the ban
 @param source Source of the banm or null for default
 @param kickPlayer if the targeted player should be kicked
 @return Ban Entry]]>
      </doc>
    </method>
    <method name="sendActionBar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sends an Action Bar message to the client.

 Use Section symbols for legacy color codes to send formatting.

 @param message The message to send]]>
      </doc>
    </method>
    <method name="sendActionBar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alternateChar" type="char"/>
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sends an Action Bar message to the client.

 Use supplied alternative character to the section symbol to represent legacy color codes.

 @param alternateChar Alternate symbol such as '&amp;'
 @param message The message to send]]>
      </doc>
    </method>
    <method name="sendActionBar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an Action Bar message to the client.

 @param message The components to send]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Sends the component to the player

 @param component the components to send]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an array of components as a single message to the player

 @param components the components to send]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This is unlikely the API you want to use. See {@link #sendActionBar(String)} for a more proper Action Bar API. This deprecated API may send unsafe items to the client.">
      <param name="position" type="net.md_5.bungee.api.ChatMessageType"/>
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an array of components as a single message to the specified screen position of this player

 @deprecated This is unlikely the API you want to use. See {@link #sendActionBar(String)} for a more proper Action Bar API. This deprecated API may send unsafe items to the client.
 @param position the screen position
 @param components the components to send]]>
      </doc>
    </method>
    <method name="setPlayerListHeaderFooter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="header" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <param name="footer" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Set the text displayed in the player list header and footer for this player

 @param header content for the top of the player list
 @param footer content for the bottom of the player list]]>
      </doc>
    </method>
    <method name="setPlayerListHeaderFooter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="header" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <param name="footer" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Set the text displayed in the player list header and footer for this player

 @param header content for the top of the player list
 @param footer content for the bottom of the player list]]>
      </doc>
    </method>
    <method name="setTitleTimes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #updateTitle(Title)}">
      <param name="fadeInTicks" type="int"/>
      <param name="stayTicks" type="int"/>
      <param name="fadeOutTicks" type="int"/>
      <doc>
      <![CDATA[Update the times for titles displayed to the player

 @param fadeInTicks  ticks to fade-in
 @param stayTicks    ticks to stay visible
 @param fadeOutTicks ticks to fade-out
 @deprecated Use {@link #updateTitle(Title)}]]>
      </doc>
    </method>
    <method name="setSubtitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #updateTitle(Title)}">
      <param name="subtitle" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Update the subtitle of titles displayed to the player

 @param subtitle Subtitle to set
 @deprecated Use {@link #updateTitle(Title)}]]>
      </doc>
    </method>
    <method name="setSubtitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #updateTitle(Title)}">
      <param name="subtitle" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Update the subtitle of titles displayed to the player

 @param subtitle Subtitle to set
 @deprecated Use {@link #updateTitle(Title)}]]>
      </doc>
    </method>
    <method name="showTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}">
      <param name="title" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Show the given title to the player, along with the last subtitle set, using the last set times

 @param title Title to set
 @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}]]>
      </doc>
    </method>
    <method name="showTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}">
      <param name="title" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Show the given title to the player, along with the last subtitle set, using the last set times

 @param title Title to set
 @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}]]>
      </doc>
    </method>
    <method name="showTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}">
      <param name="title" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <param name="subtitle" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <param name="fadeInTicks" type="int"/>
      <param name="stayTicks" type="int"/>
      <param name="fadeOutTicks" type="int"/>
      <doc>
      <![CDATA[Show the given title and subtitle to the player using the given times

 @param title        big text
 @param subtitle     little text under it
 @param fadeInTicks  ticks to fade-in
 @param stayTicks    ticks to stay visible
 @param fadeOutTicks ticks to fade-out
 @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}]]>
      </doc>
    </method>
    <method name="showTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}">
      <param name="title" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <param name="subtitle" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <param name="fadeInTicks" type="int"/>
      <param name="stayTicks" type="int"/>
      <param name="fadeOutTicks" type="int"/>
      <doc>
      <![CDATA[Show the given title and subtitle to the player using the given times

 @param title        big text
 @param subtitle     little text under it
 @param fadeInTicks  ticks to fade-in
 @param stayTicks    ticks to stay visible
 @param fadeOutTicks ticks to fade-out
 @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}]]>
      </doc>
    </method>
    <method name="sendTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="com.destroystokyo.paper.Title"/>
      <doc>
      <![CDATA[Show the title to the player, overriding any previously displayed title.

 <p>This method overrides any previous title, use {@link #updateTitle(Title)} to change the existing one.</p>

 @param title the title to send
 @throws NullPointerException if the title is null]]>
      </doc>
    </method>
    <method name="updateTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="com.destroystokyo.paper.Title"/>
      <doc>
      <![CDATA[Show the title to the player, overriding any previously displayed title.

 <p>This method doesn't override previous titles, but changes their values.</p>

 @param title the title to send
 @throws NullPointerException if title is null]]>
      </doc>
    </method>
    <method name="hideTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Hide any title that is currently visible to the player]]>
      </doc>
    </method>
    <method name="updateInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Forces an update of the player's entire inventory.]]>
      </doc>
    </method>
    <method name="setPlayerTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="relative" type="boolean"/>
      <doc>
      <![CDATA[Sets the current time on the player's client. When relative is true the
 player's time will be kept synchronized to its world time with the
 specified offset.
 <p>
 When using non relative time the player's time will stay fixed at the
 specified time parameter. It's up to the caller to continue updating
 the player's time. To restore player time to normal use
 resetPlayerTime().

 @param time The current player's perceived time or the player's time
     offset from the server time.
 @param relative When true the player time is kept relative to its world
     time.]]>
      </doc>
    </method>
    <method name="getPlayerTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player's current timestamp.

 @return The player's time]]>
      </doc>
    </method>
    <method name="getPlayerTimeOffset" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player's current time offset relative to server time, or
 the current player's fixed time if the player's time is absolute.

 @return The player's time]]>
      </doc>
    </method>
    <method name="isPlayerTimeRelative" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the player's time is relative to the server time,
 otherwise the player's time is absolute and will not change its current
 time unless done so with setPlayerTime().

 @return true if the player's time is relative to the server time.]]>
      </doc>
    </method>
    <method name="resetPlayerTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Restores the normal condition where the player's time is synchronized
 with the server time.
 <p>
 Equivalent to calling setPlayerTime(0, true).]]>
      </doc>
    </method>
    <method name="setPlayerWeather"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.WeatherType"/>
      <doc>
      <![CDATA[Sets the type of weather the player will see.  When used, the weather
 status of the player is locked until {@link #resetPlayerWeather()} is
 used.

 @param type The WeatherType enum type the player should experience]]>
      </doc>
    </method>
    <method name="getPlayerWeather" return="org.bukkit.WeatherType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of weather the player is currently experiencing.

 @return The WeatherType that the player is currently experiencing or
     null if player is seeing server weather.]]>
      </doc>
    </method>
    <method name="resetPlayerWeather"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Restores the normal condition where the player's weather is controlled
 by server conditions.]]>
      </doc>
    </method>
    <method name="giveExp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Gives the player the amount of experience specified.

 @param amount Exp amount to give]]>
      </doc>
    </method>
    <method name="giveExp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <param name="applyMending" type="boolean"/>
      <doc>
      <![CDATA[Gives the player the amount of experience specified.

 @param amount Exp amount to give
 @param applyMending Mend players items with mending, with same behavior as picking up orbs. calls {@link #applyMending(int)}]]>
      </doc>
    </method>
    <method name="applyMending" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Applies the mending effect to any items just as picking up an orb would.

 Can also be called with {@link #giveExp(int, boolean)} by passing true to applyMending

 @param amount Exp to apply
 @return the remaining experience]]>
      </doc>
    </method>
    <method name="giveExpLevels"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Gives the player the amount of experience levels specified. Levels can
 be taken by specifying a negative amount.

 @param amount amount of experience levels to give or take]]>
      </doc>
    </method>
    <method name="getExp" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the players current experience points towards the next level.
 <p>
 This is a percentage value. 0 is "no progress" and 1 is "next level".

 @return Current experience points]]>
      </doc>
    </method>
    <method name="setExp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exp" type="float"/>
      <doc>
      <![CDATA[Sets the players current experience points towards the next level
 <p>
 This is a percentage value. 0 is "no progress" and 1 is "next level".

 @param exp New experience points]]>
      </doc>
    </method>
    <method name="getLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the players current experience level

 @return Current experience level]]>
      </doc>
    </method>
    <method name="setLevel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the players current experience level

 @param level New experience level]]>
      </doc>
    </method>
    <method name="getTotalExperience" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the players total experience points.
 <br>
 This refers to the total amount of experience the player has collected
 over time and is not currently displayed to the client.

 @return Current total experience points]]>
      </doc>
    </method>
    <method name="setTotalExperience"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exp" type="int"/>
      <doc>
      <![CDATA[Sets the players current experience points.
 <br>
 This refers to the total amount of experience the player has collected
 over time and is not currently displayed to the client.

 @param exp New total experience points]]>
      </doc>
    </method>
    <method name="sendExperienceChange"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="progress" type="float"/>
      <doc>
      <![CDATA[Send an experience change.

 This fakes an experience change packet for a user. This will not actually
 change the experience points in any way.

 @param progress Experience progress percentage (between 0.0 and 1.0)
 @see #setExp(float)]]>
      </doc>
    </method>
    <method name="sendExperienceChange"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="progress" type="float"/>
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Send an experience change.

 This fakes an experience change packet for a user. This will not actually
 change the experience points in any way.

 @param progress New experience progress percentage (between 0.0 and 1.0)
 @param level New experience level

 @see #setExp(float)
 @see #setLevel(int)]]>
      </doc>
    </method>
    <method name="getExhaustion" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the players current exhaustion level.
 <p>
 Exhaustion controls how fast the food level drops. While you have a
 certain amount of exhaustion, your saturation will drop to zero, and
 then your food will drop to zero.

 @return Exhaustion level]]>
      </doc>
    </method>
    <method name="setExhaustion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Sets the players current exhaustion level

 @param value Exhaustion level]]>
      </doc>
    </method>
    <method name="getSaturation" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the players current saturation level.
 <p>
 Saturation is a buffer for food level. Your food level will not drop if
 you are saturated {@literal >} 0.

 @return Saturation level]]>
      </doc>
    </method>
    <method name="setSaturation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Sets the players current saturation level

 @param value Saturation level]]>
      </doc>
    </method>
    <method name="getFoodLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the players current food level

 @return Food level]]>
      </doc>
    </method>
    <method name="setFoodLevel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the players current food level

 @param value New food level]]>
      </doc>
    </method>
    <method name="getAllowFlight" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines if the Player is allowed to fly via jump key double-tap like
 in creative mode.

 @return True if the player is allowed to fly.]]>
      </doc>
    </method>
    <method name="setAllowFlight"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flight" type="boolean"/>
      <doc>
      <![CDATA[Sets if the Player is allowed to fly via jump key double-tap like in
 creative mode.

 @param flight If flight should be allowed.]]>
      </doc>
    </method>
    <method name="hidePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link #hidePlayer(Plugin, Player)}">
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Hides a player from this player

 @param player Player to hide
 @deprecated see {@link #hidePlayer(Plugin, Player)}]]>
      </doc>
    </method>
    <method name="hidePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Hides a player from this player

 @param plugin Plugin that wants to hide the player
 @param player Player to hide]]>
      </doc>
    </method>
    <method name="showPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link #showPlayer(Plugin, Player)}">
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Allows this player to see a player that was previously hidden

 @param player Player to show
 @deprecated see {@link #showPlayer(Plugin, Player)}]]>
      </doc>
    </method>
    <method name="showPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Allows this player to see a player that was previously hidden. If
 another another plugin had hidden the player too, then the player will
 remain hidden until the other plugin calls this method too.

 @param plugin Plugin that wants to show the player
 @param player Player to show]]>
      </doc>
    </method>
    <method name="canSee" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Checks to see if a player has been hidden from this player

 @param player Player to check
 @return True if the provided player is not being hidden from this
     player]]>
      </doc>
    </method>
    <method name="isFlying" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if this player is currently flying or not.

 @return True if the player is flying, else false.]]>
      </doc>
    </method>
    <method name="setFlying"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Makes this player start or stop flying.

 @param value True to fly.]]>
      </doc>
    </method>
    <method name="setFlySpeed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the speed at which a client will fly. Negative values indicate
 reverse directions.

 @param value The new speed, from -1 to 1.
 @throws IllegalArgumentException If new speed is less than -1 or
     greater than 1]]>
      </doc>
    </method>
    <method name="setWalkSpeed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the speed at which a client will walk. Negative values indicate
 reverse directions.

 @param value The new speed, from -1 to 1.
 @throws IllegalArgumentException If new speed is less than -1 or
     greater than 1]]>
      </doc>
    </method>
    <method name="getFlySpeed" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current allowed speed that a client can fly.

 @return The current allowed speed, from -1 to 1]]>
      </doc>
    </method>
    <method name="getWalkSpeed" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current allowed speed that a client can walk.

 @return The current allowed speed, from -1 to 1]]>
      </doc>
    </method>
    <method name="setTexturePack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Minecraft no longer uses textures packs. Instead you
     should use {@link #setResourcePack(String)}.">
      <param name="url" type="java.lang.String"/>
      <doc>
      <![CDATA[Request that the player's client download and switch texture packs.
 <p>
 The player's client will download the new texture pack asynchronously
 in the background, and will automatically switch to it once the
 download is complete. If the client has downloaded and cached the same
 texture pack in the past, it will perform a file size check against
 the response content to determine if the texture pack has changed and
 needs to be downloaded again. When this request is sent for the very
 first time from a given server, the client will first display a
 confirmation GUI to the player before proceeding with the download.
 <p>
 Notes:
 <ul>
 <li>Players can disable server textures on their client, in which
     case this method will have no affect on them. Use the
     {@link PlayerResourcePackStatusEvent} to figure out whether or not
     the player loaded the pack!
 <li>There is no concept of resetting texture packs back to default
     within Minecraft, so players will have to relog to do so or you
     have to send an empty pack.
 <li>The request is send with "null" as the hash. This might result
     in newer versions not loading the pack correctly.
 </ul>

 @param url The URL from which the client will download the texture
     pack. The string must contain only US-ASCII characters and should
     be encoded as per RFC 1738.
 @throws IllegalArgumentException Thrown if the URL is null.
 @throws IllegalArgumentException Thrown if the URL is too long.
 @deprecated Minecraft no longer uses textures packs. Instead you
     should use {@link #setResourcePack(String)}.]]>
      </doc>
    </method>
    <method name="setResourcePack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #setResourcePack(String, String)}">
      <param name="url" type="java.lang.String"/>
      <doc>
      <![CDATA[Request that the player's client download and switch resource packs.
 <p>
 The player's client will download the new resource pack asynchronously
 in the background, and will automatically switch to it once the
 download is complete. If the client has downloaded and cached the same
 resource pack in the past, it will perform a file size check against
 the response content to determine if the resource pack has changed and
 needs to be downloaded again. When this request is sent for the very
 first time from a given server, the client will first display a
 confirmation GUI to the player before proceeding with the download.
 <p>
 Notes:
 <ul>
 <li>Players can disable server resources on their client, in which
     case this method will have no affect on them. Use the
     {@link PlayerResourcePackStatusEvent} to figure out whether or not
     the player loaded the pack!
 <li>There is no concept of resetting resource packs back to default
     within Minecraft, so players will have to relog to do so or you
     have to send an empty pack.
 <li>The request is send with "null" as the hash. This might result
     in newer versions not loading the pack correctly.
 </ul>

 @param url The URL from which the client will download the resource
     pack. The string must contain only US-ASCII characters and should
     be encoded as per RFC 1738.
 @throws IllegalArgumentException Thrown if the URL is null.
 @throws IllegalArgumentException Thrown if the URL is too long. The
     length restriction is an implementation specific arbitrary value.
 @deprecated use {@link #setResourcePack(String, String)}]]>
      </doc>
    </method>
    <method name="setResourcePack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <param name="hash" type="byte[]"/>
      <doc>
      <![CDATA[Request that the player's client download and switch resource packs.
 <p>
 The player's client will download the new resource pack asynchronously
 in the background, and will automatically switch to it once the
 download is complete. If the client has downloaded and cached a
 resource pack with the same hash in the past it will not download but
 directly apply the cached pack. When this request is sent for the very
 first time from a given server, the client will first display a
 confirmation GUI to the player before proceeding with the download.
 <p>
 Notes:
 <ul>
 <li>Players can disable server resources on their client, in which
     case this method will have no affect on them. Use the
     {@link PlayerResourcePackStatusEvent} to figure out whether or not
     the player loaded the pack!
 <li>There is no concept of resetting resource packs back to default
     within Minecraft, so players will have to relog to do so or you
     have to send an empty pack.
 </ul>

 @param url The URL from which the client will download the resource
     pack. The string must contain only US-ASCII characters and should
     be encoded as per RFC 1738.
 @param hash The sha1 hash sum of the resource pack file which is used
     to apply a cached version of the pack directly without downloading
     if it is available. Hast to be 20 bytes long!
 @throws IllegalArgumentException Thrown if the URL is null.
 @throws IllegalArgumentException Thrown if the URL is too long. The
     length restriction is an implementation specific arbitrary value.
 @throws IllegalArgumentException Thrown if the hash is null.
 @throws IllegalArgumentException Thrown if the hash is not 20 bytes
     long.]]>
      </doc>
    </method>
    <method name="getScoreboard" return="org.bukkit.scoreboard.Scoreboard"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Scoreboard displayed to this player

 @return The current scoreboard seen by this player]]>
      </doc>
    </method>
    <method name="setScoreboard"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scoreboard" type="org.bukkit.scoreboard.Scoreboard"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Sets the player's visible Scoreboard.

 @param scoreboard New Scoreboard for the player
 @throws IllegalArgumentException if scoreboard is null
 @throws IllegalArgumentException if scoreboard was not created by the
     {@link org.bukkit.scoreboard.ScoreboardManager scoreboard manager}
 @throws IllegalStateException if this is a player that is not logged
     yet or has logged out]]>
      </doc>
    </method>
    <method name="isHealthScaled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the client is displayed a 'scaled' health, that is, health on a
 scale from 0-{@link #getHealthScale()}.

 @return if client health display is scaled
 @see Player#setHealthScaled(boolean)]]>
      </doc>
    </method>
    <method name="setHealthScaled"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="boolean"/>
      <doc>
      <![CDATA[Sets if the client is displayed a 'scaled' health, that is, health on a
 scale from 0-{@link #getHealthScale()}.
 <p>
 Displayed health follows a simple formula <code>displayedHealth =
 getHealth() / getMaxHealth() * getHealthScale()</code>.

 @param scale if the client health display is scaled]]>
      </doc>
    </method>
    <method name="setHealthScale"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="double"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the number to scale health to for the client; this will also
 {@link #setHealthScaled(boolean) setHealthScaled(true)}.
 <p>
 Displayed health follows a simple formula <code>displayedHealth =
 getHealth() / getMaxHealth() * getHealthScale()</code>.

 @param scale the number to scale health to
 @throws IllegalArgumentException if scale is &lt;0
 @throws IllegalArgumentException if scale is {@link Double#NaN}
 @throws IllegalArgumentException if scale is too high]]>
      </doc>
    </method>
    <method name="getHealthScale" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number that health is scaled to for the client.

 @return the number that health would be scaled to for the client if
     HealthScaling is set to true
 @see Player#setHealthScale(double)
 @see Player#setHealthScaled(boolean)]]>
      </doc>
    </method>
    <method name="getSpectatorTarget" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity which is followed by the camera when in
 {@link GameMode#SPECTATOR}.

 @return the followed entity, or null if not in spectator mode or not
 following a specific entity.]]>
      </doc>
    </method>
    <method name="setSpectatorTarget"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Sets the entity which is followed by the camera when in
 {@link GameMode#SPECTATOR}.

 @param entity the entity to follow or null to reset
 @throws IllegalStateException if the player is not in
 {@link GameMode#SPECTATOR}]]>
      </doc>
    </method>
    <method name="sendTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="API behavior subject to change">
      <param name="title" type="java.lang.String"/>
      <param name="subtitle" type="java.lang.String"/>
      <doc>
      <![CDATA[Sends a title and a subtitle message to the player. If either of these
 values are null, they will not be sent and the display will remain
 unchanged. If they are empty strings, the display will be updated as
 such. If the strings contain a new line, only the first line will be
 sent. The titles will be displayed with the client's default timings.

 @param title Title text
 @param subtitle Subtitle text
 @deprecated API behavior subject to change]]>
      </doc>
    </method>
    <method name="sendTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
      <param name="subtitle" type="java.lang.String"/>
      <param name="fadeIn" type="int"/>
      <param name="stay" type="int"/>
      <param name="fadeOut" type="int"/>
      <doc>
      <![CDATA[Sends a title and a subtitle message to the player. If either of these
 values are null, they will not be sent and the display will remain
 unchanged. If they are empty strings, the display will be updated as
 such. If the strings contain a new line, only the first line will be
 sent. All timings values may take a value of -1 to indicate that they
 will use the last value sent (or the defaults if no title has been
 displayed).

 @param title Title text
 @param subtitle Subtitle text
 @param fadeIn time in ticks for titles to fade in. Defaults to 10.
 @param stay time in ticks for titles to stay. Defaults to 70.
 @param fadeOut time in ticks for titles to fade out. Defaults to 20.]]>
      </doc>
    </method>
    <method name="resetTitle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the title displayed to the player. This will clear the displayed
 title / subtitle and reset timings to their default values.]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location.

 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location.

 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="location" type="org.bukkit.Location"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param location the location to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="spawnParticle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particle" type="org.bukkit.Particle"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="count" type="int"/>
      <param name="offsetX" type="double"/>
      <param name="offsetY" type="double"/>
      <param name="offsetZ" type="double"/>
      <param name="extra" type="double"/>
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Spawns the particle (the number of times specified by count)
 at the target location. The position of each particle will be
 randomized positively and negatively by the offset parameters
 on each axis.

 @param <T> type of particle data (see {@link Particle#getDataType()}
 @param particle the particle to spawn
 @param x the position on the x axis to spawn at
 @param y the position on the y axis to spawn at
 @param z the position on the z axis to spawn at
 @param count the number of particles
 @param offsetX the maximum random offset on the X axis
 @param offsetY the maximum random offset on the Y axis
 @param offsetZ the maximum random offset on the Z axis
 @param extra the extra data for this particle, depends on the
              particle used (normally speed)
 @param data the data to use for the particle or null,
             the type of this depends on {@link Particle#getDataType()}
 @param <T> Type]]>
      </doc>
    </method>
    <method name="getAdvancementProgress" return="org.bukkit.advancement.AdvancementProgress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="advancement" type="org.bukkit.advancement.Advancement"/>
      <doc>
      <![CDATA[Return the player's progression on the specified advancement.

 @param advancement advancement
 @return object detailing the player's progress]]>
      </doc>
    </method>
    <method name="getClientViewDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the player's current client side view distance.
 <br>
 Will default to the server view distance if the client has not yet
 communicated this information,

 @return client view distance as above]]>
      </doc>
    </method>
    <method name="getLocale" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player's current locale.

 The value of the locale String is not defined properly.
 <br>
 The vanilla Minecraft client will use lowercase language / country pairs
 separated by an underscore, but custom resource packs may use any format
 they wish.

 @return the player's locale]]>
      </doc>
    </method>
    <method name="getAffectsSpawning" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether the player can affect mob spawning

 @return if the player can affect mob spawning]]>
      </doc>
    </method>
    <method name="setAffectsSpawning"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="affects" type="boolean"/>
      <doc>
      <![CDATA[Set whether the player can affect mob spawning

 @param affects Whether the player can affect mob spawning]]>
      </doc>
    </method>
    <method name="getViewDistance" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the view distance for this player

 @return the player's view distance]]>
      </doc>
    </method>
    <method name="setViewDistance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="viewDistance" type="int"/>
      <doc>
      <![CDATA[Sets the view distance for this player

 @param viewDistance the player's view distance]]>
      </doc>
    </method>
    <method name="updateCommands"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Update the list of commands sent to the client.
 <br>
 Generally useful to ensure the client has a complete list of commands
 after permission changes are done.]]>
      </doc>
    </method>
    <method name="openBook"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="book" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Open a {@link Material#WRITTEN_BOOK} for a Player

 @param book The book to open for this player]]>
      </doc>
    </method>
    <method name="setResourcePack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <param name="hash" type="java.lang.String"/>
      <doc>
      <![CDATA[Request that the player's client download and switch resource packs.
 <p>
 The player's client will download the new resource pack asynchronously
 in the background, and will automatically switch to it once the
 download is complete. If the client has downloaded and cached the same
 resource pack in the past, it will perform a quick timestamp check
 over the network to determine if the resource pack has changed and
 needs to be downloaded again. When this request is sent for the very
 first time from a given server, the client will first display a
 confirmation GUI to the player before proceeding with the download.
 <p>
 Notes:
 <ul>
 <li>Players can disable server resources on their client, in which
     case this method will have no affect on them.
 <li>There is no concept of resetting resource packs back to default
     within Minecraft, so players will have to relog to do so.
 </ul>

 @param url The URL from which the client will download the resource
     pack. The string must contain only US-ASCII characters and should
     be encoded as per RFC 1738.
 @param hash A 40 character hexadecimal and lowercase SHA-1 digest of
     the resource pack file.
 @throws IllegalArgumentException Thrown if the URL is null.
 @throws IllegalArgumentException Thrown if the URL is too long. The
     length restriction is an implementation specific arbitrary value.]]>
      </doc>
    </method>
    <method name="getResourcePackStatus" return="org.bukkit.event.player.PlayerResourcePackStatusEvent.Status"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the most recent resource pack status received from the player,
         or null if no status has ever been received from this player.]]>
      </doc>
    </method>
    <method name="getResourcePackHash" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This is no longer sent from the client and will always be null">
      <doc>
      <![CDATA[@return the most recent resource pack hash received from the player,
         or null if no hash has ever been received from this player.

 @deprecated This is no longer sent from the client and will always be null]]>
      </doc>
    </method>
    <method name="hasResourcePack" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if the last resource pack status received from this player
         was {@link org.bukkit.event.player.PlayerResourcePackStatusEvent.Status#SUCCESSFULLY_LOADED}]]>
      </doc>
    </method>
    <method name="getPlayerProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of this players profile
 @return The players profile object]]>
      </doc>
    </method>
    <method name="setPlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profile" type="com.destroystokyo.paper.profile.PlayerProfile"/>
      <doc>
      <![CDATA[Changes the PlayerProfile for this player. This will cause this player
 to be reregistered to all clients that can currently see this player
 @param profile The new profile to use]]>
      </doc>
    </method>
    <method name="getCooldownPeriod" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the amount of ticks the current cooldown lasts

 @return Amount of ticks cooldown will last]]>
      </doc>
    </method>
    <method name="getCooledAttackStrength" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="adjustTicks" type="float"/>
      <doc>
      <![CDATA[Returns the percentage of attack power available based on the cooldown (zero to one).

 @param adjustTicks Amount of ticks to add to cooldown counter for this calculation
 @return Percentage of attack power available]]>
      </doc>
    </method>
    <method name="resetCooldown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the cooldown counter to 0, effectively starting the cooldown period.]]>
      </doc>
    </method>
    <method name="getClientOption" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.destroystokyo.paper.ClientOption&lt;T&gt;"/>
      <doc>
      <![CDATA[@return the client option value of the player]]>
      </doc>
    </method>
    <method name="boostElytra" return="org.bukkit.entity.Firework"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="firework" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Boost a Player that's {@link #isGliding()} using a {@link Firework}.
 If the creation of the entity is cancelled, no boosting is done.
 This method does not fire {@link com.destroystokyo.paper.event.player.PlayerElytraBoostEvent}.

 @param firework The {@link Material#FIREWORK_ROCKET} to boost the player with
 @return The {@link Firework} boosting the Player or null if the spawning of the entity was cancelled
 @throws IllegalArgumentException if {@link #isGliding()} is false
 or if the {@code firework} isn't a {@link Material#FIREWORK_ROCKET}]]>
      </doc>
    </method>
    <method name="getClientBrandName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns player's client brand name. If the client didn't send this information, the brand name will be null.<br>
 For the Notchian client this name defaults to <code>vanilla</code>. Some modified clients report other names such as <code>forge</code>.<br>
 @return client brand name]]>
      </doc>
    </method>
    <method name="spigot" return="org.bukkit.entity.Player.Spigot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a player, connected or not]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Player -->
  <!-- start class org.bukkit.entity.Player.Spigot -->
  <class name="Player.Spigot" extends="org.bukkit.entity.Entity.Spigot"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spigot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRawAddress" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the connection address of this player, regardless of whether it
 has been spoofed or not.

 @return the player's connection address]]>
      </doc>
    </method>
    <method name="getCollidesWithEntities" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link LivingEntity#isCollidable()}">
      <doc>
      <![CDATA[Gets whether the player collides with entities

 @return the player's collision toggle state
 @deprecated see {@link LivingEntity#isCollidable()}]]>
      </doc>
    </method>
    <method name="setCollidesWithEntities"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="{@link LivingEntity#setCollidable(boolean)}">
      <param name="collides" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the player collides with entities

 @param collides whether the player should collide with entities or
 not.
 @deprecated {@link LivingEntity#setCollidable(boolean)}]]>
      </doc>
    </method>
    <method name="respawn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Respawns the player if dead.]]>
      </doc>
    </method>
    <method name="getHiddenPlayers" return="java.util.Set&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all players hidden with {@link #hidePlayer(org.bukkit.entity.Player)}.

 @return a Set with all hidden players]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent"/>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This is unlikely the API you want to use. See {@link #sendActionBar(String)} for a more proper Action Bar API. This deprecated API may send unsafe items to the client.">
      <param name="position" type="net.md_5.bungee.api.ChatMessageType"/>
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Sends the component to the specified screen position of this player

 @deprecated This is unlikely the API you want to use. See {@link #sendActionBar(String)} for a more proper Action Bar API. This deprecated API may send unsafe items to the client.
 @param position the screen position
 @param component the components to send]]>
      </doc>
    </method>
    <method name="sendMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This is unlikely the API you want to use. See {@link #sendActionBar(String)} for a more proper Action Bar API. This deprecated API may send unsafe items to the client.">
      <param name="position" type="net.md_5.bungee.api.ChatMessageType"/>
      <param name="components" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sends an array of components as a single message to the specified screen position of this player

 @deprecated This is unlikely the API you want to use. See {@link #sendActionBar(String)} for a more proper Action Bar API. This deprecated API may send unsafe items to the client.
 @param position the screen position
 @param components the components to send]]>
      </doc>
    </method>
    <method name="getPing" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.entity.Player.Spigot -->
  <!-- start interface org.bukkit.entity.PolarBear -->
  <interface name="PolarBear"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <doc>
    <![CDATA[Represents a polar bear.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.PolarBear -->
  <!-- start class org.bukkit.entity.Pose -->
  <class name="Pose" extends="java.lang.Enum&lt;org.bukkit.entity.Pose&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Pose[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Pose"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents an entity body pose.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Pose -->
  <!-- start interface org.bukkit.entity.Projectile -->
  <interface name="Projectile"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getShooter" return="org.bukkit.projectiles.ProjectileSource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve the shooter of this projectile.

 @return the {@link ProjectileSource} that shot this projectile]]>
      </doc>
    </method>
    <method name="setShooter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.projectiles.ProjectileSource"/>
      <doc>
      <![CDATA[Set the shooter of this projectile.

 @param source the {@link ProjectileSource} that shot this projectile]]>
      </doc>
    </method>
    <method name="doesBounce" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determine if this projectile should bounce or not when it hits.
 <p>
 If a small fireball does not bounce it will set the target on fire.

 @return true if it should bounce.]]>
      </doc>
    </method>
    <method name="setBounce"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="doesBounce" type="boolean"/>
      <doc>
      <![CDATA[Set whether or not this projectile should bounce or not when it hits
 something.

 @param doesBounce whether or not it should bounce.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a shootable entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Projectile -->
  <!-- start interface org.bukkit.entity.PufferFish -->
  <interface name="PufferFish"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Fish"/>
    <method name="getPuffState" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current puff state of this fish (i.e. how inflated it is).

 @return current puff state]]>
      </doc>
    </method>
    <method name="setPuffState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="int"/>
      <doc>
      <![CDATA[Sets the current puff state of this fish (i.e. how inflated it is).

 @param state new puff state]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a puffer fish.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.PufferFish -->
  <!-- start interface org.bukkit.entity.Rabbit -->
  <interface name="Rabbit"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <method name="getRabbitType" return="org.bukkit.entity.Rabbit.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The type of rabbit.]]>
      </doc>
    </method>
    <method name="setRabbitType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.entity.Rabbit.Type"/>
      <doc>
      <![CDATA[@param type Sets the type of rabbit for this entity.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.Rabbit -->
  <!-- start class org.bukkit.entity.Rabbit.Type -->
  <class name="Rabbit.Type" extends="java.lang.Enum&lt;org.bukkit.entity.Rabbit.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Rabbit.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Rabbit.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the various types a Rabbit might be.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Rabbit.Type -->
  <!-- start interface org.bukkit.entity.Raider -->
  <interface name="Raider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <method name="getPatrolTarget" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block the raider is targeting to patrol.

 @return target block or null]]>
      </doc>
    </method>
    <method name="setPatrolTarget"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <doc>
      <![CDATA[Sets the block the raider is targeting to patrol.

 @param block target block or null. Must be in same world as the entity]]>
      </doc>
    </method>
    <method name="isPatrolLeader" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this entity is a patrol leader.

 @return patrol leader status]]>
      </doc>
    </method>
    <method name="setPatrolLeader"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leader" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this entity is a patrol leader.

 @param leader patrol leader status]]>
      </doc>
    </method>
    <method name="isCanJoinRaid" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this mob can join an active raid.

 @return CanJoinRaid status]]>
      </doc>
    </method>
    <method name="setCanJoinRaid"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="join" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this mob can join an active raid.

 @param join CanJoinRaid status]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.Raider -->
  <!-- start interface org.bukkit.entity.Ravager -->
  <interface name="Ravager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Raider"/>
    <doc>
    <![CDATA[Illager beast.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Ravager -->
  <!-- start interface org.bukkit.entity.Salmon -->
  <interface name="Salmon"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Fish"/>
    <doc>
    <![CDATA[Represents a salmon fish.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Salmon -->
  <!-- start interface org.bukkit.entity.Sheep -->
  <interface name="Sheep"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <implements name="org.bukkit.material.Colorable"/>
    <method name="isSheared" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Whether the sheep is sheared.]]>
      </doc>
    </method>
    <method name="setSheared"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[@param flag Whether to shear the sheep]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Sheep.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Sheep -->
  <!-- start interface org.bukkit.entity.Shulker -->
  <interface name="Shulker"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Golem"/>
    <implements name="org.bukkit.material.Colorable"/>
  </interface>
  <!-- end interface org.bukkit.entity.Shulker -->
  <!-- start interface org.bukkit.entity.ShulkerBullet -->
  <interface name="ShulkerBullet"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Projectile"/>
    <method name="getTarget" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve the target of this bullet.

 @return the targeted entity]]>
      </doc>
    </method>
    <method name="setTarget"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Sets the target of this bullet

 @param target the entity to target]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.ShulkerBullet -->
  <!-- start interface org.bukkit.entity.Silverfish -->
  <interface name="Silverfish"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <doc>
    <![CDATA[Represents a Silverfish.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Silverfish -->
  <!-- start interface org.bukkit.entity.Sittable -->
  <interface name="Sittable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isSitting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this animal is sitting

 @return true if sitting]]>
      </doc>
    </method>
    <method name="setSitting"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sitting" type="boolean"/>
      <doc>
      <![CDATA[Sets if this animal is sitting. Will remove any path that the animal
 was following beforehand.

 @param sitting true if sitting]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An animal that can sit still.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Sittable -->
  <!-- start interface org.bukkit.entity.SizedFireball -->
  <interface name="SizedFireball"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Fireball"/>
    <method name="getDisplayItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the display {@link ItemStack}.

 @return display ItemStack]]>
      </doc>
    </method>
    <method name="setDisplayItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the display {@link ItemStack} for the fireball.

 @param item the ItemStack to display]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a sized fireball.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.SizedFireball -->
  <!-- start interface org.bukkit.entity.Skeleton -->
  <interface name="Skeleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <implements name="com.destroystokyo.paper.entity.RangedEntity"/>
    <method name="getSkeletonType" return="org.bukkit.entity.Skeleton.SkeletonType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="should check what class instance this is">
      <doc>
      <![CDATA[Gets the current type of this skeleton.

 @return Current type
 @deprecated should check what class instance this is]]>
      </doc>
    </method>
    <method name="setSkeletonType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Must spawn a new subtype variant">
      <param name="type" type="org.bukkit.entity.Skeleton.SkeletonType"/>
      <doc>
      <![CDATA[@param type type
 @deprecated Must spawn a new subtype variant]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Skeleton.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Skeleton -->
  <!-- start class org.bukkit.entity.Skeleton.SkeletonType -->
  <class name="Skeleton.SkeletonType" extends="java.lang.Enum&lt;org.bukkit.entity.Skeleton.SkeletonType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Skeleton.SkeletonType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Skeleton.SkeletonType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.entity.Skeleton.SkeletonType -->
  <!-- start interface org.bukkit.entity.SkeletonHorse -->
  <interface name="SkeletonHorse"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractHorse"/>
    <method name="getTrapTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTrap" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTrap"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trap" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Represents a SkeletonHorse - variant of {@link AbstractHorse}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.SkeletonHorse -->
  <!-- start interface org.bukkit.entity.Slime -->
  <interface name="Slime"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Mob"/>
    <method name="getSize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The size of the slime]]>
      </doc>
    </method>
    <method name="setSize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sz" type="int"/>
      <doc>
      <![CDATA[@param sz The new size of the slime.]]>
      </doc>
    </method>
    <method name="canWander" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether this slime can randomly wander/jump around on its own

 @return true if can wander]]>
      </doc>
    </method>
    <method name="setWander"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canWander" type="boolean"/>
      <doc>
      <![CDATA[Set whether this slime can randomly wander/jump around on its own

 @param canWander true if can wander]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Slime.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Slime -->
  <!-- start interface org.bukkit.entity.SmallFireball -->
  <interface name="SmallFireball"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.SizedFireball"/>
    <doc>
    <![CDATA[Represents a small {@link Fireball}]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.SmallFireball -->
  <!-- start interface org.bukkit.entity.Snowball -->
  <interface name="Snowball"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ThrowableProjectile"/>
    <doc>
    <![CDATA[Represents a snowball.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Snowball -->
  <!-- start interface org.bukkit.entity.Snowman -->
  <interface name="Snowman"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Golem"/>
    <implements name="com.destroystokyo.paper.entity.RangedEntity"/>
    <method name="isDerp" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this snowman is in "derp mode", meaning it is not wearing a
 pumpkin.

 @return True if the snowman is bald, false if it is wearing a pumpkin]]>
      </doc>
    </method>
    <method name="setDerp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="derpMode" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this snowman is in "derp mode", meaning it is not wearing a
 pumpkin. NOTE: This value is not persisted to disk and will therefore
 reset when the chunk is reloaded.

 @param derpMode True to remove the pumpkin, false to add a pumpkin]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a snowman entity]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Snowman -->
  <!-- start interface org.bukkit.entity.SpectralArrow -->
  <interface name="SpectralArrow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractArrow"/>
    <method name="getGlowingTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the amount of time that this arrow will apply
 the glowing effect for.

 @return the glowing effect ticks]]>
      </doc>
    </method>
    <method name="setGlowingTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="int"/>
      <doc>
      <![CDATA[Sets the amount of time to apply the glowing effect for.

 @param duration the glowing effect ticks]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a spectral arrow.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.SpectralArrow -->
  <!-- start interface org.bukkit.entity.Spellcaster -->
  <interface name="Spellcaster"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Illager"/>
    <method name="getSpell" return="org.bukkit.entity.Spellcaster.Spell"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link Spell} the entity is currently using.

 @return the current spell]]>
      </doc>
    </method>
    <method name="setSpell"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spell" type="org.bukkit.entity.Spellcaster.Spell"/>
      <doc>
      <![CDATA[Sets the {@link Spell} the entity is currently using.

 @param spell the spell the entity should be using]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a spell casting "Illager".]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Spellcaster -->
  <!-- start class org.bukkit.entity.Spellcaster.Spell -->
  <class name="Spellcaster.Spell" extends="java.lang.Enum&lt;org.bukkit.entity.Spellcaster.Spell&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.Spellcaster.Spell[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Spellcaster.Spell"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the current spell the entity is using.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Spellcaster.Spell -->
  <!-- start interface org.bukkit.entity.Spider -->
  <interface name="Spider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <doc>
    <![CDATA[Represents a Spider.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Spider -->
  <!-- start interface org.bukkit.entity.SplashPotion -->
  <interface name="SplashPotion"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="splash status depends on only on the potion item.">
    <implements name="org.bukkit.entity.ThrownPotion"/>
    <doc>
    <![CDATA[Represents a thrown splash potion bottle

 @deprecated splash status depends on only on the potion item.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.SplashPotion -->
  <!-- start interface org.bukkit.entity.Squid -->
  <interface name="Squid"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.WaterMob"/>
    <doc>
    <![CDATA[Represents a Squid.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Squid -->
  <!-- start interface org.bukkit.entity.Steerable -->
  <interface name="Steerable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <method name="hasSaddle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the pig has a saddle.

 @return if the pig has been saddled.]]>
      </doc>
    </method>
    <method name="setSaddle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="saddled" type="boolean"/>
      <doc>
      <![CDATA[Sets if the pig has a saddle or not

 @param saddled set if the pig has a saddle or not.]]>
      </doc>
    </method>
    <method name="getBoostTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the time in ticks this entity's movement is being increased.

 Movement speed is often increased as a result of using the
 {@link #getSteerMaterial()}.

 @return the current boost ticks]]>
      </doc>
    </method>
    <method name="setBoostTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Set the time in ticks this entity's movement will be increased.

 This will reset the current boost ticks to 0
 ({@link #getCurrentBoostTicks()}).

 @param ticks the boost time]]>
      </doc>
    </method>
    <method name="getCurrentBoostTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the time in ticks this entity's movement has been increased as of the
 most recent boost.

 Current boost ticks will never be {@literal >} {@link #getBoostTicks()}.

 @return the current boost ticks]]>
      </doc>
    </method>
    <method name="setCurrentBoostTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Set the time in ticks this entity's movement has been increased relative
 to the most recent boost.

 @param ticks the current boost ticks. Must be {@literal >=} 0 and {@literal <=}
 {@link #getBoostTicks()}]]>
      </doc>
    </method>
    <method name="getSteerMaterial" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the material used to steer this entity when ridden by a player.

 @return the lure material]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an entity which may be saddled, ridden and steered using an item.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Steerable -->
  <!-- start interface org.bukkit.entity.Stray -->
  <interface name="Stray"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Skeleton"/>
    <doc>
    <![CDATA[Represents a Stray - variant of {@link Skeleton}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Stray -->
  <!-- start interface org.bukkit.entity.Strider -->
  <interface name="Strider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Steerable"/>
    <implements name="org.bukkit.entity.Vehicle"/>
    <method name="isShivering" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check whether or not this strider is out of warm blocks and shivering.

 @return true if shivering, false otherwise]]>
      </doc>
    </method>
    <method name="setShivering"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shivering" type="boolean"/>
      <doc>
      <![CDATA[Set whether or not this strider is shivering.

 Note that the shivering state is updated frequently on the server,
 therefore this method may not affect the entity for long enough to have a
 noticeable difference.

 @param shivering its new shivering state]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Strider.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Strider -->
  <!-- start interface org.bukkit.entity.Tameable -->
  <interface name="Tameable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <method name="isTamed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this is tamed
 <p>
 If something is tamed then a player can not tame it through normal
 methods, even if it does not belong to anyone in particular.

 @return true if this has been tamed]]>
      </doc>
    </method>
    <method name="setTamed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tame" type="boolean"/>
      <doc>
      <![CDATA[Sets if this has been tamed. Not necessary if the method setOwner has
 been used, as it tames automatically.
 <p>
 If something is tamed then a player can not tame it through normal
 methods, even if it does not belong to anyone in particular.

 @param tame true if tame]]>
      </doc>
    </method>
    <method name="getOwnerUniqueId" return="java.util.UUID"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the owners UUID

 @return the owners UUID, or null if not owned]]>
      </doc>
    </method>
    <method name="getOwner" return="org.bukkit.entity.AnimalTamer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current owning AnimalTamer

 @see #getOwnerUniqueId() Recommended to use UUID version instead of this for performance.
 This method will cause OfflinePlayer to be loaded from disk if the owner is not online.

 @return the owning AnimalTamer, or null if not owned]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tamer" type="org.bukkit.entity.AnimalTamer"/>
      <doc>
      <![CDATA[Set this to be owned by given AnimalTamer.
 <p>
 If the owner is not null, this will be tamed and will have any current
 path it is following removed. If the owner is set to null, this will be
 untamed, and the current owner removed.

 @param tamer the AnimalTamer who should own this]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.Tameable -->
  <!-- start interface org.bukkit.entity.ThrowableProjectile -->
  <interface name="ThrowableProjectile"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Projectile"/>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ItemStack the thrown projectile will display.

 @return The thrown item display ItemStack]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the display ItemStack for the thrown projectile.

 @param item ItemStack set to be displayed]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.ThrowableProjectile -->
  <!-- start interface org.bukkit.entity.ThrownExpBottle -->
  <interface name="ThrownExpBottle"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.ThrowableProjectile"/>
    <doc>
    <![CDATA[Represents a thrown Experience bottle.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ThrownExpBottle -->
  <!-- start interface org.bukkit.entity.ThrownPotion -->
  <interface name="ThrownPotion"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Projectile"/>
    <method name="getEffects" return="java.util.Collection&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the effects that are applied by this potion.

 @return The potion effects]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a copy of the ItemStack for this thrown potion.
 <p>
 Altering this copy will not alter the thrown potion directly. If you want
 to alter the thrown potion, you must use the {@link
 #setItem(ItemStack) setItemStack} method.

 @return A copy of the ItemStack for this thrown potion.]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the ItemStack for this thrown potion.
 <p>
 The ItemStack must be of type {@link org.bukkit.Material#SPLASH_POTION}
 or {@link org.bukkit.Material#LINGERING_POTION}, otherwise an exception
 is thrown.

 @param item New ItemStack]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a thrown potion bottle]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ThrownPotion -->
  <!-- start interface org.bukkit.entity.TippedArrow -->
  <interface name="TippedArrow"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="tipped status depends only on base potion type not being
 UNCRAFTABLE and effects being empty.">
    <implements name="org.bukkit.entity.Arrow"/>
    <doc>
    <![CDATA[@deprecated tipped status depends only on base potion type not being
 UNCRAFTABLE and effects being empty.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.TippedArrow -->
  <!-- start interface org.bukkit.entity.TNTPrimed -->
  <interface name="TNTPrimed"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Explosive"/>
    <method name="setFuseTicks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fuseTicks" type="int"/>
      <doc>
      <![CDATA[Set the number of ticks until the TNT blows up after being primed.

 @param fuseTicks The fuse ticks]]>
      </doc>
    </method>
    <method name="getFuseTicks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve the number of ticks until the explosion of this TNTPrimed
 entity

 @return the number of ticks until this TNTPrimed explodes]]>
      </doc>
    </method>
    <method name="getSource" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source of this primed TNT. The source is the entity
 responsible for the creation of this primed TNT. (I.E. player ignites
 TNT with flint and steel.) Take note that this can be null if there is
 no suitable source. (created by the {@link
 org.bukkit.World#spawn(Location, Class)} method, for example.)
 <p>
 The source will become null if the chunk this primed TNT is in is
 unloaded then reloaded. The source entity may be invalid if for example
 it has since died or been unloaded. Callers should check
 {@link Entity#isValid()}.

 @return the source of this primed TNT]]>
      </doc>
    </method>
    <method name="getSourceLoc" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="replaced by {@link Entity#getOrigin()}">
      <doc>
      <![CDATA[Gets the source block location of the TNTPrimed

 @return the source block location the TNTPrimed was spawned from
 @deprecated replaced by {@link Entity#getOrigin()}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Primed TNT.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.TNTPrimed -->
  <!-- start interface org.bukkit.entity.TraderLlama -->
  <interface name="TraderLlama"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Llama"/>
    <doc>
    <![CDATA[Represents a trader Llama.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.TraderLlama -->
  <!-- start interface org.bukkit.entity.Trident -->
  <interface name="Trident"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractArrow"/>
    <doc>
    <![CDATA[Represents a thrown trident.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Trident -->
  <!-- start interface org.bukkit.entity.TropicalFish -->
  <interface name="TropicalFish"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Fish"/>
    <method name="getPatternColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color of the fish's pattern.

 @return pattern color]]>
      </doc>
    </method>
    <method name="setPatternColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the color of the fish's pattern

 @param color pattern color]]>
      </doc>
    </method>
    <method name="getBodyColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color of the fish's body.

 @return pattern color]]>
      </doc>
    </method>
    <method name="setBodyColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the color of the fish's body

 @param color body color]]>
      </doc>
    </method>
    <method name="getPattern" return="org.bukkit.entity.TropicalFish.Pattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the fish's pattern.

 @return pattern]]>
      </doc>
    </method>
    <method name="setPattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="org.bukkit.entity.TropicalFish.Pattern"/>
      <doc>
      <![CDATA[Sets the fish's pattern

 @param pattern new pattern]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tropical fish.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.TropicalFish -->
  <!-- start class org.bukkit.entity.TropicalFish.Pattern -->
  <class name="TropicalFish.Pattern" extends="java.lang.Enum&lt;org.bukkit.entity.TropicalFish.Pattern&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.entity.TropicalFish.Pattern[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.TropicalFish.Pattern"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Enumeration of all different fish patterns. Refer to the
 <a href="https://minecraft.gamepedia.com/Fish_(mob)">Minecraft Wiki</a>
 for pictures.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.TropicalFish.Pattern -->
  <!-- start interface org.bukkit.entity.Turtle -->
  <interface name="Turtle"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Animals"/>
    <method name="getHome" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the turtle's home location

 @return Home location]]>
      </doc>
    </method>
    <method name="setHome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Set the turtle's home location

 @param location Home location]]>
      </doc>
    </method>
    <method name="isGoingHome" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if turtle is currently pathfinding to it's home

 @return True if going home]]>
      </doc>
    </method>
    <method name="isDigging" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if turtle is digging to lay eggs

 @return True if digging]]>
      </doc>
    </method>
    <method name="hasEgg" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if turtle is carrying egg

 @return True if carrying egg]]>
      </doc>
    </method>
    <method name="setHasEgg"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hasEgg" type="boolean"/>
      <doc>
      <![CDATA[Set if turtle is carrying egg

 @param hasEgg True if carrying egg]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a turtle.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Turtle -->
  <!-- start interface org.bukkit.entity.Vehicle -->
  <interface name="Vehicle"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Entity"/>
    <method name="getVelocity" return="org.bukkit.util.Vector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the vehicle's velocity.

 @return velocity vector]]>
      </doc>
    </method>
    <method name="setVelocity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vel" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets the vehicle's velocity.

 @param vel velocity vector]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a vehicle entity.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Vehicle -->
  <!-- start interface org.bukkit.entity.Vex -->
  <interface name="Vex"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <method name="isCharging" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the charging state of this entity.

 When this entity is charging it will having a glowing red texture.

 @return charging state]]>
      </doc>
    </method>
    <method name="setCharging"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charging" type="boolean"/>
      <doc>
      <![CDATA[Sets the charging state of this entity.

 When this entity is charging it will having a glowing red texture.

 @param charging new state]]>
      </doc>
    </method>
    <method name="getSummoner" return="org.bukkit.entity.Mob"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Mob that summoned this vex

 @return Mob that summoned this vex]]>
      </doc>
    </method>
    <method name="setSummoner"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="summoner" type="org.bukkit.entity.Mob"/>
      <doc>
      <![CDATA[Set the summoner of this vex

 @param summoner New summoner]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Vex.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Vex -->
  <!-- start interface org.bukkit.entity.Villager -->
  <interface name="Villager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractVillager"/>
    <method name="getProfession" return="org.bukkit.entity.Villager.Profession"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current profession of this villager.

 @return Current profession.]]>
      </doc>
    </method>
    <method name="setProfession"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profession" type="org.bukkit.entity.Villager.Profession"/>
      <doc>
      <![CDATA[Sets the new profession of this villager.

 @param profession New profession.]]>
      </doc>
    </method>
    <method name="getVillagerType" return="org.bukkit.entity.Villager.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current type of this villager.

 @return Current type.]]>
      </doc>
    </method>
    <method name="setVillagerType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.entity.Villager.Type"/>
      <doc>
      <![CDATA[Sets the new type of this villager.

 @param type New type.]]>
      </doc>
    </method>
    <method name="getVillagerLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the level of this villager.

 A villager with a level of 1 and no experience is liable to lose its
 profession.

 @return this villager's level]]>
      </doc>
    </method>
    <method name="setVillagerLevel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the level of this villager.

 A villager with a level of 1 and no experience is liable to lose its
 profession.

 @param level the new level
 @throws IllegalArgumentException if level not between [1, 5]]]>
      </doc>
    </method>
    <method name="getVillagerExperience" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the trading experience of this villager.

 @return trading experience]]>
      </doc>
    </method>
    <method name="setVillagerExperience"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="experience" type="int"/>
      <doc>
      <![CDATA[Sets the trading experience of this villager.

 @param experience new experience
 @throws IllegalArgumentException if experience &lt; 0]]>
      </doc>
    </method>
    <method name="getRestocksToday" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of times a villager has restocked their trades today
 @return The amount of trade restocks.]]>
      </doc>
    </method>
    <method name="setRestocksToday"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="restocksToday" type="int"/>
      <doc>
      <![CDATA[Sets the amount of times a villager has restocked their trades today
 @param restocksToday new restock count]]>
      </doc>
    </method>
    <method name="sleep" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Attempts to make this villager sleep at the given location.
 <br>
 The location must be in the current world and have a bed placed at the
 location. The villager will put its head on the specified block while
 sleeping.

 @param location the location of the bed
 @return whether the sleep was successful]]>
      </doc>
    </method>
    <method name="wakeup"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Causes this villager to wake up if he's currently sleeping.

 @throws IllegalStateException if not sleeping]]>
      </doc>
    </method>
    <method name="getReputation" return="com.destroystokyo.paper.entity.villager.Reputation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uniqueId" type="java.util.UUID"/>
      <doc>
      <![CDATA[Get the {@link com.destroystokyo.paper.entity.villager.Reputation reputation}
 for a specific player by {@link UUID}.

 @param uniqueId The {@link UUID} of the player to get the reputation of.
 @return The player's copied reputation with this villager.]]>
      </doc>
    </method>
    <method name="getReputations" return="java.util.Map&lt;java.util.UUID, com.destroystokyo.paper.entity.villager.Reputation&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all {@link com.destroystokyo.paper.entity.villager.Reputation reputations}
 for all players mapped by their {@link UUID unique IDs}.

 @return All {@link com.destroystokyo.paper.entity.villager.Reputation reputations} for all players
 in a copied map.]]>
      </doc>
    </method>
    <method name="setReputation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uniqueId" type="java.util.UUID"/>
      <param name="reputation" type="com.destroystokyo.paper.entity.villager.Reputation"/>
      <doc>
      <![CDATA[Set the {@link com.destroystokyo.paper.entity.villager.Reputation reputation}
 for a specific player by {@link UUID}.

 @param uniqueId The {@link UUID} of the player to set the reputation of.
 @param reputation The {@link com.destroystokyo.paper.entity.villager.Reputation reputation} to set.]]>
      </doc>
    </method>
    <method name="setReputations"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reputations" type="java.util.Map&lt;java.util.UUID, com.destroystokyo.paper.entity.villager.Reputation&gt;"/>
      <doc>
      <![CDATA[Set all {@link com.destroystokyo.paper.entity.villager.Reputation reputations}
 for all players mapped by their {@link UUID unique IDs}.

 @param reputations All {@link com.destroystokyo.paper.entity.villager.Reputation reputations}
 for all players mapped by their {@link UUID unique IDs}.]]>
      </doc>
    </method>
    <method name="clearReputations"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear all reputations from this villager. This removes every single
 reputation regardless of its impact and the player associated.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a villager NPC]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Villager -->
  <!-- start class org.bukkit.entity.Villager.Profession -->
  <class name="Villager.Profession" extends="java.lang.Enum&lt;org.bukkit.entity.Villager.Profession&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.entity.Villager.Profession[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Villager.Profession"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the various different Villager professions there may be.
 Villagers have different trading options depending on their profession,]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Villager.Profession -->
  <!-- start class org.bukkit.entity.Villager.Type -->
  <class name="Villager.Type" extends="java.lang.Enum&lt;org.bukkit.entity.Villager.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.entity.Villager.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.entity.Villager.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents Villager type, usually corresponding to what biome they spawn
 in.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.Villager.Type -->
  <!-- start interface org.bukkit.entity.Vindicator -->
  <interface name="Vindicator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Illager"/>
    <method name="isJohnny" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this Vindicator is set to Johnny mode.
 <p>
 When in Johnny mode the Vindicator will be hostile to any kind of mob, except
 for evokers, ghasts, illusioners and other vindicators. It will even be hostile
 to vexes. All mobs, except for endermites, phantoms, guardians, slimes and
 magma cubes, will try to attack the vindicator in return.

 @return True if in Johnny mode]]>
      </doc>
    </method>
    <method name="setJohnny"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="johnny" type="boolean"/>
      <doc>
      <![CDATA[Set this Vindicator's Johnny mode.
 <p>
 When in Johnny mode the Vindicator will be hostile to any kind of mob, except
 for evokers, ghasts, illusioners and other vindicators. It will even be hostile
 to vexes. All mobs, except for endermites, phantoms, guardians, slimes and
 magma cubes, will try to attack the vindicator in return.

 @param johnny True to enable Johnny mode]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Vindicator.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Vindicator -->
  <!-- start interface org.bukkit.entity.WanderingTrader -->
  <interface name="WanderingTrader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractVillager"/>
    <doc>
    <![CDATA[Represents a wandering trader NPC]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.WanderingTrader -->
  <!-- start interface org.bukkit.entity.WaterMob -->
  <interface name="WaterMob"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Creature"/>
    <doc>
    <![CDATA[Represents a Water Mob]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.WaterMob -->
  <!-- start interface org.bukkit.entity.Witch -->
  <interface name="Witch"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Raider"/>
    <implements name="com.destroystokyo.paper.entity.RangedEntity"/>
    <method name="isDrinkingPotion" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if Witch is drinking a potion

 @return True if drinking a potion]]>
      </doc>
    </method>
    <method name="getPotionUseTimeLeft" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get time remaining (in ticks) the Witch is drinking a potion

 @return Time remaining (in ticks)]]>
      </doc>
    </method>
    <method name="getDrinkingPotion" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the potion the Witch is drinking

 @return The potion the witch is drinking]]>
      </doc>
    </method>
    <method name="setDrinkingPotion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="potion" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the potion the Witch should drink

 @param potion Potion to drink]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Witch]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Witch -->
  <!-- start interface org.bukkit.entity.Wither -->
  <interface name="Wither"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <implements name="org.bukkit.entity.Boss"/>
    <implements name="com.destroystokyo.paper.entity.RangedEntity"/>
    <doc>
    <![CDATA[Represents a Wither boss]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Wither -->
  <!-- start interface org.bukkit.entity.WitherSkeleton -->
  <interface name="WitherSkeleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Skeleton"/>
    <doc>
    <![CDATA[Represents a WitherSkeleton - variant of {@link Skeleton}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.WitherSkeleton -->
  <!-- start interface org.bukkit.entity.WitherSkull -->
  <interface name="WitherSkull"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Fireball"/>
    <method name="setCharged"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charged" type="boolean"/>
      <doc>
      <![CDATA[Sets the charged status of the wither skull.

 @param charged whether it should be charged]]>
      </doc>
    </method>
    <method name="isCharged" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the wither skull is charged.

 @return whether the wither skull is charged]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a wither skull {@link Fireball}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.WitherSkull -->
  <!-- start interface org.bukkit.entity.Wolf -->
  <interface name="Wolf"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Tameable"/>
    <implements name="org.bukkit.entity.Sittable"/>
    <method name="isAngry" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this wolf is angry

 @return Anger true if angry]]>
      </doc>
    </method>
    <method name="setAngry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="angry" type="boolean"/>
      <doc>
      <![CDATA[Sets the anger of this wolf.
 <p>
 An angry wolf can not be fed or tamed.

 @param angry true if angry
 @see #setTarget(org.bukkit.entity.LivingEntity)]]>
      </doc>
    </method>
    <method name="getCollarColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the collar color of this wolf

 @return the color of the collar]]>
      </doc>
    </method>
    <method name="setCollarColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Set the collar color of this wolf

 @param color the color to apply]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Wolf]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Wolf -->
  <!-- start interface org.bukkit.entity.Zoglin -->
  <interface name="Zoglin"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <implements name="org.bukkit.entity.Ageable"/>
    <method name="isBaby" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Ageable#isAdult()}">
      <doc>
      <![CDATA[Gets whether the zoglin is a baby

 @return Whether the zoglin is a baby
 @deprecated see {@link Ageable#isAdult()}]]>
      </doc>
    </method>
    <method name="setBaby"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the zoglin is a baby

 @param flag Whether the zoglin is a baby
 @deprecated see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Zoglin.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Zoglin -->
  <!-- start interface org.bukkit.entity.Zombie -->
  <interface name="Zombie"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Monster"/>
    <implements name="org.bukkit.entity.Ageable"/>
    <method name="isBaby" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Ageable#isAdult()}">
      <doc>
      <![CDATA[Gets whether the zombie is a baby

 @return Whether the zombie is a baby
 @deprecated see {@link Ageable#isAdult()}]]>
      </doc>
    </method>
    <method name="setBaby"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the zombie is a baby

 @param flag Whether the zombie is a baby
 @deprecated see {@link Ageable#setBaby()} and {@link Ageable#setAdult()}]]>
      </doc>
    </method>
    <method name="isVillager" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="check if instanceof {@link ZombieVillager}.">
      <doc>
      <![CDATA[Gets whether the zombie is a villager

 @return Whether the zombie is a villager
 @deprecated check if instanceof {@link ZombieVillager}.]]>
      </doc>
    </method>
    <method name="setVillager"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="must spawn {@link ZombieVillager}.">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[@param flag flag
 @deprecated must spawn {@link ZombieVillager}.]]>
      </doc>
    </method>
    <method name="setVillagerProfession"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profession" type="org.bukkit.entity.Villager.Profession"/>
      <doc>
      <![CDATA[@param profession profession
 @see ZombieVillager#getVillagerProfession()]]>
      </doc>
    </method>
    <method name="getVillagerProfession" return="org.bukkit.entity.Villager.Profession"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return profession
 @see ZombieVillager#getVillagerProfession()]]>
      </doc>
    </method>
    <method name="isConverting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if this entity is in the process of converting to a Drowned as a
 result of being underwater.

 @return conversion status]]>
      </doc>
    </method>
    <method name="getConversionTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of ticks until this entity will be converted to a Drowned
 as a result of being underwater.

 When this reaches 0, the entity will be converted.

 @return conversion time
 @throws IllegalStateException if {@link #isConverting()} is false.]]>
      </doc>
    </method>
    <method name="setConversionTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="int"/>
      <doc>
      <![CDATA[Sets the amount of ticks until this entity will be converted to a Drowned
 as a result of being underwater.

 When this reaches 0, the entity will be converted. A value of less than 0
 will stop the current conversion process without converting the current
 entity.

 @param time new conversion time]]>
      </doc>
    </method>
    <method name="isDrowning" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if zombie is drowning

 @return True if zombie conversion process has begun]]>
      </doc>
    </method>
    <method name="startDrowning"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="See {@link #setConversionTime(int)}">
      <param name="drownedConversionTime" type="int"/>
      <doc>
      <![CDATA[Make zombie start drowning

 @param drownedConversionTime Amount of time until zombie converts from drowning

 @deprecated See {@link #setConversionTime(int)}]]>
      </doc>
    </method>
    <method name="stopDrowning"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stop a zombie from starting the drowning conversion process]]>
      </doc>
    </method>
    <method name="setArmsRaised"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="raised" type="boolean"/>
      <doc>
      <![CDATA[Set if zombie has its arms raised

 @param raised True to raise arms]]>
      </doc>
    </method>
    <method name="isArmsRaised" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if zombie has arms raised

 @return True if arms are raised]]>
      </doc>
    </method>
    <method name="shouldBurnInDay" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this zombie will burn in the sunlight

 @return True if zombie will burn in sunlight]]>
      </doc>
    </method>
    <method name="setShouldBurnInDay"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shouldBurnInDay" type="boolean"/>
      <doc>
      <![CDATA[Set if this zombie should burn in the sunlight

 @param shouldBurnInDay True to burn in sunlight]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Zombie.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.Zombie -->
  <!-- start interface org.bukkit.entity.ZombieHorse -->
  <interface name="ZombieHorse"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.AbstractHorse"/>
    <doc>
    <![CDATA[Represents a ZombieHorse - variant of {@link AbstractHorse}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ZombieHorse -->
  <!-- start interface org.bukkit.entity.ZombieVillager -->
  <interface name="ZombieVillager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Zombie"/>
    <method name="setVillagerProfession"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profession" type="org.bukkit.entity.Villager.Profession"/>
      <doc>
      <![CDATA[Sets the villager profession of this zombie.]]>
      </doc>
    </method>
    <method name="getVillagerProfession" return="org.bukkit.entity.Villager.Profession"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the villager profession of this zombie.

 @return the profession or null]]>
      </doc>
    </method>
    <method name="getVillagerType" return="org.bukkit.entity.Villager.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current type of this villager.

 @return Current type.]]>
      </doc>
    </method>
    <method name="setVillagerType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.entity.Villager.Type"/>
      <doc>
      <![CDATA[Sets the new type of this villager.

 @param type New type.]]>
      </doc>
    </method>
    <method name="isConverting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if this entity is in the process of converting to a Villager as a
 result of being cured.

 @return conversion status]]>
      </doc>
    </method>
    <method name="getConversionTime" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of ticks until this entity will be converted to a
 Villager as a result of being cured.

 When this reaches 0, the entity will be converted.

 @return conversion time
 @throws IllegalStateException if {@link #isConverting()} is false.]]>
      </doc>
    </method>
    <method name="setConversionTime"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="int"/>
      <doc>
      <![CDATA[Sets the amount of ticks until this entity will be converted to a
 Villager as a result of being cured.

 When this reaches 0, the entity will be converted. A value of less than 0
 will stop the current conversion process without converting the current
 entity.

 @param time new conversion time]]>
      </doc>
    </method>
    <method name="getConversionPlayer" return="org.bukkit.OfflinePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player who initiated the conversion.

 @return the player, or <code>null</code> if the player is unknown or the
 entity isn't converting currently]]>
      </doc>
    </method>
    <method name="setConversionPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conversionPlayer" type="org.bukkit.OfflinePlayer"/>
      <doc>
      <![CDATA[Sets the player who initiated the conversion.
 <p>
 This has no effect if this entity isn't converting currently.

 @param conversionPlayer the player]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a {@link Zombie} which was once a {@link Villager}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.ZombieVillager -->
</package>
<package name="org.bukkit.entity.memory">
  <!-- start class org.bukkit.entity.memory.MemoryKey -->
  <class name="MemoryKey" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMemoryClass" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the class of values associated with this memory.

 @return the class of value objects]]>
      </doc>
    </method>
    <method name="getByKey" return="org.bukkit.entity.memory.MemoryKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespacedKey" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Returns a {@link MemoryKey} by a {@link NamespacedKey}.

 @param namespacedKey the {@link NamespacedKey} referencing a
 {@link MemoryKey}
 @return the {@link MemoryKey} or null when no {@link MemoryKey} is
 available under that key]]>
      </doc>
    </method>
    <method name="values" return="java.util.Set&lt;org.bukkit.entity.memory.MemoryKey&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of all MemoryKeys.

 @return the memoryKeys]]>
      </doc>
    </method>
    <field name="HOME" type="org.bukkit.entity.memory.MemoryKey&lt;org.bukkit.Location&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="POTENTIAL_JOB_SITE" type="org.bukkit.entity.memory.MemoryKey&lt;org.bukkit.Location&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JOB_SITE" type="org.bukkit.entity.memory.MemoryKey&lt;org.bukkit.Location&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MEETING_POINT" type="org.bukkit.entity.memory.MemoryKey&lt;org.bukkit.Location&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GOLEM_DETECTED_RECENTLY" type="org.bukkit.entity.memory.MemoryKey&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LAST_SLEPT" type="org.bukkit.entity.memory.MemoryKey&lt;java.lang.Long&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LAST_WOKEN" type="org.bukkit.entity.memory.MemoryKey&lt;java.lang.Long&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LAST_WORKED_AT_POI" type="org.bukkit.entity.memory.MemoryKey&lt;java.lang.Long&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNIVERSAL_ANGER" type="org.bukkit.entity.memory.MemoryKey&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANGRY_AT" type="org.bukkit.entity.memory.MemoryKey&lt;java.util.UUID&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ADMIRING_ITEM" type="org.bukkit.entity.memory.MemoryKey&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ADMIRING_DISABLED" type="org.bukkit.entity.memory.MemoryKey&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HUNTED_RECENTLY" type="org.bukkit.entity.memory.MemoryKey&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a key used for accessing memory values of a
 {@link org.bukkit.entity.LivingEntity}.

 @param <T> the class type of the memory value]]>
    </doc>
  </class>
  <!-- end class org.bukkit.entity.memory.MemoryKey -->
</package>
<package name="org.bukkit.entity.minecart">
  <!-- start interface org.bukkit.entity.minecart.CommandMinecart -->
  <interface name="CommandMinecart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Minecart"/>
    <method name="getCommand" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the command that this CommandMinecart will run when activated.
 This will never return null.  If the CommandMinecart does not have a
 command, an empty String will be returned instead.

 @return Command that this CommandMinecart will run when powered.]]>
      </doc>
    </method>
    <method name="setCommand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the command that this CommandMinecart will run when activated.
 Setting the command to null is the same as setting it to an empty
 String.

 @param command Command that this CommandMinecart will run when
     activated.]]>
      </doc>
    </method>
    <method name="setName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the name of this CommandMinecart.  The name is used with commands
 that this CommandMinecart executes.  Setting the name to null is the
 same as setting it to "@".

 @param name New name for this CommandMinecart.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.entity.minecart.CommandMinecart -->
  <!-- start interface org.bukkit.entity.minecart.ExplosiveMinecart -->
  <interface name="ExplosiveMinecart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Minecart"/>
    <doc>
    <![CDATA[Represents a Minecart with TNT inside it that can explode when triggered.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.minecart.ExplosiveMinecart -->
  <!-- start interface org.bukkit.entity.minecart.HopperMinecart -->
  <interface name="HopperMinecart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Minecart"/>
    <implements name="org.bukkit.inventory.InventoryHolder"/>
    <implements name="com.destroystokyo.paper.loottable.LootableEntityInventory"/>
    <method name="isEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether or not this Minecart will pick up
 items into its inventory.

 @return true if the Minecart will pick up items]]>
      </doc>
    </method>
    <method name="setEnabled"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this Minecart will pick up items.

 @param enabled new enabled state]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Minecart with a Hopper inside it]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.minecart.HopperMinecart -->
  <!-- start interface org.bukkit.entity.minecart.PoweredMinecart -->
  <interface name="PoweredMinecart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Minecart"/>
    <method name="getFuel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of ticks until the minecart runs out of fuel.

 @return Number of ticks until the minecart runs out of fuel]]>
      </doc>
    </method>
    <method name="setFuel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fuel" type="int"/>
      <doc>
      <![CDATA[Set the number of ticks until the minecart runs out of fuel.

 @param fuel Number of ticks until the minecart runs out of fuel]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a powered minecart. A powered minecart moves on its own when a
 player deposits {@link org.bukkit.Material#COAL fuel}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.minecart.PoweredMinecart -->
  <!-- start interface org.bukkit.entity.minecart.RideableMinecart -->
  <interface name="RideableMinecart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Minecart"/>
    <doc>
    <![CDATA[Represents a minecart that can have certain {@link
 org.bukkit.entity.Entity entities} as passengers. Normal passengers
 include all {@link org.bukkit.entity.LivingEntity living entities} with
 the exception of {@link org.bukkit.entity.IronGolem iron golems}.
 Non-player entities that meet normal passenger criteria automatically
 mount these minecarts when close enough.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.minecart.RideableMinecart -->
  <!-- start interface org.bukkit.entity.minecart.SpawnerMinecart -->
  <interface name="SpawnerMinecart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Minecart"/>
    <doc>
    <![CDATA[Represents a Minecart with an {@link org.bukkit.block.CreatureSpawner
 entity spawner} inside it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.minecart.SpawnerMinecart -->
  <!-- start interface org.bukkit.entity.minecart.StorageMinecart -->
  <interface name="StorageMinecart"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.entity.Minecart"/>
    <implements name="org.bukkit.inventory.InventoryHolder"/>
    <implements name="com.destroystokyo.paper.loottable.LootableEntityInventory"/>
    <doc>
    <![CDATA[Represents a minecart with a chest. These types of {@link Minecart
 minecarts} have their own inventory that can be accessed using methods
 from the {@link InventoryHolder} interface.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.entity.minecart.StorageMinecart -->
</package>
<package name="org.bukkit.event">
  <!-- start interface org.bukkit.event.Cancellable -->
  <interface name="Cancellable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isCancelled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins

 @return true if this event is cancelled]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Sets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins.

 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.event.Cancellable -->
  <!-- start class org.bukkit.event.Event -->
  <class name="Event" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Event"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default constructor is defined for cleaner code. This constructor
 assumes the event is synchronous.]]>
      </doc>
    </constructor>
    <constructor name="Event" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constructor is used to explicitly declare an event as synchronous
 or asynchronous.

 @param isAsync true indicates the event will fire asynchronously, false
     by default from default constructor]]>
      </doc>
    </constructor>
    <method name="callEvent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Calls the event and tests if cancelled.

 @return false if event was cancelled, if cancellable. otherwise true.]]>
      </doc>
    </method>
    <method name="getEventName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convenience method for providing a user-friendly identifier. By
 default, it is the event's class's {@linkplain Class#getSimpleName()
 simple name}.

 @return name of this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isAsynchronous" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Any custom event that should not by synchronized with other events must
 use the specific constructor. These are the caveats of using an
 asynchronous event:
 <ul>
 <li>The event is never fired from inside code triggered by a
     synchronous event. Attempting to do so results in an {@link
     java.lang.IllegalStateException}.
 <li>However, asynchronous event handlers may fire synchronous or
     asynchronous events
 <li>The event may be fired multiple times simultaneously and in any
     order.
 <li>Any newly registered or unregistered handler is ignored after an
     event starts execution.
 <li>The handlers for this event may block for any length of time.
 <li>Some implementations may selectively declare a specific event use
     as asynchronous. This behavior should be clearly defined.
 <li>Asynchronous calls are not calculated in the plugin timing system.
 </ul>

 @return false by default, true if the event fires asynchronously]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an event.

 All events require a static method named getHandlerList() which returns the same {@link HandlerList} as {@link #getHandlers()}.

 @see PluginManager#callEvent(Event)
 @see PluginManager#registerEvents(Listener,Plugin)]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.Event -->
  <!-- start class org.bukkit.event.Event.Result -->
  <class name="Event.Result" extends="java.lang.Enum&lt;org.bukkit.event.Event.Result&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.Event.Result[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.Event.Result"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.Event.Result -->
  <!-- start class org.bukkit.event.EventException -->
  <class name="EventException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EventException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new EventException based on the given Exception

 @param throwable Exception that triggered this Exception]]>
      </doc>
    </constructor>
    <constructor name="EventException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new EventException]]>
      </doc>
    </constructor>
    <constructor name="EventException" type="java.lang.Throwable, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new EventException with the given message

 @param cause The exception that caused this
 @param message The message]]>
      </doc>
    </constructor>
    <constructor name="EventException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new EventException with the given message

 @param message The message]]>
      </doc>
    </constructor>
    <method name="getCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If applicable, returns the Exception that triggered this Exception

 @return Inner exception, or null if one does not exist]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.event.EventException -->
  <!-- start class org.bukkit.event.EventHandler -->
  <class name="EventHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[An annotation to mark methods as being event handler methods]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.EventHandler -->
  <!-- start class org.bukkit.event.EventPriority -->
  <class name="EventPriority" extends="java.lang.Enum&lt;org.bukkit.event.EventPriority&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.EventPriority[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.EventPriority"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getSlot" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an event's priority in execution]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.EventPriority -->
  <!-- start class org.bukkit.event.HandlerList -->
  <class name="HandlerList" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HandlerList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new handler list and initialize using EventPriority.
 <p>
 The HandlerList is then added to meta-list for use in bakeAll()]]>
      </doc>
    </constructor>
    <method name="bakeAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bake all handler lists. Best used just after all normal event
 registration is complete, ie just after all plugins are loaded if
 you're using fevents in a plugin system.]]>
      </doc>
    </method>
    <method name="unregisterAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unregister all listeners from all handler lists.]]>
      </doc>
    </method>
    <method name="unregisterAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Unregister a specific plugin's listeners from all handler lists.

 @param plugin plugin to unregister]]>
      </doc>
    </method>
    <method name="unregisterAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <doc>
      <![CDATA[Unregister a specific listener from all handler lists.

 @param listener listener to unregister]]>
      </doc>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.plugin.RegisteredListener"/>
      <doc>
      <![CDATA[Register a new listener in this handler list

 @param listener listener to register]]>
      </doc>
    </method>
    <method name="registerAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listeners" type="java.util.Collection&lt;org.bukkit.plugin.RegisteredListener&gt;"/>
      <doc>
      <![CDATA[Register a collection of new listeners in this handler list

 @param listeners listeners to register]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.plugin.RegisteredListener"/>
      <doc>
      <![CDATA[Remove a listener from a specific order slot

 @param listener listener to remove]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Remove a specific plugin's listeners from this handler

 @param plugin plugin to remove]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <doc>
      <![CDATA[Remove a specific listener from this handler

 @param listener listener to remove]]>
      </doc>
    </method>
    <method name="bake"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bake HashMap and ArrayLists to 2d array - does nothing if not necessary]]>
      </doc>
    </method>
    <method name="getRegisteredListeners" return="org.bukkit.plugin.RegisteredListener[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the baked registered listeners associated with this handler list

 @return the array of registered listeners]]>
      </doc>
    </method>
    <method name="getRegisteredListeners" return="java.util.ArrayList&lt;org.bukkit.plugin.RegisteredListener&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Get a specific plugin's registered listeners associated with this
 handler list

 @param plugin the plugin to get the listeners of
 @return the list of registered listeners]]>
      </doc>
    </method>
    <method name="getHandlerLists" return="java.util.ArrayList&lt;org.bukkit.event.HandlerList&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of all handler lists for every event type

 @return the list of all handler lists]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A list of event handlers, stored per-event. Based on lahwran's fevents.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.HandlerList -->
  <!-- start interface org.bukkit.event.Listener -->
  <interface name="Listener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Simple interface for tagging all EventListeners]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.event.Listener -->
</package>
<package name="org.bukkit.event.block">
  <!-- start class org.bukkit.event.block.Action -->
  <class name="Action" extends="java.lang.Enum&lt;org.bukkit.event.block.Action&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.block.Action[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.block.Action"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.block.Action -->
  <!-- start class org.bukkit.event.block.BlockBreakEvent -->
  <class name="BlockBreakEvent" extends="org.bukkit.event.block.BlockExpEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockBreakEvent" type="org.bukkit.block.Block, org.bukkit.entity.Player"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Player that is breaking the block involved in this event.

 @return The Player that is breaking the block involved in this event]]>
      </doc>
    </method>
    <method name="setDropItems"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropItems" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not the block will drop items as it normally would.

 @param dropItems Whether or not the block will drop items]]>
      </doc>
    </method>
    <method name="isDropItems" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the block will drop items.

 @return Whether or not the block will drop items]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Called when a block is broken by a player.
 <p>
 If you wish to have the block drop experience, you must set the experience
 value above 0. By default, experience will be set in the event if:
 <ol>
 <li>The player is not in creative or adventure mode
 <li>The player can loot the block (ie: does not destroy it completely, by
     using the correct tool)
 <li>The player does not have silk touch
 <li>The block drops experience in vanilla Minecraft
 </ol>
 <p>
 Note:
 Plugins wanting to simulate a traditional block drop should set the block
 to air and utilize their own methods for determining what the default drop
 for the block being broken is and what to do about it, if anything.
 <p>
 If a Block Break event is cancelled, the block will not break and
 experience will not drop.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockBreakEvent -->
  <!-- start class org.bukkit.event.block.BlockBurnEvent -->
  <class name="BlockBurnEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockBurnEvent" type="org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockBurnEvent" type="org.bukkit.block.Block, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getIgnitingBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block which ignited this block.

 @return The Block that ignited and burned this block, or null if no
 source block exists]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a block is destroyed as a result of being burnt by fire.
 <p>
 If a Block Burn event is cancelled, the block will not be destroyed as a
 result of being burnt by fire.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockBurnEvent -->
  <!-- start class org.bukkit.event.block.BlockCanBuildEvent -->
  <class name="BlockCanBuildEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockCanBuildEvent" type="org.bukkit.block.Block, org.bukkit.block.data.BlockData, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockCanBuildEvent" type="org.bukkit.block.Block, org.bukkit.entity.Player, org.bukkit.block.data.BlockData, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param block the block involved in this event
 @param player the player placing the block
 @param type the id of the block to place
 @param canBuild whether we can build]]>
      </doc>
    </constructor>
    <method name="isBuildable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the block can be built here.
 <p>
 By default, returns Minecraft's answer on whether the block can be
 built here or not.

 @return boolean whether or not the block can be built]]>
      </doc>
    </method>
    <method name="setBuildable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the block can be built here or not.

 @param cancel true if you want to allow the block to be built here
     despite Minecraft's default behaviour]]>
      </doc>
    </method>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Material that we are trying to place.

 @return The Material that we are trying to place]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the BlockData that we are trying to place.

 @return The BlockData that we are trying to place]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player who placed the block involved in this event.
 <br>
 May be null for legacy calls of the event.

 @return The Player who placed the block involved in this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="buildable" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="blockData" type="org.bukkit.block.data.BlockData"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Called when we try to place a block, to see if we can build it here or not.
 <p>
 Note:
 <ul>
 <li>The Block returned by getBlock() is the block we are trying to place
     on, not the block we are trying to place.
 <li>If you want to figure out what is being placed, use {@link
     #getMaterial()} instead.
 </ul>]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockCanBuildEvent -->
  <!-- start class org.bukkit.event.block.BlockCookEvent -->
  <class name="BlockCookEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockCookEvent" type="org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the smelted ItemStack for this event

 @return smelting source ItemStack]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the resultant ItemStack for this event

 @return smelting result ItemStack]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the resultant ItemStack for this event

 @param result new result ItemStack]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an ItemStack is successfully cooked in a block.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockCookEvent -->
  <!-- start class org.bukkit.event.block.BlockDamageEvent -->
  <class name="BlockDamageEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockDamageEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.inventory.ItemStack, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player damaging the block involved in this event.

 @return The player damaging the block involved in this event]]>
      </doc>
    </method>
    <method name="getInstaBreak" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the block is set to instantly break when damaged by the player.

 @return true if the block should instantly break when damaged by the
     player]]>
      </doc>
    </method>
    <method name="setInstaBreak"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bool" type="boolean"/>
      <doc>
      <![CDATA[Sets if the block should instantly break when damaged by the player.

 @param bool true if you want the block to instantly break when damaged
     by the player]]>
      </doc>
    </method>
    <method name="getItemInHand" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ItemStack for the item currently in the player's hand.

 @return The ItemStack for the item currently in the player's hand]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a block is damaged by a player.
 <p>
 If a Block Damage event is cancelled, the block will not be damaged.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockDamageEvent -->
  <!-- start class org.bukkit.event.block.BlockDispenseArmorEvent -->
  <class name="BlockDispenseArmorEvent" extends="org.bukkit.event.block.BlockDispenseEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockDispenseArmorEvent" type="org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.entity.LivingEntity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTargetEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the living entity on which the armor was dispensed.

 @return the target entity]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when an equippable item is dispensed from a block and equipped on a
 nearby entity.
 <p>
 If a Block Dispense Armor event is cancelled, the equipment will not be
 equipped on the target entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockDispenseArmorEvent -->
  <!-- start class org.bukkit.event.block.BlockDispenseEvent -->
  <class name="BlockDispenseEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockDispenseEvent" type="org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.util.Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item that is being dispensed. Modifying the returned item will
 have no effect, you must use {@link
 #setItem(org.bukkit.inventory.ItemStack)} instead.

 @return An ItemStack for the item being dispensed]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item being dispensed.

 @param item the item being dispensed]]>
      </doc>
    </method>
    <method name="getVelocity" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the velocity.
 <p>
 Note: Modifying the returned Vector will not change the velocity, you
 must use {@link #setVelocity(org.bukkit.util.Vector)} instead.

 @return A Vector for the dispensed item's velocity]]>
      </doc>
    </method>
    <method name="setVelocity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vel" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets the velocity of the item being dispensed.

 @param vel the velocity of the item being dispensed]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an item is dispensed from a block.
 <p>
 If a Block Dispense event is cancelled, the block will not dispense the
 item.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockDispenseEvent -->
  <!-- start class org.bukkit.event.block.BlockDropItemEvent -->
  <class name="BlockDropItemEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockDropItemEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockState, org.bukkit.entity.Player, java.util.List&lt;org.bukkit.entity.Item&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Player that is breaking the block involved in this event.

 @return The Player that is breaking the block involved in this event]]>
      </doc>
    </method>
    <method name="getBlockState" return="org.bukkit.block.BlockState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the BlockState of the block involved in this event before it was
 broken.

 @return The BlockState of the block involved in this event]]>
      </doc>
    </method>
    <method name="getItems" return="java.util.List&lt;org.bukkit.entity.Item&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets list of the Item drops caused by the block break.

 This list is mutable - removing an item from it will cause it to not
 drop. It is not legal however to add new items to the list.

 @return The Item the block caused to drop]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called if a block broken by a player drops an item.

 If the block break is cancelled, this event won't be called.

 If isDropItems in BlockBreakEvent is set to false, this event won't be
 called.

 This event will also be called if the player breaks a multi block structure,
 for example a torch on top of a stone. Both items will have an event call.

 The Block is already broken as this event is called, so #getBlock() will be
 AIR in most cases. Use #getBlockState() for more Information about the broken
 block.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockDropItemEvent -->
  <!-- start class org.bukkit.event.block.BlockEvent -->
  <class name="BlockEvent" extends="org.bukkit.event.Event"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockEvent" type="org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block involved in this event.

 @return The Block which block is involved in this event]]>
      </doc>
    </method>
    <field name="block" type="org.bukkit.block.Block"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a block related event.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockEvent -->
  <!-- start class org.bukkit.event.block.BlockExpEvent -->
  <class name="BlockExpEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockExpEvent" type="org.bukkit.block.Block, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExpToDrop" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the experience dropped by the block after the event has processed

 @return The experience to drop]]>
      </doc>
    </method>
    <method name="setExpToDrop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exp" type="int"/>
      <doc>
      <![CDATA[Set the amount of experience dropped by the block after the event has
 processed

 @param exp 1 or higher to drop experience, else nothing will drop]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An event that's called when a block yields experience.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockExpEvent -->
  <!-- start class org.bukkit.event.block.BlockExplodeEvent -->
  <class name="BlockExplodeEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockExplodeEvent" type="org.bukkit.block.Block, java.util.List&lt;org.bukkit.block.Block&gt;, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="blockList" return="java.util.List&lt;org.bukkit.block.Block&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the list of blocks that would have been removed or were removed
 from the explosion event.

 @return All blown-up blocks]]>
      </doc>
    </method>
    <method name="getYield" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the percentage of blocks to drop from this explosion

 @return The yield.]]>
      </doc>
    </method>
    <method name="setYield"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="yield" type="float"/>
      <doc>
      <![CDATA[Sets the percentage of blocks to drop from this explosion

 @param yield The new yield percentage]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a block explodes]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockExplodeEvent -->
  <!-- start class org.bukkit.event.block.BlockFadeEvent -->
  <class name="BlockFadeEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockFadeEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewState" return="org.bukkit.block.BlockState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the state of the block that will be fading, melting or
 disappearing.

 @return The block state of the block that will be fading, melting or
     disappearing]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a block fades, melts or disappears based on world conditions
 <p>
 Examples:
 <ul>
 <li>Snow melting due to being near a light source.
 <li>Ice melting due to being near a light source.
 <li>Fire burning out after time, without destroying fuel block.
 <li>Coral fading to dead coral due to lack of water</li>
 <li>Turtle Egg bursting when a turtle hatches</li>
 </ul>
 <p>
 If a Block Fade event is cancelled, the block will not fade, melt or
 disappear.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockFadeEvent -->
  <!-- start class org.bukkit.event.block.BlockFertilizeEvent -->
  <class name="BlockFertilizeEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockFertilizeEvent" type="org.bukkit.block.Block, org.bukkit.entity.Player, java.util.List&lt;org.bukkit.block.BlockState&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player that triggered the fertilization.

 @return triggering player, or null if not applicable]]>
      </doc>
    </method>
    <method name="getBlocks" return="java.util.List&lt;org.bukkit.block.BlockState&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of all blocks changed by the fertilization.

 @return list of all changed blocks]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called with the block changes resulting from a player fertilizing a given
 block with bonemeal. Will be called after the applicable
 {@link StructureGrowEvent}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockFertilizeEvent -->
  <!-- start class org.bukkit.event.block.BlockFormEvent -->
  <class name="BlockFormEvent" extends="org.bukkit.event.block.BlockGrowEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockFormEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a block is formed or spreads based on world conditions.
 <p>
 Use {@link BlockSpreadEvent} to catch blocks that actually spread and don't
 just "randomly" form.
 <p>
 Examples:
 <ul>
 <li>Snow forming due to a snow storm.
 <li>Ice forming in a snowy Biome like Taiga or Tundra.
 <li> Obsidian / Cobblestone forming due to contact with water.
 <li> Concrete forming due to mixing of concrete powder and water.
 </ul>
 <p>
 If a Block Form event is cancelled, the block will not be formed.

 @see BlockSpreadEvent]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockFormEvent -->
  <!-- start class org.bukkit.event.block.BlockFromToEvent -->
  <class name="BlockFromToEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockFromToEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockFromToEvent" type="org.bukkit.block.Block, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the BlockFace that the block is moving to.

 @return The BlockFace that the block is moving to]]>
      </doc>
    </method>
    <method name="getToBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convenience method for getting the faced Block.

 @return The faced Block]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="to" type="org.bukkit.block.Block"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="face" type="org.bukkit.block.BlockFace"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="cancel" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents events with a source block and a destination block, currently
 only applies to liquid (lava and water) and teleporting dragon eggs.
 <p>
 If a Block From To event is cancelled, the block will not move (the liquid
 will not flow).]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockFromToEvent -->
  <!-- start class org.bukkit.event.block.BlockGrowEvent -->
  <class name="BlockGrowEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockGrowEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewState" return="org.bukkit.block.BlockState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the state of the block where it will form or spread to.

 @return The block state for this events block]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a block grows naturally in the world.
 <p>
 Examples:
 <ul>
 <li>Wheat
 <li>Sugar Cane
 <li>Cactus
 <li>Watermelon
 <li>Pumpkin
 <li>Turtle Egg
 </ul>
 <p>
 If a Block Grow event is cancelled, the block will not grow.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockGrowEvent -->
  <!-- start class org.bukkit.event.block.BlockIgniteEvent -->
  <class name="BlockIgniteEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockIgniteEvent" type="org.bukkit.block.Block, org.bukkit.event.block.BlockIgniteEvent.IgniteCause, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockIgniteEvent" type="org.bukkit.block.Block, org.bukkit.event.block.BlockIgniteEvent.IgniteCause, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockIgniteEvent" type="org.bukkit.block.Block, org.bukkit.event.block.BlockIgniteEvent.IgniteCause, org.bukkit.entity.Entity, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getCause" return="org.bukkit.event.block.BlockIgniteEvent.IgniteCause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cause of block ignite.

 @return An IgniteCause value detailing the cause of block ignition]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player who ignited this block

 @return The Player that placed/ignited the fire block, or null if not ignited by a Player.]]>
      </doc>
    </method>
    <method name="getIgnitingEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity who ignited this block

 @return The Entity that placed/ignited the fire block, or null if not ignited by a Entity.]]>
      </doc>
    </method>
    <method name="getIgnitingBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block which ignited this block

 @return The Block that placed/ignited the fire block, or null if not ignited by a Block.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a block is ignited. If you want to catch when a Player places
 fire, you need to use {@link BlockPlaceEvent}.
 <p>
 If a Block Ignite event is cancelled, the block will not be ignited.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockIgniteEvent -->
  <!-- start class org.bukkit.event.block.BlockIgniteEvent.IgniteCause -->
  <class name="BlockIgniteEvent.IgniteCause" extends="java.lang.Enum&lt;org.bukkit.event.block.BlockIgniteEvent.IgniteCause&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.block.BlockIgniteEvent.IgniteCause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.block.BlockIgniteEvent.IgniteCause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the cause of the ignite]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockIgniteEvent.IgniteCause -->
  <!-- start class org.bukkit.event.block.BlockMultiPlaceEvent -->
  <class name="BlockMultiPlaceEvent" extends="org.bukkit.event.block.BlockPlaceEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockMultiPlaceEvent" type="java.util.List&lt;org.bukkit.block.BlockState&gt;, org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.entity.Player, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockMultiPlaceEvent" type="java.util.List&lt;org.bukkit.block.BlockState&gt;, org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.entity.Player, boolean, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getReplacedBlockStates" return="java.util.List&lt;org.bukkit.block.BlockState&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of blockstates for all blocks which were replaced by the
 placement of the new blocks. Most of these blocks will just have a
 Material type of AIR.

 @return immutable list of replaced BlockStates]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fired when a single block placement action of a player triggers the
 creation of multiple blocks(e.g. placing a bed block). The block returned
 by {@link #getBlockPlaced()} and its related methods is the block where
 the placed block would exist if the placement only affected a single
 block.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockMultiPlaceEvent -->
  <!-- start class org.bukkit.event.block.BlockPhysicsEvent -->
  <class name="BlockPhysicsEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockPhysicsEvent" type="org.bukkit.block.Block, org.bukkit.block.data.BlockData, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockPhysicsEvent" type="org.bukkit.block.Block, org.bukkit.block.data.BlockData"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockPhysicsEvent" type="org.bukkit.block.Block, org.bukkit.block.data.BlockData, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSourceBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source block that triggered this event.

 Note: This will default to block if not set.

 @return The source block]]>
      </doc>
    </method>
    <method name="getChangedType" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of block that changed, causing this event

 @return Changed block's type]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a block physics check is called.
 <br>
 This event is a high frequency event, it may be called thousands of times per
 a second on a busy server. Plugins are advised to listen to the event with
 caution and only perform lightweight checks when using it.
 <br>
 In addition to this, cancelling the event is liable to leave the world in an
 inconsistent state. For example if you use the event to leave a block
 floating in mid air when that block has a requirement to be attached to
 something, there is no guarantee that the floating block will persist across
 server restarts or map upgrades.
 <br>
 Plugins should also note that where possible this event may only called for
 the "root" block of physics updates in order to limit event spam. Physics
 updates that cause other blocks to change their state may not result in an
 event for each of those blocks (usually adjacent). If you are concerned about
 monitoring these changes then you should check adjacent blocks yourself.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockPhysicsEvent -->
  <!-- start class org.bukkit.event.block.BlockPistonEvent -->
  <class name="BlockPistonEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockPistonEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="isSticky" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the Piston in the event is sticky.

 @return stickiness of the piston]]>
      </doc>
    </method>
    <method name="getDirection" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the direction in which the piston will operate.

 @return direction of the piston]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when a piston block is triggered]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockPistonEvent -->
  <!-- start class org.bukkit.event.block.BlockPistonExtendEvent -->
  <class name="BlockPistonExtendEvent" extends="org.bukkit.event.block.BlockPistonEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockPistonExtendEvent" type="org.bukkit.block.Block, int, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockPistonExtendEvent" type="org.bukkit.block.Block, java.util.List&lt;org.bukkit.block.Block&gt;, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="slime blocks make the value of this method
          inaccurate due to blocks being pushed at the side">
      <doc>
      <![CDATA[Get the amount of blocks which will be moved while extending.

 @return the amount of moving blocks
 @deprecated slime blocks make the value of this method
          inaccurate due to blocks being pushed at the side]]>
      </doc>
    </method>
    <method name="getBlocks" return="java.util.List&lt;org.bukkit.block.Block&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an immutable list of the blocks which will be moved by the
 extending.

 @return Immutable list of the moved blocks.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a piston extends]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockPistonExtendEvent -->
  <!-- start class org.bukkit.event.block.BlockPistonRetractEvent -->
  <class name="BlockPistonRetractEvent" extends="org.bukkit.event.block.BlockPistonEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockPistonRetractEvent" type="org.bukkit.block.Block, java.util.List&lt;org.bukkit.block.Block&gt;, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRetractLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location where the possible moving block might be if the
 retracting piston is sticky.

 @return The possible location of the possibly moving block.]]>
      </doc>
    </method>
    <method name="getBlocks" return="java.util.List&lt;org.bukkit.block.Block&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an immutable list of the blocks which will be moved by the
 extending.

 @return Immutable list of the moved blocks.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a piston retracts]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockPistonRetractEvent -->
  <!-- start class org.bukkit.event.block.BlockPlaceEvent -->
  <class name="BlockPlaceEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockPlaceEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockState, org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.entity.Player, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockPlaceEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockState, org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.entity.Player, boolean, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player who placed the block involved in this event.

 @return The Player who placed the block involved in this event]]>
      </doc>
    </method>
    <method name="getBlockPlaced" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clarity method for getting the placed block. Not really needed except
 for reasons of clarity.

 @return The Block that was placed]]>
      </doc>
    </method>
    <method name="getBlockReplacedState" return="org.bukkit.block.BlockState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the BlockState for the block which was replaced. Material type air
 mostly.

 @return The BlockState for the block which was replaced.]]>
      </doc>
    </method>
    <method name="getBlockAgainst" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block that this block was placed against

 @return Block the block that the new block was placed against]]>
      </doc>
    </method>
    <method name="getItemInHand" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item in the player's hand when they placed the block.

 @return The ItemStack for the item in the player's hand when they
     placed the block]]>
      </doc>
    </method>
    <method name="getHand" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the hand which placed the block
 @return Main or off-hand, depending on which hand was used to place the block]]>
      </doc>
    </method>
    <method name="canBuild" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value whether the player would be allowed to build here.
 Defaults to spawn if the server was going to stop them (such as, the
 player is in Spawn). Note that this is an entirely different check
 than BLOCK_CANBUILD, as this refers to a player, not universe-physics
 rule like cactus on dirt.

 @return boolean whether the server would allow a player to build here]]>
      </doc>
    </method>
    <method name="setBuild"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canBuild" type="boolean"/>
      <doc>
      <![CDATA[Sets the canBuild state of this event. Set to true if you want the
 player to be able to build.

 @param canBuild true if you want the player to be able to build]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="cancel" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="canBuild" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="placedAgainst" type="org.bukkit.block.Block"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="replacedBlockState" type="org.bukkit.block.BlockState"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="itemInHand" type="org.bukkit.inventory.ItemStack"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="player" type="org.bukkit.entity.Player"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="hand" type="org.bukkit.inventory.EquipmentSlot"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Called when a block is placed by a player.
 <p>
 If a Block Place event is cancelled, the block will not be placed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockPlaceEvent -->
  <!-- start class org.bukkit.event.block.BlockRedstoneEvent -->
  <class name="BlockRedstoneEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockRedstoneEvent" type="org.bukkit.block.Block, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getOldCurrent" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the old current of this block

 @return The previous current]]>
      </doc>
    </method>
    <method name="getNewCurrent" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new current of this block

 @return The new current]]>
      </doc>
    </method>
    <method name="setNewCurrent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newCurrent" type="int"/>
      <doc>
      <![CDATA[Sets the new current of this block

 @param newCurrent The new current to set]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a redstone current changes]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockRedstoneEvent -->
  <!-- start class org.bukkit.event.block.BlockShearEntityEvent -->
  <class name="BlockShearEntityEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BlockShearEntityEvent" type="org.bukkit.block.Block, org.bukkit.entity.Entity, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that was sheared.

 @return the entity that was sheared.]]>
      </doc>
    </method>
    <method name="getTool" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item used to shear this sheep.

 @return the item used to shear this sheep.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Event fired when a dispenser shears a nearby sheep.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockShearEntityEvent -->
  <!-- start class org.bukkit.event.block.BlockSpreadEvent -->
  <class name="BlockSpreadEvent" extends="org.bukkit.event.block.BlockFormEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockSpreadEvent" type="org.bukkit.block.Block, org.bukkit.block.Block, org.bukkit.block.BlockState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source block involved in this event.

 @return the Block for the source block involved in this event.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a block spreads based on world conditions.
 <p>
 Use {@link BlockFormEvent} to catch blocks that "randomly" form instead of
 actually spread.
 <p>
 Examples:
 <ul>
 <li>Mushrooms spreading.
 <li>Fire spreading.
 </ul>
 <p>
 If a Block Spread event is cancelled, the block will not spread.

 @see BlockFormEvent]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.BlockSpreadEvent -->
  <!-- start class org.bukkit.event.block.CauldronLevelChangeEvent -->
  <class name="CauldronLevelChangeEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="CauldronLevelChangeEvent" type="org.bukkit.block.Block, org.bukkit.entity.Entity, org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get entity which did this. May be null.

 @return acting entity]]>
      </doc>
    </method>
    <method name="getReason" return="org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOldLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNewLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setNewLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newLevel" type="int"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.event.block.CauldronLevelChangeEvent -->
  <!-- start class org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason -->
  <class name="CauldronLevelChangeEvent.ChangeReason" extends="java.lang.Enum&lt;org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason -->
  <!-- start class org.bukkit.event.block.EntityBlockFormEvent -->
  <class name="EntityBlockFormEvent" extends="org.bukkit.event.block.BlockFormEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityBlockFormEvent" type="org.bukkit.entity.Entity, org.bukkit.block.Block, org.bukkit.block.BlockState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the entity that formed the block.

 @return Entity involved in event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when a block is formed by entities.
 <p>
 Examples:
 <ul>
 <li>Snow formed by a {@link org.bukkit.entity.Snowman}.
 <li>Frosted Ice formed by the Frost Walker enchantment.
 </ul>]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.EntityBlockFormEvent -->
  <!-- start class org.bukkit.event.block.FluidLevelChangeEvent -->
  <class name="FluidLevelChangeEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="FluidLevelChangeEvent" type="org.bukkit.block.Block, org.bukkit.block.data.BlockData"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new data of the changed block.

 @return new data]]>
      </doc>
    </method>
    <method name="setNewData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newData" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Sets the new data of the changed block. Must be of the same Material as
 the old one.

 @param newData the new data]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the fluid level of a block changes due to changes in adjacent
 blocks.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.FluidLevelChangeEvent -->
  <!-- start class org.bukkit.event.block.LeavesDecayEvent -->
  <class name="LeavesDecayEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="LeavesDecayEvent" type="org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when leaves are decaying naturally.
 <p>
 If a Leaves Decay event is cancelled, the leaves will not decay.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.LeavesDecayEvent -->
  <!-- start class org.bukkit.event.block.MoistureChangeEvent -->
  <class name="MoistureChangeEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="MoistureChangeEvent" type="org.bukkit.block.Block, org.bukkit.block.BlockState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewState" return="org.bukkit.block.BlockState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new state of the affected block.

 @return new block state]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the moisture level of a soil block changes.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.MoistureChangeEvent -->
  <!-- start class org.bukkit.event.block.NotePlayEvent -->
  <class name="NotePlayEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="NotePlayEvent" type="org.bukkit.block.Block, org.bukkit.Instrument, org.bukkit.Note"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getInstrument" return="org.bukkit.Instrument"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link Instrument} to be used.

 @return the Instrument]]>
      </doc>
    </method>
    <method name="getNote" return="org.bukkit.Note"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link Note} to be played.

 @return the Note]]>
      </doc>
    </method>
    <method name="setInstrument"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="no effect on newer Minecraft versions">
      <param name="instrument" type="org.bukkit.Instrument"/>
      <doc>
      <![CDATA[Overrides the {@link Instrument} to be used.

 @param instrument the Instrument. Has no effect if null.
 @deprecated no effect on newer Minecraft versions]]>
      </doc>
    </method>
    <method name="setNote"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="no effect on newer Minecraft versions">
      <param name="note" type="org.bukkit.Note"/>
      <doc>
      <![CDATA[Overrides the {@link Note} to be played.

 @param note the Note. Has no effect if null.
 @deprecated no effect on newer Minecraft versions]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a note block is being played through player interaction or a
 redstone current.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.NotePlayEvent -->
  <!-- start class org.bukkit.event.block.SignChangeEvent -->
  <class name="SignChangeEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SignChangeEvent" type="org.bukkit.block.Block, org.bukkit.entity.Player, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player changing the sign involved in this event.

 @return the Player involved in this event]]>
      </doc>
    </method>
    <method name="getLines" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all of the lines of text from the sign involved in this event.

 @return the String array for the sign's lines new text]]>
      </doc>
    </method>
    <method name="getLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <exception name="IndexOutOfBoundsException" type="java.lang.IndexOutOfBoundsException"/>
      <doc>
      <![CDATA[Gets a single line of text from the sign involved in this event.

 @param index index of the line to get
 @return the String containing the line of text associated with the
     provided index
 @throws IndexOutOfBoundsException thrown when the provided index is {@literal > 3
     or < 0}]]>
      </doc>
    </method>
    <method name="setLine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="line" type="java.lang.String"/>
      <exception name="IndexOutOfBoundsException" type="java.lang.IndexOutOfBoundsException"/>
      <doc>
      <![CDATA[Sets a single line for the sign involved in this event

 @param index index of the line to set
 @param line text to set
 @throws IndexOutOfBoundsException thrown when the provided index is {@literal > 3
     or < 0}]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a sign is changed by a player.
 <p>
 If a Sign Change event is cancelled, the sign will not be changed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.SignChangeEvent -->
  <!-- start class org.bukkit.event.block.SpongeAbsorbEvent -->
  <class name="SpongeAbsorbEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SpongeAbsorbEvent" type="org.bukkit.block.Block, java.util.List&lt;org.bukkit.block.BlockState&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlocks" return="java.util.List&lt;org.bukkit.block.BlockState&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of all blocks to be removed by the sponge.
 <br>
 This list is mutable and contains the blocks in their removed state, i.e.
 having a type of {@link Material#AIR}.

 @return list of the to be removed blocks.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a sponge absorbs water from the world.
 <br>
 The world will be in its previous state, and {@link #getBlocks()} will
 represent the changes to be made to the world, if the event is not cancelled.
 <br>
 As this is a physics based event it may be called multiple times for "the
 same" changes.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.block.SpongeAbsorbEvent -->
</package>
<package name="org.bukkit.event.command">
  <!-- start class org.bukkit.event.command.UnknownCommandEvent -->
  <class name="UnknownCommandEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnknownCommandEvent" type="org.bukkit.command.CommandSender, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSender" return="org.bukkit.command.CommandSender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the CommandSender or ConsoleCommandSender
 <p>

 @return Sender of the command]]>
      </doc>
    </method>
    <method name="getCommandLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the command that was send
 <p>

 @return Command sent]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets message that will be returned
 <p>

 @return Unknown command message]]>
      </doc>
    </method>
    <method name="setMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets message that will be returned
 <p>
 Set to null to avoid any message being sent

 @param message the message to be returned, or null]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a player executes a command that is not defined]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.command.UnknownCommandEvent -->
</package>
<package name="org.bukkit.event.enchantment">
  <!-- start class org.bukkit.event.enchantment.EnchantItemEvent -->
  <class name="EnchantItemEvent" extends="org.bukkit.event.inventory.InventoryEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EnchantItemEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.InventoryView, org.bukkit.block.Block, org.bukkit.inventory.ItemStack, int, java.util.Map&lt;org.bukkit.enchantments.Enchantment, java.lang.Integer&gt;, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEnchanter" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player enchanting the item

 @return enchanting player]]>
      </doc>
    </method>
    <method name="getEnchantBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block being used to enchant the item

 @return the block used for enchanting]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item to be enchanted (can be modified)

 @return ItemStack of item]]>
      </doc>
    </method>
    <method name="getExpLevelCost" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cost (minimum level) which is displayed as a number on the right
 hand side of the enchantment offer.

 @return experience level cost]]>
      </doc>
    </method>
    <method name="setExpLevelCost"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the cost (minimum level) which is displayed as a number on the right
 hand side of the enchantment offer.

 @param level - cost in levels]]>
      </doc>
    </method>
    <method name="getEnchantsToAdd" return="java.util.Map&lt;org.bukkit.enchantments.Enchantment, java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get map of enchantment (levels, keyed by type) to be added to item
 (modify map returned to change values). Note: Any enchantments not
 allowed for the item will be ignored

 @return map of enchantment levels, keyed by enchantment]]>
      </doc>
    </method>
    <method name="whichButton" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Which button was pressed to initiate the enchanting.

 @return The button index (0, 1, or 2).]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an ItemStack is successfully enchanted (currently at
 enchantment table)]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.enchantment.EnchantItemEvent -->
  <!-- start class org.bukkit.event.enchantment.PrepareItemEnchantEvent -->
  <class name="PrepareItemEnchantEvent" extends="org.bukkit.event.inventory.InventoryEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PrepareItemEnchantEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.InventoryView, org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.enchantments.EnchantmentOffer[], int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEnchanter" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player enchanting the item

 @return enchanting player]]>
      </doc>
    </method>
    <method name="getEnchantBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block being used to enchant the item

 @return the block used for enchanting]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item to be enchanted.

 @return ItemStack of item]]>
      </doc>
    </method>
    <method name="getExpLevelCostsOffered" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getOffers()} instead of this method">
      <doc>
      <![CDATA[Get a list of offered experience level costs of the enchantment.

 @return experience level costs offered
 @deprecated Use {@link #getOffers()} instead of this method]]>
      </doc>
    </method>
    <method name="getOffers" return="org.bukkit.enchantments.EnchantmentOffer[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of available {@link EnchantmentOffer} for the player. You can
 modify the values to change the available offers for the player. An offer
 may be null, if there isn't a enchantment offer at a specific slot. There
 are 3 slots in the enchantment table available to modify.

 @return list of available enchantment offers]]>
      </doc>
    </method>
    <method name="getEnchantmentBonus" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get enchantment bonus in effect - corresponds to number of bookshelves

 @return enchantment bonus]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an ItemStack is inserted in an enchantment table - can be
 called multiple times]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.enchantment.PrepareItemEnchantEvent -->
</package>
<package name="org.bukkit.event.entity">
  <!-- start class org.bukkit.event.entity.AreaEffectCloudApplyEvent -->
  <class name="AreaEffectCloudApplyEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="AreaEffectCloudApplyEvent" type="org.bukkit.entity.AreaEffectCloud, java.util.List&lt;org.bukkit.entity.LivingEntity&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.AreaEffectCloud"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAffectedEntities" return="java.util.List&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves a mutable list of the effected entities
 <p>
 It is important to note that not every entity in this list
 is guaranteed to be effected.  The cloud may die during the
 application of its effects due to the depletion of {@link AreaEffectCloud#getDurationOnUse()}
 or {@link AreaEffectCloud#getRadiusOnUse()}

 @return the affected entity list]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a lingering potion applies it's effects. Happens
 once every 5 ticks]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.AreaEffectCloudApplyEvent -->
  <!-- start class org.bukkit.event.entity.ArrowBodyCountChangeEvent -->
  <class name="ArrowBodyCountChangeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ArrowBodyCountChangeEvent" type="org.bukkit.entity.LivingEntity, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isReset" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the event was called because the entity was reset.

 @return was reset]]>
      </doc>
    </method>
    <method name="getOldAmount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the old amount of arrows in the entity's body.

 @return amount of arrows]]>
      </doc>
    </method>
    <method name="getNewAmount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the new amount of arrows in the entity's body.

 @return amount of arrows]]>
      </doc>
    </method>
    <method name="setNewAmount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newAmount" type="int"/>
      <doc>
      <![CDATA[Sets the final amount of arrows in the entity's body.

 @param newAmount amount of arrows]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an arrow enters or exists an entity's body.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.ArrowBodyCountChangeEvent -->
  <!-- start class org.bukkit.event.entity.BatToggleSleepEvent -->
  <class name="BatToggleSleepEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BatToggleSleepEvent" type="org.bukkit.entity.Bat, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isAwake" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether or not the bat is attempting to awaken.

 @return true if trying to awaken, false otherwise]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a bat attempts to sleep or wake up from its slumber.
 <p>
 If a Bat Toggle Sleep event is cancelled, the Bat will not toggle its sleep
 state.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.BatToggleSleepEvent -->
  <!-- start class org.bukkit.event.entity.CreatureSpawnEvent -->
  <class name="CreatureSpawnEvent" extends="org.bukkit.event.entity.EntitySpawnEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CreatureSpawnEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSpawnReason" return="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason for why the creature is being spawned.

 @return A SpawnReason value detailing the reason for the creature being
     spawned]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when a creature is spawned into a world.
 <p>
 If a Creature Spawn event is cancelled, the creature will not spawn.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.CreatureSpawnEvent -->
  <!-- start class org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason -->
  <class name="CreatureSpawnEvent.SpawnReason" extends="java.lang.Enum&lt;org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the type of spawning]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason -->
  <!-- start class org.bukkit.event.entity.CreeperPowerEvent -->
  <class name="CreeperPowerEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="CreeperPowerEvent" type="org.bukkit.entity.Creeper, org.bukkit.entity.LightningStrike, org.bukkit.event.entity.CreeperPowerEvent.PowerCause"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CreeperPowerEvent" type="org.bukkit.entity.Creeper, org.bukkit.event.entity.CreeperPowerEvent.PowerCause"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Creeper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLightning" return="org.bukkit.entity.LightningStrike"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the lightning bolt which is striking the Creeper.

 @return The Entity for the lightning bolt which is striking the Creeper]]>
      </doc>
    </method>
    <method name="getCause" return="org.bukkit.event.entity.CreeperPowerEvent.PowerCause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cause of the creeper being (un)powered.

 @return A PowerCause value detailing the cause of change in power.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a Creeper is struck by lightning.
 <p>
 If a Creeper Power event is cancelled, the Creeper will not be powered.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.CreeperPowerEvent -->
  <!-- start class org.bukkit.event.entity.CreeperPowerEvent.PowerCause -->
  <class name="CreeperPowerEvent.PowerCause" extends="java.lang.Enum&lt;org.bukkit.event.entity.CreeperPowerEvent.PowerCause&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.CreeperPowerEvent.PowerCause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.CreeperPowerEvent.PowerCause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the cause of the change in power]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.CreeperPowerEvent.PowerCause -->
  <!-- start class org.bukkit.event.entity.EnderDragonChangePhaseEvent -->
  <class name="EnderDragonChangePhaseEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EnderDragonChangePhaseEvent" type="org.bukkit.entity.EnderDragon, org.bukkit.entity.EnderDragon.Phase, org.bukkit.entity.EnderDragon.Phase"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.EnderDragon"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCurrentPhase" return="org.bukkit.entity.EnderDragon.Phase"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current phase that the dragon is in. This method will return null
 when a dragon is first spawned and hasn't yet been assigned a phase.

 @return the current dragon phase]]>
      </doc>
    </method>
    <method name="getNewPhase" return="org.bukkit.entity.EnderDragon.Phase"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new phase that the dragon will switch to.

 @return the new dragon phase]]>
      </doc>
    </method>
    <method name="setNewPhase"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newPhase" type="org.bukkit.entity.EnderDragon.Phase"/>
      <doc>
      <![CDATA[Sets the new phase for the ender dragon.

 @param newPhase the new dragon phase]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an EnderDragon switches controller phase.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EnderDragonChangePhaseEvent -->
  <!-- start class org.bukkit.event.entity.EntityAirChangeEvent -->
  <class name="EntityAirChangeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityAirChangeEvent" type="org.bukkit.entity.Entity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAmount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of air the entity has left (measured in ticks).

 @return amount of air remaining]]>
      </doc>
    </method>
    <method name="setAmount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Sets the amount of air remaining for the entity (measured in ticks.

 @param amount amount of air remaining]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the amount of air an entity has remaining changes.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityAirChangeEvent -->
  <!-- start class org.bukkit.event.entity.EntityBreakDoorEvent -->
  <class name="EntityBreakDoorEvent" extends="org.bukkit.event.entity.EntityChangeBlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityBreakDoorEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an {@link Entity} breaks a door
 <p>
 Cancelling the event will cause the event to be delayed]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityBreakDoorEvent -->
  <!-- start class org.bukkit.event.entity.EntityBreedEvent -->
  <class name="EntityBreedEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityBreedEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.entity.LivingEntity, org.bukkit.entity.LivingEntity, org.bukkit.entity.LivingEntity, org.bukkit.inventory.ItemStack, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMother" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the parent creating this entity.

 @return The "birth" parent]]>
      </doc>
    </method>
    <method name="getFather" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the other parent of the newly born entity.

 @return the other parent]]>
      </doc>
    </method>
    <method name="getBreeder" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Entity responsible for breeding. Breeder is null for spontaneous
 conception.

 @return The Entity who initiated breeding.]]>
      </doc>
    </method>
    <method name="getBredWith" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The ItemStack that was used to initiate breeding, if present.

 @return ItemStack used to initiate breeding.]]>
      </doc>
    </method>
    <method name="getExperience" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of experience granted by breeding.

 @return experience amount]]>
      </doc>
    </method>
    <method name="setExperience"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="experience" type="int"/>
      <doc>
      <![CDATA[Set the amount of experience granted by breeding.

 @param experience experience amount]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when one Entity breeds with another Entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityBreedEvent -->
  <!-- start class org.bukkit.event.entity.EntityChangeBlockEvent -->
  <class name="EntityChangeBlockEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityChangeBlockEvent" type="org.bukkit.entity.Entity, org.bukkit.block.Block, org.bukkit.block.data.BlockData"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block the entity is changing

 @return the block that is changing]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getTo" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Material that the block is changing into

 @return the material that the block is changing into]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the data for the block that would be changed into

 @return the data for the block that would be changed into]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when any Entity changes a block and a more specific event is not available.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityChangeBlockEvent -->
  <!-- start class org.bukkit.event.entity.EntityCombustByBlockEvent -->
  <class name="EntityCombustByBlockEvent" extends="org.bukkit.event.entity.EntityCombustEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityCombustByBlockEvent" type="org.bukkit.block.Block, org.bukkit.entity.Entity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCombuster" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The combuster can be lava or a block that is on fire.
 <p>
 WARNING: block may be null.

 @return the Block that set the combustee alight.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when a block causes an entity to combust.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityCombustByBlockEvent -->
  <!-- start class org.bukkit.event.entity.EntityCombustByEntityEvent -->
  <class name="EntityCombustByEntityEvent" extends="org.bukkit.event.entity.EntityCombustEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityCombustByEntityEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCombuster" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the entity that caused the combustion event.

 @return the Entity that set the combustee alight.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when an entity causes another entity to combust.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityCombustByEntityEvent -->
  <!-- start class org.bukkit.event.entity.EntityCombustEvent -->
  <class name="EntityCombustEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityCombustEvent" type="org.bukkit.entity.Entity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getDuration" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the amount of time (in seconds) the combustee should be alight
     for]]>
      </doc>
    </method>
    <method name="setDuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="int"/>
      <doc>
      <![CDATA[The number of seconds the combustee should be alight for.
 <p>
 This value will only ever increase the combustion time, not decrease
 existing combustion times.

 @param duration the time in seconds to be alight for.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity combusts.
 <p>
 If an Entity Combust event is cancelled, the entity will not combust.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityCombustEvent -->
  <!-- start class org.bukkit.event.entity.EntityCreatePortalEvent -->
  <class name="EntityCreatePortalEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use {@link PortalCreateEvent}">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityCreatePortalEvent" type="org.bukkit.entity.LivingEntity, java.util.List&lt;org.bukkit.block.BlockState&gt;, org.bukkit.PortalType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBlocks" return="java.util.List&lt;org.bukkit.block.BlockState&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of all blocks associated with the portal.

 @return List of blocks that will be changed.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getPortalType" return="org.bukkit.PortalType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of portal that is trying to be created.

 @return Type of portal.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a Living Entity creates a portal in a world.

 @deprecated Use {@link PortalCreateEvent}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityCreatePortalEvent -->
  <!-- start class org.bukkit.event.entity.EntityDamageByBlockEvent -->
  <class name="EntityDamageByBlockEvent" extends="org.bukkit.event.entity.EntityDamageEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityDamageByBlockEvent" type="org.bukkit.block.Block, org.bukkit.entity.Entity, org.bukkit.event.entity.EntityDamageEvent.DamageCause, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityDamageByBlockEvent" type="org.bukkit.block.Block, org.bukkit.entity.Entity, org.bukkit.event.entity.EntityDamageEvent.DamageCause, java.util.Map&lt;org.bukkit.event.entity.EntityDamageEvent.DamageModifier, java.lang.Double&gt;, java.util.Map&lt;org.bukkit.event.entity.EntityDamageEvent.DamageModifier, ? extends &lt;any&gt;&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDamager" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the block that damaged the player.

 @return Block that damaged the player]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when an entity is damaged by a block]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityDamageByBlockEvent -->
  <!-- start class org.bukkit.event.entity.EntityDamageByEntityEvent -->
  <class name="EntityDamageByEntityEvent" extends="org.bukkit.event.entity.EntityDamageEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityDamageByEntityEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity, org.bukkit.event.entity.EntityDamageEvent.DamageCause, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityDamageByEntityEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity, org.bukkit.event.entity.EntityDamageEvent.DamageCause, java.util.Map&lt;org.bukkit.event.entity.EntityDamageEvent.DamageModifier, java.lang.Double&gt;, java.util.Map&lt;org.bukkit.event.entity.EntityDamageEvent.DamageModifier, ? extends &lt;any&gt;&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDamager" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entity that damaged the defender.

 @return Entity that damaged the defender.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when an entity is damaged by an entity]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityDamageByEntityEvent -->
  <!-- start class org.bukkit.event.entity.EntityDamageEvent -->
  <class name="EntityDamageEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityDamageEvent" type="org.bukkit.entity.Entity, org.bukkit.event.entity.EntityDamageEvent.DamageCause, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityDamageEvent" type="org.bukkit.entity.Entity, org.bukkit.event.entity.EntityDamageEvent.DamageCause, java.util.Map&lt;org.bukkit.event.entity.EntityDamageEvent.DamageModifier, java.lang.Double&gt;, java.util.Map&lt;org.bukkit.event.entity.EntityDamageEvent.DamageModifier, ? extends &lt;any&gt;&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getOriginalDamage" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.event.entity.EntityDamageEvent.DamageModifier"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets the original damage for the specified modifier, as defined at this
 event's construction.

 @param type the modifier
 @return the original damage
 @throws IllegalArgumentException if type is null]]>
      </doc>
    </method>
    <method name="setDamage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.event.entity.EntityDamageEvent.DamageModifier"/>
      <param name="damage" type="double"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Sets the damage for the specified modifier.

 @param type the damage modifier
 @param damage the scalar value of the damage's modifier
 @throws IllegalArgumentException if type is null
 @throws UnsupportedOperationException if the caller does not support
     the particular DamageModifier, or to rephrase, when {@link
     #isApplicable(DamageModifier)} returns false
 @see #getFinalDamage()]]>
      </doc>
    </method>
    <method name="getDamage" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.event.entity.EntityDamageEvent.DamageModifier"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets the damage change for some modifier

 @param type the damage modifier
 @return The raw amount of damage caused by the event
 @throws IllegalArgumentException if type is null
 @see DamageModifier#BASE]]>
      </doc>
    </method>
    <method name="isApplicable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.event.entity.EntityDamageEvent.DamageModifier"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[This checks to see if a particular modifier is valid for this event's
 caller, such that, {@link #setDamage(DamageModifier, double)} will not
 throw an {@link UnsupportedOperationException}.
 <p>
 {@link DamageModifier#BASE} is always applicable.

 @param type the modifier
 @return true if the modifier is supported by the caller, false otherwise
 @throws IllegalArgumentException if type is null]]>
      </doc>
    </method>
    <method name="getDamage" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the raw amount of damage caused by the event

 @return The raw amount of damage caused by the event
 @see DamageModifier#BASE]]>
      </doc>
    </method>
    <method name="getFinalDamage" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of damage caused by the event after all damage
 reduction is applied.

 @return the amount of damage caused by the event]]>
      </doc>
    </method>
    <method name="setDamage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="double"/>
      <doc>
      <![CDATA[Sets the raw amount of damage caused by the event.
 <p>
 For compatibility this also recalculates the modifiers and scales
 them by the difference between the modifier for the previous damage
 value and the new one.

 @param damage The raw amount of damage caused by the event]]>
      </doc>
    </method>
    <method name="getCause" return="org.bukkit.event.entity.EntityDamageEvent.DamageCause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cause of the damage.

 @return A DamageCause value detailing the cause of the damage.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Stores data for damage events]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityDamageEvent -->
  <!-- start class org.bukkit.event.entity.EntityDamageEvent.DamageCause -->
  <class name="EntityDamageEvent.DamageCause" extends="java.lang.Enum&lt;org.bukkit.event.entity.EntityDamageEvent.DamageCause&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.EntityDamageEvent.DamageCause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.EntityDamageEvent.DamageCause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the cause of the damage]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityDamageEvent.DamageCause -->
  <!-- start class org.bukkit.event.entity.EntityDamageEvent.DamageModifier -->
  <class name="EntityDamageEvent.DamageModifier" extends="java.lang.Enum&lt;org.bukkit.event.entity.EntityDamageEvent.DamageModifier&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="This API is responsible for a large number of implementation
 problems and is in general unsustainable to maintain. It is likely to be
 removed very soon in a subsequent release. Please see
 https://www.spigotmc.org/threads/194446/ for more information.">
    <method name="values" return="org.bukkit.event.entity.EntityDamageEvent.DamageModifier[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.EntityDamageEvent.DamageModifier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the types of modifier

 @deprecated This API is responsible for a large number of implementation
 problems and is in general unsustainable to maintain. It is likely to be
 removed very soon in a subsequent release. Please see
 https://www.spigotmc.org/threads/194446/ for more information.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityDamageEvent.DamageModifier -->
  <!-- start class org.bukkit.event.entity.EntityDeathEvent -->
  <class name="EntityDeathEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityDeathEvent" type="org.bukkit.entity.LivingEntity, java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityDeathEvent" type="org.bukkit.entity.LivingEntity, java.util.List&lt;org.bukkit.inventory.ItemStack&gt;, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDroppedExp" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets how much EXP should be dropped from this death.
 <p>
 This does not indicate how much EXP should be taken from the entity in
 question, merely how much should be created after its death.

 @return Amount of EXP to drop.]]>
      </doc>
    </method>
    <method name="setDroppedExp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exp" type="int"/>
      <doc>
      <![CDATA[Sets how much EXP should be dropped from this death.
 <p>
 This does not indicate how much EXP should be taken from the entity in
 question, merely how much should be created after its death.

 @param exp Amount of EXP to drop.]]>
      </doc>
    </method>
    <method name="getDrops" return="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all the items which will drop when the entity dies

 @return Items to drop when the entity dies]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getReviveHealth" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of health that the entity should revive with after cancelling the event.
 Set to the entity's max health by default.

 @return The amount of health]]>
      </doc>
    </method>
    <method name="setReviveHealth"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reviveHealth" type="double"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Set the amount of health that the entity should revive with after cancelling the event.
 Revive health value must be between 0 (exclusive) and the entity's max health (inclusive).

 @param reviveHealth The amount of health
 @throws IllegalArgumentException Thrown if the health is {@literal <= 0 or >} max health]]>
      </doc>
    </method>
    <method name="shouldPlayDeathSound" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether or not the death sound should play when the entity dies. If the event is cancelled it does not play!

 @return Whether or not the death sound should play. Event is called with this set to false if the entity is silent.]]>
      </doc>
    </method>
    <method name="setShouldPlayDeathSound"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="playDeathSound" type="boolean"/>
      <doc>
      <![CDATA[Set whether or not the death sound should play when the entity dies. If the event is cancelled it does not play!

 @param playDeathSound Enable or disable the death sound]]>
      </doc>
    </method>
    <method name="getDeathSound" return="org.bukkit.Sound"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the sound that the entity makes when dying

 @return The sound that the entity makes]]>
      </doc>
    </method>
    <method name="setDeathSound"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sound" type="org.bukkit.Sound"/>
      <doc>
      <![CDATA[Set the sound that the entity makes when dying

 @param sound The sound that the entity should make when dying]]>
      </doc>
    </method>
    <method name="getDeathSoundCategory" return="org.bukkit.SoundCategory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the sound category that the death sound should play in

 @return The sound category]]>
      </doc>
    </method>
    <method name="setDeathSoundCategory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="soundCategory" type="org.bukkit.SoundCategory"/>
      <doc>
      <![CDATA[Set the sound category that the death sound should play in.

 @param soundCategory The sound category]]>
      </doc>
    </method>
    <method name="getDeathSoundVolume" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the volume that the death sound will play at.

 @return The volume the death sound will play at]]>
      </doc>
    </method>
    <method name="setDeathSoundVolume"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="volume" type="float"/>
      <doc>
      <![CDATA[Set the volume the death sound should play at. If the event is cancelled this will not play the sound!

 @param volume The volume the death sound should play at]]>
      </doc>
    </method>
    <method name="getDeathSoundPitch" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the pitch that the death sound will play with.

 @return The pitch the death sound will play with]]>
      </doc>
    </method>
    <method name="setDeathSoundPitch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[GSetet the pitch that the death sound should play with.

 @param pitch The pitch the death sound should play with]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown whenever a LivingEntity dies]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityDeathEvent -->
  <!-- start class org.bukkit.event.entity.EntityDropItemEvent -->
  <class name="EntityDropItemEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityDropItemEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Item"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItemDrop" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Item created by the entity

 @return Item created by the entity]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when an entity creates an item drop.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityDropItemEvent -->
  <!-- start class org.bukkit.event.entity.EntityEnterBlockEvent -->
  <class name="EntityEnterBlockEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityEnterBlockEvent" type="org.bukkit.entity.Entity, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the block the entity will enter.

 @return the block]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an {@link Entity} enters a block and is stored in that block.
 <p>
 This event is called for bees entering a bee hive.
 <br>
 It is not called when a silverfish "enters" a stone block. For that listen to
 the {@link EntityChangeBlockEvent}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityEnterBlockEvent -->
  <!-- start class org.bukkit.event.entity.EntityEnterLoveModeEvent -->
  <class name="EntityEnterLoveModeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityEnterLoveModeEvent" type="org.bukkit.entity.Animals, org.bukkit.entity.HumanEntity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Animals"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the animal that is entering love mode.

 @return The animal that is entering love mode]]>
      </doc>
    </method>
    <method name="getHumanEntity" return="org.bukkit.entity.HumanEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Human Entity that caused the animal to enter love mode.

 @return The Human entity that caused the animal to enter love mode, or
 null if there wasn't one.]]>
      </doc>
    </method>
    <method name="getTicksInLove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of ticks that the animal will fall in love for.

 @return The amount of ticks that the animal will fall in love for]]>
      </doc>
    </method>
    <method name="setTicksInLove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticksInLove" type="int"/>
      <doc>
      <![CDATA[Sets the amount of ticks that the animal will fall in love for.

 @param ticksInLove The amount of ticks that the animal will fall in love
 for]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity enters love mode.
 <br>
 This can be cancelled but the item will still be consumed that was used to
 make the entity enter into love mode.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityEnterLoveModeEvent -->
  <!-- start class org.bukkit.event.entity.EntityEvent -->
  <class name="EntityEvent" extends="org.bukkit.event.Event"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityEvent" type="org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Entity involved in this event

 @return Entity who is involved in this event]]>
      </doc>
    </method>
    <method name="getEntityType" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the EntityType of the Entity involved in this event.

 @return EntityType of the Entity involved in this event]]>
      </doc>
    </method>
    <field name="entity" type="org.bukkit.entity.Entity"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents an Entity-related event]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityEvent -->
  <!-- start class org.bukkit.event.entity.EntityExplodeEvent -->
  <class name="EntityExplodeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityExplodeEvent" type="org.bukkit.entity.Entity, org.bukkit.Location, java.util.List&lt;org.bukkit.block.Block&gt;, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="blockList" return="java.util.List&lt;org.bukkit.block.Block&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the list of blocks that would have been removed or were removed
 from the explosion event.

 @return All blown-up blocks]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the location where the explosion happened.
 <p>
 It is not possible to get this value from the Entity as the Entity no
 longer exists in the world.

 @return The location of the explosion]]>
      </doc>
    </method>
    <method name="getYield" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the percentage of blocks to drop from this explosion

 @return The yield.]]>
      </doc>
    </method>
    <method name="setYield"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="yield" type="float"/>
      <doc>
      <![CDATA[Sets the percentage of blocks to drop from this explosion

 @param yield The new yield percentage]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity explodes]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityExplodeEvent -->
  <!-- start class org.bukkit.event.entity.EntityInteractEvent -->
  <class name="EntityInteractEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityInteractEvent" type="org.bukkit.entity.Entity, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the involved block

 @return the block clicked with this item.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="block" type="org.bukkit.block.Block"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Called when an entity interacts with an object]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityInteractEvent -->
  <!-- start class org.bukkit.event.entity.EntityPickupItemEvent -->
  <class name="EntityPickupItemEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityPickupItemEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.entity.Item, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getItem" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Item picked up by the entity.

 @return Item]]>
      </doc>
    </method>
    <method name="getRemaining" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount remaining on the ground, if any

 @return amount remaining on the ground]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a entity picks an item up from the ground]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPickupItemEvent -->
  <!-- start class org.bukkit.event.entity.EntityPlaceEvent -->
  <class name="EntityPlaceEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="draft API">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityPlaceEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player placing the entity

 @return the player placing the entity]]>
      </doc>
    </method>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the block that the entity was placed on

 @return the block that the entity was placed on]]>
      </doc>
    </method>
    <method name="getBlockFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the face of the block that the entity was placed on

 @return the face of the block that the entity was placed on]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Triggered when a entity is created in the world by a player "placing" an item
 on a block.
 <br>
 Note that this event is currently only fired for four specific placements:
 armor stands, boats, minecarts, and end crystals.

 @deprecated draft API]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPlaceEvent -->
  <!-- start class org.bukkit.event.entity.EntityPortalEnterEvent -->
  <class name="EntityPortalEnterEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityPortalEnterEvent" type="org.bukkit.entity.Entity, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the portal block the entity is touching

 @return The portal block the entity is touching]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity comes into contact with a portal]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPortalEnterEvent -->
  <!-- start class org.bukkit.event.entity.EntityPortalEvent -->
  <class name="EntityPortalEvent" extends="org.bukkit.event.entity.EntityTeleportEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityPortalEvent" type="org.bukkit.entity.Entity, org.bukkit.Location, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityPortalEvent" type="org.bukkit.entity.Entity, org.bukkit.Location, org.bukkit.Location, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setSearchRadius"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="searchRadius" type="int"/>
      <doc>
      <![CDATA[Set the Block radius to search in for available portals.

 @param searchRadius the radius in which to search for a portal from the
 location]]>
      </doc>
    </method>
    <method name="getSearchRadius" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the search radius value for finding an available portal.

 @return the currently set search radius]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a non-player entity is about to teleport because it is in
 contact with a portal.
 <p>
 For players see {@link org.bukkit.event.player.PlayerPortalEvent}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPortalEvent -->
  <!-- start class org.bukkit.event.entity.EntityPortalExitEvent -->
  <class name="EntityPortalExitEvent" extends="org.bukkit.event.entity.EntityTeleportEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityPortalExitEvent" type="org.bukkit.entity.Entity, org.bukkit.Location, org.bukkit.Location, org.bukkit.util.Vector, org.bukkit.util.Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBefore" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the velocity that the entity has before entering the
 portal.

 @return velocity of entity before entering the portal]]>
      </doc>
    </method>
    <method name="getAfter" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the velocity that the entity will have after exiting the
 portal.

 @return velocity of entity after exiting the portal]]>
      </doc>
    </method>
    <method name="setAfter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="after" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets the velocity that the entity will have after exiting the portal.

 @param after the velocity after exiting the portal]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called before an entity exits a portal.
 <p>
 This event allows you to modify the velocity of the entity after they have
 successfully exited the portal.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPortalExitEvent -->
  <!-- start class org.bukkit.event.entity.EntityPoseChangeEvent -->
  <class name="EntityPoseChangeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityPoseChangeEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Pose"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPose" return="org.bukkit.entity.Pose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity's new pose.

 @return the new pose]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity changes its pose.

 @see Entity#getPose()]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPoseChangeEvent -->
  <!-- start class org.bukkit.event.entity.EntityPotionEffectEvent -->
  <class name="EntityPotionEffectEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityPotionEffectEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.potion.PotionEffect, org.bukkit.potion.PotionEffect, org.bukkit.event.entity.EntityPotionEffectEvent.Cause, org.bukkit.event.entity.EntityPotionEffectEvent.Action, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getOldEffect" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the old potion effect of the changed type, which will be removed.

 @return The old potion effect or null if the entity did not have the
 changed effect type.]]>
      </doc>
    </method>
    <method name="getNewEffect" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets new potion effect of the changed type to be applied.

 @return The new potion effect or null if the effect of the changed type
 will be removed.]]>
      </doc>
    </method>
    <method name="getCause" return="org.bukkit.event.entity.EntityPotionEffectEvent.Cause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cause why the effect has changed.

 @return A Cause value why the effect has changed.]]>
      </doc>
    </method>
    <method name="getAction" return="org.bukkit.event.entity.EntityPotionEffectEvent.Action"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the action which will be performed on the potion effect type.

 @return An action to be performed on the potion effect type.]]>
      </doc>
    </method>
    <method name="getModifiedType" return="org.bukkit.potion.PotionEffectType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the modified potion effect type.

 @return The effect type which will be modified on the entity.]]>
      </doc>
    </method>
    <method name="isOverride" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if the new potion effect will override the old potion effect
 (Only applicable for the CHANGED Action).

 @return If the new effect will override the old one.]]>
      </doc>
    </method>
    <method name="setOverride"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="override" type="boolean"/>
      <doc>
      <![CDATA[Sets if the new potion effect will override the old potion effect (Only
 applicable for the CHANGED action).

 @param override If the new effect will override the old one.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a potion effect is modified on an entity.
 <p>
 If the event is cancelled, no change will be made on the entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPotionEffectEvent -->
  <!-- start class org.bukkit.event.entity.EntityPotionEffectEvent.Action -->
  <class name="EntityPotionEffectEvent.Action" extends="java.lang.Enum&lt;org.bukkit.event.entity.EntityPotionEffectEvent.Action&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.EntityPotionEffectEvent.Action[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.EntityPotionEffectEvent.Action"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the action to be performed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPotionEffectEvent.Action -->
  <!-- start class org.bukkit.event.entity.EntityPotionEffectEvent.Cause -->
  <class name="EntityPotionEffectEvent.Cause" extends="java.lang.Enum&lt;org.bukkit.event.entity.EntityPotionEffectEvent.Cause&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.EntityPotionEffectEvent.Cause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.EntityPotionEffectEvent.Cause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the cause why an effect was changed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityPotionEffectEvent.Cause -->
  <!-- start class org.bukkit.event.entity.EntityRegainHealthEvent -->
  <class name="EntityRegainHealthEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityRegainHealthEvent" type="org.bukkit.entity.Entity, double, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityRegainHealthEvent" type="org.bukkit.entity.Entity, double, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isFastRegen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this event a result of the fast regeneration mechanic

 @return Whether the event is the result of a fast regeneration mechanic]]>
      </doc>
    </method>
    <method name="getAmount" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of regained health

 @return The amount of health regained]]>
      </doc>
    </method>
    <method name="setAmount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="double"/>
      <doc>
      <![CDATA[Sets the amount of regained health

 @param amount the amount of health the entity will regain]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getRegainReason" return="org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason for why the entity is regaining health

 @return A RegainReason detailing the reason for the entity regaining
     health]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Stores data for health-regain events]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityRegainHealthEvent -->
  <!-- start class org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason -->
  <class name="EntityRegainHealthEvent.RegainReason" extends="java.lang.Enum&lt;org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the type of health regaining that is occurring]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason -->
  <!-- start class org.bukkit.event.entity.EntityResurrectEvent -->
  <class name="EntityResurrectEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityResurrectEvent" type="org.bukkit.entity.LivingEntity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity dies and may have the opportunity to be resurrected.
 Will be called in a cancelled state if the entity does not have a totem
 equipped.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityResurrectEvent -->
  <!-- start class org.bukkit.event.entity.EntityShootBowEvent -->
  <class name="EntityShootBowEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityShootBowEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.inventory.ItemStack, org.bukkit.entity.Entity, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityShootBowEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack, org.bukkit.entity.Entity, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityShootBowEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack, org.bukkit.entity.Entity, org.bukkit.inventory.EquipmentSlot, float, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConsumeArrow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumeArrow" type="boolean"/>
    </method>
    <method name="getConsumeArrow" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getArrowItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBow" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the bow ItemStack used to fire the arrow.

 @return the bow involved in this event]]>
      </doc>
    </method>
    <method name="getConsumable" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the ItemStack to be consumed in this event (if any).

 For instance, bows will consume an arrow ItemStack in a player's
 inventory.

 @return the consumable item]]>
      </doc>
    </method>
    <method name="getProjectile" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the projectile which will be launched by this event

 @return the launched projectile]]>
      </doc>
    </method>
    <method name="setProjectile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="projectile" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Replaces the projectile which will be launched

 @param projectile the new projectile]]>
      </doc>
    </method>
    <method name="getHand" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the hand from which the bow was shot.

 @return the hand]]>
      </doc>
    </method>
    <method name="getForce" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the force the arrow was launched with

 @return bow shooting force, up to 1.0]]>
      </doc>
    </method>
    <method name="setConsumeItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumeItem" type="boolean"/>
      <doc>
      <![CDATA[Set whether or not the consumable item should be consumed in this event.

 If set to false, it is recommended that a call to
 {@link Player#updateInventory()} is made as the client may disagree with
 the server's decision to not consume a consumable item.
 <p>
 This value is ignored for entities where items are not required
 (skeletons, pillagers, etc.) or with crossbows (as no item is being
 consumed).

 @param consumeItem whether or not to consume the item]]>
      </doc>
    </method>
    <method name="shouldConsumeItem" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether or not the consumable item should be consumed in this event.

 @return true if consumed, false otherwise]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a LivingEntity shoots a bow firing an arrow]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityShootBowEvent -->
  <!-- start class org.bukkit.event.entity.EntitySpawnEvent -->
  <class name="EntitySpawnEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntitySpawnEvent" type="org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location at which the entity is spawning.

 @return The location at which the entity is spawning]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity is spawned into a world.
 <p>
 If an Entity Spawn event is cancelled, the entity will not spawn.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntitySpawnEvent -->
  <!-- start class org.bukkit.event.entity.EntitySpellCastEvent -->
  <class name="EntitySpellCastEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntitySpellCastEvent" type="org.bukkit.entity.Spellcaster, org.bukkit.entity.Spellcaster.Spell"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Spellcaster"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSpell" return="org.bukkit.entity.Spellcaster.Spell"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the spell to be cast in this event.

 This is a convenience method equivalent to
 {@link Spellcaster#getSpell()}.

 @return the spell to cast]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a {@link Spellcaster} casts a spell.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntitySpellCastEvent -->
  <!-- start class org.bukkit.event.entity.EntityTameEvent -->
  <class name="EntityTameEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityTameEvent" type="org.bukkit.entity.LivingEntity, org.bukkit.entity.AnimalTamer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getOwner" return="org.bukkit.entity.AnimalTamer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the owning AnimalTamer

 @return the owning AnimalTamer]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a LivingEntity is tamed]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityTameEvent -->
  <!-- start class org.bukkit.event.entity.EntityTargetEvent -->
  <class name="EntityTargetEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityTargetEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity, org.bukkit.event.entity.EntityTargetEvent.TargetReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getReason" return="org.bukkit.event.entity.EntityTargetEvent.TargetReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the reason for the targeting

 @return The reason]]>
      </doc>
    </method>
    <method name="getTarget" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the entity that this is targeting.
 <p>
 This will be null in the case that the event is called when the mob
 forgets its target.

 @return The entity]]>
      </doc>
    </method>
    <method name="setTarget"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Set the entity that you want the mob to target instead.
 <p>
 It is possible to be null, null will cause the entity to be
 target-less.
 <p>
 This is different from cancelling the event. Cancelling the event will
 cause the entity to keep an original target, while setting to be null
 will cause the entity to be reset.

 @param target The entity to target]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a creature targets or untargets another entity]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityTargetEvent -->
  <!-- start class org.bukkit.event.entity.EntityTargetEvent.TargetReason -->
  <class name="EntityTargetEvent.TargetReason" extends="java.lang.Enum&lt;org.bukkit.event.entity.EntityTargetEvent.TargetReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.EntityTargetEvent.TargetReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.EntityTargetEvent.TargetReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the reason for the targeting]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityTargetEvent.TargetReason -->
  <!-- start class org.bukkit.event.entity.EntityTargetLivingEntityEvent -->
  <class name="EntityTargetLivingEntityEvent" extends="org.bukkit.event.entity.EntityTargetEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityTargetLivingEntityEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.LivingEntity, org.bukkit.event.entity.EntityTargetEvent.TargetReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTarget" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTarget"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Set the Entity that you want the mob to target.
 <p>
 It is possible to be null, null will cause the entity to be
 target-less.
 <p>
 Must be a LivingEntity, or null.

 @param target The entity to target]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when an Entity targets a {@link LivingEntity} and can only target
 LivingEntity's.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityTargetLivingEntityEvent -->
  <!-- start class org.bukkit.event.entity.EntityTeleportEvent -->
  <class name="EntityTeleportEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityTeleportEvent" type="org.bukkit.entity.Entity, org.bukkit.Location, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getFrom" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location that this entity moved from

 @return Location this entity moved from]]>
      </doc>
    </method>
    <method name="setFrom"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the location that this entity moved from

 @param from New location this entity moved from]]>
      </doc>
    </method>
    <method name="getTo" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location that this entity moved to

 @return Location the entity moved to]]>
      </doc>
    </method>
    <method name="setTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the location that this entity moved to

 @param to New Location this entity moved to]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a non-player entity is teleported from one location to another.
 <br>
 This may be as a result of natural causes (Enderman, Shulker), pathfinding
 (Wolf), or commands (/teleport).]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityTeleportEvent -->
  <!-- start class org.bukkit.event.entity.EntityToggleGlideEvent -->
  <class name="EntityToggleGlideEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityToggleGlideEvent" type="org.bukkit.entity.LivingEntity, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="isGliding" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Sent when an entity's gliding status is toggled with an Elytra.
 Examples of when this event would be called:
 <ul>
     <li>Player presses the jump key while in midair and using an Elytra</li>
     <li>Player lands on ground while they are gliding (with an Elytra)</li>
 </ul>
 This can be visually estimated by the animation in which a player turns horizontal.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityToggleGlideEvent -->
  <!-- start class org.bukkit.event.entity.EntityToggleSwimEvent -->
  <class name="EntityToggleSwimEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityToggleSwimEvent" type="org.bukkit.entity.LivingEntity, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="isSwimming" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Sent when an entity's swimming status is toggled.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityToggleSwimEvent -->
  <!-- start class org.bukkit.event.entity.EntityTransformEvent -->
  <class name="EntityTransformEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityTransformEvent" type="org.bukkit.entity.Entity, java.util.List&lt;org.bukkit.entity.Entity&gt;, org.bukkit.event.entity.EntityTransformEvent.TransformReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTransformedEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that the original entity was transformed to.

 This returns the first entity in the transformed entity list.

 @return The transformed entity.
 @see #getTransformedEntities()]]>
      </doc>
    </method>
    <method name="getTransformedEntities" return="java.util.List&lt;org.bukkit.entity.Entity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entities that the original entity was transformed to.

 @return The transformed entities.]]>
      </doc>
    </method>
    <method name="getTransformReason" return="org.bukkit.event.entity.EntityTransformEvent.TransformReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason for the conversion that has occurred.

 @return The reason for conversion that has occurred.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity is about to be replaced by another entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityTransformEvent -->
  <!-- start class org.bukkit.event.entity.EntityTransformEvent.TransformReason -->
  <class name="EntityTransformEvent.TransformReason" extends="java.lang.Enum&lt;org.bukkit.event.entity.EntityTransformEvent.TransformReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.EntityTransformEvent.TransformReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.EntityTransformEvent.TransformReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.entity.EntityTransformEvent.TransformReason -->
  <!-- start class org.bukkit.event.entity.EntityUnleashEvent -->
  <class name="EntityUnleashEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EntityUnleashEvent" type="org.bukkit.entity.Entity, org.bukkit.event.entity.EntityUnleashEvent.UnleashReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getReason" return="org.bukkit.event.entity.EntityUnleashEvent.UnleashReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the reason for the unleashing.

 @return The reason]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called immediately prior to an entity being unleashed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.EntityUnleashEvent -->
  <!-- start class org.bukkit.event.entity.EntityUnleashEvent.UnleashReason -->
  <class name="EntityUnleashEvent.UnleashReason" extends="java.lang.Enum&lt;org.bukkit.event.entity.EntityUnleashEvent.UnleashReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.EntityUnleashEvent.UnleashReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.EntityUnleashEvent.UnleashReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.entity.EntityUnleashEvent.UnleashReason -->
  <!-- start class org.bukkit.event.entity.ExpBottleEvent -->
  <class name="ExpBottleEvent" extends="org.bukkit.event.entity.ProjectileHitEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExpBottleEvent" type="org.bukkit.entity.ThrownExpBottle, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.ThrownExpBottle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getShowEffect" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method indicates if the particle effect should be shown.

 @return true if the effect will be shown, false otherwise]]>
      </doc>
    </method>
    <method name="setShowEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="showEffect" type="boolean"/>
      <doc>
      <![CDATA[This method sets if the particle effect will be shown.
 <p>
 This does not change the experience created.

 @param showEffect true indicates the effect will be shown, false
     indicates no effect will be shown]]>
      </doc>
    </method>
    <method name="getExperience" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method retrieves the amount of experience to be created.
 <p>
 The number indicates a total amount to be divided into orbs.

 @return the total amount of experience to be created]]>
      </doc>
    </method>
    <method name="setExperience"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exp" type="int"/>
      <doc>
      <![CDATA[This method sets the amount of experience to be created.
 <p>
 The number indicates a total amount to be divided into orbs.

 @param exp the total amount of experience to be created]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a ThrownExpBottle hits and releases experience.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.ExpBottleEvent -->
  <!-- start class org.bukkit.event.entity.ExplosionPrimeEvent -->
  <class name="ExplosionPrimeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ExplosionPrimeEvent" type="org.bukkit.entity.Entity, float, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ExplosionPrimeEvent" type="org.bukkit.entity.Explosive"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getRadius" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the radius of the explosion

 @return returns the radius of the explosion]]>
      </doc>
    </method>
    <method name="setRadius"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radius" type="float"/>
      <doc>
      <![CDATA[Sets the radius of the explosion

 @param radius the radius of the explosion]]>
      </doc>
    </method>
    <method name="getFire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this explosion will create fire or not

 @return true if this explosion will create fire]]>
      </doc>
    </method>
    <method name="setFire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fire" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this explosion will create fire or not

 @param fire true if you want this explosion to create fire]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity has made a decision to explode.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.ExplosionPrimeEvent -->
  <!-- start class org.bukkit.event.entity.FireworkExplodeEvent -->
  <class name="FireworkExplodeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="FireworkExplodeEvent" type="org.bukkit.entity.Firework"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Set the cancelled state of this event. If the firework explosion is
 cancelled, the firework will still be removed, but no particles will be
 displayed.

 @param cancel whether to cancel or not.]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Firework"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a firework explodes.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.FireworkExplodeEvent -->
  <!-- start class org.bukkit.event.entity.FoodLevelChangeEvent -->
  <class name="FoodLevelChangeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="FoodLevelChangeEvent" type="org.bukkit.entity.HumanEntity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FoodLevelChangeEvent" type="org.bukkit.entity.HumanEntity, int, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.HumanEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item that triggered this event, if any.

 @return an ItemStack for the item being consumed]]>
      </doc>
    </method>
    <method name="getFoodLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the resultant food level that the entity involved in this event
 should be set to.
 <p>
 Where 20 is a full food bar and 0 is an empty one.

 @return The resultant food level]]>
      </doc>
    </method>
    <method name="setFoodLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the resultant food level that the entity involved in this event
 should be set to

 @param level the resultant food level that the entity involved in this
     event should be set to]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a human entity's food level changes]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.FoodLevelChangeEvent -->
  <!-- start class org.bukkit.event.entity.HorseJumpEvent -->
  <class name="HorseJumpEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="HorseJumpEvent" type="org.bukkit.entity.AbstractHorse, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="horse jumping was moved client side.">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[@deprecated horse jumping was moved client side.]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.AbstractHorse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPower" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the power of the jump.
 <p>
 Power is a value that defines how much of the horse's jump strength
 should be used for the jump. Power is effectively multiplied times
 the horse's jump strength to determine how high the jump is; 0
 represents no jump strength while 1 represents full jump strength.
 Setting power to a value above 1 will use additional jump strength
 that the horse does not usually have.
 <p>
 Power does not affect how high the horse is capable of jumping, only
 how much of its jumping capability will be used in this jump. To set
 the horse's overall jump strength, see {@link
 AbstractHorse#setJumpStrength(double)}.

 @return jump strength]]>
      </doc>
    </method>
    <method name="setPower"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="horse jumping was moved client side.">
      <param name="power" type="float"/>
      <doc>
      <![CDATA[Sets the power of the jump.
 <p>
 Jump power can be set to a value above 1.0 which will increase the
 strength of this jump above the horse's actual jump strength.
 <p>
 Setting the jump power to 0 will result in the jump animation still
 playing, but the horse not leaving the ground. Only canceling this
 event will result in no jump animation at all.

 @param power power of the jump
 @deprecated horse jumping was moved client side.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a horse jumps.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.HorseJumpEvent -->
  <!-- start class org.bukkit.event.entity.ItemDespawnEvent -->
  <class name="ItemDespawnEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ItemDespawnEvent" type="org.bukkit.entity.Item, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location at which the item is despawning.

 @return The location at which the item is despawning]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when a {@link org.bukkit.entity.Item} is removed from
 the world because it has existed for 5 minutes.
 <p>
 Cancelling the event results in the item being allowed to exist for 5 more
 minutes. This behavior is not guaranteed and may change in future versions.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.ItemDespawnEvent -->
  <!-- start class org.bukkit.event.entity.ItemMergeEvent -->
  <class name="ItemMergeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ItemMergeEvent" type="org.bukkit.entity.Item, org.bukkit.entity.Item"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTarget" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Item entity the main Item is being merged into.

 @return The Item being merged with]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.event.entity.ItemMergeEvent -->
  <!-- start class org.bukkit.event.entity.ItemSpawnEvent -->
  <class name="ItemSpawnEvent" extends="org.bukkit.event.entity.EntitySpawnEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ItemSpawnEvent" type="org.bukkit.entity.Item, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ItemSpawnEvent" type="org.bukkit.entity.Item"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an item is spawned into a world]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.ItemSpawnEvent -->
  <!-- start class org.bukkit.event.entity.LingeringPotionSplashEvent -->
  <class name="LingeringPotionSplashEvent" extends="org.bukkit.event.entity.ProjectileHitEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="LingeringPotionSplashEvent" type="org.bukkit.entity.ThrownPotion, org.bukkit.entity.AreaEffectCloud"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.ThrownPotion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAreaEffectCloud" return="org.bukkit.entity.AreaEffectCloud"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the AreaEffectCloud spawned

 @return The spawned AreaEffectCloud]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a splash potion hits an area]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.LingeringPotionSplashEvent -->
  <!-- start class org.bukkit.event.entity.PigZapEvent -->
  <class name="PigZapEvent" extends="com.destroystokyo.paper.event.entity.EntityZapEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PigZapEvent" type="org.bukkit.entity.Pig, org.bukkit.entity.LightningStrike, org.bukkit.entity.PigZombie"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Pig"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLightning" return="org.bukkit.entity.LightningStrike"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the bolt which is striking the pig.

 @return lightning entity]]>
      </doc>
    </method>
    <method name="getPigZombie" return="org.bukkit.entity.PigZombie"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link EntityTransformEvent#getTransformedEntity()}">
      <doc>
      <![CDATA[Gets the zombie pig that will replace the pig, provided the event is
 not cancelled first.

 @return resulting entity
 @deprecated use {@link EntityTransformEvent#getTransformedEntity()}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stores data for pigs being zapped]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.PigZapEvent -->
  <!-- start class org.bukkit.event.entity.PigZombieAngerEvent -->
  <class name="PigZombieAngerEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PigZombieAngerEvent" type="org.bukkit.entity.PigZombie, org.bukkit.entity.Entity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTarget" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity (if any) which triggered this anger update.

 @return triggering entity, or null]]>
      </doc>
    </method>
    <method name="getNewAnger" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new anger resulting from this event.

 @return new anger
 @see PigZombie#getAnger()]]>
      </doc>
    </method>
    <method name="setNewAnger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newAnger" type="int"/>
      <doc>
      <![CDATA[Sets the new anger resulting from this event.

 @param newAnger the new anger
 @see PigZombie#setAnger(int)]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.PigZombie"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a Pig Zombie is angered by another entity.
 <p>
 If the event is cancelled, the pig zombie will not be angered.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.PigZombieAngerEvent -->
  <!-- start class org.bukkit.event.entity.PlayerDeathEvent -->
  <class name="PlayerDeathEvent" extends="org.bukkit.event.entity.EntityDeathEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerDeathEvent" type="org.bukkit.entity.Player, java.util.List&lt;org.bukkit.inventory.ItemStack&gt;, int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerDeathEvent" type="org.bukkit.entity.Player, java.util.List&lt;org.bukkit.inventory.ItemStack&gt;, int, int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerDeathEvent" type="org.bukkit.entity.Player, java.util.List&lt;org.bukkit.inventory.ItemStack&gt;, int, int, int, int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerDeathEvent" type="org.bukkit.entity.Player, java.util.List&lt;org.bukkit.inventory.ItemStack&gt;, int, int, int, int, java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItemsToKeep" return="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A mutable collection to add items that the player should retain in their inventory on death (Similar to KeepInventory game rule)

 You <b>MUST</b> remove the item from the .getDrops() collection too or it will duplicate!
 <pre>{@code
    {@literal @EventHandler(ignoreCancelled = true)}
     public void onPlayerDeath(PlayerDeathEvent event) {
         for (Iterator<ItemStack> iterator = event.getDrops().iterator(); iterator.hasNext(); ) {
             ItemStack drop = iterator.next();
             List<String> lore = drop.getLore();
             if (lore != null && !lore.isEmpty()) {
                 if (lore.get(0).contains("(SOULBOUND)")) {
                     iterator.remove();
                     event.getItemsToKeep().add(drop);
                 }
             }
         }
     }
 }</pre>

 Adding an item to this list that the player did not previously have will give them the item on death.
 An example case could be a "Note" that "You died at X/Y/Z coordinates"

 @return The list to hold items to keep]]>
      </doc>
    </method>
    <method name="shouldDropExperience" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return should experience be dropped from this death]]>
      </doc>
    </method>
    <method name="setShouldDropExperience"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="doExpDrop" type="boolean"/>
      <doc>
      <![CDATA[@param doExpDrop sets if experience should be dropped from this death]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDeathMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deathMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the death message that will appear to everyone on the server.

 @param deathMessage Message to appear to other players on the server.]]>
      </doc>
    </method>
    <method name="getDeathMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the death message that will appear to everyone on the server.

 @return Message to appear to other players on the server.]]>
      </doc>
    </method>
    <method name="getNewExp" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets how much EXP the Player should have at respawn.
 <p>
 This does not indicate how much EXP should be dropped, please see
 {@link #getDroppedExp()} for that.

 @return New EXP of the respawned player]]>
      </doc>
    </method>
    <method name="setNewExp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exp" type="int"/>
      <doc>
      <![CDATA[Sets how much EXP the Player should have at respawn.
 <p>
 This does not indicate how much EXP should be dropped, please see
 {@link #setDroppedExp(int)} for that.

 @param exp New EXP of the respawned player]]>
      </doc>
    </method>
    <method name="getNewLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Level the Player should have at respawn.

 @return New Level of the respawned player]]>
      </doc>
    </method>
    <method name="setNewLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the Level the Player should have at respawn.

 @param level New Level of the respawned player]]>
      </doc>
    </method>
    <method name="getNewTotalExp" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Total EXP the Player should have at respawn.

 @return New Total EXP of the respawned player]]>
      </doc>
    </method>
    <method name="setNewTotalExp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="totalExp" type="int"/>
      <doc>
      <![CDATA[Sets the Total EXP the Player should have at respawn.

 @param totalExp New Total EXP of the respawned player]]>
      </doc>
    </method>
    <method name="getKeepLevel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the Player should keep all EXP at respawn.
 <p>
 This flag overrides other EXP settings

 @return True if Player should keep all pre-death exp]]>
      </doc>
    </method>
    <method name="setKeepLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keepLevel" type="boolean"/>
      <doc>
      <![CDATA[Sets if the Player should keep all EXP at respawn.
 <p>
 This overrides all other EXP settings
 <p>
 <b>This doesn't prevent prevent the EXP from dropping.
 {@link #setDroppedExp(int)} should be used stop the
 EXP from dropping.</b>

 @param keepLevel True to keep all current value levels]]>
      </doc>
    </method>
    <method name="setKeepInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keepInventory" type="boolean"/>
      <doc>
      <![CDATA[Sets if the Player keeps inventory on death.
 <p>
 <b>This doesn't prevent prevent the items from dropping.
 {@code getDrops().clear()} should be used stop the
 items from dropping.</b>

 @param keepInventory True to keep the inventory]]>
      </doc>
    </method>
    <method name="getKeepInventory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the Player keeps inventory on death.

 @return True if the player keeps inventory on death]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown whenever a {@link Player} dies]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.PlayerDeathEvent -->
  <!-- start class org.bukkit.event.entity.PlayerLeashEntityEvent -->
  <class name="PlayerLeashEntityEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerLeashEntityEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity, org.bukkit.entity.Player"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLeashHolder" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entity that is holding the leash.

 @return The leash holder]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entity being leashed.

 @return The entity]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player involved in this event

 @return Player who is involved in this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Called immediately prior to a creature being leashed by a player.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.PlayerLeashEntityEvent -->
  <!-- start class org.bukkit.event.entity.PotionSplashEvent -->
  <class name="PotionSplashEvent" extends="org.bukkit.event.entity.ProjectileHitEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PotionSplashEvent" type="org.bukkit.entity.ThrownPotion, java.util.Map&lt;org.bukkit.entity.LivingEntity, java.lang.Double&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.ThrownPotion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPotion" return="org.bukkit.entity.ThrownPotion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the potion which caused this event

 @return The thrown potion entity]]>
      </doc>
    </method>
    <method name="getAffectedEntities" return="java.util.Collection&lt;org.bukkit.entity.LivingEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves a list of all effected entities

 @return A fresh copy of the affected entity list]]>
      </doc>
    </method>
    <method name="getIntensity" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="org.bukkit.entity.LivingEntity"/>
      <doc>
      <![CDATA[Gets the intensity of the potion's effects for given entity; This
 depends on the distance to the impact center

 @param entity Which entity to get intensity for
 @return intensity relative to maximum effect; 0.0: not affected; 1.0:
     fully hit by potion effects]]>
      </doc>
    </method>
    <method name="setIntensity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="org.bukkit.entity.LivingEntity"/>
      <param name="intensity" type="double"/>
      <doc>
      <![CDATA[Overwrites the intensity for a given entity

 @param entity For which entity to define a new intensity
 @param intensity relative to maximum effect]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a splash potion hits an area]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.PotionSplashEvent -->
  <!-- start class org.bukkit.event.entity.ProjectileHitEvent -->
  <class name="ProjectileHitEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProjectileHitEvent" type="org.bukkit.entity.Projectile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProjectileHitEvent" type="org.bukkit.entity.Projectile, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProjectileHitEvent" type="org.bukkit.entity.Projectile, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProjectileHitEvent" type="org.bukkit.entity.Projectile, org.bukkit.entity.Entity, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProjectileHitEvent" type="org.bukkit.entity.Projectile, org.bukkit.entity.Entity, org.bukkit.block.Block, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Projectile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHitBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block that was hit, if it was a block that was hit.

 @return hit block or else null]]>
      </doc>
    </method>
    <method name="getHitBlockFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block face that was hit, if it was a block that was hit and the
 face was provided in the vent.

 @return hit face or else null]]>
      </doc>
    </method>
    <method name="getHitEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that was hit, if it was an entity that was hit.

 @return hit entity or else null]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a projectile hits an object]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.ProjectileHitEvent -->
  <!-- start class org.bukkit.event.entity.ProjectileLaunchEvent -->
  <class name="ProjectileLaunchEvent" extends="org.bukkit.event.entity.EntitySpawnEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ProjectileLaunchEvent" type="org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Projectile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a projectile is launched.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.ProjectileLaunchEvent -->
  <!-- start class org.bukkit.event.entity.SheepDyeWoolEvent -->
  <class name="SheepDyeWoolEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SheepDyeWoolEvent" type="org.bukkit.entity.Sheep, org.bukkit.DyeColor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Sheep"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getColor" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the DyeColor the sheep is being dyed

 @return the DyeColor the sheep is being dyed]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the DyeColor the sheep is being dyed

 @param color the DyeColor the sheep will be dyed]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a sheep's wool is dyed]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.SheepDyeWoolEvent -->
  <!-- start class org.bukkit.event.entity.SheepRegrowWoolEvent -->
  <class name="SheepRegrowWoolEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SheepRegrowWoolEvent" type="org.bukkit.entity.Sheep"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Sheep"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a sheep regrows its wool]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.SheepRegrowWoolEvent -->
  <!-- start class org.bukkit.event.entity.SlimeSplitEvent -->
  <class name="SlimeSplitEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="SlimeSplitEvent" type="org.bukkit.entity.Slime, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Slime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of smaller slimes to spawn

 @return the amount of slimes to spawn]]>
      </doc>
    </method>
    <method name="setCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Sets how many smaller slimes will spawn on the split

 @param count the amount of slimes to spawn]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a Slime splits into smaller Slimes upon death]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.SlimeSplitEvent -->
  <!-- start class org.bukkit.event.entity.SpawnerSpawnEvent -->
  <class name="SpawnerSpawnEvent" extends="org.bukkit.event.entity.EntitySpawnEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SpawnerSpawnEvent" type="org.bukkit.entity.Entity, org.bukkit.block.CreatureSpawner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSpawner" return="org.bukkit.block.CreatureSpawner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity is spawned into a world by a spawner.
 <p>
 If a Spawner Spawn event is cancelled, the entity will not spawn.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.SpawnerSpawnEvent -->
  <!-- start class org.bukkit.event.entity.StriderTemperatureChangeEvent -->
  <class name="StriderTemperatureChangeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StriderTemperatureChangeEvent" type="org.bukkit.entity.Strider, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Strider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShivering" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Strider's new shivering state.

 @return the new shivering state]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a {@link Strider}'s temperature has changed as a result of
 entering or existing blocks it considers warm.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.StriderTemperatureChangeEvent -->
  <!-- start class org.bukkit.event.entity.VillagerAcquireTradeEvent -->
  <class name="VillagerAcquireTradeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VillagerAcquireTradeEvent" type="org.bukkit.entity.AbstractVillager, org.bukkit.inventory.MerchantRecipe"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRecipe" return="org.bukkit.inventory.MerchantRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the recipe to be acquired.

 @return the new recipe]]>
      </doc>
    </method>
    <method name="setRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipe" type="org.bukkit.inventory.MerchantRecipe"/>
      <doc>
      <![CDATA[Set the recipe to be acquired.

 @param recipe the new recipe]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.AbstractVillager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called whenever a villager acquires a new trade.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.VillagerAcquireTradeEvent -->
  <!-- start class org.bukkit.event.entity.VillagerCareerChangeEvent -->
  <class name="VillagerCareerChangeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VillagerCareerChangeEvent" type="org.bukkit.entity.Villager, org.bukkit.entity.Villager.Profession, org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Villager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProfession" return="org.bukkit.entity.Villager.Profession"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the future profession of the villager.

 @return The profession the villager will change to]]>
      </doc>
    </method>
    <method name="setProfession"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profession" type="org.bukkit.entity.Villager.Profession"/>
      <doc>
      <![CDATA[Sets the profession the villager will become from this event.

 @param profession new profession]]>
      </doc>
    </method>
    <method name="getReason" return="org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason for why the villager's career is changing.

 @return Reason for villager's profession changing]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.event.entity.VillagerCareerChangeEvent -->
  <!-- start class org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason -->
  <class name="VillagerCareerChangeEvent.ChangeReason" extends="java.lang.Enum&lt;org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Reasons for the villager's profession changing.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason -->
  <!-- start class org.bukkit.event.entity.VillagerReplenishTradeEvent -->
  <class name="VillagerReplenishTradeEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VillagerReplenishTradeEvent" type="org.bukkit.entity.AbstractVillager, org.bukkit.inventory.MerchantRecipe, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRecipe" return="org.bukkit.inventory.MerchantRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the recipe to replenish.

 @return the replenished recipe]]>
      </doc>
    </method>
    <method name="setRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipe" type="org.bukkit.inventory.MerchantRecipe"/>
      <doc>
      <![CDATA[Set the recipe to replenish.

 @param recipe the replenished recipe]]>
      </doc>
    </method>
    <method name="getBonus" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the bonus uses added. The maximum uses of the recipe will be
 increased by this number.

 @return the extra uses added]]>
      </doc>
    </method>
    <method name="setBonus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bonus" type="int"/>
      <doc>
      <![CDATA[Set the bonus uses added.

 @param bonus the extra uses added
 @see VillagerReplenishTradeEvent#getBonus()]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.AbstractVillager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a villager's trade's maximum uses is increased, due to a player's
 trade.

 @see MerchantRecipe#getMaxUses()]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.entity.VillagerReplenishTradeEvent -->
</package>
<package name="org.bukkit.event.hanging">
  <!-- start class org.bukkit.event.hanging.HangingBreakByEntityEvent -->
  <class name="HangingBreakByEntityEvent" extends="org.bukkit.event.hanging.HangingBreakEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HangingBreakByEntityEvent" type="org.bukkit.entity.Hanging, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HangingBreakByEntityEvent" type="org.bukkit.entity.Hanging, org.bukkit.entity.Entity, org.bukkit.event.hanging.HangingBreakEvent.RemoveCause"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRemover" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that removed the hanging entity.
 May be null, for example when broken by an explosion.

 @return the entity that removed the hanging entity]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Triggered when a hanging entity is removed by an entity]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.hanging.HangingBreakByEntityEvent -->
  <!-- start class org.bukkit.event.hanging.HangingBreakEvent -->
  <class name="HangingBreakEvent" extends="org.bukkit.event.hanging.HangingEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="HangingBreakEvent" type="org.bukkit.entity.Hanging, org.bukkit.event.hanging.HangingBreakEvent.RemoveCause"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCause" return="org.bukkit.event.hanging.HangingBreakEvent.RemoveCause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cause for the hanging entity's removal

 @return the RemoveCause for the hanging entity's removal]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Triggered when a hanging entity is removed]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.hanging.HangingBreakEvent -->
  <!-- start class org.bukkit.event.hanging.HangingBreakEvent.RemoveCause -->
  <class name="HangingBreakEvent.RemoveCause" extends="java.lang.Enum&lt;org.bukkit.event.hanging.HangingBreakEvent.RemoveCause&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.hanging.HangingBreakEvent.RemoveCause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.hanging.HangingBreakEvent.RemoveCause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the cause of the removal]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.hanging.HangingBreakEvent.RemoveCause -->
  <!-- start class org.bukkit.event.hanging.HangingEvent -->
  <class name="HangingEvent" extends="org.bukkit.event.Event"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HangingEvent" type="org.bukkit.entity.Hanging"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Hanging"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the hanging entity involved in this event.

 @return the hanging entity]]>
      </doc>
    </method>
    <field name="hanging" type="org.bukkit.entity.Hanging"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a hanging entity-related event.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.hanging.HangingEvent -->
  <!-- start class org.bukkit.event.hanging.HangingPlaceEvent -->
  <class name="HangingPlaceEvent" extends="org.bukkit.event.hanging.HangingEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="HangingPlaceEvent" type="org.bukkit.entity.Hanging, org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player placing the hanging entity

 @return the player placing the hanging entity]]>
      </doc>
    </method>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the block that the hanging entity was placed on

 @return the block that the hanging entity was placed on]]>
      </doc>
    </method>
    <method name="getBlockFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the face of the block that the hanging entity was placed on

 @return the face of the block that the hanging entity was placed on]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Triggered when a hanging entity is created in the world]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.hanging.HangingPlaceEvent -->
</package>
<package name="org.bukkit.event.inventory">
  <!-- start class org.bukkit.event.inventory.BrewEvent -->
  <class name="BrewEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BrewEvent" type="org.bukkit.block.Block, org.bukkit.inventory.BrewerInventory, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContents" return="org.bukkit.inventory.BrewerInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the contents of the Brewing Stand.

 @return the contents]]>
      </doc>
    </method>
    <method name="getFuelLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the remaining fuel level.

 @return the remaining fuel]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the brewing of the contents inside the Brewing Stand is
 complete.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.BrewEvent -->
  <!-- start class org.bukkit.event.inventory.BrewingStandFuelEvent -->
  <class name="BrewingStandFuelEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BrewingStandFuelEvent" type="org.bukkit.block.Block, org.bukkit.inventory.ItemStack, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFuel" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ItemStack of the fuel before the amount was subtracted.

 @return the fuel ItemStack]]>
      </doc>
    </method>
    <method name="getFuelPower" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the fuel power for this fuel. Each unit of power can fuel one
 brewing operation.

 @return the fuel power for this fuel]]>
      </doc>
    </method>
    <method name="setFuelPower"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fuelPower" type="int"/>
      <doc>
      <![CDATA[Sets the fuel power for this fuel. Each unit of power can fuel one
 brewing operation.

 @param fuelPower the fuel power for this fuel]]>
      </doc>
    </method>
    <method name="isConsuming" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the brewing stand's fuel will be reduced / consumed or not.

 @return whether the fuel will be reduced or not]]>
      </doc>
    </method>
    <method name="setConsuming"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consuming" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the brewing stand's fuel will be reduced / consumed or not.

 @param consuming whether the fuel will be reduced or not]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an ItemStack is about to increase the fuel level of a brewing
 stand.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.BrewingStandFuelEvent -->
  <!-- start class org.bukkit.event.inventory.ClickType -->
  <class name="ClickType" extends="java.lang.Enum&lt;org.bukkit.event.inventory.ClickType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.inventory.ClickType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.inventory.ClickType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="isKeyboardClick" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ClickType represents the pressing of a key on a
 keyboard.

 @return true if this ClickType represents the pressing of a key]]>
      </doc>
    </method>
    <method name="isCreativeAction" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ClickType represents an action that can only be
 performed by a Player in creative mode.

 @return true if this action requires Creative mode]]>
      </doc>
    </method>
    <method name="isRightClick" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ClickType represents a right click.

 @return true if this ClickType represents a right click]]>
      </doc>
    </method>
    <method name="isLeftClick" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ClickType represents a left click.

 @return true if this ClickType represents a left click]]>
      </doc>
    </method>
    <method name="isShiftClick" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this ClickType indicates that the shift key was pressed
 down when the click was made.

 @return true if the action uses Shift.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[What the client did to trigger this action (not the result).]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.ClickType -->
  <!-- start class org.bukkit.event.inventory.CraftItemEvent -->
  <class name="CraftItemEvent" extends="org.bukkit.event.inventory.InventoryClickEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CraftItemEvent" type="org.bukkit.inventory.Recipe, org.bukkit.inventory.InventoryView, org.bukkit.event.inventory.InventoryType.SlotType, int, org.bukkit.event.inventory.ClickType, org.bukkit.event.inventory.InventoryAction"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CraftItemEvent" type="org.bukkit.inventory.Recipe, org.bukkit.inventory.InventoryView, org.bukkit.event.inventory.InventoryType.SlotType, int, org.bukkit.event.inventory.ClickType, org.bukkit.event.inventory.InventoryAction, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRecipe" return="org.bukkit.inventory.Recipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return A copy of the current recipe on the crafting matrix.]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.CraftingInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the recipe of an Item is completed inside a crafting matrix.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.CraftItemEvent -->
  <!-- start class org.bukkit.event.inventory.DragType -->
  <class name="DragType" extends="java.lang.Enum&lt;org.bukkit.event.inventory.DragType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.inventory.DragType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.inventory.DragType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the effect of a drag that will be applied to an Inventory in an
 InventoryDragEvent.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.DragType -->
  <!-- start class org.bukkit.event.inventory.FurnaceBurnEvent -->
  <class name="FurnaceBurnEvent" extends="org.bukkit.event.block.BlockEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="FurnaceBurnEvent" type="org.bukkit.block.Block, org.bukkit.inventory.ItemStack, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFuel" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the fuel ItemStack for this event

 @return the fuel ItemStack]]>
      </doc>
    </method>
    <method name="getBurnTime" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the burn time for this fuel

 @return the burn time for this fuel]]>
      </doc>
    </method>
    <method name="setBurnTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="burnTime" type="int"/>
      <doc>
      <![CDATA[Sets the burn time for this fuel

 @param burnTime the burn time for this fuel]]>
      </doc>
    </method>
    <method name="isBurning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the furnace's fuel is burning or not.

 @return whether the furnace's fuel is burning or not.]]>
      </doc>
    </method>
    <method name="setBurning"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="burning" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the furnace's fuel is burning or not.

 @param burning true if the furnace's fuel is burning]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an ItemStack is successfully burned as fuel in a furnace.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.FurnaceBurnEvent -->
  <!-- start class org.bukkit.event.inventory.FurnaceExtractEvent -->
  <class name="FurnaceExtractEvent" extends="org.bukkit.event.block.BlockExpEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FurnaceExtractEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.Material, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the player that triggered the event

 @return the relevant player]]>
      </doc>
    </method>
    <method name="getItemType" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Material of the item being retrieved

 @return the material of the item]]>
      </doc>
    </method>
    <method name="getItemAmount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the item count being retrieved

 @return the amount of the item]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This event is called when a player takes items out of the furnace]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.FurnaceExtractEvent -->
  <!-- start class org.bukkit.event.inventory.FurnaceSmeltEvent -->
  <class name="FurnaceSmeltEvent" extends="org.bukkit.event.block.BlockCookEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FurnaceSmeltEvent" type="org.bukkit.block.Block, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Called when an ItemStack is successfully smelted in a furnace.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.FurnaceSmeltEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryAction -->
  <class name="InventoryAction" extends="java.lang.Enum&lt;org.bukkit.event.inventory.InventoryAction&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.inventory.InventoryAction[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.inventory.InventoryAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An estimation of what the result will be.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryAction -->
  <!-- start class org.bukkit.event.inventory.InventoryClickEvent -->
  <class name="InventoryClickEvent" extends="org.bukkit.event.inventory.InventoryInteractEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InventoryClickEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.event.inventory.InventoryType.SlotType, int, org.bukkit.event.inventory.ClickType, org.bukkit.event.inventory.InventoryAction"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="InventoryClickEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.event.inventory.InventoryType.SlotType, int, org.bukkit.event.inventory.ClickType, org.bukkit.event.inventory.InventoryAction, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSlotType" return="org.bukkit.event.inventory.InventoryType.SlotType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of slot that was clicked.

 @return the slot type]]>
      </doc>
    </method>
    <method name="getCursor" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current ItemStack on the cursor.

 @return the cursor ItemStack]]>
      </doc>
    </method>
    <method name="getCurrentItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ItemStack currently in the clicked slot.

 @return the item in the clicked]]>
      </doc>
    </method>
    <method name="isRightClick" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the ClickType for this event represents a right
 click.

 @return true if the ClickType uses the right mouse button.
 @see ClickType#isRightClick()]]>
      </doc>
    </method>
    <method name="isLeftClick" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the ClickType for this event represents a left
 click.

 @return true if the ClickType uses the left mouse button.
 @see ClickType#isLeftClick()]]>
      </doc>
    </method>
    <method name="isShiftClick" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the ClickType for this event indicates that the key was
 pressed down when the click was made.

 @return true if the ClickType uses Shift or Ctrl.
 @see ClickType#isShiftClick()]]>
      </doc>
    </method>
    <method name="setCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This changes the ItemStack in their hand before any
     calculations are applied to the Inventory, which has a tendency to
     create inconsistencies between the Player and the server, and to
     make unexpected changes in the behavior of the clicked Inventory.">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item on the cursor.

 @param stack the new cursor item
 @deprecated This changes the ItemStack in their hand before any
     calculations are applied to the Inventory, which has a tendency to
     create inconsistencies between the Player and the server, and to
     make unexpected changes in the behavior of the clicked Inventory.]]>
      </doc>
    </method>
    <method name="setCurrentItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the ItemStack currently in the clicked slot.

 @param stack the item to be placed in the current slot]]>
      </doc>
    </method>
    <method name="getClickedInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the inventory corresponding to the clicked slot.

 @see InventoryView#getInventory(int)
 @return inventory, or null if clicked outside]]>
      </doc>
    </method>
    <method name="getSlot" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The slot number that was clicked, ready for passing to
 {@link Inventory#getItem(int)}. Note that there may be two slots with
 the same slot number, since a view links two different inventories.

 @return The slot number.]]>
      </doc>
    </method>
    <method name="getRawSlot" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The raw slot number clicked, ready for passing to {@link InventoryView
 #getItem(int)} This slot number is unique for the view.

 @return the slot number]]>
      </doc>
    </method>
    <method name="getHotbarButton" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the ClickType is NUMBER_KEY, this method will return the index of
 the pressed key (0-8).

 @return the number on the key minus 1 (range 0-8); or -1 if not
     a NUMBER_KEY action]]>
      </doc>
    </method>
    <method name="getAction" return="org.bukkit.event.inventory.InventoryAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the InventoryAction that triggered this event.
 <p>
 This action cannot be changed, and represents what the normal outcome
 of the event will be. To change the behavior of this
 InventoryClickEvent, changes must be manually applied.

 @return the InventoryAction that triggered this event.]]>
      </doc>
    </method>
    <method name="getClick" return="org.bukkit.event.inventory.ClickType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ClickType for this event.
 <p>
 This is insulated against changes to the inventory by other plugins.

 @return the type of inventory click]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when a player clicks a slot in an inventory.
 <p>
 Because InventoryClickEvent occurs within a modification of the Inventory,
 not all Inventory related methods are safe to use.
 <p>
 The following should never be invoked by an EventHandler for
 InventoryClickEvent using the HumanEntity or InventoryView associated with
 this event:
 <ul>
 <li>{@link HumanEntity#closeInventory()}
 <li>{@link HumanEntity#openInventory(Inventory)}
 <li>{@link HumanEntity#openWorkbench(Location, boolean)}
 <li>{@link HumanEntity#openEnchanting(Location, boolean)}
 <li>{@link InventoryView#close()}
 </ul>
 To invoke one of these methods, schedule a task using
 {@link BukkitScheduler#runTask(Plugin, Runnable)}, which will run the task
 on the next tick. Also be aware that this is not an exhaustive list, and
 other methods could potentially create issues as well.
 <p>
 Assuming the EntityHuman associated with this event is an instance of a
 Player, manipulating the MaxStackSize or contents of an Inventory will
 require an Invocation of {@link Player#updateInventory()}.
 <p>
 Modifications to slots that are modified by the results of this
 InventoryClickEvent can be overwritten. To change these slots, this event
 should be cancelled and all desired changes to the inventory applied.
 Alternatively, scheduling a task using {@link BukkitScheduler#runTask(
 Plugin, Runnable)}, which would execute the task on the next tick, would
 work as well.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryClickEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryCloseEvent -->
  <class name="InventoryCloseEvent" extends="org.bukkit.event.inventory.InventoryEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InventoryCloseEvent" type="org.bukkit.inventory.InventoryView"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="InventoryCloseEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.event.inventory.InventoryCloseEvent.Reason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getReason" return="org.bukkit.event.inventory.InventoryCloseEvent.Reason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPlayer" return="org.bukkit.entity.HumanEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player involved in this event

 @return Player who is involved in this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a player related inventory event]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryCloseEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryCloseEvent.Reason -->
  <class name="InventoryCloseEvent.Reason" extends="java.lang.Enum&lt;org.bukkit.event.inventory.InventoryCloseEvent.Reason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.inventory.InventoryCloseEvent.Reason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.inventory.InventoryCloseEvent.Reason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryCloseEvent.Reason -->
  <!-- start class org.bukkit.event.inventory.InventoryCreativeEvent -->
  <class name="InventoryCreativeEvent" extends="org.bukkit.event.inventory.InventoryClickEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InventoryCreativeEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.event.inventory.InventoryType.SlotType, int, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCursor" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <doc>
    <![CDATA[This event is called when a player in creative mode puts down or picks up
 an item in their inventory / hotbar and when they drop items from their
 Inventory while in creative mode.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryCreativeEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryDragEvent -->
  <class name="InventoryDragEvent" extends="org.bukkit.event.inventory.InventoryInteractEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InventoryDragEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack, boolean, java.util.Map&lt;java.lang.Integer, org.bukkit.inventory.ItemStack&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewItems" return="java.util.Map&lt;java.lang.Integer, org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all items to be added to the inventory in this drag.

 @return map from raw slot id to new ItemStack]]>
      </doc>
    </method>
    <method name="getRawSlots" return="java.util.Set&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the raw slot ids to be changed in this drag.

 @return list of raw slot ids, suitable for getView().getItem(int)]]>
      </doc>
    </method>
    <method name="getInventorySlots" return="java.util.Set&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the slots to be changed in this drag.

 @return list of converted slot ids, suitable for {@link
     org.bukkit.inventory.Inventory#getItem(int)}.]]>
      </doc>
    </method>
    <method name="getCursor" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the result cursor after the drag is done. The returned value is
 mutable.

 @return the result cursor]]>
      </doc>
    </method>
    <method name="setCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newCursor" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the result cursor after the drag is done.
 <p>
 Changing this item stack changes the cursor item. Note that changing
 the affected "dragged" slots does not change this ItemStack, nor does
 changing this ItemStack affect the "dragged" slots.

 @param newCursor the new cursor ItemStack]]>
      </doc>
    </method>
    <method name="getOldCursor" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an ItemStack representing the cursor prior to any modifications
 as a result of this drag.

 @return the original cursor]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.event.inventory.DragType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the DragType that describes the behavior of ItemStacks placed
 after this InventoryDragEvent.
 <p>
 The ItemStacks and the raw slots that they're being applied to can be
 found using {@link #getNewItems()}.

 @return the DragType of this InventoryDragEvent]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when the player drags an item in their cursor across
 the inventory. The ItemStack is distributed across the slots the
 HumanEntity dragged over. The method of distribution is described by the
 DragType returned by {@link #getType()}.
 <p>
 Canceling this event will result in none of the changes described in
 {@link #getNewItems()} being applied to the Inventory.
 <p>
 Because InventoryDragEvent occurs within a modification of the Inventory,
 not all Inventory related methods are safe to use.
 <p>
 The following should never be invoked by an EventHandler for
 InventoryDragEvent using the HumanEntity or InventoryView associated with
 this event.
 <ul>
 <li>{@link HumanEntity#closeInventory()}
 <li>{@link HumanEntity#openInventory(Inventory)}
 <li>{@link HumanEntity#openWorkbench(Location, boolean)}
 <li>{@link HumanEntity#openEnchanting(Location, boolean)}
 <li>{@link InventoryView#close()}
 </ul>
 To invoke one of these methods, schedule a task using
 {@link BukkitScheduler#runTask(Plugin, Runnable)}, which will run the task
 on the next tick.  Also be aware that this is not an exhaustive list, and
 other methods could potentially create issues as well.
 <p>
 Assuming the EntityHuman associated with this event is an instance of a
 Player, manipulating the MaxStackSize or contents of an Inventory will
 require an Invocation of {@link Player#updateInventory()}.
 <p>
 Any modifications to slots that are modified by the results of this
 InventoryDragEvent will be overwritten. To change these slots, this event
 should be cancelled and the changes applied. Alternatively, scheduling a
 task using {@link BukkitScheduler#runTask(Plugin, Runnable)}, which would
 execute the task on the next tick, would work as well.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryDragEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryEvent -->
  <class name="InventoryEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InventoryEvent" type="org.bukkit.inventory.InventoryView"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the primary Inventory involved in this transaction

 @return The upper inventory.]]>
      </doc>
    </method>
    <method name="getViewers" return="java.util.List&lt;org.bukkit.entity.HumanEntity&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the list of players viewing the primary (upper) inventory involved
 in this event

 @return A list of people viewing.]]>
      </doc>
    </method>
    <method name="getView" return="org.bukkit.inventory.InventoryView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the view object itself

 @return InventoryView]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="transaction" type="org.bukkit.inventory.InventoryView"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a player related inventory event]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryInteractEvent -->
  <class name="InventoryInteractEvent" extends="org.bukkit.event.inventory.InventoryEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="InventoryInteractEvent" type="org.bukkit.inventory.InventoryView"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getWhoClicked" return="org.bukkit.entity.HumanEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player who performed the click.

 @return The clicking player.]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newResult" type="org.bukkit.event.Event.Result"/>
      <doc>
      <![CDATA[Sets the result of this event. This will change whether or not this
 event is considered cancelled.

 @param newResult the new {@link org.bukkit.event.Event.Result} for this event
 @see #isCancelled()]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.event.Event.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link org.bukkit.event.Event.Result} of this event. The Result describes the
 behavior that will be applied to the inventory in relation to this
 event.

 @return the Result of this event.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not this event is cancelled. This is based off of the
 Result value returned by {@link #getResult()}.  Result.ALLOW and
 Result.DEFAULT will result in a returned value of false, but
 Result.DENY will result in a returned value of true.
 <p>
 {@inheritDoc}

 @return whether the event is cancelled]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toCancel" type="boolean"/>
      <doc>
      <![CDATA[Proxy method to {@link #setResult(org.bukkit.event.Event.Result)} for the Cancellable
 interface. {@link #setResult(org.bukkit.event.Event.Result)} is preferred, as it allows
 you to specify the Result beyond Result.DENY and Result.ALLOW.
 <p>
 {@inheritDoc}

 @param toCancel result becomes DENY if true, ALLOW if false]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract base class for events that describe an interaction between a
 HumanEntity and the contents of an Inventory.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryInteractEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryMoveItemEvent -->
  <class name="InventoryMoveItemEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="InventoryMoveItemEvent" type="org.bukkit.inventory.Inventory, org.bukkit.inventory.ItemStack, org.bukkit.inventory.Inventory, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Inventory that the ItemStack is being taken from

 @return Inventory that the ItemStack is being taken from]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ItemStack being moved; if modified, the original item will not
 be removed from the source inventory.

 @return ItemStack]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the ItemStack being moved; if this is different from the original
 ItemStack, the original item will not be removed from the source
 inventory.

 @param itemStack The ItemStack]]>
      </doc>
    </method>
    <method name="getDestination" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Inventory that the ItemStack is being put into

 @return Inventory that the ItemStack is being put into]]>
      </doc>
    </method>
    <method name="getInitiator" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Inventory that initiated the transfer. This will always be
 either the destination or source Inventory.

 @return Inventory that initiated the transfer]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="calledGetItem" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="calledSetItem" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Called when some entity or block (e.g. hopper) tries to move items directly
 from one inventory to another.
 <p>
 When this event is called, the initiator may already have removed the item
 from the source inventory and is ready to move it into the destination
 inventory.
 <p>
 If this event is cancelled, the items will be returned to the source
 inventory, if needed.
 <p>
 If this event is not cancelled, the initiator will try to put the ItemStack
 into the destination inventory. If this is not possible and the ItemStack
 has not been modified, the source inventory slot will be restored to its
 former state. Otherwise any additional items will be discarded.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryMoveItemEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryOpenEvent -->
  <class name="InventoryOpenEvent" extends="org.bukkit.event.inventory.InventoryEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="InventoryOpenEvent" type="org.bukkit.inventory.InventoryView"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.HumanEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player involved in this event

 @return Player who is involved in this event]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins.
 <p>
 If an inventory open event is cancelled, the inventory screen will not
 show.

 @return true if this event is cancelled]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Sets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins.
 <p>
 If an inventory open event is cancelled, the inventory screen will not
 show.

 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a player related inventory event]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryOpenEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryPickupItemEvent -->
  <class name="InventoryPickupItemEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="InventoryPickupItemEvent" type="org.bukkit.inventory.Inventory, org.bukkit.entity.Item"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Inventory that picked up the item

 @return Inventory]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Item entity that was picked up

 @return Item]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a hopper or hopper minecart picks up a dropped item.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryPickupItemEvent -->
  <!-- start class org.bukkit.event.inventory.InventoryType -->
  <class name="InventoryType" extends="java.lang.Enum&lt;org.bukkit.event.inventory.InventoryType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.inventory.InventoryType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.inventory.InventoryType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getDefaultSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultTitle" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCreatable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Denotes that this InventoryType can be created via the normal
 {@link org.bukkit.Bukkit#createInventory} methods.

 @return if this InventoryType can be created and shown to a player]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the different kinds of inventories available in Bukkit.
 <br>
 Only InventoryTypes marked {@link #isCreatable()} can be created.
 <br>
 The current list of inventories that cannot be created via
 {@link org.bukkit.Bukkit#createInventory} are:<br>
 <blockquote>
     {@link InventoryType#CREATIVE}, {@link InventoryType#CRAFTING} and
     {@link InventoryType#MERCHANT}
 </blockquote>

 See {@link org.bukkit.Bukkit#createInventory} for more information.

 @see org.bukkit.Bukkit#createInventory(InventoryHolder, InventoryType)]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryType -->
  <!-- start class org.bukkit.event.inventory.InventoryType.SlotType -->
  <class name="InventoryType.SlotType" extends="java.lang.Enum&lt;org.bukkit.event.inventory.InventoryType.SlotType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.inventory.InventoryType.SlotType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.inventory.InventoryType.SlotType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.inventory.InventoryType.SlotType -->
  <!-- start class org.bukkit.event.inventory.PrepareAnvilEvent -->
  <class name="PrepareAnvilEvent" extends="com.destroystokyo.paper.event.inventory.PrepareResultEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PrepareAnvilEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInventory" return="org.bukkit.inventory.AnvilInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get result item, may be null.

 @return result item]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <doc>
    <![CDATA[Called when an item is put in a slot for repair by an anvil.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.PrepareAnvilEvent -->
  <!-- start class org.bukkit.event.inventory.PrepareItemCraftEvent -->
  <class name="PrepareItemCraftEvent" extends="org.bukkit.event.inventory.InventoryEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PrepareItemCraftEvent" type="org.bukkit.inventory.CraftingInventory, org.bukkit.inventory.InventoryView, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRecipe" return="org.bukkit.inventory.Recipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the recipe that has been formed. If this event was triggered by a
 tool repair, this will be a temporary shapeless recipe representing the
 repair.

 @return The recipe being crafted.]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.CraftingInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The crafting inventory on which the recipe was formed.]]>
      </doc>
    </method>
    <method name="isRepair" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this event was triggered by a tool repair operation rather
 than a crafting recipe.

 @return True if this is a repair.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.event.inventory.PrepareItemCraftEvent -->
  <!-- start class org.bukkit.event.inventory.PrepareSmithingEvent -->
  <class name="PrepareSmithingEvent" extends="com.destroystokyo.paper.event.inventory.PrepareResultEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PrepareSmithingEvent" type="org.bukkit.inventory.InventoryView, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInventory" return="org.bukkit.inventory.SmithingInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get result item, may be null.

 @return result item]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <doc>
    <![CDATA[Called when an item is put in a slot for upgrade by a Smithing Table.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.PrepareSmithingEvent -->
  <!-- start class org.bukkit.event.inventory.TradeSelectEvent -->
  <class name="TradeSelectEvent" extends="org.bukkit.event.inventory.InventoryInteractEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TradeSelectEvent" type="org.bukkit.inventory.InventoryView, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used to get the index of the trade the player clicked on.

 @return The index of the trade clicked by the player]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.MerchantInventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMerchant" return="org.bukkit.inventory.Merchant"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Merchant involved.

 @return the Merchant]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called whenever a player clicks a new trade on the trades
 sidebar.
 <p>
 This event allows the user to get the index of the trade, letting them get
 the MerchantRecipe via the Merchant.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.inventory.TradeSelectEvent -->
</package>
<package name="org.bukkit.event.player">
  <!-- start class org.bukkit.event.player.AsyncPlayerChatEvent -->
  <class name="AsyncPlayerChatEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="AsyncPlayerChatEvent" type="boolean, org.bukkit.entity.Player, java.lang.String, java.util.Set&lt;org.bukkit.entity.Player&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param async This changes the event to a synchronous state.
 @param who the chat sender
 @param message the message sent
 @param players the players to receive the message. This may be a lazy
     or unmodifiable collection.]]>
      </doc>
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the message that the player is attempting to send. This message
 will be used with {@link #getFormat()}.

 @return Message the player is attempting to send]]>
      </doc>
    </method>
    <method name="setMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the message that the player will send. This message will be used
 with {@link #getFormat()}.

 @param message New message that the player will send]]>
      </doc>
    </method>
    <method name="getFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the format to use to display this chat message.
 <p>
 When this event finishes execution, the first format parameter is the
 {@link Player#getDisplayName()} and the second parameter is {@link
 #getMessage()}

 @return {@link String#format(String, Object...)} compatible format
     string]]>
      </doc>
    </method>
    <method name="setFormat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <exception name="IllegalFormatException" type="java.util.IllegalFormatException"/>
      <exception name="NullPointerException" type="java.lang.NullPointerException"/>
      <doc>
      <![CDATA[Sets the format to use to display this chat message.
 <p>
 When this event finishes execution, the first format parameter is the
 {@link Player#getDisplayName()} and the second parameter is {@link
 #getMessage()}

 @param format {@link String#format(String, Object...)} compatible
     format string
 @throws IllegalFormatException if the underlying API throws the
     exception
 @throws NullPointerException if format is null
 @see String#format(String, Object...)]]>
      </doc>
    </method>
    <method name="getRecipients" return="java.util.Set&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set of recipients that this chat message will be displayed to.
 <p>
 The set returned is not guaranteed to be mutable and may auto-populate
 on access. Any listener accessing the returned set should be aware that
 it may reduce performance for a lazy set implementation.
 <p>
 Listeners should be aware that modifying the list may throw {@link
 UnsupportedOperationException} if the event caller provides an
 unmodifiable set.

 @return All Players who will see this chat message]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event will sometimes fire synchronously, depending on how it was
 triggered.
 <p>
 The constructor provides a boolean to indicate if the event was fired
 synchronously or asynchronously. When asynchronous, this event can be
 called from any thread, sans the main thread, and has limited access to the
 API.
 <p>
 If a player is the direct cause of this event by an incoming packet, this
 event will be asynchronous. If a plugin triggers this event by compelling a
 player to chat, this event will be synchronous.
 <p>
 Care should be taken to check {@link #isAsynchronous()} and treat the event
 appropriately.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.AsyncPlayerChatEvent -->
  <!-- start class org.bukkit.event.player.AsyncPlayerPreLoginEvent -->
  <class name="AsyncPlayerPreLoginEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AsyncPlayerPreLoginEvent" type="java.lang.String, java.net.InetAddress"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AsyncPlayerPreLoginEvent" type="java.lang.String, java.net.InetAddress, java.util.UUID"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AsyncPlayerPreLoginEvent" type="java.lang.String, java.net.InetAddress, java.util.UUID, com.destroystokyo.paper.profile.PlayerProfile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayerProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the PlayerProfile of the player logging in
 @return The Profile]]>
      </doc>
    </method>
    <method name="setPlayerProfile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profile" type="com.destroystokyo.paper.profile.PlayerProfile"/>
    </method>
    <method name="getLoginResult" return="org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current result of the login, as an enum

 @return Current Result of the login]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.event.player.PlayerPreLoginEvent.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method uses a deprecated enum from {@link
     PlayerPreLoginEvent}">
      <doc>
      <![CDATA[Gets the current result of the login, as an enum

 @return Current Result of the login
 @deprecated This method uses a deprecated enum from {@link
     PlayerPreLoginEvent}
 @see #getLoginResult()]]>
      </doc>
    </method>
    <method name="setLoginResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result"/>
      <doc>
      <![CDATA[Sets the new result of the login, as an enum

 @param result New result to set]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method uses a deprecated enum from {@link
     PlayerPreLoginEvent}">
      <param name="result" type="org.bukkit.event.player.PlayerPreLoginEvent.Result"/>
      <doc>
      <![CDATA[Sets the new result of the login, as an enum

 @param result New result to set
 @deprecated This method uses a deprecated enum from {@link
     PlayerPreLoginEvent}
 @see #setLoginResult(Result)]]>
      </doc>
    </method>
    <method name="getKickMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current kick message that will be used if getResult() !=
 Result.ALLOWED

 @return Current kick message]]>
      </doc>
    </method>
    <method name="setKickMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the kick message to display if getResult() != Result.ALLOWED

 @param message New kick message]]>
      </doc>
    </method>
    <method name="allow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows the player to log in]]>
      </doc>
    </method>
    <method name="disallow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result"/>
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Disallows the player from logging in, with the given reason

 @param result New result for disallowing the player
 @param message Kick message to display to the user]]>
      </doc>
    </method>
    <method name="disallow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method uses a deprecated enum from {@link
     PlayerPreLoginEvent}">
      <param name="result" type="org.bukkit.event.player.PlayerPreLoginEvent.Result"/>
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Disallows the player from logging in, with the given reason

 @param result New result for disallowing the player
 @param message Kick message to display to the user
 @deprecated This method uses a deprecated enum from {@link
     PlayerPreLoginEvent}
 @see #disallow(Result, String)]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player's name.

 @return the player's name]]>
      </doc>
    </method>
    <method name="getAddress" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player IP address.

 @return The IP address]]>
      </doc>
    </method>
    <method name="getUniqueId" return="java.util.UUID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player's unique ID.

 @return The unique ID]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Stores details for players attempting to log in.
 <p>
 This event is asynchronous, and not run using main thread.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.AsyncPlayerPreLoginEvent -->
  <!-- start class org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result -->
  <class name="AsyncPlayerPreLoginEvent.Result" extends="java.lang.Enum&lt;org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Basic kick reasons for communicating to plugins]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result -->
  <!-- start class org.bukkit.event.player.PlayerAdvancementDoneEvent -->
  <class name="PlayerAdvancementDoneEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerAdvancementDoneEvent" type="org.bukkit.entity.Player, org.bukkit.advancement.Advancement"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAdvancement" return="org.bukkit.advancement.Advancement"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the advancement which has been completed.

 @return completed advancement]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player has completed all criteria in an advancement.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerAdvancementDoneEvent -->
  <!-- start class org.bukkit.event.player.PlayerAnimationEvent -->
  <class name="PlayerAnimationEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerAnimationEvent" type="org.bukkit.entity.Player"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new PlayerAnimation event

 @param player The player instance]]>
      </doc>
    </constructor>
    <method name="getAnimationType" return="org.bukkit.event.player.PlayerAnimationType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of this animation event

 @return the animation type]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a player animation event]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerAnimationEvent -->
  <!-- start class org.bukkit.event.player.PlayerAnimationType -->
  <class name="PlayerAnimationType" extends="java.lang.Enum&lt;org.bukkit.event.player.PlayerAnimationType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.player.PlayerAnimationType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.player.PlayerAnimationType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Different types of player animations]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerAnimationType -->
  <!-- start class org.bukkit.event.player.PlayerArmorStandManipulateEvent -->
  <class name="PlayerArmorStandManipulateEvent" extends="org.bukkit.event.player.PlayerInteractEntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerArmorStandManipulateEvent" type="org.bukkit.entity.Player, org.bukkit.entity.ArmorStand, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayerItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the item held by the player. If this Item is null and the armor stand Item is also null,
 there will be no transaction between the player and the armor stand.
 If the Player's item is null, but the armor stand item is not then the player will obtain the armor stand item.
 In the case that the Player's item is not null, but the armor stand item is null, the players item will be placed on the armor stand.
 If both items are not null, the items will be swapped.
 In the case that the event is cancelled the original items will remain the same.
 @return the item held by the player.]]>
      </doc>
    </method>
    <method name="getArmorStandItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the item held by the armor stand.
 If this Item is null and the player's Item is also null, there will be no transaction between the player and the armor stand.
 If the Player's item is null, but the armor stand item is not then the player will obtain the armor stand item.
 In the case that the Player's item is not null, but the armor stand item is null, the players item will be placed on the armor stand.
 If both items are not null, the items will be swapped.
 In the case that the event is cancelled the original items will remain the same.
 @return the item held by the armor stand.]]>
      </doc>
    </method>
    <method name="getSlot" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw item slot of the armor stand in this event.

 @return the index of the item obtained or placed of the armor stand.]]>
      </doc>
    </method>
    <method name="getRightClicked" return="org.bukkit.entity.ArmorStand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player interacts with an armor stand and will either swap, retrieve or place an item.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerArmorStandManipulateEvent -->
  <!-- start class org.bukkit.event.player.PlayerAttemptPickupItemEvent -->
  <class name="PlayerAttemptPickupItemEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerAttemptPickupItemEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Item"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerAttemptPickupItemEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Item, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItem" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Item attempted by the player.

 @return Item]]>
      </doc>
    </method>
    <method name="getRemaining" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount that will remain on the ground, if any

 @return amount that will remain on the ground]]>
      </doc>
    </method>
    <method name="setFlyAtPlayer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flyAtPlayer" type="boolean"/>
      <doc>
      <![CDATA[Set if the item will fly at the player
 <p>Cancelling the event will set this value to false.</p>

 @param flyAtPlayer True for item to fly at player]]>
      </doc>
    </method>
    <method name="getFlyAtPlayer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the item will fly at the player

 @return True if the item will fly at the player]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a player attempts to pick an item up from the ground]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerAttemptPickupItemEvent -->
  <!-- start class org.bukkit.event.player.PlayerBedEnterEvent -->
  <class name="PlayerBedEnterEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerBedEnterEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBedEnterEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBedEnterResult" return="org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This describes the default outcome of this event.

 @return the bed enter result representing the default outcome of this event]]>
      </doc>
    </method>
    <method name="useBed" return="org.bukkit.event.Event.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This controls the action to take with the bed that was clicked on.
 <p>
 In case of {@link org.bukkit.event.Event.Result#DEFAULT}, the default outcome is described by
 {@link #getBedEnterResult()}.

 @return the action to take with the interacted bed
 @see #setUseBed(org.bukkit.event.Event.Result)]]>
      </doc>
    </method>
    <method name="setUseBed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="useBed" type="org.bukkit.event.Event.Result"/>
      <doc>
      <![CDATA[Sets the action to take with the interacted bed.
 <p>
 {@link org.bukkit.event.Event.Result#ALLOW} will result in the player sleeping, regardless of
 the default outcome described by {@link #getBedEnterResult()}.
 <br>
 {@link org.bukkit.event.Event.Result#DENY} will prevent the player from sleeping. This has the
 same effect as canceling the event via {@link #setCancelled(boolean)}.
 <br>
 {@link org.bukkit.event.Event.Result#DEFAULT} will result in the outcome described by
 {@link #getBedEnterResult()}.

 @param useBed the action to take with the interacted bed
 @see #useBed()]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cancellation state of this event. Set to true if you want to
 prevent the player from sleeping.
 <p>
 Canceling the event has the same effect as setting {@link #useBed()} to
 {@link org.bukkit.event.Event.Result#DENY}.
 <p>
 For backwards compatibility reasons this also returns true if
 {@link #useBed()} is {@link org.bukkit.event.Event.Result#DEFAULT} and the
 {@link #getBedEnterResult() default action} is to prevent bed entering.

 @return boolean cancellation state]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Sets the cancellation state of this event. A canceled event will not be
 executed in the server, but will still pass to other plugins.
 <p>
 Canceling this event will prevent use of the bed.

 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <method name="getBed" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the bed block involved in this event.

 @return the bed block involved in this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is fired when the player is almost about to enter the bed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerBedEnterEvent -->
  <!-- start class org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult -->
  <class name="PlayerBedEnterEvent.BedEnterResult" extends="java.lang.Enum&lt;org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the default possible outcomes of this event.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult -->
  <!-- start class org.bukkit.event.player.PlayerBedLeaveEvent -->
  <class name="PlayerBedLeaveEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerBedLeaveEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBed" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the bed block involved in this event.

 @return the bed block involved in this event]]>
      </doc>
    </method>
    <method name="shouldSetSpawnLocation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get if this event should set the new spawn location for the
 {@link Player}.
 <br>
 This does not remove any existing spawn location, only prevent it from
 being changed (if true).
 <br>
 To change a {@link Player}'s spawn location, use
 {@link Player#setBedSpawnLocation(Location)}.

 @return true if the spawn location will be changed]]>
      </doc>
    </method>
    <method name="setSpawnLocation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="setBedSpawn" type="boolean"/>
      <doc>
      <![CDATA[Set if this event should set the new spawn location for the
 {@link Player}.
 <br>
 This will not remove any existing spawn location, only prevent it from
 being changed (if true).
 <br>
 To change a {@link Player}'s spawn location, use
 {@link Player#setBedSpawnLocation(Location)}.

 @param setBedSpawn true to change the new spawn location]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is fired when the player is leaving a bed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerBedLeaveEvent -->
  <!-- start class org.bukkit.event.player.PlayerBucketEmptyEvent -->
  <class name="PlayerBucketEmptyEvent" extends="org.bukkit.event.player.PlayerBucketEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerBucketEmptyEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketEmptyEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketEmptyEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketEmptyEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player empties a bucket]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerBucketEmptyEvent -->
  <!-- start class org.bukkit.event.player.PlayerBucketEvent -->
  <class name="PlayerBucketEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerBucketEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBucket" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the bucket used in this event

 @return the used bucket]]>
      </doc>
    </method>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the resulting item in hand after the bucket event

 @return ItemStack hold in hand after the event.]]>
      </doc>
    </method>
    <method name="setItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the item in hand after the event

 @param itemStack the new held ItemStack after the bucket event.]]>
      </doc>
    </method>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block involved in this event.

 @return The Block which block is involved in this event]]>
      </doc>
    </method>
    <method name="getBlockClicked" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the block clicked

 @return the clicked block]]>
      </doc>
    </method>
    <method name="getBlockFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the face on the clicked block

 @return the clicked face]]>
      </doc>
    </method>
    <method name="getHand" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hand used to perform this action.

 @return the hand used]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Called when a player interacts with a Bucket]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerBucketEvent -->
  <!-- start class org.bukkit.event.player.PlayerBucketFillEvent -->
  <class name="PlayerBucketFillEvent" extends="org.bukkit.event.player.PlayerBucketEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerBucketFillEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketFillEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketFillEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerBucketFillEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.Material, org.bukkit.inventory.ItemStack, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player fills a bucket]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerBucketFillEvent -->
  <!-- start class org.bukkit.event.player.PlayerChangedMainHandEvent -->
  <class name="PlayerChangedMainHandEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerChangedMainHandEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.MainHand"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMainHand" return="org.bukkit.inventory.MainHand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new main hand of the player. The old hand is still momentarily
 available via {@link Player#getMainHand()}.

 @return the new {@link MainHand} of the player]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player changes their main hand in the client settings.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerChangedMainHandEvent -->
  <!-- start class org.bukkit.event.player.PlayerChangedWorldEvent -->
  <class name="PlayerChangedWorldEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerChangedWorldEvent" type="org.bukkit.entity.Player, org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFrom" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world the player is switching from.

 @return  player's previous world]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player switches to another world.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerChangedWorldEvent -->
  <!-- start class org.bukkit.event.player.PlayerChannelEvent -->
  <class name="PlayerChannelEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerChannelEvent" type="org.bukkit.entity.Player, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getChannel" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called after a player registers or unregisters a new plugin
 channel.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerChannelEvent -->
  <!-- start class org.bukkit.event.player.PlayerChatEvent -->
  <class name="PlayerChatEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="This event will fire from the main thread and allows the use of
     all of the Bukkit API, unlike the {@link AsyncPlayerChatEvent}.
     lEsS_tHaNp>
     Listening to this event forces chat to wait for the main thread which
     causes delays for chat. {@link AsyncPlayerChatEvent} is the encouraged
     alternative for thread safe implementations.">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerChatEvent" type="org.bukkit.entity.Player, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerChatEvent" type="org.bukkit.entity.Player, java.lang.String, java.lang.String, java.util.Set&lt;org.bukkit.entity.Player&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the message that the player is attempting to send

 @return Message the player is attempting to send]]>
      </doc>
    </method>
    <method name="setMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the message that the player will send

 @param message New message that the player will send]]>
      </doc>
    </method>
    <method name="setPlayer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Sets the player that this message will display as, or command will be
 executed as

 @param player New player which this event will execute as]]>
      </doc>
    </method>
    <method name="getFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the format to use to display this chat message

 @return String.Format compatible format string]]>
      </doc>
    </method>
    <method name="setFormat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the format to use to display this chat message

 @param format String.Format compatible format string]]>
      </doc>
    </method>
    <method name="getRecipients" return="java.util.Set&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set of recipients that this chat message will be displayed to

 @return All Players who will see this chat message]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Holds information for player chat and commands

 @deprecated This event will fire from the main thread and allows the use of
     all of the Bukkit API, unlike the {@link AsyncPlayerChatEvent}.
     <p>
     Listening to this event forces chat to wait for the main thread which
     causes delays for chat. {@link AsyncPlayerChatEvent} is the encouraged
     alternative for thread safe implementations.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerChatEvent -->
  <!-- start class org.bukkit.event.player.PlayerChatTabCompleteEvent -->
  <class name="PlayerChatTabCompleteEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="This event is no longer fired due to client changes">
    <constructor name="PlayerChatTabCompleteEvent" type="org.bukkit.entity.Player, java.lang.String, java.util.Collection&lt;java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getChatMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chat message being tab-completed.

 @return the chat message]]>
      </doc>
    </method>
    <method name="getLastToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the last 'token' of the message being tab-completed.
 <p>
 The token is the substring starting with the character after the last
 space in the message.

 @return The last token for the chat message]]>
      </doc>
    </method>
    <method name="getTabCompletions" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is the collection of completions for this event.

 @return the current completions]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player attempts to tab-complete a chat message.

 @deprecated This event is no longer fired due to client changes]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerChatTabCompleteEvent -->
  <!-- start class org.bukkit.event.player.PlayerCommandPreprocessEvent -->
  <class name="PlayerCommandPreprocessEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerCommandPreprocessEvent" type="org.bukkit.entity.Player, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerCommandPreprocessEvent" type="org.bukkit.entity.Player, java.lang.String, java.util.Set&lt;org.bukkit.entity.Player&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the command that the player is attempting to send.
 <p>
 All commands begin with a special character; implementations do not
 consider the first character when executing the content.

 @return Message the player is attempting to send]]>
      </doc>
    </method>
    <method name="setMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the command that the player will send.
 <p>
 All commands begin with a special character; implementations do not
 consider the first character when executing the content.

 @param command New message that the player will send
 @throws IllegalArgumentException if command is null or empty]]>
      </doc>
    </method>
    <method name="setPlayer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.entity.Player"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the player that this command will be executed as.

 @param player New player which this event will execute as
 @throws IllegalArgumentException if the player provided is null]]>
      </doc>
    </method>
    <method name="getRecipients" return="java.util.Set&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method is provided for backward compatibility with no
     guarantee to the effect of viewing or modifying the set.">
      <doc>
      <![CDATA[Gets a set of recipients that this chat message will be displayed to.
 <p>
 The set returned is not guaranteed to be mutable and may auto-populate
 on access. Any listener accessing the returned set should be aware that
 it may reduce performance for a lazy set implementation. Listeners
 should be aware that modifying the list may throw {@link
 UnsupportedOperationException} if the event caller provides an
 unmodifiable set.

 @deprecated This method is provided for backward compatibility with no
     guarantee to the effect of viewing or modifying the set.
 @return All Players who will see this chat message]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called whenever a player runs a command (by placing a slash
 at the start of their message). It is called early in the command handling
 process, and modifications in this event (via {@link #setMessage(String)})
 will be shown in the behavior.
 <p>
 Many plugins will have <b>no use for this event</b>, and you should
 attempt to avoid using it if it is not necessary.
 <p>
 Some examples of valid uses for this event are:
 <ul>
 <li>Logging executed commands to a separate file
 <li>Variable substitution. For example, replacing
     <code>${nearbyPlayer}</code> with the name of the nearest other
     player, or simulating the <code>@a</code> and <code>@p</code>
     decorators used by Command Blocks in plugins that do not handle it.
 <li>Conditionally blocking commands belonging to other plugins. For
     example, blocking the use of the <code>/home</code> command in a
     combat arena.
 <li>Per-sender command aliases. For example, after a player runs the
     command <code>/calias cr gamemode creative</code>, the next time they
     run <code>/cr</code>, it gets replaced into
     <code>/gamemode creative</code>. (Global command aliases should be
     done by registering the alias.)
 </ul>
 <p>
 Examples of incorrect uses are:
 <ul>
 <li>Using this event to run command logic
 </ul>
 <p>
 If the event is cancelled, processing of the command will halt.
 <p>
 The state of whether or not there is a slash (<code>/</code>) at the
 beginning of the message should be preserved. If a slash is added or
 removed, unexpected behavior may result.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerCommandPreprocessEvent -->
  <!-- start class org.bukkit.event.player.PlayerCommandSendEvent -->
  <class name="PlayerCommandSendEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerCommandSendEvent" type="org.bukkit.entity.Player, java.util.Collection&lt;java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCommands" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a mutable collection of all top level commands to be sent.
 <br>
 It is not legal to add entries to this collection, only remove them.
 Behaviour of adding entries is undefined.

 @return collection of all commands]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when the list of available server commands is sent to
 the player.
 <br>
 Commands may be removed from display using this event, but implementations
 are not required to securely remove all traces of the command. If secure
 removal of commands is required, then the command should be assigned a
 permission which is not granted to the player.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerCommandSendEvent -->
  <!-- start class org.bukkit.event.player.PlayerDropItemEvent -->
  <class name="PlayerDropItemEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerDropItemEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Item"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItemDrop" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ItemDrop created by the player

 @return ItemDrop created by the player]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a player drops an item from their inventory]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerDropItemEvent -->
  <!-- start class org.bukkit.event.player.PlayerEditBookEvent -->
  <class name="PlayerEditBookEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerEditBookEvent" type="org.bukkit.entity.Player, int, org.bukkit.inventory.meta.BookMeta, org.bukkit.inventory.meta.BookMeta, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPreviousBookMeta" return="org.bukkit.inventory.meta.BookMeta"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the book meta currently on the book.
 <p>
 Note: this is a copy of the book meta. You cannot use this object to
 change the existing book meta.

 @return the book meta currently on the book]]>
      </doc>
    </method>
    <method name="getNewBookMeta" return="org.bukkit.inventory.meta.BookMeta"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the book meta that the player is attempting to add to the book.
 <p>
 Note: this is a copy of the proposed new book meta. Use {@link
 #setNewBookMeta(BookMeta)} to change what will actually be added to the
 book.

 @return the book meta that the player is attempting to add]]>
      </doc>
    </method>
    <method name="getSlot" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="books may be signed from off hand">
      <doc>
      <![CDATA[Gets the inventory slot number for the book item that triggered this
 event.
 <p>
 This is a slot number on the player's hotbar in the range 0-8, or -1 for
 off hand.

 @return the inventory slot number that the book item occupies
 @deprecated books may be signed from off hand]]>
      </doc>
    </method>
    <method name="setNewBookMeta"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newBookMeta" type="org.bukkit.inventory.meta.BookMeta"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the book meta that will actually be added to the book.

 @param newBookMeta new book meta
 @throws IllegalArgumentException if the new book meta is null]]>
      </doc>
    </method>
    <method name="isSigning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether or not the book is being signed. If a book is signed the
 Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.

 @return true if the book is being signed]]>
      </doc>
    </method>
    <method name="setSigning"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signing" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not the book is being signed. If a book is signed the
 Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.

 @param signing whether or not the book is being signed.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Called when a player edits or signs a book and quill item. If the event is
 cancelled, no changes are made to the BookMeta]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerEditBookEvent -->
  <!-- start class org.bukkit.event.player.PlayerEggThrowEvent -->
  <class name="PlayerEggThrowEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerEggThrowEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Egg, boolean, byte, org.bukkit.entity.EntityType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEgg" return="org.bukkit.entity.Egg"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the egg involved in this event.

 @return the egg involved in this event]]>
      </doc>
    </method>
    <method name="isHatching" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the egg is hatching or not. Will be what the server
 would've done without interaction.

 @return boolean Whether the egg is going to hatch or not]]>
      </doc>
    </method>
    <method name="setHatching"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hatching" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the egg will hatch or not.

 @param hatching true if you want the egg to hatch, false if you want it
     not to]]>
      </doc>
    </method>
    <method name="getHatchingType" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of the mob being hatched (EntityType.CHICKEN by default)

 @return The type of the mob being hatched by the egg]]>
      </doc>
    </method>
    <method name="setHatchingType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hatchType" type="org.bukkit.entity.EntityType"/>
      <doc>
      <![CDATA[Change the type of mob being hatched by the egg

 @param hatchType The type of the mob being hatched by the egg]]>
      </doc>
    </method>
    <method name="getNumHatches" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of mob hatches from the egg. By default the number will
 be the number the server would've done
 <ul>
 <li>7/8 chance of being 0
 <li>31/256 ~= 1/8 chance to be 1
 <li>1/256 chance to be 4
 </ul>

 @return The number of mobs going to be hatched by the egg]]>
      </doc>
    </method>
    <method name="setNumHatches"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numHatches" type="byte"/>
      <doc>
      <![CDATA[Change the number of mobs coming out of the hatched egg
 <p>
 The boolean hatching will override this number. Ie. If hatching =
 false, this number will not matter

 @param numHatches The number of mobs coming out of the egg]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player throws an egg and it might hatch]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerEggThrowEvent -->
  <!-- start class org.bukkit.event.player.PlayerEvent -->
  <class name="PlayerEvent" extends="org.bukkit.event.Event"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerEvent" type="org.bukkit.entity.Player"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerEvent" type="org.bukkit.entity.Player, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player involved in this event

 @return Player who is involved in this event]]>
      </doc>
    </method>
    <field name="player" type="org.bukkit.entity.Player"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a player related event]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerEvent -->
  <!-- start class org.bukkit.event.player.PlayerExpChangeEvent -->
  <class name="PlayerExpChangeEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerExpChangeEvent" type="org.bukkit.entity.Player, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerExpChangeEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the source that provided the experience.

 @return The source of the experience]]>
      </doc>
    </method>
    <method name="getAmount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of experience the player will receive

 @return The amount of experience]]>
      </doc>
    </method>
    <method name="setAmount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Set the amount of experience the player will receive

 @param amount The amount of experience to set]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a players experience changes naturally]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerExpChangeEvent -->
  <!-- start class org.bukkit.event.player.PlayerFishEvent -->
  <class name="PlayerFishEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerFishEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity, org.bukkit.entity.FishHook, org.bukkit.event.player.PlayerFishEvent.State"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCaught" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity caught by the player.
 <p>
 If player has fished successfully, the result may be cast to {@link
 org.bukkit.entity.Item}.

 @return Entity caught by the player, Entity if fishing, and null if
     bobber has gotten stuck in the ground or nothing has been caught]]>
      </doc>
    </method>
    <method name="getHook" return="org.bukkit.entity.FishHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the fishing hook.

 @return the entity representing the fishing hook/bobber.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getExpToDrop" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of experience received when fishing.
 <p>
 Note: This value has no default effect unless the event state is {@link
 State#CAUGHT_FISH}.

 @return the amount of experience to drop]]>
      </doc>
    </method>
    <method name="setExpToDrop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Sets the amount of experience received when fishing.
 <p>
 Note: This value has no default effect unless the event state is {@link
 State#CAUGHT_FISH}.

 @param amount the amount of experience to drop]]>
      </doc>
    </method>
    <method name="getState" return="org.bukkit.event.player.PlayerFishEvent.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the state of the fishing

 @return A State detailing the state of the fishing]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a player is fishing]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerFishEvent -->
  <!-- start class org.bukkit.event.player.PlayerFishEvent.State -->
  <class name="PlayerFishEvent.State" extends="java.lang.Enum&lt;org.bukkit.event.player.PlayerFishEvent.State&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.player.PlayerFishEvent.State[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.player.PlayerFishEvent.State"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the state of the fishing]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerFishEvent.State -->
  <!-- start class org.bukkit.event.player.PlayerGameModeChangeEvent -->
  <class name="PlayerGameModeChangeEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerGameModeChangeEvent" type="org.bukkit.entity.Player, org.bukkit.GameMode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getNewGameMode" return="org.bukkit.GameMode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the GameMode the player is switched to.

 @return  player's new GameMode]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the GameMode of the player is changed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerGameModeChangeEvent -->
  <!-- start class org.bukkit.event.player.PlayerHarvestBlockEvent -->
  <class name="PlayerHarvestBlockEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerHarvestBlockEvent" type="org.bukkit.entity.Player, org.bukkit.block.Block, java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHarvestedBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block that is being harvested.

 @return The block that is being harvested]]>
      </doc>
    </method>
    <method name="getItemsHarvested" return="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of items that are being harvested from this block.

 @return A list of items that are being harvested from this block]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called whenever a player harvests a block.
 <br>
 A 'harvest' is when a block drops an item (usually some sort of crop) and
 changes state, but is not broken in order to drop the item.
 <br>
 This event is not called for when a block is broken, to handle that, listen
 for {@link org.bukkit.event.block.BlockBreakEvent} and
 {@link org.bukkit.event.block.BlockDropItemEvent}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerHarvestBlockEvent -->
  <!-- start class org.bukkit.event.player.PlayerInteractAtEntityEvent -->
  <class name="PlayerInteractAtEntityEvent" extends="org.bukkit.event.player.PlayerInteractEntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerInteractAtEntityEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity, org.bukkit.util.Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerInteractAtEntityEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity, org.bukkit.util.Vector, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getClickedPosition" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an event that is called when a player right clicks an entity that
 also contains the location where the entity was clicked.
 <br>
 Note that the client may sometimes spuriously send this packet in addition to {@link PlayerInteractEntityEvent}.
 Users are advised to listen to this (parent) class unless specifically required.
 <br>
 Note that interacting with Armor Stands fires this event only and not its parent and as such users are expressly required
 to listen to this event for that scenario.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerInteractAtEntityEvent -->
  <!-- start class org.bukkit.event.player.PlayerInteractEntityEvent -->
  <class name="PlayerInteractEntityEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerInteractEntityEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerInteractEntityEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getRightClicked" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity that was right-clicked by the player.

 @return entity right clicked by player]]>
      </doc>
    </method>
    <method name="getHand" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hand used to perform this interaction.

 @return the hand used to interact]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="clickedEntity" type="org.bukkit.entity.Entity"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents an event that is called when a player right clicks an entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerInteractEntityEvent -->
  <!-- start class org.bukkit.event.player.PlayerInteractEvent -->
  <class name="PlayerInteractEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerInteractEvent" type="org.bukkit.entity.Player, org.bukkit.event.block.Action, org.bukkit.inventory.ItemStack, org.bukkit.block.Block, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerInteractEvent" type="org.bukkit.entity.Player, org.bukkit.event.block.Action, org.bukkit.inventory.ItemStack, org.bukkit.block.Block, org.bukkit.block.BlockFace, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAction" return="org.bukkit.event.block.Action"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the action type

 @return Action returns the type of interaction]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This event has two possible cancellation states, one for
 {@link #useInteractedBlock()} and one for {@link #useItemInHand()}. It is
 possible a call might have the former false, but the latter true, eg in
 the case of using a firework whilst gliding. Callers should check the
 relevant methods individually.">
      <doc>
      <![CDATA[Gets the cancellation state of this event. Set to true if you want to
 prevent buckets from placing water and so forth

 @return boolean cancellation state
 @deprecated This event has two possible cancellation states, one for
 {@link #useInteractedBlock()} and one for {@link #useItemInHand()}. It is
 possible a call might have the former false, but the latter true, eg in
 the case of using a firework whilst gliding. Callers should check the
 relevant methods individually.]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Sets the cancellation state of this event. A canceled event will not be
 executed in the server, but will still pass to other plugins
 <p>
 Canceling this event will prevent use of food (player won't lose the
 food item), prevent bows/snowballs/eggs from firing, etc. (player won't
 lose the ammo)

 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the item in hand represented by this event

 @return ItemStack the item used]]>
      </doc>
    </method>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convenience method. Returns the material of the item represented by
 this event

 @return Material the material of the item used]]>
      </doc>
    </method>
    <method name="hasBlock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this event involved a block

 @return boolean true if it did]]>
      </doc>
    </method>
    <method name="hasItem" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this event involved an item

 @return boolean true if it did]]>
      </doc>
    </method>
    <method name="isBlockInHand" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convenience method to inform the user whether this was a block
 placement event.

 @return boolean true if the item in hand was a block]]>
      </doc>
    </method>
    <method name="getClickedBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the clicked block

 @return Block returns the block clicked with this item.]]>
      </doc>
    </method>
    <method name="getBlockFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the face of the block that was clicked

 @return BlockFace returns the face of the block that was clicked]]>
      </doc>
    </method>
    <method name="useInteractedBlock" return="org.bukkit.event.Event.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This controls the action to take with the block (if any) that was
 clicked on. This event gets processed for all blocks, but most don't
 have a default action

 @return the action to take with the interacted block]]>
      </doc>
    </method>
    <method name="setUseInteractedBlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="useInteractedBlock" type="org.bukkit.event.Event.Result"/>
      <doc>
      <![CDATA[@param useInteractedBlock the action to take with the interacted block]]>
      </doc>
    </method>
    <method name="useItemInHand" return="org.bukkit.event.Event.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This controls the action to take with the item the player is holding.
 This includes both blocks and items (such as flint and steel or
 records). When this is set to default, it will be allowed if no action
 is taken on the interacted block.

 @return the action to take with the item in hand]]>
      </doc>
    </method>
    <method name="setUseItemInHand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="useItemInHand" type="org.bukkit.event.Event.Result"/>
      <doc>
      <![CDATA[@param useItemInHand the action to take with the item in hand]]>
      </doc>
    </method>
    <method name="getHand" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hand used to perform this interaction. May be null in the case of
 {@link Action#PHYSICAL}.

 @return the hand used to interact. May be null.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="item" type="org.bukkit.inventory.ItemStack"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="action" type="org.bukkit.event.block.Action"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="blockClicked" type="org.bukkit.block.Block"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="blockFace" type="org.bukkit.block.BlockFace"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents an event that is called when a player interacts with an object or
 air, potentially fired once for each hand. The hand can be determined using
 {@link #getHand()}.
 <p>
 This event will fire as cancelled if the vanilla behavior is to do nothing
 (e.g interacting with air). For the purpose of avoiding doubt, this means
 that the event will only be in the cancelled state if it is fired as a result
 of some prediction made by the server where no subsequent code will run,
 rather than when the subsequent interaction activity (e.g. placing a block in
 an illegal position ({@link BlockCanBuildEvent}) will fail.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerInteractEvent -->
  <!-- start class org.bukkit.event.player.PlayerItemBreakEvent -->
  <class name="PlayerItemBreakEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerItemBreakEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBrokenItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item that broke

 @return The broken item]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired when a player's item breaks (such as a shovel or flint and steel).
 <p>
 The item that's breaking will exist in the inventory with a stack size of
 0. After the event, the item's durability will be reset to 0.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerItemBreakEvent -->
  <!-- start class org.bukkit.event.player.PlayerItemConsumeEvent -->
  <class name="PlayerItemConsumeEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerItemConsumeEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param player the player consuming
 @param item the ItemStack being consumed]]>
      </doc>
    </constructor>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item that is being consumed. Modifying the returned item will
 have no effect, you must use {@link
 #setItem(org.bukkit.inventory.ItemStack)} instead.

 @return an ItemStack for the item being consumed]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the item being consumed

 @param item the item being consumed]]>
      </doc>
    </method>
    <method name="getReplacement" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the custom item stack that will replace the consumed item, or null if no
 custom replacement has been set (which means the default replacement will be used).

 @return The custom item stack that will replace the consumed item or null]]>
      </doc>
    </method>
    <method name="setReplacement"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="replacement" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set a custom item stack to replace the consumed item. Pass null to clear any custom
 stack that has been set and use the default replacement.

 @param replacement Replacement item to set, null to clear any custom stack and use default]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event will fire when a player is finishing consuming an item (food,
 potion, milk bucket).
 <br>
 If the ItemStack is modified the server will use the effects of the new
 item and not remove the original one from the player's inventory.
 <br>
 If the event is cancelled the effect will not be applied and the item will
 not be removed from the player's inventory.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerItemConsumeEvent -->
  <!-- start class org.bukkit.event.player.PlayerItemDamageEvent -->
  <class name="PlayerItemDamageEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerItemDamageEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item being damaged.

 @return the item]]>
      </doc>
    </method>
    <method name="getDamage" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of durability damage this item will be taking.

 @return durability change]]>
      </doc>
    </method>
    <method name="setDamage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="int"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an item used by the player takes durability damage as a result of
 being used.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerItemDamageEvent -->
  <!-- start class org.bukkit.event.player.PlayerItemHeldEvent -->
  <class name="PlayerItemHeldEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerItemHeldEvent" type="org.bukkit.entity.Player, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPreviousSlot" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the previous held slot index

 @return Previous slot index]]>
      </doc>
    </method>
    <method name="getNewSlot" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new held slot index

 @return New slot index]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Fired when a player changes their currently held item]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerItemHeldEvent -->
  <!-- start class org.bukkit.event.player.PlayerItemMendEvent -->
  <class name="PlayerItemMendEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerItemMendEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack, org.bukkit.entity.ExperienceOrb, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link ItemStack} to be repaired.

 This is not necessarily the item the player is holding.

 @return the item to be repaired]]>
      </doc>
    </method>
    <method name="getExperienceOrb" return="org.bukkit.entity.ExperienceOrb"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the experience orb triggering the event.

 @return the experience orb]]>
      </doc>
    </method>
    <method name="getRepairAmount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount the item is to be repaired.

 The default value is twice the value of the consumed experience orb
 or the remaining damage left on the item, whichever is smaller.

 @return how much damage will be repaired by the experience orb]]>
      </doc>
    </method>
    <method name="setRepairAmount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Set the amount the item will be repaired.

 Half of this value will be subtracted from the experience orb which initiated this event.

 @param amount how much damage will be repaired on the item]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents when a player has an item repaired via the Mending enchantment.
 <br>
 This event is fired directly before the {@link PlayerExpChangeEvent}, and the
 results of this event directly affect the {@link PlayerExpChangeEvent}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerItemMendEvent -->
  <!-- start class org.bukkit.event.player.PlayerJoinEvent -->
  <class name="PlayerJoinEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerJoinEvent" type="org.bukkit.entity.Player, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getJoinMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the join message to send to all online players

 @return string join message. Can be null]]>
      </doc>
    </method>
    <method name="setJoinMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="joinMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the join message to send to all online players

 @param joinMessage join message. If null, no message will be sent]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player joins a server]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerJoinEvent -->
  <!-- start class org.bukkit.event.player.PlayerKickEvent -->
  <class name="PlayerKickEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerKickEvent" type="org.bukkit.entity.Player, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getReason" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason why the player is getting kicked

 @return string kick reason]]>
      </doc>
    </method>
    <method name="getLeaveMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the leave message send to all online players

 @return string kick reason]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="setReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kickReason" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the reason why the player is getting kicked

 @param kickReason kick reason]]>
      </doc>
    </method>
    <method name="setLeaveMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leaveMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the leave message send to all online players

 @param leaveMessage leave message]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player gets kicked from the server]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerKickEvent -->
  <!-- start class org.bukkit.event.player.PlayerLevelChangeEvent -->
  <class name="PlayerLevelChangeEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerLevelChangeEvent" type="org.bukkit.entity.Player, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getOldLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the old level of the player

 @return The old level of the player]]>
      </doc>
    </method>
    <method name="getNewLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new level of the player

 @return The new (current) level of the player]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a players level changes]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerLevelChangeEvent -->
  <!-- start class org.bukkit.event.player.PlayerLocaleChangeEvent -->
  <class name="PlayerLocaleChangeEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerLocaleChangeEvent" type="org.bukkit.entity.Player, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLocale" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Player#getLocale()

 @return the player's new locale]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player changes their locale in the client settings.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerLocaleChangeEvent -->
  <!-- start class org.bukkit.event.player.PlayerLoginEvent -->
  <class name="PlayerLoginEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerLoginEvent" type="org.bukkit.entity.Player, java.lang.String, java.net.InetAddress, java.net.InetAddress"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constructor defaults message to an empty string, and result to
 ALLOWED

 @param player The {@link Player} for this event
 @param hostname The hostname that was used to connect to the server
 @param address The address the player used to connect, provided for
     timing issues
 @param realAddress the actual, unspoofed connecting address]]>
      </doc>
    </constructor>
    <constructor name="PlayerLoginEvent" type="org.bukkit.entity.Player, java.lang.String, java.net.InetAddress"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerLoginEvent" type="org.bukkit.entity.Player, java.lang.String, java.net.InetAddress, org.bukkit.event.player.PlayerLoginEvent.Result, java.lang.String, java.net.InetAddress"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constructor pre-configures the event with a result and message

 @param player The {@link Player} for this event
 @param hostname The hostname that was used to connect to the server
 @param address The address the player used to connect, provided for
     timing issues
 @param result The result status for this event
 @param message The message to be displayed if result denies login
 @param realAddress the actual, unspoofed connecting address]]>
      </doc>
    </constructor>
    <method name="getRealAddress" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the connection address of this player, regardless of whether it has been spoofed or not.

 @return the player's connection address]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.event.player.PlayerLoginEvent.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current result of the login, as an enum

 @return Current Result of the login]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.event.player.PlayerLoginEvent.Result"/>
      <doc>
      <![CDATA[Sets the new result of the login, as an enum

 @param result New result to set]]>
      </doc>
    </method>
    <method name="getKickMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current kick message that will be used if getResult() !=
 Result.ALLOWED

 @return Current kick message]]>
      </doc>
    </method>
    <method name="setKickMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the kick message to display if getResult() != Result.ALLOWED

 @param message New kick message]]>
      </doc>
    </method>
    <method name="getHostname" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the hostname that the player used to connect to the server, or
 blank if unknown

 @return The hostname]]>
      </doc>
    </method>
    <method name="allow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows the player to log in]]>
      </doc>
    </method>
    <method name="disallow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.event.player.PlayerLoginEvent.Result"/>
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Disallows the player from logging in, with the given reason

 @param result New result for disallowing the player
 @param message Kick message to display to the user]]>
      </doc>
    </method>
    <method name="getAddress" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the {@link InetAddress} for the Player associated with this event.
 This method is provided as a workaround for player.getAddress()
 returning null during PlayerLoginEvent.

 @return The address for this player. For legacy compatibility, this may
     be null.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Stores details for players attempting to log in.
 <br>
 Note that this event is called <i>early</i> in the player initialization
 process. It is recommended that most options involving the Player
 <i>entity</i> be postponed to the {@link PlayerJoinEvent} instead.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerLoginEvent -->
  <!-- start class org.bukkit.event.player.PlayerLoginEvent.Result -->
  <class name="PlayerLoginEvent.Result" extends="java.lang.Enum&lt;org.bukkit.event.player.PlayerLoginEvent.Result&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.player.PlayerLoginEvent.Result[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.player.PlayerLoginEvent.Result"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Basic kick reasons for communicating to plugins]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerLoginEvent.Result -->
  <!-- start class org.bukkit.event.player.PlayerMoveEvent -->
  <class name="PlayerMoveEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerMoveEvent" type="org.bukkit.entity.Player, org.bukkit.Location, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins
 <p>
 If a move or teleport event is cancelled, the player will be moved or
 teleported back to the Location as defined by getFrom(). This will not
 fire an event

 @return true if this event is cancelled]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
      <doc>
      <![CDATA[Sets the cancellation state of this event. A cancelled event will not
 be executed in the server, but will still pass to other plugins
 <p>
 If a move or teleport event is cancelled, the player will be moved or
 teleported back to the Location as defined by getFrom(). This will not
 fire an event

 @param cancel true if you wish to cancel this event]]>
      </doc>
    </method>
    <method name="getFrom" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location this player moved from

 @return Location the player moved from]]>
      </doc>
    </method>
    <method name="setFrom"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the location to mark as where the player moved from

 @param from New location to mark as the players previous location]]>
      </doc>
    </method>
    <method name="getTo" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location this player moved to

 @return Location the player moved to]]>
      </doc>
    </method>
    <method name="setTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the location that this player will move to

 @param to New Location this player will move to]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Holds information for player movement events]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerMoveEvent -->
  <!-- start class org.bukkit.event.player.PlayerPickupArrowEvent -->
  <class name="PlayerPickupArrowEvent" extends="org.bukkit.event.player.PlayerPickupItemEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerPickupArrowEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Item, org.bukkit.entity.AbstractArrow"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getArrow" return="org.bukkit.entity.AbstractArrow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the arrow being picked up by the player

 @return The arrow being picked up]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown when a player picks up an arrow from the ground.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerPickupArrowEvent -->
  <!-- start class org.bukkit.event.player.PlayerPickupItemEvent -->
  <class name="PlayerPickupItemEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="{@link EntityPickupItemEvent}">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerPickupItemEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Item, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItem" return="org.bukkit.entity.Item"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Item picked up by the player.

 @return Item]]>
      </doc>
    </method>
    <method name="getRemaining" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount remaining on the ground, if any

 @return amount remaining on the ground]]>
      </doc>
    </method>
    <method name="setFlyAtPlayer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flyAtPlayer" type="boolean"/>
      <doc>
      <![CDATA[Set if the item will fly at the player
 <p>Cancelling the event will set this value to false.</p>

 @param flyAtPlayer True for item to fly at player]]>
      </doc>
    </method>
    <method name="getFlyAtPlayer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the item will fly at the player

 @return True if the item will fly at the player]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a player picks an item up from the ground
 @deprecated {@link EntityPickupItemEvent}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerPickupItemEvent -->
  <!-- start class org.bukkit.event.player.PlayerPortalEvent -->
  <class name="PlayerPortalEvent" extends="org.bukkit.event.player.PlayerTeleportEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerPortalEvent" type="org.bukkit.entity.Player, org.bukkit.Location, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerPortalEvent" type="org.bukkit.entity.Player, org.bukkit.Location, org.bukkit.Location, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerPortalEvent" type="org.bukkit.entity.Player, org.bukkit.Location, org.bukkit.Location, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause, int, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setSearchRadius"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="searchRadius" type="int"/>
      <doc>
      <![CDATA[Set the Block radius to search in for available portals.

 @param searchRadius the radius in which to search for a portal from the
 location]]>
      </doc>
    </method>
    <method name="getSearchRadius" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the search radius value for finding an available portal.

 @return the currently set search radius]]>
      </doc>
    </method>
    <method name="getCanCreatePortal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the server will attempt to create a destination portal or
 not.

 @return whether there should create be a destination portal created]]>
      </doc>
    </method>
    <method name="setCanCreatePortal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canCreatePortal" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the server should attempt to create a destination portal or
 not.

 @param canCreatePortal Sets whether there should be a destination portal
 created]]>
      </doc>
    </method>
    <method name="setCreationRadius"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="creationRadius" type="int"/>
      <doc>
      <![CDATA[Sets the maximum radius the world is searched for a free space from the
 given location.

 If enough free space is found then the portal will be created there, if
 not it will force create with air-space at the target location.

 Does not apply to end portal target platforms which will always appear at
 the target location.

 @param creationRadius the radius in which to create a portal from the
 location]]>
      </doc>
    </method>
    <method name="getCreationRadius" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum radius the world is searched for a free space from the
 given location.

 If enough free space is found then the portal will be created there, if
 not it will force create with air-space at the target location.

 Does not apply to end portal target platforms which will always appear at
 the target location.

 @return the currently set creation radius]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player is about to teleport because it is in contact with a
 portal.
 <p>
 For other entities see {@link org.bukkit.event.entity.EntityPortalEvent}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerPortalEvent -->
  <!-- start class org.bukkit.event.player.PlayerPreLoginEvent -->
  <class name="PlayerPreLoginEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="This event causes synchronization from the login thread; {@link
     AsyncPlayerPreLoginEvent} is preferred to keep the secondary threads
     asynchronous.">
    <constructor name="PlayerPreLoginEvent" type="java.lang.String, java.net.InetAddress"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerPreLoginEvent" type="java.lang.String, java.net.InetAddress, java.util.UUID"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getResult" return="org.bukkit.event.player.PlayerPreLoginEvent.Result"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current result of the login, as an enum

 @return Current Result of the login]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.event.player.PlayerPreLoginEvent.Result"/>
      <doc>
      <![CDATA[Sets the new result of the login, as an enum

 @param result New result to set]]>
      </doc>
    </method>
    <method name="getKickMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current kick message that will be used if getResult() !=
 Result.ALLOWED

 @return Current kick message]]>
      </doc>
    </method>
    <method name="setKickMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the kick message to display if getResult() != Result.ALLOWED

 @param message New kick message]]>
      </doc>
    </method>
    <method name="allow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows the player to log in]]>
      </doc>
    </method>
    <method name="disallow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.event.player.PlayerPreLoginEvent.Result"/>
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Disallows the player from logging in, with the given reason

 @param result New result for disallowing the player
 @param message Kick message to display to the user]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player's name.

 @return the player's name]]>
      </doc>
    </method>
    <method name="getAddress" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player IP address.

 @return The IP address]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUniqueId" return="java.util.UUID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player's unique ID.

 @return The unique ID]]>
      </doc>
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Stores details for players attempting to log in

 @deprecated This event causes synchronization from the login thread; {@link
     AsyncPlayerPreLoginEvent} is preferred to keep the secondary threads
     asynchronous.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerPreLoginEvent -->
  <!-- start class org.bukkit.event.player.PlayerPreLoginEvent.Result -->
  <class name="PlayerPreLoginEvent.Result" extends="java.lang.Enum&lt;org.bukkit.event.player.PlayerPreLoginEvent.Result&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.player.PlayerPreLoginEvent.Result[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.player.PlayerPreLoginEvent.Result"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Basic kick reasons for communicating to plugins]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerPreLoginEvent.Result -->
  <!-- start class org.bukkit.event.player.PlayerQuitEvent -->
  <class name="PlayerQuitEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerQuitEvent" type="org.bukkit.entity.Player, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getQuitMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the quit message to send to all online players

 @return string quit message]]>
      </doc>
    </method>
    <method name="setQuitMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="quitMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the quit message to send to all online players

 @param quitMessage quit message]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player leaves a server]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerQuitEvent -->
  <!-- start class org.bukkit.event.player.PlayerRecipeDiscoverEvent -->
  <class name="PlayerRecipeDiscoverEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerRecipeDiscoverEvent" type="org.bukkit.entity.Player, org.bukkit.NamespacedKey"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRecipe" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the namespaced key of the discovered recipe.

 @return the discovered recipe]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player discovers a new recipe in the recipe book.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerRecipeDiscoverEvent -->
  <!-- start class org.bukkit.event.player.PlayerRegisterChannelEvent -->
  <class name="PlayerRegisterChannelEvent" extends="org.bukkit.event.player.PlayerChannelEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerRegisterChannelEvent" type="org.bukkit.entity.Player, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[This is called immediately after a player registers for a plugin channel.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerRegisterChannelEvent -->
  <!-- start class org.bukkit.event.player.PlayerResourcePackStatusEvent -->
  <class name="PlayerResourcePackStatusEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerResourcePackStatusEvent" type="org.bukkit.entity.Player, org.bukkit.event.player.PlayerResourcePackStatusEvent.Status"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerResourcePackStatusEvent" type="org.bukkit.entity.Player, org.bukkit.event.player.PlayerResourcePackStatusEvent.Status, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHash" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStatus" return="org.bukkit.event.player.PlayerResourcePackStatusEvent.Status"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the status of this pack.

 @return the current status]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player takes action on a resource pack request sent via
 {@link Player#setResourcePack(java.lang.String)}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerResourcePackStatusEvent -->
  <!-- start class org.bukkit.event.player.PlayerResourcePackStatusEvent.Status -->
  <class name="PlayerResourcePackStatusEvent.Status" extends="java.lang.Enum&lt;org.bukkit.event.player.PlayerResourcePackStatusEvent.Status&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.player.PlayerResourcePackStatusEvent.Status[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.player.PlayerResourcePackStatusEvent.Status"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Status of the resource pack.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerResourcePackStatusEvent.Status -->
  <!-- start class org.bukkit.event.player.PlayerRespawnEvent -->
  <class name="PlayerRespawnEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerRespawnEvent" type="org.bukkit.entity.Player, org.bukkit.Location, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerRespawnEvent" type="org.bukkit.entity.Player, org.bukkit.Location, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRespawnLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current respawn location

 @return Location current respawn location]]>
      </doc>
    </method>
    <method name="setRespawnLocation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="respawnLocation" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the new respawn location

 @param respawnLocation new location for the respawn]]>
      </doc>
    </method>
    <method name="isBedSpawn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the respawn location is the player's bed.

 @return true if the respawn location is the player's bed.]]>
      </doc>
    </method>
    <method name="isAnchorSpawn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the respawn location is the player's respawn anchor.

 @return true if the respawn location is the player's respawn anchor.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player respawns.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerRespawnEvent -->
  <!-- start class org.bukkit.event.player.PlayerRiptideEvent -->
  <class name="PlayerRiptideEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerRiptideEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item containing the used enchantment.

 @return held enchanted item]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is fired when the player activates the riptide enchantment, using
 their trident to propel them through the air.
 <br>
 N.B. the riptide action is currently performed client side, so manipulating
 the player in this event may have undesired effects.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerRiptideEvent -->
  <!-- start class org.bukkit.event.player.PlayerShearEntityEvent -->
  <class name="PlayerShearEntityEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerShearEntityEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity, org.bukkit.inventory.ItemStack, org.bukkit.inventory.EquipmentSlot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerShearEntityEvent" type="org.bukkit.entity.Player, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entity the player is shearing

 @return the entity the player is shearing]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item used to shear the entity.

 @return the shears]]>
      </doc>
    </method>
    <method name="getHand" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the hand used to shear the entity.

 @return the hand]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player shears an entity]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerShearEntityEvent -->
  <!-- start class org.bukkit.event.player.PlayerStatisticIncrementEvent -->
  <class name="PlayerStatisticIncrementEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerStatisticIncrementEvent" type="org.bukkit.entity.Player, org.bukkit.Statistic, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerStatisticIncrementEvent" type="org.bukkit.entity.Player, org.bukkit.Statistic, int, int, org.bukkit.entity.EntityType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerStatisticIncrementEvent" type="org.bukkit.entity.Player, org.bukkit.Statistic, int, int, org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getStatistic" return="org.bukkit.Statistic"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the statistic that is being incremented.

 @return the incremented statistic]]>
      </doc>
    </method>
    <method name="getPreviousValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the previous value of the statistic.

 @return the previous value of the statistic]]>
      </doc>
    </method>
    <method name="getNewValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the new value of the statistic.

 @return the new value of the statistic]]>
      </doc>
    </method>
    <method name="getEntityType" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the EntityType if {@link #getStatistic() getStatistic()} is an
 entity statistic otherwise returns null.

 @return the EntityType of the statistic]]>
      </doc>
    </method>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Material if {@link #getStatistic() getStatistic()} is a block
 or item statistic otherwise returns null.

 @return the Material of the statistic]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="statistic" type="org.bukkit.Statistic"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Called when a player statistic is incremented.
 <p>
 This event is not called for some high frequency statistics, e.g. movement
 based statistics.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerStatisticIncrementEvent -->
  <!-- start class org.bukkit.event.player.PlayerSwapHandItemsEvent -->
  <class name="PlayerSwapHandItemsEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerSwapHandItemsEvent" type="org.bukkit.entity.Player, org.bukkit.inventory.ItemStack, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMainHandItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item switched to the main hand.

 @return item in the main hand]]>
      </doc>
    </method>
    <method name="setMainHandItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mainHandItem" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item in the main hand.

 @param mainHandItem new item in the main hand]]>
      </doc>
    </method>
    <method name="getOffHandItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item switched to the off hand.

 @return item in the off hand]]>
      </doc>
    </method>
    <method name="setOffHandItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offHandItem" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item in the off hand.

 @param offHandItem new item in the off hand]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player swap items between main hand and off hand using the
 hotkey.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerSwapHandItemsEvent -->
  <!-- start class org.bukkit.event.player.PlayerTakeLecternBookEvent -->
  <class name="PlayerTakeLecternBookEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerTakeLecternBookEvent" type="org.bukkit.entity.Player, org.bukkit.block.Lectern"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLectern" return="org.bukkit.block.Lectern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the lectern involved.

 @return the Lectern]]>
      </doc>
    </method>
    <method name="getBook" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current ItemStack on the lectern.

 @return the ItemStack on the Lectern]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when a player clicks the button to take a book of a
 Lectern. If this event is cancelled the book remains on the lectern.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerTakeLecternBookEvent -->
  <!-- start class org.bukkit.event.player.PlayerTeleportEvent -->
  <class name="PlayerTeleportEvent" extends="org.bukkit.event.player.PlayerMoveEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerTeleportEvent" type="org.bukkit.entity.Player, org.bukkit.Location, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PlayerTeleportEvent" type="org.bukkit.entity.Player, org.bukkit.Location, org.bukkit.Location, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCause" return="org.bukkit.event.player.PlayerTeleportEvent.TeleportCause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cause of this teleportation event

 @return Cause of the event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Holds information for player teleport events]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerTeleportEvent -->
  <!-- start class org.bukkit.event.player.PlayerTeleportEvent.TeleportCause -->
  <class name="PlayerTeleportEvent.TeleportCause" extends="java.lang.Enum&lt;org.bukkit.event.player.PlayerTeleportEvent.TeleportCause&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.player.PlayerTeleportEvent.TeleportCause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.player.PlayerTeleportEvent.TeleportCause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.player.PlayerTeleportEvent.TeleportCause -->
  <!-- start class org.bukkit.event.player.PlayerToggleFlightEvent -->
  <class name="PlayerToggleFlightEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerToggleFlightEvent" type="org.bukkit.entity.Player, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isFlying" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the player is trying to start or stop flying.

 @return flying state]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player toggles their flying state]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerToggleFlightEvent -->
  <!-- start class org.bukkit.event.player.PlayerToggleSneakEvent -->
  <class name="PlayerToggleSneakEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerToggleSneakEvent" type="org.bukkit.entity.Player, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isSneaking" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the player is now sneaking or not.

 @return sneaking state]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player toggles their sneaking state]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerToggleSneakEvent -->
  <!-- start class org.bukkit.event.player.PlayerToggleSprintEvent -->
  <class name="PlayerToggleSprintEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerToggleSprintEvent" type="org.bukkit.entity.Player, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isSprinting" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the player is now sprinting or not.

 @return sprinting state]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a player toggles their sprinting state]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerToggleSprintEvent -->
  <!-- start class org.bukkit.event.player.PlayerUnleashEntityEvent -->
  <class name="PlayerUnleashEntityEvent" extends="org.bukkit.event.entity.EntityUnleashEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerUnleashEntityEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Player"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player who is unleashing the entity.

 @return The player]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Called prior to an entity being unleashed due to a player's action.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerUnleashEntityEvent -->
  <!-- start class org.bukkit.event.player.PlayerUnregisterChannelEvent -->
  <class name="PlayerUnregisterChannelEvent" extends="org.bukkit.event.player.PlayerChannelEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerUnregisterChannelEvent" type="org.bukkit.entity.Player, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[This is called immediately after a player unregisters for a plugin channel.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerUnregisterChannelEvent -->
  <!-- start class org.bukkit.event.player.PlayerVelocityEvent -->
  <class name="PlayerVelocityEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PlayerVelocityEvent" type="org.bukkit.entity.Player, org.bukkit.util.Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getVelocity" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the velocity vector that will be sent to the player

 @return Vector the player will get]]>
      </doc>
    </method>
    <method name="setVelocity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="velocity" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets the velocity vector that will be sent to the player

 @param velocity The velocity vector that will be sent to the player]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the velocity of a player changes.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.player.PlayerVelocityEvent -->
</package>
<package name="org.bukkit.event.raid">
  <!-- start class org.bukkit.event.raid.RaidEvent -->
  <class name="RaidEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RaidEvent" type="org.bukkit.Raid, org.bukkit.World"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getRaid" return="org.bukkit.Raid"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raid involved with this event.

 @return Raid]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents events related to raids.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.raid.RaidEvent -->
  <!-- start class org.bukkit.event.raid.RaidFinishEvent -->
  <class name="RaidFinishEvent" extends="org.bukkit.event.raid.RaidEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RaidFinishEvent" type="org.bukkit.Raid, org.bukkit.World, java.util.List&lt;org.bukkit.entity.Player&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getWinners" return="java.util.List&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable list contains all winners.
 <br>
 <b>Note: Players who are considered as heroes but were not online at the
 end would not be included in this list.</b>

 @return winners]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when a {@link Raid} was complete with a clear result.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.raid.RaidFinishEvent -->
  <!-- start class org.bukkit.event.raid.RaidSpawnWaveEvent -->
  <class name="RaidSpawnWaveEvent" extends="org.bukkit.event.raid.RaidEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RaidSpawnWaveEvent" type="org.bukkit.Raid, org.bukkit.World, org.bukkit.entity.Raider, java.util.List&lt;org.bukkit.entity.Raider&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPatrolLeader" return="org.bukkit.entity.Raider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the patrol leader.

 @return {@link Raider}]]>
      </doc>
    </method>
    <method name="getRaiders" return="java.util.List&lt;org.bukkit.entity.Raider&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all {@link Raider} that spawned in this wave.

 @return an immutable list of raiders]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a raid wave spawns.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.raid.RaidSpawnWaveEvent -->
  <!-- start class org.bukkit.event.raid.RaidStopEvent -->
  <class name="RaidStopEvent" extends="org.bukkit.event.raid.RaidEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RaidStopEvent" type="org.bukkit.Raid, org.bukkit.World, org.bukkit.event.raid.RaidStopEvent.Reason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getReason" return="org.bukkit.event.raid.RaidStopEvent.Reason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the stop reason.

 @return Reason]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a {@link Raid} is stopped.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.raid.RaidStopEvent -->
  <!-- start class org.bukkit.event.raid.RaidStopEvent.Reason -->
  <class name="RaidStopEvent.Reason" extends="java.lang.Enum&lt;org.bukkit.event.raid.RaidStopEvent.Reason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.raid.RaidStopEvent.Reason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.raid.RaidStopEvent.Reason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.raid.RaidStopEvent.Reason -->
  <!-- start class org.bukkit.event.raid.RaidTriggerEvent -->
  <class name="RaidTriggerEvent" extends="org.bukkit.event.raid.RaidEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="RaidTriggerEvent" type="org.bukkit.Raid, org.bukkit.World, org.bukkit.entity.Player"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the player who triggered the raid.

 @return triggering player]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a {@link Raid} is triggered (e.g: a player with Bad Omen effect
 enters a village).]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.raid.RaidTriggerEvent -->
</package>
<package name="org.bukkit.event.server">
  <!-- start class org.bukkit.event.server.BroadcastMessageEvent -->
  <class name="BroadcastMessageEvent" extends="org.bukkit.event.server.ServerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="BroadcastMessageEvent" type="java.lang.String, java.util.Set&lt;org.bukkit.command.CommandSender&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BroadcastMessageEvent" type="boolean, java.lang.String, java.util.Set&lt;org.bukkit.command.CommandSender&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the message to broadcast.

 @return Message to broadcast]]>
      </doc>
    </method>
    <method name="setMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the message to broadcast.

 @param message New message to broadcast]]>
      </doc>
    </method>
    <method name="getRecipients" return="java.util.Set&lt;org.bukkit.command.CommandSender&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set of recipients that this chat message will be displayed to.
 <p>
 The set returned is not guaranteed to be mutable and may auto-populate
 on access. Any listener accessing the returned set should be aware that
 it may reduce performance for a lazy set implementation.
 <p>
 Listeners should be aware that modifying the list may throw {@link
 UnsupportedOperationException} if the event caller provides an
 unmodifiable set.

 @return All CommandSenders who will see this chat message]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Event triggered for server broadcast messages such as from
 {@link org.bukkit.Server#broadcast(String, String)}.

 <b>This event behaves similarly to {@link AsyncPlayerChatEvent} in that it
 should be async if fired from an async thread. Please see that event for
 further information.</b>]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.BroadcastMessageEvent -->
  <!-- start class org.bukkit.event.server.MapInitializeEvent -->
  <class name="MapInitializeEvent" extends="org.bukkit.event.server.ServerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapInitializeEvent" type="org.bukkit.map.MapView"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMap" return="org.bukkit.map.MapView"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the map initialized in this event.

 @return Map for this event]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a map is initialized.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.MapInitializeEvent -->
  <!-- start class org.bukkit.event.server.PluginDisableEvent -->
  <class name="PluginDisableEvent" extends="org.bukkit.event.server.PluginEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginDisableEvent" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a plugin is disabled.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.PluginDisableEvent -->
  <!-- start class org.bukkit.event.server.PluginEnableEvent -->
  <class name="PluginEnableEvent" extends="org.bukkit.event.server.PluginEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginEnableEvent" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a plugin is enabled.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.PluginEnableEvent -->
  <!-- start class org.bukkit.event.server.PluginEvent -->
  <class name="PluginEvent" extends="org.bukkit.event.server.ServerEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginEvent" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin involved in this event

 @return Plugin for this event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Used for plugin enable and disable events]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.PluginEvent -->
  <!-- start class org.bukkit.event.server.RemoteServerCommandEvent -->
  <class name="RemoteServerCommandEvent" extends="org.bukkit.event.server.ServerCommandEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RemoteServerCommandEvent" type="org.bukkit.command.CommandSender, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when a command is received over RCON. See the javadocs
 of {@link ServerCommandEvent} for more information.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.RemoteServerCommandEvent -->
  <!-- start class org.bukkit.event.server.ServerCommandEvent -->
  <class name="ServerCommandEvent" extends="org.bukkit.event.server.ServerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ServerCommandEvent" type="org.bukkit.command.CommandSender, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCommand" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the command that the user is attempting to execute from the
 console

 @return Command the user is attempting to execute]]>
      </doc>
    </method>
    <method name="setCommand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the command that the server will execute

 @param message New message that the server will execute]]>
      </doc>
    </method>
    <method name="getSender" return="org.bukkit.command.CommandSender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the command sender.

 @return The sender]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[This event is called when a command is run by a non-player. It is
 called early in the command handling process, and modifications in this
 event (via {@link #setCommand(String)}) will be shown in the behavior.
 <p>
 Many plugins will have <b>no use for this event</b>, and you should
 attempt to avoid using it if it is not necessary.
 <p>
 Some examples of valid uses for this event are:
 <ul>
 <li>Logging executed commands to a separate file
 <li>Variable substitution. For example, replacing <code>${ip:Steve}</code>
     with the connection IP of the player named Steve, or simulating the
     <code>@a</code> and <code>@p</code> decorators used by Command Blocks
     for plugins that do not handle it.
 <li>Conditionally blocking commands belonging to other plugins.
 <li>Per-sender command aliases. For example, after the console runs the
     command <code>/calias cr gamemode creative</code>, the next time they
     run <code>/cr</code>, it gets replaced into
     <code>/gamemode creative</code>. (Global command aliases should be
     done by registering the alias.)
 </ul>
 <p>
 Examples of incorrect uses are:
 <ul>
 <li>Using this event to run command logic
 </ul>
 <p>
 If the event is cancelled, processing of the command will halt.
 <p>
 The state of whether or not there is a slash (<code>/</code>) at the
 beginning of the message should be preserved. If a slash is added or
 removed, unexpected behavior may result.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.ServerCommandEvent -->
  <!-- start class org.bukkit.event.server.ServerEvent -->
  <class name="ServerEvent" extends="org.bukkit.event.Event"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerEvent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerEvent" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Miscellaneous server events]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.ServerEvent -->
  <!-- start class org.bukkit.event.server.ServerListPingEvent -->
  <class name="ServerListPingEvent" extends="org.bukkit.event.server.ServerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable&lt;org.bukkit.entity.Player&gt;"/>
    <constructor name="ServerListPingEvent" type="java.net.InetAddress, java.lang.String, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServerListPingEvent" type="java.net.InetAddress, java.lang.String, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constructor is intended for implementations that provide the
 {@link #iterator()} method, thus provided the {@link #getNumPlayers()}
 count.

 @param address the address of the pinger
 @param motd the message of the day
 @param maxPlayers the max number of players]]>
      </doc>
    </constructor>
    <method name="getAddress" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the address the ping is coming from.

 @return the address]]>
      </doc>
    </method>
    <method name="getMotd" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the message of the day message.

 @return the message of the day]]>
      </doc>
    </method>
    <method name="setMotd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="motd" type="java.lang.String"/>
      <doc>
      <![CDATA[Change the message of the day message.

 @param motd the message of the day]]>
      </doc>
    </method>
    <method name="getNumPlayers" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of players sent.

 @return the number of players]]>
      </doc>
    </method>
    <method name="getMaxPlayers" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum number of players sent.

 @return the maximum number of players]]>
      </doc>
    </method>
    <method name="setMaxPlayers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxPlayers" type="int"/>
      <doc>
      <![CDATA[Set the maximum number of players sent.

 @param maxPlayers the maximum number of player]]>
      </doc>
    </method>
    <method name="setServerIcon"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="icon" type="org.bukkit.util.CachedServerIcon"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Sets the server-icon sent to the client.

 @param icon the icon to send to the client
 @throws IllegalArgumentException if the {@link CachedServerIcon} is not
     created by the caller of this event; null may be accepted for some
     implementations
 @throws UnsupportedOperationException if the caller of this event does
     not support setting the server icon]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator&lt;org.bukkit.entity.Player&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p>
 Calling the {@link Iterator#remove()} method will force that particular
 player to not be displayed on the player list, decrease the size
 returned by {@link #getNumPlayers()}, and will not be returned again by
 any new iterator.

 @throws UnsupportedOperationException if the caller of this event does
     not support removing players]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when a server list ping is coming in. Displayed players can be
 checked and removed by {@link #iterator() iterating} over this event.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.ServerListPingEvent -->
  <!-- start class org.bukkit.event.server.ServerLoadEvent -->
  <class name="ServerLoadEvent" extends="org.bukkit.event.server.ServerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerLoadEvent" type="org.bukkit.event.server.ServerLoadEvent.LoadType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code ServerLoadEvent} with a given loading type.

 @param type the context in which the server was loaded]]>
      </doc>
    </constructor>
    <method name="getType" return="org.bukkit.event.server.ServerLoadEvent.LoadType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the context in which the server was loaded.

 @return the context in which the server was loaded]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when either the server startup or reload has completed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.ServerLoadEvent -->
  <!-- start class org.bukkit.event.server.ServerLoadEvent.LoadType -->
  <class name="ServerLoadEvent.LoadType" extends="java.lang.Enum&lt;org.bukkit.event.server.ServerLoadEvent.LoadType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.server.ServerLoadEvent.LoadType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.server.ServerLoadEvent.LoadType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the context in which the enclosing event has been completed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.ServerLoadEvent.LoadType -->
  <!-- start class org.bukkit.event.server.ServiceEvent -->
  <class name="ServiceEvent" extends="org.bukkit.event.server.ServerEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceEvent" type="org.bukkit.plugin.RegisteredServiceProvider&lt;?&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getProvider" return="org.bukkit.plugin.RegisteredServiceProvider&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An event relating to a registered service. This is called in a {@link
 org.bukkit.plugin.ServicesManager}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.ServiceEvent -->
  <!-- start class org.bukkit.event.server.ServiceRegisterEvent -->
  <class name="ServiceRegisterEvent" extends="org.bukkit.event.server.ServiceEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceRegisterEvent" type="org.bukkit.plugin.RegisteredServiceProvider&lt;?&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when a service is registered.
 <p>
 Warning: The order in which register and unregister events are called
 should not be relied upon.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.ServiceRegisterEvent -->
  <!-- start class org.bukkit.event.server.ServiceUnregisterEvent -->
  <class name="ServiceUnregisterEvent" extends="org.bukkit.event.server.ServiceEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceUnregisterEvent" type="org.bukkit.plugin.RegisteredServiceProvider&lt;?&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This event is called when a service is unregistered.
 <p>
 Warning: The order in which register and unregister events are called
 should not be relied upon.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.ServiceUnregisterEvent -->
  <!-- start class org.bukkit.event.server.TabCompleteEvent -->
  <class name="TabCompleteEvent" extends="org.bukkit.event.Event"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="TabCompleteEvent" type="org.bukkit.command.CommandSender, java.lang.String, java.util.List&lt;java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TabCompleteEvent" type="org.bukkit.command.CommandSender, java.lang.String, java.util.List&lt;java.lang.String&gt;, boolean, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSender" return="org.bukkit.command.CommandSender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the sender completing this command.

 @return the {@link CommandSender} instance]]>
      </doc>
    </method>
    <method name="getBuffer" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the entire buffer which formed the basis of this completion.

 @return command buffer, as entered]]>
      </doc>
    </method>
    <method name="getCompletions" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The list of completions which will be offered to the sender, in order.
 This list is mutable and reflects what will be offered.

 @return a list of offered completions]]>
      </doc>
    </method>
    <method name="isCommand" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return True if it is a command being tab completed, false if it is a chat message.]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The position looked at by the sender, or null if none]]>
      </doc>
    </method>
    <method name="setCompletions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="completions" type="java.util.List&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Set the completions offered, overriding any already set.

 The passed collection will be cloned to a new List. You must call {{@link #getCompletions()}} to mutate from here

 @param completions the new completions]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a {@link CommandSender} of any description (ie: player or
 console) attempts to tab complete.
 <br>
 Note that due to client changes, if the sender is a Player, this event will
 only begin to fire once command arguments are specified, not commands
 themselves. Plugins wishing to remove commands from tab completion are
 advised to ensure the client does not have permission for the relevant
 commands, or use {@link PlayerCommandSendEvent}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.server.TabCompleteEvent -->
</package>
<package name="org.bukkit.event.vehicle">
  <!-- start class org.bukkit.event.vehicle.VehicleBlockCollisionEvent -->
  <class name="VehicleBlockCollisionEvent" extends="org.bukkit.event.vehicle.VehicleCollisionEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VehicleBlockCollisionEvent" type="org.bukkit.entity.Vehicle, org.bukkit.block.Block"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block the vehicle collided with

 @return the block the vehicle collided with]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Raised when a vehicle collides with a block.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleBlockCollisionEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleCollisionEvent -->
  <class name="VehicleCollisionEvent" extends="org.bukkit.event.vehicle.VehicleEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VehicleCollisionEvent" type="org.bukkit.entity.Vehicle"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Raised when a vehicle collides.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleCollisionEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleCreateEvent -->
  <class name="VehicleCreateEvent" extends="org.bukkit.event.vehicle.VehicleEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VehicleCreateEvent" type="org.bukkit.entity.Vehicle"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancelled" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Raised when a vehicle is created.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleCreateEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleDamageEvent -->
  <class name="VehicleDamageEvent" extends="org.bukkit.event.vehicle.VehicleEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VehicleDamageEvent" type="org.bukkit.entity.Vehicle, org.bukkit.entity.Entity, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAttacker" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Entity that is attacking the vehicle

 @return the Entity that is attacking the vehicle]]>
      </doc>
    </method>
    <method name="getDamage" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the damage done to the vehicle

 @return the damage done to the vehicle]]>
      </doc>
    </method>
    <method name="setDamage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="double"/>
      <doc>
      <![CDATA[Sets the damage done to the vehicle

 @param damage The damage]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Raised when a vehicle receives damage.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleDamageEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleDestroyEvent -->
  <class name="VehicleDestroyEvent" extends="org.bukkit.event.vehicle.VehicleEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VehicleDestroyEvent" type="org.bukkit.entity.Vehicle, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAttacker" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Entity that has destroyed the vehicle, potentially null

 @return the Entity that has destroyed the vehicle, potentially null]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Raised when a vehicle is destroyed, which could be caused by either a
 player or the environment. This is not raised if the boat is simply
 'removed' due to other means.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleDestroyEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleEnterEvent -->
  <class name="VehicleEnterEvent" extends="org.bukkit.event.vehicle.VehicleEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VehicleEnterEvent" type="org.bukkit.entity.Vehicle, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntered" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Entity that entered the vehicle.

 @return the Entity that entered the vehicle]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Raised when an entity enters a vehicle.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleEnterEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleEntityCollisionEvent -->
  <class name="VehicleEntityCollisionEvent" extends="org.bukkit.event.vehicle.VehicleCollisionEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VehicleEntityCollisionEvent" type="org.bukkit.entity.Vehicle, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="isPickupCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPickupCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="isCollisionCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCollisionCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Raised when a vehicle collides with an entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleEntityCollisionEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleEvent -->
  <class name="VehicleEvent" extends="org.bukkit.event.Event"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VehicleEvent" type="org.bukkit.entity.Vehicle"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getVehicle" return="org.bukkit.entity.Vehicle"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the vehicle.

 @return the vehicle]]>
      </doc>
    </method>
    <field name="vehicle" type="org.bukkit.entity.Vehicle"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a vehicle-related event.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleExitEvent -->
  <class name="VehicleExitEvent" extends="org.bukkit.event.vehicle.VehicleEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="VehicleExitEvent" type="org.bukkit.entity.Vehicle, org.bukkit.entity.LivingEntity, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="VehicleExitEvent" type="org.bukkit.entity.Vehicle, org.bukkit.entity.LivingEntity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExited" return="org.bukkit.entity.LivingEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the living entity that exited the vehicle.

 @return The entity.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="isCancellable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Raised when a living entity exits a vehicle.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleExitEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleMoveEvent -->
  <class name="VehicleMoveEvent" extends="org.bukkit.event.vehicle.VehicleEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VehicleMoveEvent" type="org.bukkit.entity.Vehicle, org.bukkit.Location, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFrom" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the previous position.

 @return Old position.]]>
      </doc>
    </method>
    <method name="getTo" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the next position.

 @return New position.]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Raised when a vehicle moves.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleMoveEvent -->
  <!-- start class org.bukkit.event.vehicle.VehicleUpdateEvent -->
  <class name="VehicleUpdateEvent" extends="org.bukkit.event.vehicle.VehicleEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VehicleUpdateEvent" type="org.bukkit.entity.Vehicle"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a vehicle updates]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.vehicle.VehicleUpdateEvent -->
</package>
<package name="org.bukkit.event.weather">
  <!-- start class org.bukkit.event.weather.LightningStrikeEvent -->
  <class name="LightningStrikeEvent" extends="org.bukkit.event.weather.WeatherEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="LightningStrikeEvent" type="org.bukkit.World, org.bukkit.entity.LightningStrike"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LightningStrikeEvent" type="org.bukkit.World, org.bukkit.entity.LightningStrike, org.bukkit.event.weather.LightningStrikeEvent.Cause"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getLightning" return="org.bukkit.entity.LightningStrike"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the bolt which is striking the earth.

 @return lightning entity]]>
      </doc>
    </method>
    <method name="getCause" return="org.bukkit.event.weather.LightningStrikeEvent.Cause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the cause of this lightning strike.

 @return strike cause]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Stores data for lightning striking]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.weather.LightningStrikeEvent -->
  <!-- start class org.bukkit.event.weather.LightningStrikeEvent.Cause -->
  <class name="LightningStrikeEvent.Cause" extends="java.lang.Enum&lt;org.bukkit.event.weather.LightningStrikeEvent.Cause&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.weather.LightningStrikeEvent.Cause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.weather.LightningStrikeEvent.Cause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.event.weather.LightningStrikeEvent.Cause -->
  <!-- start class org.bukkit.event.weather.ThunderChangeEvent -->
  <class name="ThunderChangeEvent" extends="org.bukkit.event.weather.WeatherEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="ThunderChangeEvent" type="org.bukkit.World, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="toThunderState" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the state of thunder that the world is being set to

 @return true if the weather is being set to thundering, false otherwise]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Stores data for thunder state changing in a world]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.weather.ThunderChangeEvent -->
  <!-- start class org.bukkit.event.weather.WeatherChangeEvent -->
  <class name="WeatherChangeEvent" extends="org.bukkit.event.weather.WeatherEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="WeatherChangeEvent" type="org.bukkit.World, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="toWeatherState" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the state of weather that the world is being set to

 @return true if the weather is being set to raining, false otherwise]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Stores data for weather changing in a world]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.weather.WeatherChangeEvent -->
  <!-- start class org.bukkit.event.weather.WeatherEvent -->
  <class name="WeatherEvent" extends="org.bukkit.event.Event"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WeatherEvent" type="org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getWorld" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the World where this event is occurring

 @return World this event is occurring in]]>
      </doc>
    </method>
    <field name="world" type="org.bukkit.World"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a Weather-related event]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.weather.WeatherEvent -->
</package>
<package name="org.bukkit.event.world">
  <!-- start class org.bukkit.event.world.ChunkEvent -->
  <class name="ChunkEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChunkEvent" type="org.bukkit.Chunk"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getChunk" return="org.bukkit.Chunk"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chunk being loaded/unloaded

 @return Chunk that triggered this event]]>
      </doc>
    </method>
    <field name="chunk" type="org.bukkit.Chunk"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a Chunk related event]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.ChunkEvent -->
  <!-- start class org.bukkit.event.world.ChunkLoadEvent -->
  <class name="ChunkLoadEvent" extends="org.bukkit.event.world.ChunkEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChunkLoadEvent" type="org.bukkit.Chunk, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNewChunk" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if this chunk was newly created or not.
 <p>
 Note that if this chunk is new, it will not be populated at this time.

 @return true if the chunk is new, otherwise false]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a chunk is loaded]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.ChunkLoadEvent -->
  <!-- start class org.bukkit.event.world.ChunkPopulateEvent -->
  <class name="ChunkPopulateEvent" extends="org.bukkit.event.world.ChunkEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChunkPopulateEvent" type="org.bukkit.Chunk"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a new chunk has finished being populated.
 <p>
 If your intent is to populate the chunk using this event, please see {@link
 BlockPopulator}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.ChunkPopulateEvent -->
  <!-- start class org.bukkit.event.world.ChunkUnloadEvent -->
  <class name="ChunkUnloadEvent" extends="org.bukkit.event.world.ChunkEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChunkUnloadEvent" type="org.bukkit.Chunk"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ChunkUnloadEvent" type="org.bukkit.Chunk, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isSaveChunk" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return whether this chunk will be saved to disk.

 @return chunk save status]]>
      </doc>
    </method>
    <method name="setSaveChunk"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="saveChunk" type="boolean"/>
      <doc>
      <![CDATA[Set whether this chunk will be saved to disk.

 @param saveChunk chunk save status]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a chunk is unloaded]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.ChunkUnloadEvent -->
  <!-- start class org.bukkit.event.world.LootGenerateEvent -->
  <class name="LootGenerateEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="LootGenerateEvent" type="org.bukkit.World, org.bukkit.entity.Entity, org.bukkit.inventory.InventoryHolder, org.bukkit.loot.LootTable, org.bukkit.loot.LootContext, java.util.List&lt;org.bukkit.inventory.ItemStack&gt;, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the entity used as context for loot generation (if applicable).

 For inventories where entities are not required to generate loot, such as
 hoppers, null will be returned.

 This is a convenience method for
 {@code getLootContext().getLootedEntity()}.

 @return the entity]]>
      </doc>
    </method>
    <method name="getInventoryHolder" return="org.bukkit.inventory.InventoryHolder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the inventory holder in which the loot was generated.

 If the loot was generated as a result of the block being broken, the
 inventory holder will be null as this event is called post block break.

 @return the inventory holder]]>
      </doc>
    </method>
    <method name="getLootTable" return="org.bukkit.loot.LootTable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the loot table used to generate loot.

 @return the loot table]]>
      </doc>
    </method>
    <method name="getLootContext" return="org.bukkit.loot.LootContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the loot context used to provide context to the loot table's loot
 generation.

 @return the loot context]]>
      </doc>
    </method>
    <method name="setLoot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loot" type="java.util.Collection&lt;org.bukkit.inventory.ItemStack&gt;"/>
      <doc>
      <![CDATA[Set the loot to be generated. Null items will be treated as air.

 Note: the set collection is not the one which will be returned by
 {@link #getLoot()}.

 @param loot the loot to generate, null to clear all loot]]>
      </doc>
    </method>
    <method name="getLoot" return="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a mutable list of all loot to be generated.

 Any items added or removed from the returned list will be reflected in
 the loot generation. Null items will be treated as air.

 @return the loot to generate]]>
      </doc>
    </method>
    <method name="isPlugin" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check whether or not this event was called as a result of a plugin
 invoking
 {@link LootTable#fillInventory(org.bukkit.inventory.Inventory, java.util.Random, LootContext)}.

 @return true if plugin caused, false otherwise]]>
      </doc>
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a {@link LootTable} is generated in the world for an
 {@link InventoryHolder}.

 This event is NOT currently called when an entity's loot table has been
 generated (use {@link EntityDeathEvent#getDrops()}, but WILL be called by
 plugins invoking
 {@link LootTable#fillInventory(org.bukkit.inventory.Inventory, java.util.Random, LootContext)}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.LootGenerateEvent -->
  <!-- start class org.bukkit.event.world.PortalCreateEvent -->
  <class name="PortalCreateEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="PortalCreateEvent" type="java.util.List&lt;org.bukkit.block.BlockState&gt;, org.bukkit.World, org.bukkit.event.world.PortalCreateEvent.CreateReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PortalCreateEvent" type="java.util.List&lt;org.bukkit.block.BlockState&gt;, org.bukkit.World, org.bukkit.entity.Entity, org.bukkit.event.world.PortalCreateEvent.CreateReason"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlocks" return="java.util.List&lt;org.bukkit.block.BlockState&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an array list of all the blocks associated with the created portal

 @return array list of all the blocks associated with the created portal]]>
      </doc>
    </method>
    <method name="getEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Entity that triggered this portal creation (if available)

 @return Entity involved in this event]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getReason" return="org.bukkit.event.world.PortalCreateEvent.CreateReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason for the portal's creation

 @return CreateReason for the portal's creation]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a portal is created]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.PortalCreateEvent -->
  <!-- start class org.bukkit.event.world.PortalCreateEvent.CreateReason -->
  <class name="PortalCreateEvent.CreateReason" extends="java.lang.Enum&lt;org.bukkit.event.world.PortalCreateEvent.CreateReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.world.PortalCreateEvent.CreateReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.world.PortalCreateEvent.CreateReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum to specify the various reasons for a portal's creation]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.PortalCreateEvent.CreateReason -->
  <!-- start class org.bukkit.event.world.SpawnChangeEvent -->
  <class name="SpawnChangeEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SpawnChangeEvent" type="org.bukkit.World, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPreviousLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the previous spawn location

 @return Location that used to be spawn]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An event that is called when a world's spawn changes. The world's previous
 spawn location is included.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.SpawnChangeEvent -->
  <!-- start class org.bukkit.event.world.StructureGrowEvent -->
  <class name="StructureGrowEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="StructureGrowEvent" type="org.bukkit.Location, org.bukkit.TreeType, boolean, org.bukkit.entity.Player, java.util.List&lt;org.bukkit.block.BlockState&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location of the structure.

 @return Location of the structure]]>
      </doc>
    </method>
    <method name="getSpecies" return="org.bukkit.TreeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the species type (birch, normal, pine, red mushroom, brown
 mushroom)

 @return Structure species]]>
      </doc>
    </method>
    <method name="isFromBonemeal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if structure was grown using bonemeal.

 @return True if the structure was grown using bonemeal.]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.Player"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player that created the structure.

 @return Player that created the structure, null if was not created
     manually]]>
      </doc>
    </method>
    <method name="getBlocks" return="java.util.List&lt;org.bukkit.block.BlockState&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of all blocks associated with the structure.

 @return list of all blocks associated with the structure.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Event that is called when an organic structure attempts to grow (Sapling {@literal ->}
 Tree), (Mushroom {@literal ->} Huge Mushroom), naturally or using bonemeal.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.StructureGrowEvent -->
  <!-- start class org.bukkit.event.world.TimeSkipEvent -->
  <class name="TimeSkipEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="TimeSkipEvent" type="org.bukkit.World, org.bukkit.event.world.TimeSkipEvent.SkipReason, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSkipReason" return="org.bukkit.event.world.TimeSkipEvent.SkipReason"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the reason why the time has skipped.

 @return a SkipReason value detailing why the time has skipped]]>
      </doc>
    </method>
    <method name="getSkipAmount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of time that was skipped.

 @return Amount of time skipped]]>
      </doc>
    </method>
    <method name="setSkipAmount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="skipAmount" type="long"/>
      <doc>
      <![CDATA[Sets the amount of time to skip.

 @param skipAmount Amount of time to skip]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when the time skips in a world.
 <p>
 If the event is cancelled the time will not change.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.TimeSkipEvent -->
  <!-- start class org.bukkit.event.world.TimeSkipEvent.SkipReason -->
  <class name="TimeSkipEvent.SkipReason" extends="java.lang.Enum&lt;org.bukkit.event.world.TimeSkipEvent.SkipReason&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.event.world.TimeSkipEvent.SkipReason[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.event.world.TimeSkipEvent.SkipReason"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enum specifying the reason the time skipped.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.TimeSkipEvent.SkipReason -->
  <!-- start class org.bukkit.event.world.WorldEvent -->
  <class name="WorldEvent" extends="org.bukkit.event.Event"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WorldEvent" type="org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getWorld" return="org.bukkit.World"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the world primarily involved with this event

 @return World which caused this event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents events within a world]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.WorldEvent -->
  <!-- start class org.bukkit.event.world.WorldInitEvent -->
  <class name="WorldInitEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WorldInitEvent" type="org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a World is initializing]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.WorldInitEvent -->
  <!-- start class org.bukkit.event.world.WorldLoadEvent -->
  <class name="WorldLoadEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WorldLoadEvent" type="org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a World is loaded]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.WorldLoadEvent -->
  <!-- start class org.bukkit.event.world.WorldSaveEvent -->
  <class name="WorldSaveEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WorldSaveEvent" type="org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a World is saved.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.WorldSaveEvent -->
  <!-- start class org.bukkit.event.world.WorldUnloadEvent -->
  <class name="WorldUnloadEvent" extends="org.bukkit.event.world.WorldEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="WorldUnloadEvent" type="org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when a World is unloaded]]>
    </doc>
  </class>
  <!-- end class org.bukkit.event.world.WorldUnloadEvent -->
</package>
<package name="org.bukkit.generator">
  <!-- start class org.bukkit.generator.BlockPopulator -->
  <class name="BlockPopulator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockPopulator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="populate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="random" type="java.util.Random"/>
      <param name="source" type="org.bukkit.Chunk"/>
      <doc>
      <![CDATA[Populates an area of blocks at or around the given chunk.
 <p>
 The chunks on each side of the specified chunk must already exist; that
 is, there must be one north, east, south and west of the specified
 chunk. The "corner" chunks may not exist, in which scenario the
 populator should record any changes required for those chunks and
 perform the changes when they are ready.

 @param world The world to generate in
 @param random The random generator to use
 @param source The chunk to generate for]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A block populator is responsible for generating a small area of blocks.
 <p>
 For example, generating glowstone inside the nether or generating dungeons
 full of treasure]]>
    </doc>
  </class>
  <!-- end class org.bukkit.generator.BlockPopulator -->
  <!-- start class org.bukkit.generator.ChunkGenerator -->
  <class name="ChunkGenerator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChunkGenerator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="generateChunkData" return="org.bukkit.generator.ChunkGenerator.ChunkData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="random" type="java.util.Random"/>
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="biome" type="org.bukkit.generator.ChunkGenerator.BiomeGrid"/>
      <doc>
      <![CDATA[Shapes the chunk for the given coordinates.

 This method must return a ChunkData.
 <p>
 Notes:
 <p>
 This method should <b>never</b> attempt to get the Chunk at
 the passed coordinates, as doing so may cause an infinite loop
 <p>
 This method should <b>never</b> modify a ChunkData after it has
 been returned.
 <p>
 This method <b>must</b> return a ChunkData returned by {@link ChunkGenerator#createChunkData(org.bukkit.World)}

 @param world The world this chunk will be used for
 @param random The random generator to use
 @param x The X-coordinate of the chunk
 @param z The Z-coordinate of the chunk
 @param biome Proposed biome values for chunk - can be updated by
     generator
 @return ChunkData containing the types for each block created by this
     generator]]>
      </doc>
    </method>
    <method name="createChunkData" return="org.bukkit.generator.ChunkGenerator.ChunkData"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Create a ChunkData for a world.
 @param world the world the ChunkData is for
 @return a new ChunkData for world]]>
      </doc>
    </method>
    <method name="canSpawn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Tests if the specified location is valid for a natural spawn position

 @param world The world we're testing on
 @param x X-coordinate of the block to test
 @param z Z-coordinate of the block to test
 @return true if the location is valid, otherwise false]]>
      </doc>
    </method>
    <method name="getDefaultPopulators" return="java.util.List&lt;org.bukkit.generator.BlockPopulator&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Gets a list of default {@link BlockPopulator}s to apply to a given
 world

 @param world World to apply to
 @return List containing any amount of BlockPopulators]]>
      </doc>
    </method>
    <method name="getFixedSpawnLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="random" type="java.util.Random"/>
      <doc>
      <![CDATA[Gets a fixed spawn location to use for a given world.
 <p>
 A null value is returned if a world should not use a fixed spawn point,
 and will instead attempt to find one randomly.

 @param world The world to locate a spawn point for
 @param random Random generator to use in the calculation
 @return Location containing a new spawn point, otherwise null]]>
      </doc>
    </method>
    <method name="isParallelCapable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if this ChunkGenerator is parallel capable.

 See {@link ChunkGenerator} for more information.

 @return parallel capable status]]>
      </doc>
    </method>
    <method name="shouldGenerateCaves" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the server should generate Vanilla caves after this
 ChunkGenerator.

 @return true if the server should generate Vanilla caves]]>
      </doc>
    </method>
    <method name="shouldGenerateDecorations" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the server should generate Vanilla decorations after this
 ChunkGenerator.

 @return true if the server should generate Vanilla decorations]]>
      </doc>
    </method>
    <method name="shouldGenerateMobs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the server should generate Vanilla mobs after this
 ChunkGenerator.

 @return true if the server should generate Vanilla mobs]]>
      </doc>
    </method>
    <method name="shouldGenerateStructures" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if the server should generate Vanilla structures after this
 ChunkGenerator.

 @return true if the server should generate Vanilla structures]]>
      </doc>
    </method>
    <method name="createVanillaChunkData" return="org.bukkit.generator.ChunkGenerator.ChunkData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Create a ChunkData for use in a generator, that is populated by the vanilla generator for that world

 @param world the world to create the ChunkData for
 @param x the x coordinate of the chunk
 @param z the z coordinate of the chunk
 @return a new ChunkData for the world]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A chunk generator is responsible for the initial shaping of an entire
 chunk. For example, the nether chunk generator should shape netherrack and
 soulsand.

 By default only one thread will call
 {@link #generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
 at a time, although this may not necessarily be the main server thread.

 If your generator is capable of fully asynchronous generation, then
 {@link #isParallelCapable()} should be overridden accordingly to allow
 multiple concurrent callers.

 Some aspects of world generation can be delegated to the Vanilla generator.
 The methods {@link ChunkGenerator#shouldGenerateCaves()}, {@link ChunkGenerator#shouldGenerateDecorations()},
 {@link ChunkGenerator#shouldGenerateMobs()} and {@link ChunkGenerator#shouldGenerateStructures()} can be
 overridden to enable this.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.generator.ChunkGenerator -->
  <!-- start interface org.bukkit.generator.ChunkGenerator.BiomeGrid -->
  <interface name="ChunkGenerator.BiomeGrid"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getBiome" return="org.bukkit.block.Biome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="biomes are now 3-dimensional">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get biome at x, z within chunk being generated

 @param x - 0-15
 @param z - 0-15
 @return Biome value
 @deprecated biomes are now 3-dimensional]]>
      </doc>
    </method>
    <method name="getBiome" return="org.bukkit.block.Biome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get biome at x, z within chunk being generated

 @param x - 0-15
 @param y - 0-255
 @param z - 0-15
 @return Biome value]]>
      </doc>
    </method>
    <method name="setBiome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="biomes are now 3-dimensional">
      <param name="x" type="int"/>
      <param name="z" type="int"/>
      <param name="bio" type="org.bukkit.block.Biome"/>
      <doc>
      <![CDATA[Set biome at x, z within chunk being generated

 @param x - 0-15
 @param z - 0-15
 @param bio - Biome value
 @deprecated biomes are now 3-dimensional]]>
      </doc>
    </method>
    <method name="setBiome"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <param name="bio" type="org.bukkit.block.Biome"/>
      <doc>
      <![CDATA[Set biome at x, z within chunk being generated

 @param x - 0-15
 @param y - 0-255
 @param z - 0-15
 @param bio - Biome value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to biome section for chunk to be generated: initialized with
 default values for world type and seed.
 <p>
 Custom generator is free to access and tailor values during
 generateBlockSections() or generateExtBlockSections().]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.generator.ChunkGenerator.BiomeGrid -->
  <!-- start interface org.bukkit.generator.ChunkGenerator.ChunkData -->
  <interface name="ChunkGenerator.ChunkData"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMaxHeight" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum height for the chunk.

 Setting blocks at or above this height will do nothing.

 @return the maximum height]]>
      </doc>
    </method>
    <method name="setBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Set the block at x,y,z in the chunk data to material.

 Note: setting blocks outside the chunk's bounds does nothing.

 @param x the x location in the chunk from 0-15 inclusive
 @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
 @param z the z location in the chunk from 0-15 inclusive
 @param material the type to set the block to]]>
      </doc>
    </method>
    <method name="setBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <param name="material" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Set the block at x,y,z in the chunk data to material.

 Setting blocks outside the chunk's bounds does nothing.

 @param x the x location in the chunk from 0-15 inclusive
 @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
 @param z the z location in the chunk from 0-15 inclusive
 @param material the type to set the block to]]>
      </doc>
    </method>
    <method name="setBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <param name="blockData" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Set the block at x,y,z in the chunk data to material.

 Setting blocks outside the chunk's bounds does nothing.

 @param x the x location in the chunk from 0-15 inclusive
 @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
 @param z the z location in the chunk from 0-15 inclusive
 @param blockData the type to set the block to]]>
      </doc>
    </method>
    <method name="setRegion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xMin" type="int"/>
      <param name="yMin" type="int"/>
      <param name="zMin" type="int"/>
      <param name="xMax" type="int"/>
      <param name="yMax" type="int"/>
      <param name="zMax" type="int"/>
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Set a region of this chunk from xMin, yMin, zMin (inclusive)
 to xMax, yMax, zMax (exclusive) to material.

 Setting blocks outside the chunk's bounds does nothing.

 @param xMin minimum x location (inclusive) in the chunk to set
 @param yMin minimum y location (inclusive) in the chunk to set
 @param zMin minimum z location (inclusive) in the chunk to set
 @param xMax maximum x location (exclusive) in the chunk to set
 @param yMax maximum y location (exclusive) in the chunk to set
 @param zMax maximum z location (exclusive) in the chunk to set
 @param material the type to set the blocks to]]>
      </doc>
    </method>
    <method name="setRegion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xMin" type="int"/>
      <param name="yMin" type="int"/>
      <param name="zMin" type="int"/>
      <param name="xMax" type="int"/>
      <param name="yMax" type="int"/>
      <param name="zMax" type="int"/>
      <param name="material" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Set a region of this chunk from xMin, yMin, zMin (inclusive)
 to xMax, yMax, zMax (exclusive) to material.

 Setting blocks outside the chunk's bounds does nothing.

 @param xMin minimum x location (inclusive) in the chunk to set
 @param yMin minimum y location (inclusive) in the chunk to set
 @param zMin minimum z location (inclusive) in the chunk to set
 @param xMax maximum x location (exclusive) in the chunk to set
 @param yMax maximum y location (exclusive) in the chunk to set
 @param zMax maximum z location (exclusive) in the chunk to set
 @param material the type to set the blocks to]]>
      </doc>
    </method>
    <method name="setRegion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xMin" type="int"/>
      <param name="yMin" type="int"/>
      <param name="zMin" type="int"/>
      <param name="xMax" type="int"/>
      <param name="yMax" type="int"/>
      <param name="zMax" type="int"/>
      <param name="blockData" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Set a region of this chunk from xMin, yMin, zMin (inclusive) to xMax,
 yMax, zMax (exclusive) to material.

 Setting blocks outside the chunk's bounds does nothing.

 @param xMin minimum x location (inclusive) in the chunk to set
 @param yMin minimum y location (inclusive) in the chunk to set
 @param zMin minimum z location (inclusive) in the chunk to set
 @param xMax maximum x location (exclusive) in the chunk to set
 @param yMax maximum y location (exclusive) in the chunk to set
 @param zMax maximum z location (exclusive) in the chunk to set
 @param blockData the type to set the blocks to]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get the type of the block at x, y, z.

 Getting blocks outside the chunk's bounds returns air.

 @param x the x location in the chunk from 0-15 inclusive
 @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
 @param z the z location in the chunk from 0-15 inclusive
 @return the type of the block or Material.AIR if x, y or z are outside the chunk's bounds]]>
      </doc>
    </method>
    <method name="getTypeAndData" return="org.bukkit.material.MaterialData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get the type and data of the block at x, y, z.

 Getting blocks outside the chunk's bounds returns air.

 @param x the x location in the chunk from 0-15 inclusive
 @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
 @param z the z location in the chunk from 0-15 inclusive
 @return the type and data of the block or the MaterialData for air if x, y or z are outside the chunk's bounds]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get the type and data of the block at x, y, z.

 Getting blocks outside the chunk's bounds returns air.

 @param x the x location in the chunk from 0-15 inclusive
 @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
 @param z the z location in the chunk from 0-15 inclusive
 @return the data of the block or the BlockData for air if x, y or z are outside the chunk's bounds]]>
      </doc>
    </method>
    <method name="getData" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Uses magic values">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Get the block data at x,y,z in the chunk data.

 Getting blocks outside the chunk's bounds returns 0.

 @param x the x location in the chunk from 0-15 inclusive
 @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
 @param z the z location in the chunk from 0-15 inclusive
 @return the block data value or air if x, y or z are outside the chunk's bounds
 @deprecated Uses magic values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Data for a Chunk.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.generator.ChunkGenerator.ChunkData -->
</package>
<package name="org.bukkit.help">
  <!-- start class org.bukkit.help.GenericCommandHelpTopic -->
  <class name="GenericCommandHelpTopic" extends="org.bukkit.help.HelpTopic"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GenericCommandHelpTopic" type="org.bukkit.command.Command"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="canSee" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
    </method>
    <field name="command" type="org.bukkit.command.Command"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Lacking an alternative, the help system will create instances of
 GenericCommandHelpTopic for each command in the server's CommandMap. You
 can use this class as a base class for custom help topics, or as an example
 for how to write your own.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.help.GenericCommandHelpTopic -->
  <!-- start interface org.bukkit.help.HelpMap -->
  <interface name="HelpMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getHelpTopic" return="org.bukkit.help.HelpTopic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="topicName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a help topic for a given topic name.

 @param topicName The help topic name to look up.
 @return A {@link HelpTopic} object matching the topic name or null if
     none can be found.]]>
      </doc>
    </method>
    <method name="getHelpTopics" return="java.util.Collection&lt;org.bukkit.help.HelpTopic&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all the registered help topics.

 @return All the registered help topics.]]>
      </doc>
    </method>
    <method name="addTopic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="topic" type="org.bukkit.help.HelpTopic"/>
      <doc>
      <![CDATA[Adds a topic to the server's help index.

 @param topic The new help topic to add.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears out the contents of the help index. Normally called during
 server reload.]]>
      </doc>
    </method>
    <method name="registerHelpTopicFactory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="commandClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="factory" type="org.bukkit.help.HelpTopicFactory&lt;?&gt;"/>
      <doc>
      <![CDATA[Associates a {@link HelpTopicFactory} object with given command base
 class. Plugins typically call this method during {@code onLoad()}. Once
 registered, the custom HelpTopicFactory will be used to create a custom
 {@link HelpTopic} for all commands deriving from the {@code
 commandClass} base class, or all commands deriving from {@link
 org.bukkit.command.PluginCommand} who's executor derives from {@code
 commandClass} base class.

 @param commandClass The class for which the custom HelpTopicFactory
     applies. Must derive from either {@link org.bukkit.command.Command}
     or {@link org.bukkit.command.CommandExecutor}.
 @param factory The {@link HelpTopicFactory} implementation to associate
     with the {@code commandClass}.
 @throws IllegalArgumentException Thrown if {@code commandClass} does
     not derive from a legal base class.]]>
      </doc>
    </method>
    <method name="getIgnoredPlugins" return="java.util.List&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the list of plugins the server administrator has chosen to exclude
 from the help index. Plugin authors who choose to directly extend
 {@link org.bukkit.command.Command} instead of {@link
 org.bukkit.command.PluginCommand} will need to check this collection in
 their {@link HelpTopicFactory} implementations to ensure they meet the
 server administrator's expectations.

 @return A list of plugins that should be excluded from the help index.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The HelpMap tracks all help topics registered in a Bukkit server. When the
 server starts up or is reloaded, help is processed and topics are added in
 the following order:

 <ol>
 <li>General topics are loaded from the help.yml
 <li>Plugins load and optionally call {@code addTopic()}
 <li>Registered plugin commands are processed by {@link HelpTopicFactory}
     objects to create topics
 <li>Topic contents are amended as directed in help.yml
 </ol>]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.help.HelpMap -->
  <!-- start class org.bukkit.help.HelpTopic -->
  <class name="HelpTopic" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HelpTopic"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="canSee" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="player" type="org.bukkit.command.CommandSender"/>
      <doc>
      <![CDATA[Determines if a {@link Player} is allowed to see this help topic.
 <p>
 HelpTopic implementations should take server administrator wishes into
 account as set by the {@link HelpTopic#amendCanSee(String)} function.

 @param player The Player in question.
 @return True of the Player can see this help topic, false otherwise.]]>
      </doc>
    </method>
    <method name="amendCanSee"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amendedPermission" type="java.lang.String"/>
      <doc>
      <![CDATA[Allows the server administrator to override the permission required to
 see a help topic.
 <p>
 HelpTopic implementations should take this into account when
 determining topic visibility on the {@link
 HelpTopic#canSee(org.bukkit.command.CommandSender)} function.

 @param amendedPermission The permission node the server administrator
     wishes to apply to this topic.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this help topic.

 @return The topic name.]]>
      </doc>
    </method>
    <method name="getShortText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a brief description that will be displayed in the topic index.

 @return A brief topic description.]]>
      </doc>
    </method>
    <method name="getFullText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWho" type="org.bukkit.command.CommandSender"/>
      <doc>
      <![CDATA[Returns the full description of this help topic that is displayed when
 the user requests this topic's details.
 <p>
 The result will be paginated to properly fit the user's client.

 @param forWho The player or console requesting the full text. Useful
     for further security trimming the command's full text based on
     sub-permissions in custom implementations.

 @return A full topic description.]]>
      </doc>
    </method>
    <method name="amendTopic"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amendedShortText" type="java.lang.String"/>
      <param name="amendedFullText" type="java.lang.String"/>
      <doc>
      <![CDATA[Allows the server admin (or another plugin) to add or replace the
 contents of a help topic.
 <p>
 A null in either parameter will leave that part of the topic unchanged.
 In either amending parameter, the string {@literal <text>} is replaced
 with the existing contents in the help topic. Use this to append or
 prepend additional content into an automatically generated help topic.

 @param amendedShortText The new topic short text to use, or null to
     leave alone.
 @param amendedFullText The new topic full text to use, or null to leave
     alone.]]>
      </doc>
    </method>
    <method name="applyAmendment" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="baseText" type="java.lang.String"/>
      <param name="amendment" type="java.lang.String"/>
      <doc>
      <![CDATA[Developers implementing their own custom HelpTopic implementations can
 use this utility method to ensure their implementations comply with the
 expected behavior of the {@link HelpTopic#amendTopic(String, String)}
 method.

 @param baseText The existing text of the help topic.
 @param amendment The amending text from the amendTopic() method.
 @return The application of the amending text to the existing text,
     according to the expected rules of amendTopic().]]>
      </doc>
    </method>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="shortText" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="fullText" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="amendedPermission" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[HelpTopic implementations are displayed to the user when the user uses the
 /help command.
 <p>
 Custom implementations of this class can work at two levels. A simple
 implementation only needs to set the value of {@code name}, {@code
 shortText}, and {@code fullText} in the constructor. This base class will
 take care of the rest.
 <p>
 Complex implementations can be created by overriding the behavior of all
 the methods in this class.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.help.HelpTopic -->
  <!-- start class org.bukkit.help.HelpTopicComparator -->
  <class name="HelpTopicComparator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Comparator&lt;org.bukkit.help.HelpTopic&gt;"/>
    <method name="topicNameComparatorInstance" return="org.bukkit.help.HelpTopicComparator.TopicNameComparator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="helpTopicComparatorInstance" return="org.bukkit.help.HelpTopicComparator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lhs" type="org.bukkit.help.HelpTopic"/>
      <param name="rhs" type="org.bukkit.help.HelpTopic"/>
    </method>
    <doc>
    <![CDATA[Used to impose a custom total ordering on help topics.
 <p>
 All topics are listed in alphabetic order, but topics that start with a
 slash come after topics that don't.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.help.HelpTopicComparator -->
  <!-- start class org.bukkit.help.HelpTopicComparator.TopicNameComparator -->
  <class name="HelpTopicComparator.TopicNameComparator" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Comparator&lt;java.lang.String&gt;"/>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lhs" type="java.lang.String"/>
      <param name="rhs" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.help.HelpTopicComparator.TopicNameComparator -->
  <!-- start interface org.bukkit.help.HelpTopicFactory -->
  <interface name="HelpTopicFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createTopic" return="org.bukkit.help.HelpTopic"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="TCommand extends org.bukkit.command.Command"/>
      <doc>
      <![CDATA[This method accepts a command deriving from a custom command base class
 and constructs a custom HelpTopic for it.

 @param command The custom command to build a help topic for.
 @return A new custom help topic or {@code null} to intentionally NOT
     create a topic.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A HelpTopicFactory is used to create custom {@link HelpTopic} objects from
 commands that inherit from a common base class or have executors that
 inherit from a common base class. You can use a custom HelpTopic to change
 the way all the commands in your plugin display in the help. If your plugin
 implements a complex permissions system, a custom help topic may also be
 appropriate.
 <p>
 To automatically bind your plugin's commands to your custom HelpTopic
 implementation, first make sure all your commands or executors derive from
 a custom base class (it doesn't have to do anything). Next implement a
 custom HelpTopicFactory that accepts your custom command base class and
 instantiates an instance of your custom HelpTopic from it. Finally,
 register your HelpTopicFactory against your command base class using the
 {@link HelpMap#registerHelpTopicFactory(Class, HelpTopicFactory)} method.
 <p>
 As the help system iterates over all registered commands to make help
 topics, it first checks to see if there is a HelpTopicFactory registered
 for the command's base class. If so, the factory is used to make a help
 topic rather than a generic help topic. If no factory is found for the
 command's base class and the command derives from {@link
 org.bukkit.command.PluginCommand}, then the type of the command's executor
 is inspected looking for a registered HelpTopicFactory. Finally, if no
 factory is found, a generic help topic is created for the command.

 @param <TCommand> The base class for your custom commands.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.help.HelpTopicFactory -->
  <!-- start class org.bukkit.help.IndexHelpTopic -->
  <class name="IndexHelpTopic" extends="org.bukkit.help.HelpTopic"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IndexHelpTopic" type="java.lang.String, java.lang.String, java.lang.String, java.util.Collection&lt;org.bukkit.help.HelpTopic&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IndexHelpTopic" type="java.lang.String, java.lang.String, java.lang.String, java.util.Collection&lt;org.bukkit.help.HelpTopic&gt;, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setTopicsCollection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="topics" type="java.util.Collection&lt;org.bukkit.help.HelpTopic&gt;"/>
      <doc>
      <![CDATA[Sets the contents of the internal allTopics collection.

 @param topics The topics to set.]]>
      </doc>
    </method>
    <method name="canSee" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
    </method>
    <method name="amendCanSee"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amendedPermission" type="java.lang.String"/>
    </method>
    <method name="getFullText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
    </method>
    <method name="buildPreamble" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <doc>
      <![CDATA[Builds the topic preamble. Override this method to change how the index
 preamble looks.

 @param sender The command sender requesting the preamble.
 @return The topic preamble.]]>
      </doc>
    </method>
    <method name="buildIndexLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="topic" type="org.bukkit.help.HelpTopic"/>
      <doc>
      <![CDATA[Builds individual lines in the index topic. Override this method to
 change how index lines are rendered.

 @param sender The command sender requesting the index line.
 @param topic  The topic to render into an index line.
 @return The rendered index line.]]>
      </doc>
    </method>
    <field name="permission" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="preamble" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="allTopics" type="java.util.Collection&lt;org.bukkit.help.HelpTopic&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This help topic generates a list of other help topics. This class is useful
 for adding your own index help topics. To enforce a particular order, use a
 sorted collection.
 <p>
 If a preamble is provided to the constructor, that text will be displayed
 before the first item in the index.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.help.IndexHelpTopic -->
</package>
<package name="org.bukkit.inventory">
  <!-- start interface org.bukkit.inventory.AbstractHorseInventory -->
  <interface name="AbstractHorseInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getSaddle" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item in the horse's saddle slot.

 @return the saddle item]]>
      </doc>
    </method>
    <method name="setSaddle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item in the horse's saddle slot.

 @param stack the new item]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface to the inventory of an {@link AbstractHorse}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.AbstractHorseInventory -->
  <!-- start interface org.bukkit.inventory.AnvilInventory -->
  <interface name="AnvilInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getRenameText" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name to be applied to the repaired item. An empty string denotes
 the default item name.

 @return the rename text]]>
      </doc>
    </method>
    <method name="getRepairCost" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the experience cost (in levels) to complete the current repair.

 @return the experience cost]]>
      </doc>
    </method>
    <method name="setRepairCost"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="levels" type="int"/>
      <doc>
      <![CDATA[Set the experience cost (in levels) to complete the current repair.

 @param levels the experience cost]]>
      </doc>
    </method>
    <method name="getMaximumRepairCost" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum experience cost (in levels) to be allowed by the current
 repair. If the result of {@link #getRepairCost()} exceeds the returned
 value, the repair result will be air to due being "too expensive".
 <p>
 By default, this level is set to 40. Players in creative mode ignore the
 maximum repair cost.

 @return the maximum experience cost]]>
      </doc>
    </method>
    <method name="setMaximumRepairCost"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="levels" type="int"/>
      <doc>
      <![CDATA[Set the maximum experience cost (in levels) to be allowed by the current
 repair. The default value set by vanilla Minecraft is 40.

 @param levels the maximum experience cost]]>
      </doc>
    </method>
    <method name="getFirstItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item in the left input slot.

 @return item in the first slot]]>
      </doc>
    </method>
    <method name="setFirstItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="firstItem" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item in the left input slot.

 @param firstItem item to set]]>
      </doc>
    </method>
    <method name="getSecondItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item in the right input slot.

 @return item in the second slot]]>
      </doc>
    </method>
    <method name="setSecondItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="secondItem" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item in the right input slot.

 @param secondItem item to set]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item in the result slot.

 @return item in the result slot]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item in the result slot.
 Note that the client might not be able to take out the item if it does not match the input items.

 @param result item to set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the inventory of an Anvil.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.AnvilInventory -->
  <!-- start interface org.bukkit.inventory.ArmoredHorseInventory -->
  <interface name="ArmoredHorseInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.AbstractHorseInventory"/>
    <method name="getArmor" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item in the horse's armor slot.

 @return the armor item]]>
      </doc>
    </method>
    <method name="setArmor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item in the horse's armor slot.

 @param stack the new item]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.inventory.ArmoredHorseInventory -->
  <!-- start interface org.bukkit.inventory.BeaconInventory -->
  <interface name="BeaconInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the item powering the beacon.

 @param item The new item]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the item powering the beacon.

 @return The current item.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Beacon.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.BeaconInventory -->
  <!-- start class org.bukkit.inventory.BlastingRecipe -->
  <class name="BlastingRecipe" extends="org.bukkit.inventory.CookingRecipe&lt;org.bukkit.inventory.BlastingRecipe&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlastingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.Material, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlastingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.inventory.RecipeChoice, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Represents a campfire recipe.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.BlastingRecipe -->
  <!-- start interface org.bukkit.inventory.BlockInventoryHolder -->
  <interface name="BlockInventoryHolder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.InventoryHolder"/>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block associated with this holder.

 @return the block associated with this holder
 @throws IllegalStateException if the holder is a block state and is not
 placed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a block inventory holder - either a BlockState, or a regular
 Block.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.BlockInventoryHolder -->
  <!-- start interface org.bukkit.inventory.BrewerInventory -->
  <interface name="BrewerInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getIngredient" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current ingredient for brewing.

 @return The ingredient.]]>
      </doc>
    </method>
    <method name="setIngredient"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ingredient" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the current ingredient for brewing.

 @param ingredient The ingredient]]>
      </doc>
    </method>
    <method name="getFuel" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current fuel for brewing.

 @return The fuel]]>
      </doc>
    </method>
    <method name="setFuel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fuel" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the current fuel for brewing. Generally only
 {@link Material#BLAZE_POWDER} will be of use.

 @param fuel The fuel]]>
      </doc>
    </method>
    <method name="getHolder" return="org.bukkit.block.BrewingStand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Brewing Stand.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.BrewerInventory -->
  <!-- start class org.bukkit.inventory.CampfireRecipe -->
  <class name="CampfireRecipe" extends="org.bukkit.inventory.CookingRecipe&lt;org.bukkit.inventory.CampfireRecipe&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CampfireRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.Material, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CampfireRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.inventory.RecipeChoice, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Represents a campfire recipe.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.CampfireRecipe -->
  <!-- start interface org.bukkit.inventory.CartographyInventory -->
  <interface name="CartographyInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <doc>
    <![CDATA[Interface to the inventory of a Cartography table.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.CartographyInventory -->
  <!-- start interface org.bukkit.inventory.ComplexRecipe -->
  <interface name="ComplexRecipe"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Recipe"/>
    <implements name="org.bukkit.Keyed"/>
    <doc>
    <![CDATA[Represents a complex recipe which has imperative server-defined behavior, eg
 armor dyeing.

 Note: Since a complex recipe has dynamic outputs, {@link #getResult()} will
 sometimes return an AIR ItemStack.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.ComplexRecipe -->
  <!-- start class org.bukkit.inventory.CookingRecipe -->
  <class name="CookingRecipe" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Recipe"/>
    <implements name="org.bukkit.Keyed"/>
    <constructor name="CookingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.Material, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a cooking recipe to craft the specified ItemStack.

 @param key The unique recipe key
 @param result The item you want the recipe to create.
 @param source The input material.
 @param experience The experience given by this recipe
 @param cookingTime The cooking time (in ticks)]]>
      </doc>
    </constructor>
    <constructor name="CookingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.inventory.RecipeChoice, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a cooking recipe to craft the specified ItemStack.

 @param key The unique recipe key
 @param result The item you want the recipe to create.
 @param input The input choices.
 @param experience The experience given by this recipe
 @param cookingTime The cooking time (in ticks)]]>
      </doc>
    </constructor>
    <method name="setInput" return="org.bukkit.inventory.CookingRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Sets the input of this cooking recipe.

 @param input The input material.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="getInput" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the input material.

 @return The input material.]]>
      </doc>
    </method>
    <method name="setInputChoice" return="T extends org.bukkit.inventory.CookingRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="org.bukkit.inventory.RecipeChoice"/>
      <doc>
      <![CDATA[Sets the input of this cooking recipe.

 @param input The input choice.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="getInputChoice" return="org.bukkit.inventory.RecipeChoice"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the input choice.

 @return The input choice.]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the result of this recipe.

 @return The resulting stack.]]>
      </doc>
    </method>
    <method name="setExperience"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="experience" type="float"/>
      <doc>
      <![CDATA[Sets the experience given by this recipe.

 @param experience the experience level]]>
      </doc>
    </method>
    <method name="getExperience" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the experience given by this recipe.

 @return experience level]]>
      </doc>
    </method>
    <method name="setCookingTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cookingTime" type="int"/>
      <doc>
      <![CDATA[Set the cooking time for this recipe in ticks.

 @param cookingTime new cooking time]]>
      </doc>
    </method>
    <method name="getCookingTime" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the cooking time for this recipe in ticks.

 @return cooking time]]>
      </doc>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGroup" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group of this recipe. Recipes with the same group may be grouped
 together when displayed in the client.

 @return recipe group. An empty string denotes no group. May not be null.]]>
      </doc>
    </method>
    <method name="setGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the group of this recipe. Recipes with the same group may be grouped
 together when displayed in the client.

 @param group recipe group. An empty string denotes no group. May not be
 null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a cooking recipe.
 @param <T> type of recipe]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.CookingRecipe -->
  <!-- start interface org.bukkit.inventory.CraftingInventory -->
  <interface name="CraftingInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check what item is in the result slot of this crafting inventory.

 @return The result item.]]>
      </doc>
    </method>
    <method name="getMatrix" return="org.bukkit.inventory.ItemStack[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the contents of the crafting matrix.

 @return The contents. Individual entries may be null.]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newResult" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the item in the result slot of the crafting inventory.

 @param newResult The new result item.]]>
      </doc>
    </method>
    <method name="setMatrix"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contents" type="org.bukkit.inventory.ItemStack[]"/>
      <doc>
      <![CDATA[Replace the contents of the crafting matrix

 @param contents The new contents. Individual entries may be null.
 @throws IllegalArgumentException if the length of contents is greater
     than the size of the crafting matrix.]]>
      </doc>
    </method>
    <method name="getRecipe" return="org.bukkit.inventory.Recipe"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current recipe formed on the crafting inventory, if any.

 @return The recipe, or null if the current contents don't match any
     recipe.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the crafting inventories]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.CraftingInventory -->
  <!-- start interface org.bukkit.inventory.DoubleChestInventory -->
  <interface name="DoubleChestInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getLeftSide" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the left half of this double chest.

 @return The left side inventory]]>
      </doc>
    </method>
    <method name="getRightSide" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the right side of this double chest.

 @return The right side inventory]]>
      </doc>
    </method>
    <method name="getHolder" return="org.bukkit.block.DoubleChest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Double Chest.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.DoubleChestInventory -->
  <!-- start interface org.bukkit.inventory.EnchantingInventory -->
  <interface name="EnchantingInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the item being enchanted.

 @param item The new item]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the item being enchanted.

 @return The current item.]]>
      </doc>
    </method>
    <method name="setSecondary"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the secondary item being used for the enchant.

 @param item The new item]]>
      </doc>
    </method>
    <method name="getSecondary" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the secondary item being used for the enchant.

 @return The second item]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the inventory of an Enchantment Table.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.EnchantingInventory -->
  <!-- start interface org.bukkit.inventory.EntityEquipment -->
  <interface name="EntityEquipment"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Stores the ItemStack at the given equipment slot in the inventory.

 @param slot the slot to put the ItemStack
 @param item the ItemStack to set]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <doc>
      <![CDATA[Gets the ItemStack at the given equipment slot in the inventory.

 @param slot the slot to get the ItemStack
 @return the ItemStack in the given slot]]>
      </doc>
    </method>
    <method name="getItemInMainHand" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the item the entity is currently holding
 in their main hand.

 @return the currently held item]]>
      </doc>
    </method>
    <method name="setItemInMainHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item the entity is holding in their main hand.

 @param item The item to put into the entities hand]]>
      </doc>
    </method>
    <method name="getItemInOffHand" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the item the entity is currently holding
 in their off hand.

 @return the currently held item]]>
      </doc>
    </method>
    <method name="setItemInOffHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item the entity is holding in their off hand.

 @param item The item to put into the entities hand]]>
      </doc>
    </method>
    <method name="getItemInHand" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="entities can duel wield now use the methods for the
      specific hand instead">
      <doc>
      <![CDATA[Gets a copy of the item the entity is currently holding

 @deprecated entities can duel wield now use the methods for the
      specific hand instead
 @see #getItemInMainHand()
 @see #getItemInOffHand()
 @return the currently held item]]>
      </doc>
    </method>
    <method name="setItemInHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="entities can duel wield now use the methods for the
      specific hand instead">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item the entity is holding

 @deprecated entities can duel wield now use the methods for the
      specific hand instead
 @see #setItemInMainHand(ItemStack)
 @see #setItemInOffHand(ItemStack)
 @param stack The item to put into the entities hand]]>
      </doc>
    </method>
    <method name="getHelmet" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the helmet currently being worn by the entity

 @return The helmet being worn]]>
      </doc>
    </method>
    <method name="setHelmet"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="helmet" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the helmet worn by the entity

 @param helmet The helmet to put on the entity]]>
      </doc>
    </method>
    <method name="getChestplate" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the chest plate currently being worn by the entity

 @return The chest plate being worn]]>
      </doc>
    </method>
    <method name="setChestplate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chestplate" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the chest plate worn by the entity

 @param chestplate The chest plate to put on the entity]]>
      </doc>
    </method>
    <method name="getLeggings" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the leggings currently being worn by the entity

 @return The leggings being worn]]>
      </doc>
    </method>
    <method name="setLeggings"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leggings" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the leggings worn by the entity

 @param leggings The leggings to put on the entity]]>
      </doc>
    </method>
    <method name="getBoots" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the boots currently being worn by the entity

 @return The boots being worn]]>
      </doc>
    </method>
    <method name="setBoots"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="boots" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the boots worn by the entity

 @param boots The boots to put on the entity]]>
      </doc>
    </method>
    <method name="getArmorContents" return="org.bukkit.inventory.ItemStack[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of all worn armor

 @return The array of worn armor. Individual items may be null.]]>
      </doc>
    </method>
    <method name="setArmorContents"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="items" type="org.bukkit.inventory.ItemStack[]"/>
      <doc>
      <![CDATA[Sets the entities armor to the provided array of ItemStacks

 @param items The items to set the armor as. Individual items may be null.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the entity of all armor and held items]]>
      </doc>
    </method>
    <method name="getItemInHandDropChance" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="entities can duel wield now use the methods for the specific
 hand instead">
      <doc>
      <![CDATA[@deprecated entities can duel wield now use the methods for the specific
 hand instead
 @see #getItemInMainHandDropChance()
 @see #getItemInOffHandDropChance()
 @return drop chance]]>
      </doc>
    </method>
    <method name="setItemInHandDropChance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="entities can duel wield now use the methods for the specific
 hand instead">
      <param name="chance" type="float"/>
      <doc>
      <![CDATA[@deprecated entities can duel wield now use the methods for the specific
 hand instead
 @see #setItemInMainHandDropChance(float)
 @see #setItemInOffHandDropChance(float)
 @param chance drop chance]]>
      </doc>
    </method>
    <method name="getItemInMainHandDropChance" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chance of the main hand item being dropped upon this creature's
 death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @return chance of the currently held item being dropped (1 for players)]]>
      </doc>
    </method>
    <method name="setItemInMainHandDropChance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chance" type="float"/>
      <doc>
      <![CDATA[Sets the chance of the item this creature is currently holding in their
 main hand being dropped upon this creature's death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @param chance the chance of the main hand item being dropped
 @throws UnsupportedOperationException when called on players]]>
      </doc>
    </method>
    <method name="getItemInOffHandDropChance" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chance of the off hand item being dropped upon this creature's
 death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @return chance of the off hand item being dropped (1 for players)]]>
      </doc>
    </method>
    <method name="setItemInOffHandDropChance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chance" type="float"/>
      <doc>
      <![CDATA[Sets the chance of the off hand item being dropped upon this creature's
 death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @param chance the chance of off hand item being dropped
 @throws UnsupportedOperationException when called on players]]>
      </doc>
    </method>
    <method name="getHelmetDropChance" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chance of the helmet being dropped upon this creature's death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @return the chance of the helmet being dropped (1 for players)]]>
      </doc>
    </method>
    <method name="setHelmetDropChance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chance" type="float"/>
      <doc>
      <![CDATA[Sets the chance of the helmet being dropped upon this creature's death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @param chance of the helmet being dropped
 @throws UnsupportedOperationException when called on players]]>
      </doc>
    </method>
    <method name="getChestplateDropChance" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chance of the chest plate being dropped upon this creature's
 death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @return the chance of the chest plate being dropped (1 for players)]]>
      </doc>
    </method>
    <method name="setChestplateDropChance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chance" type="float"/>
      <doc>
      <![CDATA[Sets the chance of the chest plate being dropped upon this creature's
 death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @param chance of the chest plate being dropped
 @throws UnsupportedOperationException when called on players]]>
      </doc>
    </method>
    <method name="getLeggingsDropChance" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chance of the leggings being dropped upon this creature's
 death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @return the chance of the leggings being dropped (1 for players)]]>
      </doc>
    </method>
    <method name="setLeggingsDropChance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chance" type="float"/>
      <doc>
      <![CDATA[Sets the chance of the leggings being dropped upon this creature's
 death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @param chance chance of the leggings being dropped
 @throws UnsupportedOperationException when called on players]]>
      </doc>
    </method>
    <method name="getBootsDropChance" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the chance of the boots being dropped upon this creature's death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @return the chance of the boots being dropped (1 for players)]]>
      </doc>
    </method>
    <method name="setBootsDropChance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chance" type="float"/>
      <doc>
      <![CDATA[Sets the chance of the boots being dropped upon this creature's death.

 <ul>
 <li>A drop chance of 0.0F will never drop
 <li>A drop chance of 1.0F will always drop
 </ul>

 @param chance of the boots being dropped
 @throws UnsupportedOperationException when called on players]]>
      </doc>
    </method>
    <method name="getHolder" return="org.bukkit.entity.Entity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the entity this EntityEquipment belongs to

 @return the entity this EntityEquipment belongs to]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface to a creatures inventory]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.EntityEquipment -->
  <!-- start class org.bukkit.inventory.EquipmentSlot -->
  <class name="EquipmentSlot" extends="java.lang.Enum&lt;org.bukkit.inventory.EquipmentSlot&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.inventory.EquipmentSlot[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.inventory.EquipmentSlot"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.inventory.EquipmentSlot -->
  <!-- start interface org.bukkit.inventory.FurnaceInventory -->
  <interface name="FurnaceInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current item in the result slot.

 @return The item]]>
      </doc>
    </method>
    <method name="getFuel" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current fuel.

 @return The item]]>
      </doc>
    </method>
    <method name="getSmelting" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the item currently smelting.

 @return The item]]>
      </doc>
    </method>
    <method name="setFuel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the current fuel.

 @param stack The item]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the current item in the result slot.

 @param stack The item]]>
      </doc>
    </method>
    <method name="setSmelting"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Set the item currently smelting.

 @param stack The item]]>
      </doc>
    </method>
    <method name="getHolder" return="org.bukkit.block.Furnace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Furnace.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.FurnaceInventory -->
  <!-- start class org.bukkit.inventory.FurnaceRecipe -->
  <class name="FurnaceRecipe" extends="org.bukkit.inventory.CookingRecipe&lt;org.bukkit.inventory.FurnaceRecipe&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FurnaceRecipe" type="org.bukkit.inventory.ItemStack, org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FurnaceRecipe" type="org.bukkit.inventory.ItemStack, org.bukkit.material.MaterialData"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FurnaceRecipe" type="org.bukkit.inventory.ItemStack, org.bukkit.material.MaterialData, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FurnaceRecipe" type="org.bukkit.inventory.ItemStack, org.bukkit.Material, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FurnaceRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.Material, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a furnace recipe to craft the specified ItemStack.

 @param key The unique recipe key
 @param result The item you want the recipe to create.
 @param source The input material.
 @param experience The experience given by this recipe
 @param cookingTime The cooking time (in ticks)]]>
      </doc>
    </constructor>
    <constructor name="FurnaceRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.Material, int, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FurnaceRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.inventory.RecipeChoice, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a furnace recipe to craft the specified ItemStack.

 @param key The unique recipe key
 @param result The item you want the recipe to create.
 @param input The input choices.
 @param experience The experience given by this recipe
 @param cookingTime The cooking time (in ticks)]]>
      </doc>
    </constructor>
    <method name="setInput" return="org.bukkit.inventory.FurnaceRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Sets the input of this furnace recipe.

 @param input The input material.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="setInput" return="org.bukkit.inventory.FurnaceRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="org.bukkit.Material"/>
    </method>
    <method name="setInput" return="org.bukkit.inventory.FurnaceRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="input" type="org.bukkit.Material"/>
      <param name="data" type="int"/>
      <doc>
      <![CDATA[Sets the input of this furnace recipe.

 @param input The input material.
 @param data The data value. (Note: This is currently ignored by the
     CraftBukkit server.)
 @return The changed recipe, so you can chain calls.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setInputChoice" return="org.bukkit.inventory.FurnaceRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="org.bukkit.inventory.RecipeChoice"/>
    </method>
    <doc>
    <![CDATA[Represents a furnace recipe.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.FurnaceRecipe -->
  <!-- start interface org.bukkit.inventory.GrindstoneInventory -->
  <interface name="GrindstoneInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getUpperItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the upper input item.

 @return upper input item]]>
      </doc>
    </method>
    <method name="setUpperItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="upperItem" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the upper input item.

 @param upperItem item to set]]>
      </doc>
    </method>
    <method name="getLowerItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the lower input item.

 @return lower input item]]>
      </doc>
    </method>
    <method name="setLowerItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerItem" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the lower input item.

 @param lowerItem item to set]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the result.

 @return result]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the result.

 @param result item to set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Grindstone.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.GrindstoneInventory -->
  <!-- start interface org.bukkit.inventory.HorseInventory -->
  <interface name="HorseInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.AbstractHorseInventory"/>
    <implements name="org.bukkit.inventory.ArmoredHorseInventory"/>
    <doc>
    <![CDATA[An interface to the inventory of a Horse.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.HorseInventory -->
  <!-- start interface org.bukkit.inventory.Inventory -->
  <interface name="Inventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable&lt;org.bukkit.inventory.ItemStack&gt;"/>
    <method name="getSize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the size of the inventory

 @return The size of the inventory]]>
      </doc>
    </method>
    <method name="getMaxStackSize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the maximum stack size for an ItemStack in this inventory.

 @return The maximum size for an ItemStack in this inventory.]]>
      </doc>
    </method>
    <method name="setMaxStackSize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[This method allows you to change the maximum stack size for an
 inventory.
 <p>
 <b>Caveats:</b>
 <ul>
 <li>Not all inventories respect this value.
 <li>Stacks larger than 127 may be clipped when the world is saved.
 <li>This value is not guaranteed to be preserved; be sure to set it
     before every time you want to set a slot over the max stack size.
 <li>Stacks larger than the default max size for this type of inventory
     may not display correctly in the client.
 </ul>

 @param size The new maximum stack size for items in this inventory.]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the ItemStack found in the slot at the given index

 @param index The index of the Slot's ItemStack to return
 @return The ItemStack in the slot]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Stores the ItemStack at the given index of the inventory.

 @param index The index where to put the ItemStack
 @param item The ItemStack to set]]>
      </doc>
    </method>
    <method name="addItem" return="java.util.HashMap&lt;java.lang.Integer, org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="items" type="org.bukkit.inventory.ItemStack[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Stores the given ItemStacks in the inventory. This will try to fill
 existing stacks and empty slots as well as it can.
 <p>
 The returned HashMap contains what it couldn't store, where the key is
 the index of the parameter, and the value is the ItemStack at that
 index of the varargs parameter. If all items are stored, it will return
 an empty HashMap.
 <p>
 If you pass in ItemStacks which exceed the maximum stack size for the
 Material, first they will be added to partial stacks where
 Material.getMaxStackSize() is not exceeded, up to
 Material.getMaxStackSize(). When there are no partial stacks left
 stacks will be split on Inventory.getMaxStackSize() allowing you to
 exceed the maximum stack size for that material.
 <p>
 It is known that in some implementations this method will also set
 the inputted argument amount to the number of that item not placed in
 slots.

 @param items The ItemStacks to add
 @return A HashMap containing items that didn't fit.
 @throws IllegalArgumentException if items or any element in it is null]]>
      </doc>
    </method>
    <method name="removeItem" return="java.util.HashMap&lt;java.lang.Integer, org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="items" type="org.bukkit.inventory.ItemStack[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Removes the given ItemStacks from the inventory.
 <p>
 It will try to remove 'as much as possible' from the types and amounts
 you give as arguments.
 <p>
 The returned HashMap contains what it couldn't remove, where the key is
 the index of the parameter, and the value is the ItemStack at that
 index of the varargs parameter. If all the given ItemStacks are
 removed, it will return an empty HashMap.
 <p>
 It is known that in some implementations this method will also set the
 inputted argument amount to the number of that item not removed from
 slots.

 @param items The ItemStacks to remove
 @return A HashMap containing items that couldn't be removed.
 @throws IllegalArgumentException if items is null]]>
      </doc>
    </method>
    <method name="removeItemAnySlot" return="java.util.HashMap&lt;java.lang.Integer, org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="items" type="org.bukkit.inventory.ItemStack[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Searches all possible inventory slots in order to remove the given ItemStacks.
 <p>
 Similar to {@link Inventory#removeItem(ItemStack...)} in behavior, except this
 method will check all possible slots in the inventory, rather than just the main
 storage contents.
 <p>
 It will try to remove 'as much as possible' from the types and amounts
 you give as arguments.
 <p>
 The returned HashMap contains what it couldn't remove, where the key is
 the index of the parameter, and the value is the ItemStack at that
 index of the varargs parameter. If all the given ItemStacks are
 removed, it will return an empty HashMap.
 <p>
 It is known that in some implementations this method will also set the
 inputted argument amount to the number of that item not removed from
 slots.

 @param items The ItemStacks to remove
 @return A HashMap containing items that couldn't be removed.
 @throws IllegalArgumentException if items is null]]>
      </doc>
    </method>
    <method name="getContents" return="org.bukkit.inventory.ItemStack[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all ItemStacks from the inventory

 @return An array of ItemStacks from the inventory. Individual items may be null.]]>
      </doc>
    </method>
    <method name="setContents"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="items" type="org.bukkit.inventory.ItemStack[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Completely replaces the inventory's contents. Removes all existing
 contents and replaces it with the ItemStacks given in the array.

 @param items A complete replacement for the contents; the length must
     be less than or equal to {@link #getSize()}.
 @throws IllegalArgumentException If the array has more items than the
     inventory.]]>
      </doc>
    </method>
    <method name="getStorageContents" return="org.bukkit.inventory.ItemStack[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the contents from the section of the inventory where items can
 reasonably be expected to be stored. In most cases this will represent
 the entire inventory, but in some cases it may exclude armor or result
 slots.
 <br>
 It is these contents which will be used for add / contains / remove
 methods which look for a specific stack.

 @return inventory storage contents. Individual items may be null.]]>
      </doc>
    </method>
    <method name="setStorageContents"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="items" type="org.bukkit.inventory.ItemStack[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Put the given ItemStacks into the storage slots

 @param items The ItemStacks to use as storage contents
 @throws IllegalArgumentException If the array has more items than the
 inventory.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Checks if the inventory contains any ItemStacks with the given
 material.

 @param material The material to check for
 @return true if an ItemStack is found with the given Material
 @throws IllegalArgumentException if material is null]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Checks if the inventory contains any ItemStacks matching the given
 ItemStack.
 <p>
 This will only return true if both the type and the amount of the stack
 match.

 @param item The ItemStack to match against
 @return false if item is null, true if any exactly matching ItemStacks
     were found]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <param name="amount" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Checks if the inventory contains any ItemStacks with the given
 material, adding to at least the minimum amount specified.

 @param material The material to check for
 @param amount The minimum amount
 @return true if amount is less than 1, true if enough ItemStacks were
     found to add to the given amount
 @throws IllegalArgumentException if material is null]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Checks if the inventory contains at least the minimum amount specified
 of exactly matching ItemStacks.
 <p>
 An ItemStack only counts if both the type and the amount of the stack
 match.

 @param item the ItemStack to match against
 @param amount how many identical stacks to check for
 @return false if item is null, true if amount less than 1, true if
     amount of exactly matching ItemStacks were found
 @see #containsAtLeast(ItemStack, int)]]>
      </doc>
    </method>
    <method name="containsAtLeast" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Checks if the inventory contains ItemStacks matching the given
 ItemStack whose amounts sum to at least the minimum amount specified.

 @param item the ItemStack to match against
 @param amount the minimum amount
 @return false if item is null, true if amount less than 1, true if
     enough ItemStacks were found to add to the given amount]]>
      </doc>
    </method>
    <method name="all" return="java.util.HashMap&lt;java.lang.Integer, ? extends org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns a HashMap with all slots and ItemStacks in the inventory with
 the given Material.
 <p>
 The HashMap contains entries where, the key is the slot index, and the
 value is the ItemStack in that slot. If no matching ItemStack with the
 given Material is found, an empty map is returned.

 @param material The material to look for
 @return A HashMap containing the slot index, ItemStack pairs
 @throws IllegalArgumentException if material is null]]>
      </doc>
    </method>
    <method name="all" return="java.util.HashMap&lt;java.lang.Integer, ? extends org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Finds all slots in the inventory containing any ItemStacks with the
 given ItemStack. This will only match slots if both the type and the
 amount of the stack match
 <p>
 The HashMap contains entries where, the key is the slot index, and the
 value is the ItemStack in that slot. If no matching ItemStack with the
 given Material is found, an empty map is returned.

 @param item The ItemStack to match against
 @return A map from slot indexes to item at index]]>
      </doc>
    </method>
    <method name="first" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Finds the first slot in the inventory containing an ItemStack with the
 given material

 @param material The material to look for
 @return The slot index of the given Material or -1 if not found
 @throws IllegalArgumentException if material is null]]>
      </doc>
    </method>
    <method name="first" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Returns the first slot in the inventory containing an ItemStack with
 the given stack. This will only match a slot if both the type and the
 amount of the stack match

 @param item The ItemStack to match against
 @return The slot index of the given ItemStack or -1 if not found]]>
      </doc>
    </method>
    <method name="firstEmpty" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the first empty Slot.

 @return The first empty Slot found, or -1 if no empty slots.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check whether or not this inventory is empty. An inventory is considered
 to be empty if there are no ItemStacks in any slot of this inventory.

 @return true if empty, false otherwise]]>
      </doc>
    </method>
    <method name="remove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Removes all stacks in the inventory matching the given material.

 @param material The material to remove
 @throws IllegalArgumentException if material is null]]>
      </doc>
    </method>
    <method name="remove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Removes all stacks in the inventory matching the given stack.
 <p>
 This will only match a slot if both the type and the amount of the
 stack match

 @param item The ItemStack to match against]]>
      </doc>
    </method>
    <method name="clear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Clears out a particular slot in the index.

 @param index The index to empty.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears out the whole Inventory.]]>
      </doc>
    </method>
    <method name="getViewers" return="java.util.List&lt;org.bukkit.entity.HumanEntity&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of players viewing the inventory. Note that a player is
 considered to be viewing their own inventory and internal crafting
 screen even when said inventory is not open. They will normally be
 considered to be viewing their inventory even when they have a
 different inventory screen open, but it's possible for customized
 inventory screens to exclude the viewer's inventory, so this should
 never be assumed to be non-empty.

 @return A list of HumanEntities who are viewing this Inventory.]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.event.inventory.InventoryType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns what type of inventory this is.

 @return The InventoryType representing the type of inventory.]]>
      </doc>
    </method>
    <method name="getHolder" return="org.bukkit.inventory.InventoryHolder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block or entity belonging to the open inventory

 @return The holder of the inventory; null if it has no holder.]]>
      </doc>
    </method>
    <method name="getHolder" return="org.bukkit.inventory.InventoryHolder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="useSnapshot" type="boolean"/>
      <doc>
      <![CDATA[Gets the block or entity belonging to the open inventory

 @param useSnapshot Create a snapshot if the holder is a tile entity
 @return The holder of the inventory; null if it has no holder.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.ListIterator&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.ListIterator&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns an iterator starting at the given index. If the index is
 positive, then the first call to next() will return the item at that
 index; if it is negative, the first call to previous will return the
 item at index (getSize() + index).

 @param index The index.
 @return An iterator.]]>
      </doc>
    </method>
    <method name="getLocation" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the location of the block or entity which corresponds to this inventory. May return null if this container
 was custom created or is a virtual / subcontainer.

 @return location or null if not applicable.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the various inventories. Behavior relating to {@link
 Material#AIR} is unspecified.

 <br>
 <b>Note that whilst {@link #iterator()} deals with the entire inventory, add
 / contains / remove methods deal only with the storage contents.</b>
 <br>
 <b>Consider using {@link #getContents()} and {@link #getStorageContents()} for
 specific iteration.</b>

 @see #getContents()
 @see #getStorageContents()]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.Inventory -->
  <!-- start interface org.bukkit.inventory.InventoryHolder -->
  <interface name="InventoryHolder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the object's inventory.

 @return The inventory.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.inventory.InventoryHolder -->
  <!-- start class org.bukkit.inventory.InventoryView -->
  <class name="InventoryView" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InventoryView"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTopInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the upper inventory involved in this transaction.

 @return the inventory]]>
      </doc>
    </method>
    <method name="getBottomInventory" return="org.bukkit.inventory.Inventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the lower inventory involved in this transaction.

 @return the inventory]]>
      </doc>
    </method>
    <method name="getPlayer" return="org.bukkit.entity.HumanEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the player viewing.

 @return the player]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.event.inventory.InventoryType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determine the type of inventory involved in the transaction. This
 indicates the window style being shown. It will never return PLAYER,
 since that is common to all windows.

 @return the inventory type]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="int"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets one item in this inventory view by its raw slot ID.
 <p>
 Note: If slot ID -999 is chosen, it may be expected that the item is
 dropped on the ground. This is not required behaviour, however.

 @param slot The ID as returned by InventoryClickEvent.getRawSlot()
 @param item The new item to put in the slot, or null to clear it.]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="int"/>
      <doc>
      <![CDATA[Gets one item in this inventory view by its raw slot ID.

 @param slot The ID as returned by InventoryClickEvent.getRawSlot()
 @return The item currently in the slot.]]>
      </doc>
    </method>
    <method name="setCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item on the cursor of one of the viewing players.

 @param item The item to put on the cursor, or null to remove the item
     on their cursor.]]>
      </doc>
    </method>
    <method name="getCursor" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the item on the cursor of one of the viewing players.

 @return The item on the player's cursor, or null if they aren't holding
     one.]]>
      </doc>
    </method>
    <method name="getInventory" return="org.bukkit.inventory.Inventory"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="rawSlot" type="int"/>
      <doc>
      <![CDATA[Gets the inventory corresponding to the given raw slot ID.

 If the slot ID is {@link #OUTSIDE} null will be returned, otherwise
 behaviour for illegal and negative slot IDs is undefined.

 May be used with {@link #convertSlot(int)} to directly index an
 underlying inventory.

 @param rawSlot The raw slot ID.
 @return corresponding inventory, or null]]>
      </doc>
    </method>
    <method name="convertSlot" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="rawSlot" type="int"/>
      <doc>
      <![CDATA[Converts a raw slot ID into its local slot ID into whichever of the two
 inventories the slot points to.
 <p>
 If the raw slot refers to the upper inventory, it will be returned
 unchanged and thus be suitable for getTopInventory().getItem(); if it
 refers to the lower inventory, the output will differ from the input
 and be suitable for getBottomInventory().getItem().

 @param rawSlot The raw slot ID.
 @return The converted slot ID.]]>
      </doc>
    </method>
    <method name="getSlotType" return="org.bukkit.event.inventory.InventoryType.SlotType"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="int"/>
      <doc>
      <![CDATA[Determine the type of the slot by its raw slot ID.
 <p>
 If the type of the slot is unknown, then
 {@link InventoryType.SlotType#CONTAINER} will be returned.

 @param slot The raw slot ID
 @return the slot type]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the inventory view.]]>
      </doc>
    </method>
    <method name="countSlots" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check the total number of slots in this view, combining the upper and
 lower inventories.
 <p>
 Note though that it's possible for this to be greater than the sum of
 the two inventories if for example some slots are not being used.

 @return The total size]]>
      </doc>
    </method>
    <method name="setProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="prop" type="org.bukkit.inventory.InventoryView.Property"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets an extra property of this inventory if supported by that
 inventory, for example the state of a progress bar.

 @param prop the window property to update
 @param value the new value for the window property
 @return true if the property was updated successfully, false if the
     property is not supported by that inventory]]>
      </doc>
    </method>
    <method name="getTitle" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the title of this inventory window.

 @return The title.]]>
      </doc>
    </method>
    <field name="OUTSIDE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a view linking two inventories and a single player (whose
 inventory may or may not be one of the two).
 <p>
 Note: If you implement this interface but fail to satisfy the expected
 contracts of certain methods, there's no guarantee that the game will work
 as it should.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.InventoryView -->
  <!-- start class org.bukkit.inventory.InventoryView.Property -->
  <class name="InventoryView.Property" extends="java.lang.Enum&lt;org.bukkit.inventory.InventoryView.Property&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.inventory.InventoryView.Property[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.inventory.InventoryView.Property"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getType" return="org.bukkit.event.inventory.InventoryType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the id of this view.

 @return the id of this view
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents various extra properties of certain inventory windows.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.InventoryView.Property -->
  <!-- start interface org.bukkit.inventory.ItemFactory -->
  <interface name="ItemFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getItemMeta" return="org.bukkit.inventory.meta.ItemMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[This creates a new item meta for the material.

 @param material The material to consider as base for the meta
 @return a new ItemMeta that could be applied to an item stack of the
     specified material]]>
      </doc>
    </method>
    <method name="isApplicable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="meta" type="org.bukkit.inventory.meta.ItemMeta"/>
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[This method checks the item meta to confirm that it is applicable (no
 data lost if applied) to the specified ItemStack.
 <p>
 A {@link SkullMeta} would not be valid for a sword, but a normal {@link
 ItemMeta} from an enchanted dirt block would.

 @param meta Meta to check
 @param stack Item that meta will be applied to
 @return true if the meta can be applied without losing data, false
     otherwise
 @throws IllegalArgumentException if the meta was not created by this
     factory]]>
      </doc>
    </method>
    <method name="isApplicable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="meta" type="org.bukkit.inventory.meta.ItemMeta"/>
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[This method checks the item meta to confirm that it is applicable (no
 data lost if applied) to the specified Material.
 <p>
 A {@link SkullMeta} would not be valid for a sword, but a normal {@link
 ItemMeta} from an enchanted dirt block would.

 @param meta Meta to check
 @param material Material that meta will be applied to
 @return true if the meta can be applied without losing data, false
     otherwise
 @throws IllegalArgumentException if the meta was not created by this
     factory]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="meta1" type="org.bukkit.inventory.meta.ItemMeta"/>
      <param name="meta2" type="org.bukkit.inventory.meta.ItemMeta"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[This method is used to compare two item meta data objects.

 @param meta1 First meta to compare, and may be null to indicate no data
 @param meta2 Second meta to compare, and may be null to indicate no
     data
 @return false if one of the meta has data the other does not, otherwise
     true
 @throws IllegalArgumentException if either meta was not created by this
     factory]]>
      </doc>
    </method>
    <method name="asMetaFor" return="org.bukkit.inventory.meta.ItemMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="meta" type="org.bukkit.inventory.meta.ItemMeta"/>
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns an appropriate item meta for the specified stack.
 <p>
 The item meta returned will always be a valid meta for a given
 ItemStack of the specified material. It may be a more or less specific
 meta, and could also be the same meta or meta type as the parameter.
 The item meta returned will also always be the most appropriate meta.
 <p>
 Example, if a {@link SkullMeta} is being applied to a book, this method
 would return a {@link BookMeta} containing all information in the
 specified meta that is applicable to an {@link ItemMeta}, the highest
 common interface.

 @param meta the meta to convert
 @param stack the stack to convert the meta for
 @return An appropriate item meta for the specified item stack. No
     guarantees are made as to if a copy is returned. This will be null
     for a stack of air.
 @throws IllegalArgumentException if the specified meta was not created
     by this factory]]>
      </doc>
    </method>
    <method name="asMetaFor" return="org.bukkit.inventory.meta.ItemMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="meta" type="org.bukkit.inventory.meta.ItemMeta"/>
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns an appropriate item meta for the specified material.
 <p>
 The item meta returned will always be a valid meta for a given
 ItemStack of the specified material. It may be a more or less specific
 meta, and could also be the same meta or meta type as the parameter.
 The item meta returned will also always be the most appropriate meta.
 <p>
 Example, if a {@link SkullMeta} is being applied to a book, this method
 would return a {@link BookMeta} containing all information in the
 specified meta that is applicable to an {@link ItemMeta}, the highest
 common interface.

 @param meta the meta to convert
 @param material the material to convert the meta for
 @return An appropriate item meta for the specified item material. No
     guarantees are made as to if a copy is returned. This will be null for air.
 @throws IllegalArgumentException if the specified meta was not created
     by this factory]]>
      </doc>
    </method>
    <method name="getDefaultLeatherColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the default color for all leather armor.

 @return the default color for leather armor]]>
      </doc>
    </method>
    <method name="updateMaterial" return="org.bukkit.Material"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="for internal use only">
      <param name="meta" type="org.bukkit.inventory.meta.ItemMeta"/>
      <param name="material" type="org.bukkit.Material"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Apply a material change for an item meta. Do not use under any
 circumstances.

 @param meta meta
 @param material material
 @return updated material
 @throws IllegalArgumentException if bad material or data
 @deprecated for internal use only]]>
      </doc>
    </method>
    <method name="ensureServerConversions" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Minecart updates are converting simple item stacks into more complex NBT oriented Item Stacks.

 Use this method to to ensure any desired data conversions are processed.
 The input itemstack will not be the same as the returned itemstack.

 @param item The item to process conversions on
 @return A potentially Data Converted ItemStack]]>
      </doc>
    </method>
    <method name="getI18NDisplayName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Gets the Display name as seen in the Client.
 Currently the server only supports the English language. To override this,
 You must replace the language file embedded in the server jar.

 @param item Item to return Display name of
 @return Display name of Item]]>
      </doc>
    </method>
    <method name="hoverContentOf" return="net.md_5.bungee.api.chat.hover.content.Content"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Creates a {@link net.md_5.bungee.api.chat.hover.content.Content} of that ItemStack for displaying.

 @param itemStack
 @return the {@link net.md_5.bungee.api.chat.hover.content.Content} of that ItemStack]]>
      </doc>
    </method>
    <method name="hoverContentOf" return="net.md_5.bungee.api.chat.hover.content.Content"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[Creates a {@link net.md_5.bungee.api.chat.hover.content.Content} of that {@link org.bukkit.entity.Entity} for displaying.
 Uses the display name of the entity, if present.

 @param entity Entity to create the HoverEvent for
 @return the {@link net.md_5.bungee.api.chat.hover.content.Content} of that {@link org.bukkit.entity.Entity}]]>
      </doc>
    </method>
    <method name="hoverContentOf" return="net.md_5.bungee.api.chat.hover.content.Content"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="org.bukkit.entity.Entity"/>
      <param name="customName" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a {@link net.md_5.bungee.api.chat.hover.content.Content} of that {@link org.bukkit.entity.Entity} for displaying.

 @param entity Entity to create the HoverEvent for
 @param customName a custom name that should be displayed, if not passed entity name will be displayed
 @return the {@link net.md_5.bungee.api.chat.hover.content.Content} of that {@link org.bukkit.entity.Entity}]]>
      </doc>
    </method>
    <method name="hoverContentOf" return="net.md_5.bungee.api.chat.hover.content.Content"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="org.bukkit.entity.Entity"/>
      <param name="customName" type="net.md_5.bungee.api.chat.BaseComponent"/>
      <doc>
      <![CDATA[Creates a {@link net.md_5.bungee.api.chat.hover.content.Content} of that {@link org.bukkit.entity.Entity} for displaying.

 @param entity Entity to create the HoverEvent for
 @param customName a custom name that should be displayed, if not passed entity name will be displayed
 @return the {@link net.md_5.bungee.api.chat.hover.content.Content} of that {@link org.bukkit.entity.Entity}]]>
      </doc>
    </method>
    <method name="hoverContentOf" return="net.md_5.bungee.api.chat.hover.content.Content"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="org.bukkit.entity.Entity"/>
      <param name="customName" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Creates a {@link net.md_5.bungee.api.chat.hover.content.Content} of that {@link org.bukkit.entity.Entity} for displaying.

 @param entity Entity to create the HoverEvent for
 @param customName a custom name that should be displayed, if not passed entity name will be displayed
 @return the {@link net.md_5.bungee.api.chat.hover.content.Content} of that {@link org.bukkit.entity.Entity}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An instance of the ItemFactory can be obtained with {@link
 Server#getItemFactory()}.
 <p>
 The ItemFactory is solely responsible for creating item meta containers to
 apply on item stacks.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.ItemFactory -->
  <!-- start class org.bukkit.inventory.ItemFlag -->
  <class name="ItemFlag" extends="java.lang.Enum&lt;org.bukkit.inventory.ItemFlag&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.inventory.ItemFlag[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.inventory.ItemFlag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A ItemFlag can hide some Attributes from ItemStacks]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.ItemFlag -->
  <!-- start class org.bukkit.inventory.ItemStack -->
  <class name="ItemStack" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <constructor name="ItemStack"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ItemStack" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defaults stack size to 1, with no extra data.
 <p>
 <b>IMPORTANT: An <i>Item</i>Stack is only designed to contain
 <i>items</i>. Do not use this class to encapsulate Materials for which
 {@link Material#isItem()} returns false.</b>

 @param type item material]]>
      </doc>
    </constructor>
    <constructor name="ItemStack" type="org.bukkit.Material, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An item stack with no extra data.
 <p>
 <b>IMPORTANT: An <i>Item</i>Stack is only designed to contain
 <i>items</i>. Do not use this class to encapsulate Materials for which
 {@link Material#isItem()} returns false.</b>

 @param type item material
 @param amount stack size]]>
      </doc>
    </constructor>
    <constructor name="ItemStack" type="org.bukkit.Material, int, short"
      static="false" final="false" visibility="public"
      deprecated="see {@link #setDurability(short)}">
      <doc>
      <![CDATA[An item stack with the specified damage / durability

 @param type item material
 @param amount stack size
 @param damage durability / damage
 @deprecated see {@link #setDurability(short)}]]>
      </doc>
    </constructor>
    <constructor name="ItemStack" type="org.bukkit.Material, int, short, java.lang.Byte"
      static="false" final="false" visibility="public"
      deprecated="this method uses an ambiguous data byte object">
      <doc>
      <![CDATA[@param type the type
 @param amount the amount in the stack
 @param damage the damage value of the item
 @param data the data value or null
 @deprecated this method uses an ambiguous data byte object]]>
      </doc>
    </constructor>
    <constructor name="ItemStack" type="org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Creates a new item stack derived from the specified stack

 @param stack the stack to copy
 @throws IllegalArgumentException if the specified stack is null or
     returns an item meta not created by the item factory]]>
      </doc>
    </constructor>
    <method name="getType" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of this item

 @return Type of the items in this stack]]>
      </doc>
    </method>
    <method name="setType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Sets the type of this item
 <p>
 Note that in doing so you will reset the MaterialData for this stack.
 <p>
 <b>IMPORTANT: An <i>Item</i>Stack is only designed to contain
 <i>items</i>. Do not use this class to encapsulate Materials for which
 {@link Material#isItem()} returns false.</b>

 @param type New type to set the items in this stack to]]>
      </doc>
    </method>
    <method name="getAmount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of items in this stack

 @return Amount of items in this stack]]>
      </doc>
    </method>
    <method name="setAmount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Sets the amount of items in this stack

 @param amount New amount of items in this stack]]>
      </doc>
    </method>
    <method name="getData" return="org.bukkit.material.MaterialData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the MaterialData for this stack of items

 @return MaterialData for this item]]>
      </doc>
    </method>
    <method name="setData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Sets the MaterialData for this stack of items

 @param data New MaterialData for this item]]>
      </doc>
    </method>
    <method name="setDurability"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="durability is now part of ItemMeta. To avoid confusion and
 misuse, {@link #getItemMeta()}, {@link #setItemMeta(ItemMeta)} and
 {@link Damageable#setDamage(int)} should be used instead. This is because
 any call to this method will be overwritten by subsequent setting of
 ItemMeta which was created before this call.">
      <param name="durability" type="short"/>
      <doc>
      <![CDATA[Sets the durability of this item

 @param durability Durability of this item
 @deprecated durability is now part of ItemMeta. To avoid confusion and
 misuse, {@link #getItemMeta()}, {@link #setItemMeta(ItemMeta)} and
 {@link Damageable#setDamage(int)} should be used instead. This is because
 any call to this method will be overwritten by subsequent setting of
 ItemMeta which was created before this call.]]>
      </doc>
    </method>
    <method name="getDurability" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link #setDurability(short)}">
      <doc>
      <![CDATA[Gets the durability of this item

 @return Durability of this item
 @deprecated see {@link #setDurability(short)}]]>
      </doc>
    </method>
    <method name="getMaxStackSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum stacksize for the material hold in this ItemStack.
 (Returns -1 if it has no idea)

 @return The maximum you can stack this material to.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="isSimilar" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[This method is the same as equals, but does not consider stack size
 (amount).

 @param stack the item stack to compare to
 @return true if the two stacks are equal, ignoring the amount]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsEnchantment" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Checks if this ItemStack contains the given {@link Enchantment}

 @param ench Enchantment to test
 @return True if this has the given enchantment]]>
      </doc>
    </method>
    <method name="getEnchantmentLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Gets the level of the specified enchantment on this item stack

 @param ench Enchantment to check
 @return Level of the enchantment, or 0]]>
      </doc>
    </method>
    <method name="getEnchantments" return="java.util.Map&lt;org.bukkit.enchantments.Enchantment, java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a map containing all enchantments and their levels on this item.

 @return Map of enchantments.]]>
      </doc>
    </method>
    <method name="addEnchantments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enchantments" type="java.util.Map&lt;org.bukkit.enchantments.Enchantment, java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Adds the specified enchantments to this item stack.
 <p>
 This method is the same as calling {@link
 #addEnchantment(org.bukkit.enchantments.Enchantment, int)} for each
 element of the map.

 @param enchantments Enchantments to add
 @throws IllegalArgumentException if the specified enchantments is null
 @throws IllegalArgumentException if any specific enchantment or level
     is null. <b>Warning</b>: Some enchantments may be added before this
     exception is thrown.]]>
      </doc>
    </method>
    <method name="addEnchantment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Adds the specified {@link Enchantment} to this item stack.
 <p>
 If this item stack already contained the given enchantment (at any
 level), it will be replaced.

 @param ench Enchantment to add
 @param level Level of the enchantment
 @throws IllegalArgumentException if enchantment null, or enchantment is
     not applicable]]>
      </doc>
    </method>
    <method name="addUnsafeEnchantments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enchantments" type="java.util.Map&lt;org.bukkit.enchantments.Enchantment, java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Adds the specified enchantments to this item stack in an unsafe manner.
 <p>
 This method is the same as calling {@link
 #addUnsafeEnchantment(org.bukkit.enchantments.Enchantment, int)} for
 each element of the map.

 @param enchantments Enchantments to add]]>
      </doc>
    </method>
    <method name="addUnsafeEnchantment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Adds the specified {@link Enchantment} to this item stack.
 <p>
 If this item stack already contained the given enchantment (at any
 level), it will be replaced.
 <p>
 This method is unsafe and will ignore level restrictions or item type.
 Use at your own discretion.

 @param ench Enchantment to add
 @param level Level of the enchantment]]>
      </doc>
    </method>
    <method name="removeEnchantment" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Removes the specified {@link Enchantment} if it exists on this
 ItemStack

 @param ench Enchantment to remove
 @return Previous level, or 0]]>
      </doc>
    </method>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="deserialize" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Required method for configuration serialization

 @param args map to deserialize
 @return deserialized item stack
 @see ConfigurationSerializable]]>
      </doc>
    </method>
    <method name="getItemMeta" return="org.bukkit.inventory.meta.ItemMeta"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a copy of this ItemStack's {@link ItemMeta}.

 @return a copy of the current ItemStack's ItemData]]>
      </doc>
    </method>
    <method name="hasItemMeta" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if any meta data has been defined.

 @return Returns true if some meta data has been set for this item]]>
      </doc>
    </method>
    <method name="setItemMeta" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemMeta" type="org.bukkit.inventory.meta.ItemMeta"/>
      <doc>
      <![CDATA[Set the ItemMeta of this ItemStack.

 @param itemMeta new ItemMeta, or null to indicate meta data be cleared.
 @return True if successfully applied ItemMeta, see {@link
     ItemFactory#isApplicable(ItemMeta, ItemStack)}
 @throws IllegalArgumentException if the item meta was not created by
     the {@link ItemFactory}]]>
      </doc>
    </method>
    <method name="ensureServerConversions" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Minecart updates are converting simple item stacks into more complex NBT oriented Item Stacks.

 Use this method to to ensure any desired data conversions are processed.
 The input itemstack will not be the same as the returned itemstack.

 @return A potentially Data Converted ItemStack]]>
      </doc>
    </method>
    <method name="deserializeBytes" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Deserializes this itemstack from raw NBT bytes. NBT is safer for data migrations as it will
 use the built in data converter instead of bukkits dangerous serialization system.

 This expects that the DataVersion was stored on the root of the Compound, as saved from
 the {@link #serializeAsBytes()} API returned.
 @return ItemStack migrated to this version of Minecraft if needed.]]>
      </doc>
    </method>
    <method name="serializeAsBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Serializes this itemstack to raw bytes in NBT. NBT is safer for data migrations as it will
 use the built in data converter instead of bukkits dangerous serialization system.
 @return bytes representing this item in NBT.]]>
      </doc>
    </method>
    <method name="getI18NDisplayName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Display name as seen in the Client.
 Currently the server only supports the English language. To override this,
 You must replace the language file embedded in the server jar.

 @return Display name of Item]]>
      </doc>
    </method>
    <method name="getMaxItemUseDuration" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asOne" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clones the itemstack and returns it a single quantity.
 @return The new itemstack with 1 quantity]]>
      </doc>
    </method>
    <method name="asQuantity" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qty" type="int"/>
      <doc>
      <![CDATA[Clones the itemstack and returns it as the specified quantity
 @param qty The quantity of the cloned item
 @return The new itemstack with specified quantity]]>
      </doc>
    </method>
    <method name="add" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Adds 1 to this itemstack. Will not go over the items max stack size.
 @return The same item (not a clone)]]>
      </doc>
    </method>
    <method name="add" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qty" type="int"/>
      <doc>
      <![CDATA[Adds quantity to this itemstack. Will not go over the items max stack size.

 @param qty The amount to add
 @return The same item (not a clone)]]>
      </doc>
    </method>
    <method name="subtract" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Subtracts 1 to this itemstack.  Going to 0 or less will invalidate the item.
 @return The same item (not a clone)]]>
      </doc>
    </method>
    <method name="subtract" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qty" type="int"/>
      <doc>
      <![CDATA[Subtracts quantity to this itemstack. Going to 0 or less will invalidate the item.

 @param qty The amount to add
 @return The same item (not a clone)]]>
      </doc>
    </method>
    <method name="getLore" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the item has lore, returns it, else it will return null
 @return The lore, or null]]>
      </doc>
    </method>
    <method name="setLore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lore" type="java.util.List&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Sets the lore for this item.
 Removes lore when given null.

 @param lore the lore that will be set]]>
      </doc>
    </method>
    <method name="addItemFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemFlags" type="org.bukkit.inventory.ItemFlag[]"/>
      <doc>
      <![CDATA[Set itemflags which should be ignored when rendering a ItemStack in the Client. This Method does silently ignore double set itemFlags.

 @param itemFlags The hideflags which shouldn't be rendered]]>
      </doc>
    </method>
    <method name="removeItemFlags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemFlags" type="org.bukkit.inventory.ItemFlag[]"/>
      <doc>
      <![CDATA[Remove specific set of itemFlags. This tells the Client it should render it again. This Method does silently ignore double removed itemFlags.

 @param itemFlags Hideflags which should be removed]]>
      </doc>
    </method>
    <method name="getItemFlags" return="java.util.Set&lt;org.bukkit.inventory.ItemFlag&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current set itemFlags. The collection returned is unmodifiable.

 @return A set of all itemFlags set]]>
      </doc>
    </method>
    <method name="hasItemFlag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="org.bukkit.inventory.ItemFlag"/>
      <doc>
      <![CDATA[Check if the specified flag is present on this item.

 @param flag the flag to check
 @return if it is present]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a stack of items.
 <p>
 <b>IMPORTANT: An <i>Item</i>Stack is only designed to contain <i>items</i>. Do not
 use this class to encapsulate Materials for which {@link Material#isItem()}
 returns false.</b>]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.ItemStack -->
  <!-- start interface org.bukkit.inventory.LecternInventory -->
  <interface name="LecternInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getHolder" return="org.bukkit.block.Lectern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBook" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the lectern's held book.

 @return book set in the lectern]]>
      </doc>
    </method>
    <method name="setBook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="book" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the lectern's held book.

 @param book the new book]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Lectern.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.LecternInventory -->
  <!-- start interface org.bukkit.inventory.LlamaInventory -->
  <interface name="LlamaInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.SaddledHorseInventory"/>
    <method name="getDecor" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the item in the llama's decor slot.

 @return the decor item]]>
      </doc>
    </method>
    <method name="setDecor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item in the llama's decor slot.

 @param stack the new item]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface to the inventory of a {@link Llama}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.LlamaInventory -->
  <!-- start interface org.bukkit.inventory.LoomInventory -->
  <interface name="LoomInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <doc>
    <![CDATA[Interface to the inventory of a Loom.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.LoomInventory -->
  <!-- start class org.bukkit.inventory.MainHand -->
  <class name="MainHand" extends="java.lang.Enum&lt;org.bukkit.inventory.MainHand&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.inventory.MainHand[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.inventory.MainHand"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the chosen main hand of a player]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.MainHand -->
  <!-- start interface org.bukkit.inventory.Merchant -->
  <interface name="Merchant"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRecipes" return="java.util.List&lt;org.bukkit.inventory.MerchantRecipe&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of trades currently available from this merchant.

 @return an immutable list of trades]]>
      </doc>
    </method>
    <method name="setRecipes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipes" type="java.util.List&lt;org.bukkit.inventory.MerchantRecipe&gt;"/>
      <doc>
      <![CDATA[Set the list of trades currently available from this merchant.
 <br>
 This will not change the selected trades of players currently trading
 with this merchant.

 @param recipes a list of recipes]]>
      </doc>
    </method>
    <method name="getRecipe" return="org.bukkit.inventory.MerchantRecipe"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <exception name="IndexOutOfBoundsException" type="java.lang.IndexOutOfBoundsException"/>
      <doc>
      <![CDATA[Get the recipe at a certain index of this merchant's trade list.

 @param i the index
 @return the recipe
 @throws IndexOutOfBoundsException if recipe index out of bounds]]>
      </doc>
    </method>
    <method name="setRecipe"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="recipe" type="org.bukkit.inventory.MerchantRecipe"/>
      <exception name="IndexOutOfBoundsException" type="java.lang.IndexOutOfBoundsException"/>
      <doc>
      <![CDATA[Set the recipe at a certain index of this merchant's trade list.

 @param i the index
 @param recipe the recipe
 @throws IndexOutOfBoundsException if recipe index out of bounds]]>
      </doc>
    </method>
    <method name="getRecipeCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of trades this merchant currently has available.

 @return the recipe count]]>
      </doc>
    </method>
    <method name="isTrading" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this merchant is currently trading.

 @return whether the merchant is trading]]>
      </doc>
    </method>
    <method name="getTrader" return="org.bukkit.entity.HumanEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the player this merchant is trading with, or null if it is not
 currently trading.

 @return the trader, or null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a merchant. A merchant is a special type of inventory which can
 facilitate custom trades between items.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.Merchant -->
  <!-- start interface org.bukkit.inventory.MerchantInventory -->
  <interface name="MerchantInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getSelectedRecipeIndex" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the index of the currently selected recipe.

 @return the index of the currently selected recipe]]>
      </doc>
    </method>
    <method name="getSelectedRecipe" return="org.bukkit.inventory.MerchantRecipe"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the currently active recipe.
 <p>
 This will be <code>null</code> if the items provided by the player do
 not match the ingredients of the selected recipe. This does not
 necessarily match the recipe selected by the player: If the player has
 selected the first recipe, the merchant will search all of its offers
 for a matching recipe to activate.

 @return the currently active recipe]]>
      </doc>
    </method>
    <method name="getMerchant" return="org.bukkit.inventory.Merchant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Merchant associated with this inventory.

 @return merchant]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a trading inventory between a player and a merchant.
 <br>
 The holder of this Inventory is the owning Villager, or null if the player is
 trading with a merchant created by a plugin.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.MerchantInventory -->
  <!-- start class org.bukkit.inventory.MerchantRecipe -->
  <class name="MerchantRecipe" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Recipe"/>
    <constructor name="MerchantRecipe" type="org.bukkit.inventory.ItemStack, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MerchantRecipe" type="org.bukkit.inventory.ItemStack, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MerchantRecipe" type="org.bukkit.inventory.ItemStack, int, int, boolean, int, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addIngredient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="removeIngredient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="setIngredients"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ingredients" type="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"/>
    </method>
    <method name="getIngredients" return="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUses" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of times this trade has been used.

 @return the number of uses]]>
      </doc>
    </method>
    <method name="setUses"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uses" type="int"/>
      <doc>
      <![CDATA[Set the number of times this trade has been used.

 @param uses the number of uses]]>
      </doc>
    </method>
    <method name="getMaxUses" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the maximum number of uses this trade has.
 <br>
 The maximum uses of this trade may increase when a player trades with the
 owning merchant.

 @return the maximum number of uses]]>
      </doc>
    </method>
    <method name="setMaxUses"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxUses" type="int"/>
      <doc>
      <![CDATA[Set the maximum number of uses this trade has.

 @param maxUses the maximum number of time this trade can be used]]>
      </doc>
    </method>
    <method name="hasExperienceReward" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to reward experience to the player for the trade.

 @return whether to reward experience to the player for completing this
 trade]]>
      </doc>
    </method>
    <method name="setExperienceReward"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Set whether to reward experience to the player for the trade.

 @param flag whether to reward experience to the player for completing
 this trade]]>
      </doc>
    </method>
    <method name="getVillagerExperience" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the amount of experience the villager earns from this trade.

 @return villager experience]]>
      </doc>
    </method>
    <method name="setVillagerExperience"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="villagerExperience" type="int"/>
      <doc>
      <![CDATA[Sets the amount of experience the villager earns from this trade.

 @param villagerExperience new experience amount]]>
      </doc>
    </method>
    <method name="getPriceMultiplier" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the additive price multiplier for the cost of this trade.

 @return price multiplier]]>
      </doc>
    </method>
    <method name="setPriceMultiplier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priceMultiplier" type="float"/>
      <doc>
      <![CDATA[Sets the additive price multiplier for the cost of this trade.

 @param priceMultiplier new price multiplier]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a merchant's trade.

 Trades can take one or two ingredients, and provide one result. The
 ingredients' ItemStack amounts are respected in the trade.
 <br>
 A trade has a limited number of uses, after which the trade can no longer be
 used, unless the player uses a different trade, which will cause its maximum
 uses to increase.
 <br>
 A trade may or may not reward experience for being completed.

 @see org.bukkit.event.entity.VillagerReplenishTradeEvent]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.MerchantRecipe -->
  <!-- start interface org.bukkit.inventory.PlayerInventory -->
  <interface name="PlayerInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getArmorContents" return="org.bukkit.inventory.ItemStack[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all ItemStacks from the armor slots

 @return All the ItemStacks from the armor slots. Individual items can be null.]]>
      </doc>
    </method>
    <method name="getExtraContents" return="org.bukkit.inventory.ItemStack[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all additional ItemStacks stored in this inventory.
 <br>
 NB: What defines an extra slot is up to the implementation, however it
 will not be contained within {@link #getStorageContents()} or
 {@link #getArmorContents()}

 @return All additional ItemStacks. Individual items can be null.]]>
      </doc>
    </method>
    <method name="getHelmet" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the ItemStack from the helmet slot

 @return The ItemStack in the helmet slot]]>
      </doc>
    </method>
    <method name="getChestplate" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the ItemStack from the chestplate slot

 @return The ItemStack in the chestplate slot]]>
      </doc>
    </method>
    <method name="getLeggings" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the ItemStack from the leg slot

 @return The ItemStack in the leg slot]]>
      </doc>
    </method>
    <method name="getBoots" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the ItemStack from the boots slot

 @return The ItemStack in the boots slot]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Stores the ItemStack at the given index of the inventory.
 <p>
 Indexes 0 through 8 refer to the hotbar. 9 through 35 refer to the main inventory, counting up from 9 at the top
 left corner of the inventory, moving to the right, and moving to the row below it back on the left side when it
 reaches the end of the row. It follows the same path in the inventory like you would read a book.
 <p>
 Indexes 36 through 39 refer to the armor slots. Though you can set armor with this method using these indexes,
 you are encouraged to use the provided methods for those slots.
 <p>
 Index 40 refers to the off hand (shield) item slot. Though you can set off hand with this method using this index,
 you are encouraged to use the provided method for this slot.
 <p>
 If you attempt to use this method with an index less than 0 or greater than 40, an ArrayIndexOutOfBounds
 exception will be thrown.

 @param index The index where to put the ItemStack
 @param item The ItemStack to set
 @throws ArrayIndexOutOfBoundsException when index &lt; 0 || index &gt; 40
 @see #setBoots(ItemStack)
 @see #setChestplate(ItemStack)
 @see #setHelmet(ItemStack)
 @see #setLeggings(ItemStack)
 @see #setItemInOffHand(ItemStack)]]>
      </doc>
    </method>
    <method name="setItem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Stores the ItemStack at the given equipment slot in the inventory.

 @param slot the slot to put the ItemStack
 @param item the ItemStack to set

 @see #setItem(int, ItemStack)]]>
      </doc>
    </method>
    <method name="getItem" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <doc>
      <![CDATA[Gets the ItemStack at the given equipment slot in the inventory.

 @param slot the slot to get the ItemStack

 @return the ItemStack in the given slot]]>
      </doc>
    </method>
    <method name="setArmorContents"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="items" type="org.bukkit.inventory.ItemStack[]"/>
      <doc>
      <![CDATA[Put the given ItemStacks into the armor slots

 @param items The ItemStacks to use as armour]]>
      </doc>
    </method>
    <method name="setExtraContents"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="items" type="org.bukkit.inventory.ItemStack[]"/>
      <doc>
      <![CDATA[Put the given ItemStacks into the extra slots
 <br>
 See {@link #getExtraContents()} for an explanation of extra slots.

 @param items The ItemStacks to use as extra]]>
      </doc>
    </method>
    <method name="setHelmet"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="helmet" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Put the given ItemStack into the helmet slot. This does not check if
 the ItemStack is a helmet

 @param helmet The ItemStack to use as helmet]]>
      </doc>
    </method>
    <method name="setChestplate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chestplate" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Put the given ItemStack into the chestplate slot. This does not check
 if the ItemStack is a chestplate

 @param chestplate The ItemStack to use as chestplate]]>
      </doc>
    </method>
    <method name="setLeggings"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leggings" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Put the given ItemStack into the leg slot. This does not check if the
 ItemStack is a pair of leggings

 @param leggings The ItemStack to use as leggings]]>
      </doc>
    </method>
    <method name="setBoots"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="boots" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Put the given ItemStack into the boots slot. This does not check if the
 ItemStack is a boots

 @param boots The ItemStack to use as boots]]>
      </doc>
    </method>
    <method name="getItemInMainHand" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the item the player is currently holding
 in their main hand.

 @return the currently held item]]>
      </doc>
    </method>
    <method name="setItemInMainHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item the player is holding in their main hand.

 @param item The item to put into the player's hand]]>
      </doc>
    </method>
    <method name="getItemInOffHand" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of the item the player is currently holding
 in their off hand.

 @return the currently held item]]>
      </doc>
    </method>
    <method name="setItemInOffHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item the player is holding in their off hand.

 @param item The item to put into the player's hand]]>
      </doc>
    </method>
    <method name="getItemInHand" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="players can duel wield now use the methods for the
      specific hand instead">
      <doc>
      <![CDATA[Gets a copy of the item the player is currently holding

 @deprecated players can duel wield now use the methods for the
      specific hand instead
 @see #getItemInMainHand()
 @see #getItemInOffHand()
 @return the currently held item]]>
      </doc>
    </method>
    <method name="setItemInHand"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="players can duel wield now use the methods for the
      specific hand instead">
      <param name="stack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the item the player is holding

 @deprecated players can duel wield now use the methods for the
      specific hand instead
 @see #setItemInMainHand(ItemStack)
 @see #setItemInOffHand(ItemStack)
 @param stack The item to put into the player's hand]]>
      </doc>
    </method>
    <method name="getHeldItemSlot" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the slot number of the currently held item

 @return Held item slot number]]>
      </doc>
    </method>
    <method name="setHeldItemSlot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="int"/>
      <doc>
      <![CDATA[Set the slot number of the currently held item.
 <p>
 This validates whether the slot is between 0 and 8 inclusive.

 @param slot The new slot number
 @throws IllegalArgumentException Thrown if slot is not between 0 and 8
     inclusive]]>
      </doc>
    </method>
    <method name="getHolder" return="org.bukkit.entity.HumanEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Player, including the four armor slots and any extra slots.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.PlayerInventory -->
  <!-- start interface org.bukkit.inventory.Recipe -->
  <interface name="Recipe"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the result of this recipe.

 @return The result stack]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents some type of crafting recipe.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.Recipe -->
  <!-- start interface org.bukkit.inventory.RecipeChoice -->
  <interface name="RecipeChoice"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Predicate&lt;org.bukkit.inventory.ItemStack&gt;"/>
    <implements name="java.lang.Cloneable"/>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="for compatability only">
      <doc>
      <![CDATA[Gets a single item stack representative of this stack choice.

 @return a single representative item
 @deprecated for compatability only]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.RecipeChoice"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="test" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <doc>
    <![CDATA[Represents a potential item match within a recipe. All choices within a
 recipe must be satisfied for it to be craftable.

 <b>This class is not legal for implementation by plugins!</b>]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.RecipeChoice -->
  <!-- start class org.bukkit.inventory.RecipeChoice.ExactChoice -->
  <class name="RecipeChoice.ExactChoice" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="draft API">
    <implements name="org.bukkit.inventory.RecipeChoice"/>
    <constructor name="ExactChoice" type="org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ExactChoice" type="org.bukkit.inventory.ItemStack[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ExactChoice" type="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChoices" return="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.inventory.RecipeChoice.ExactChoice"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="test" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a choice that will be valid only one of the stacks is exactly
 matched (aside from stack size).
 <br>
 <b>Only valid for shaped recipes</b>

 @deprecated draft API]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.RecipeChoice.ExactChoice -->
  <!-- start class org.bukkit.inventory.RecipeChoice.MaterialChoice -->
  <class name="RecipeChoice.MaterialChoice" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.RecipeChoice"/>
    <constructor name="MaterialChoice" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MaterialChoice" type="org.bukkit.Material[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MaterialChoice" type="org.bukkit.Tag&lt;org.bukkit.Material&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a MaterialChoice with the current values of the specified
 tag.

 @param choices the tag]]>
      </doc>
    </constructor>
    <constructor name="MaterialChoice" type="java.util.List&lt;org.bukkit.Material&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="test" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="getItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChoices" return="java.util.List&lt;org.bukkit.Material&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.inventory.RecipeChoice.MaterialChoice"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a choice of multiple matching Materials.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.RecipeChoice.MaterialChoice -->
  <!-- start interface org.bukkit.inventory.SaddledHorseInventory -->
  <interface name="SaddledHorseInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.AbstractHorseInventory"/>
  </interface>
  <!-- end interface org.bukkit.inventory.SaddledHorseInventory -->
  <!-- start class org.bukkit.inventory.ShapedRecipe -->
  <class name="ShapedRecipe" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Recipe"/>
    <implements name="org.bukkit.Keyed"/>
    <constructor name="ShapedRecipe" type="org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ShapedRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a shaped recipe to craft the specified ItemStack. The
 constructor merely determines the result and type; to set the actual
 recipe, you'll need to call the appropriate methods.

 @param key the unique recipe key
 @param result The item you want the recipe to create.
 @see ShapedRecipe#shape(String...)
 @see ShapedRecipe#setIngredient(char, Material)
 @see ShapedRecipe#setIngredient(char, Material, int)
 @see ShapedRecipe#setIngredient(char, MaterialData)]]>
      </doc>
    </constructor>
    <method name="shape" return="org.bukkit.inventory.ShapedRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shape" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the shape of this recipe to the specified rows. Each character
 represents a different ingredient; exactly what each character
 represents is set separately. The first row supplied corresponds with
 the upper most part of the recipe on the workbench e.g. if all three
 rows are supplies the first string represents the top row on the
 workbench.

 @param shape The rows of the recipe (up to 3 rows).
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="setIngredient" return="org.bukkit.inventory.ShapedRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="char"/>
      <param name="ingredient" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Sets the material that a character in the recipe shape refers to.

 @param key The character that represents the ingredient in the shape.
 @param ingredient The ingredient.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="setIngredient" return="org.bukkit.inventory.ShapedRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="char"/>
      <param name="ingredient" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Sets the material that a character in the recipe shape refers to.

 @param key The character that represents the ingredient in the shape.
 @param ingredient The ingredient.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="setIngredient" return="org.bukkit.inventory.ShapedRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="key" type="char"/>
      <param name="ingredient" type="org.bukkit.Material"/>
      <param name="raw" type="int"/>
      <doc>
      <![CDATA[Sets the material that a character in the recipe shape refers to.

 @param key The character that represents the ingredient in the shape.
 @param ingredient The ingredient.
 @param raw The raw material data as an integer.
 @return The changed recipe, so you can chain calls.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setIngredient" return="org.bukkit.inventory.ShapedRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="char"/>
      <param name="ingredient" type="org.bukkit.inventory.RecipeChoice"/>
    </method>
    <method name="setIngredient" return="org.bukkit.inventory.ShapedRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="char"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="getIngredientMap" return="java.util.Map&lt;java.lang.Character, org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a copy of the ingredients map.

 @return The mapping of character to ingredients.]]>
      </doc>
    </method>
    <method name="getChoiceMap" return="java.util.Map&lt;java.lang.Character, org.bukkit.inventory.RecipeChoice&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getShape" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the shape.

 @return The recipe's shape.
 @throws NullPointerException when not set yet]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the result.

 @return The result stack.]]>
      </doc>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGroup" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group of this recipe. Recipes with the same group may be grouped
 together when displayed in the client.

 @return recipe group. An empty string denotes no group. May not be null.]]>
      </doc>
    </method>
    <method name="setGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the group of this recipe. Recipes with the same group may be grouped
 together when displayed in the client.

 @param group recipe group. An empty string denotes no group. May not be
 null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a shaped (ie normal) crafting recipe.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.ShapedRecipe -->
  <!-- start class org.bukkit.inventory.ShapelessRecipe -->
  <class name="ShapelessRecipe" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Recipe"/>
    <implements name="org.bukkit.Keyed"/>
    <constructor name="ShapelessRecipe" type="org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ShapelessRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a shapeless recipe to craft the specified ItemStack. The
 constructor merely determines the result and type; to set the actual
 recipe, you'll need to call the appropriate methods.

 @param key the unique recipe key
 @param result The item you want the recipe to create.
 @see ShapelessRecipe#addIngredient(Material)
 @see ShapelessRecipe#addIngredient(MaterialData)
 @see ShapelessRecipe#addIngredient(Material,int)
 @see ShapelessRecipe#addIngredient(int,Material)
 @see ShapelessRecipe#addIngredient(int,MaterialData)
 @see ShapelessRecipe#addIngredient(int,Material,int)]]>
      </doc>
    </constructor>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ingredient" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Adds the specified ingredient.

 @param ingredient The ingredient to add.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ingredient" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Adds the specified ingredient.

 @param ingredient The ingredient to add.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="ingredient" type="org.bukkit.Material"/>
      <param name="rawdata" type="int"/>
      <doc>
      <![CDATA[Adds the specified ingredient.

 @param ingredient The ingredient to add.
 @param rawdata The data value, or -1 to allow any data value.
 @return The changed recipe, so you can chain calls.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <param name="ingredient" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Adds multiples of the specified ingredient.

 @param count How many to add (can't be more than 9!)
 @param ingredient The ingredient to add.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <param name="ingredient" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Adds multiples of the specified ingredient.

 @param count How many to add (can't be more than 9!)
 @param ingredient The ingredient to add.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="count" type="int"/>
      <param name="ingredient" type="org.bukkit.Material"/>
      <param name="rawdata" type="int"/>
      <doc>
      <![CDATA[Adds multiples of the specified ingredient.

 @param count How many to add (can't be more than 9!)
 @param ingredient The ingredient to add.
 @param rawdata The data value, or -1 to allow any data value.
 @return The changed recipe, so you can chain calls.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ingredient" type="org.bukkit.inventory.RecipeChoice"/>
    </method>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="addIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ingredient" type="org.bukkit.inventory.RecipeChoice"/>
      <doc>
      <![CDATA[Removes an ingredient from the list.

 @param ingredient The ingredient to remove
 @return The changed recipe.]]>
      </doc>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ingredient" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Removes an ingredient from the list. If the ingredient occurs multiple
 times, only one instance of it is removed. Only removes exact matches,
 with a data value of 0.

 @param ingredient The ingredient to remove
 @return The changed recipe.]]>
      </doc>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ingredient" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Removes an ingredient from the list. If the ingredient occurs multiple
 times, only one instance of it is removed. If the data value is -1,
 only ingredients with a -1 data value will be removed.

 @param ingredient The ingredient to remove
 @return The changed recipe.]]>
      </doc>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <param name="ingredient" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Removes multiple instances of an ingredient from the list. If there are
 less instances then specified, all will be removed. Only removes exact
 matches, with a data value of 0.

 @param count The number of copies to remove.
 @param ingredient The ingredient to remove
 @return The changed recipe.]]>
      </doc>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <param name="ingredient" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Removes multiple instances of an ingredient from the list. If there are
 less instances then specified, all will be removed. If the data value
 is -1, only ingredients with a -1 data value will be removed.

 @param count The number of copies to remove.
 @param ingredient The ingredient to remove.
 @return The changed recipe.]]>
      </doc>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="ingredient" type="org.bukkit.Material"/>
      <param name="rawdata" type="int"/>
      <doc>
      <![CDATA[Removes an ingredient from the list. If the ingredient occurs multiple
 times, only one instance of it is removed. If the data value is -1,
 only ingredients with a -1 data value will be removed.

 @param ingredient The ingredient to remove
 @param rawdata The data value;
 @return The changed recipe.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="removeIngredient" return="org.bukkit.inventory.ShapelessRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="count" type="int"/>
      <param name="ingredient" type="org.bukkit.Material"/>
      <param name="rawdata" type="int"/>
      <doc>
      <![CDATA[Removes multiple instances of an ingredient from the list. If there are
 less instances then specified, all will be removed. If the data value
 is -1, only ingredients with a -1 data value will be removed.

 @param count The number of copies to remove.
 @param ingredient The ingredient to remove.
 @param rawdata The data value.
 @return The changed recipe.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the result of this recipe.

 @return The result stack.]]>
      </doc>
    </method>
    <method name="getIngredientList" return="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the list of ingredients used for this recipe.

 @return The input list]]>
      </doc>
    </method>
    <method name="getChoiceList" return="java.util.List&lt;org.bukkit.inventory.RecipeChoice&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGroup" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group of this recipe. Recipes with the same group may be grouped
 together when displayed in the client.

 @return recipe group. An empty string denotes no group. May not be null.]]>
      </doc>
    </method>
    <method name="setGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the group of this recipe. Recipes with the same group may be grouped
 together when displayed in the client.

 @param group recipe group. An empty string denotes no group. May not be
 null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a shapeless recipe, where the arrangement of the ingredients on
 the crafting grid does not matter.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.ShapelessRecipe -->
  <!-- start interface org.bukkit.inventory.SmithingInventory -->
  <interface name="SmithingInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getInputEquipment" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the input equipment (first slot).

 @return input equipment item]]>
      </doc>
    </method>
    <method name="setInputEquipment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the input equipment (first slot).

 @param itemStack item to set]]>
      </doc>
    </method>
    <method name="getInputMineral" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the input mineral (second slot).

 @return input mineral item]]>
      </doc>
    </method>
    <method name="setInputMineral"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the input mineral (second slot).

 @param itemStack item to set]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the result item.

 @return result]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the result item.

 @param itemStack item to set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Smithing table.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.SmithingInventory -->
  <!-- start class org.bukkit.inventory.SmithingRecipe -->
  <class name="SmithingRecipe" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Recipe"/>
    <implements name="org.bukkit.Keyed"/>
    <constructor name="SmithingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.inventory.RecipeChoice, org.bukkit.inventory.RecipeChoice"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a smithing recipe to produce the specified result ItemStack.

 @param key The unique recipe key
 @param result The item you want the recipe to create.
 @param base The base ingredient
 @param addition The addition ingredient]]>
      </doc>
    </constructor>
    <method name="getBase" return="org.bukkit.inventory.RecipeChoice"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the base recipe item.

 @return base choice]]>
      </doc>
    </method>
    <method name="getAddition" return="org.bukkit.inventory.RecipeChoice"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the addition recipe item.

 @return addition choice]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a smithing recipe.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.SmithingRecipe -->
  <!-- start class org.bukkit.inventory.SmokingRecipe -->
  <class name="SmokingRecipe" extends="org.bukkit.inventory.CookingRecipe&lt;org.bukkit.inventory.SmokingRecipe&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SmokingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.Material, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SmokingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.inventory.RecipeChoice, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Represents a campfire recipe.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.SmokingRecipe -->
  <!-- start interface org.bukkit.inventory.StonecutterInventory -->
  <interface name="StonecutterInventory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Inventory"/>
    <method name="getInputItem" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the input item.

 @return input item]]>
      </doc>
    </method>
    <method name="setInputItem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the input item.

 @param itemStack item to set]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the result item.

 @return result]]>
      </doc>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemStack" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Sets the result item.

 @param itemStack item to set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to the inventory of a Stonecutter.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.StonecutterInventory -->
  <!-- start class org.bukkit.inventory.StonecuttingRecipe -->
  <class name="StonecuttingRecipe" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.Recipe"/>
    <implements name="org.bukkit.Keyed"/>
    <constructor name="StonecuttingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a Stonecutting recipe to craft the specified ItemStack.

 @param key The unique recipe key
 @param result The item you want the recipe to create.
 @param source The input material.]]>
      </doc>
    </constructor>
    <constructor name="StonecuttingRecipe" type="org.bukkit.NamespacedKey, org.bukkit.inventory.ItemStack, org.bukkit.inventory.RecipeChoice"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a cooking recipe to craft the specified ItemStack.

 @param key The unique recipe key
 @param result The item you want the recipe to create.
 @param input The input choices.]]>
      </doc>
    </constructor>
    <method name="setInput" return="org.bukkit.inventory.StonecuttingRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Sets the input of this cooking recipe.

 @param input The input material.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="getInput" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the input material.

 @return The input material.]]>
      </doc>
    </method>
    <method name="setInputChoice" return="org.bukkit.inventory.StonecuttingRecipe"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="org.bukkit.inventory.RecipeChoice"/>
      <doc>
      <![CDATA[Sets the input of this cooking recipe.

 @param input The input choice.
 @return The changed recipe, so you can chain calls.]]>
      </doc>
    </method>
    <method name="getInputChoice" return="org.bukkit.inventory.RecipeChoice"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the input choice.

 @return The input choice.]]>
      </doc>
    </method>
    <method name="getResult" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the result of this recipe.

 @return The resulting stack.]]>
      </doc>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGroup" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group of this recipe. Recipes with the same group may be grouped
 together when displayed in the client.

 @return recipe group. An empty string denotes no group. May not be null.]]>
      </doc>
    </method>
    <method name="setGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the group of this recipe. Recipes with the same group may be grouped
 together when displayed in the client.

 @param group recipe group. An empty string denotes no group. May not be
 null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Stonecutting recipe.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.StonecuttingRecipe -->
</package>
<package name="org.bukkit.inventory.meta">
  <!-- start interface org.bukkit.inventory.meta.BannerMeta -->
  <interface name="BannerMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="getBaseColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="banner color is now stored as the data value, not meta.">
      <doc>
      <![CDATA[Returns the base color for this banner

 @return the base color
 @deprecated banner color is now stored as the data value, not meta.]]>
      </doc>
    </method>
    <method name="setBaseColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="banner color is now stored as the data value, not meta.">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the base color for this banner

 @param color the base color
 @deprecated banner color is now stored as the data value, not meta.]]>
      </doc>
    </method>
    <method name="getPatterns" return="java.util.List&lt;org.bukkit.block.banner.Pattern&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of patterns on this banner

 @return the patterns]]>
      </doc>
    </method>
    <method name="setPatterns"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="patterns" type="java.util.List&lt;org.bukkit.block.banner.Pattern&gt;"/>
      <doc>
      <![CDATA[Sets the patterns used on this banner

 @param patterns the new list of patterns]]>
      </doc>
    </method>
    <method name="addPattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="org.bukkit.block.banner.Pattern"/>
      <doc>
      <![CDATA[Adds a new pattern on top of the existing
 patterns

 @param pattern the new pattern to add]]>
      </doc>
    </method>
    <method name="getPattern" return="org.bukkit.block.banner.Pattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Returns the pattern at the specified index

 @param i the index
 @return the pattern
 @throws IndexOutOfBoundsException when index is not in [0, numberOfPatterns()) range]]>
      </doc>
    </method>
    <method name="removePattern" return="org.bukkit.block.banner.Pattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Removes the pattern at the specified index

 @param i the index
 @return the removed pattern
 @throws IndexOutOfBoundsException when index is not in [0, numberOfPatterns()) range]]>
      </doc>
    </method>
    <method name="setPattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="pattern" type="org.bukkit.block.banner.Pattern"/>
      <doc>
      <![CDATA[Sets the pattern at the specified index

 @param i       the index
 @param pattern the new pattern
 @throws IndexOutOfBoundsException when index is not in [0, numberOfPatterns()) range]]>
      </doc>
    </method>
    <method name="numberOfPatterns" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of patterns on this
 banner

 @return the number of patterns]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.BannerMeta -->
  <!-- start interface org.bukkit.inventory.meta.BlockDataMeta -->
  <interface name="BlockDataMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasBlockData" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the item has block data currently attached to it.

 @return whether block data is already attached]]>
      </doc>
    </method>
    <method name="getBlockData" return="org.bukkit.block.data.BlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Returns the currently attached block data for this item or creates a new
 one if one doesn't exist.

 The state is a copy, it must be set back (or to another item) with
 {@link #setBlockData(org.bukkit.block.data.BlockData)}

 @param material the material we wish to get this data in the context of
 @return the attached data or new data]]>
      </doc>
    </method>
    <method name="setBlockData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blockData" type="org.bukkit.block.data.BlockData"/>
      <doc>
      <![CDATA[Attaches a copy of the passed block data to the item.

 @param blockData the block data to attach to the block.
 @throws IllegalArgumentException if the blockData is null or invalid for
 this item.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.BlockDataMeta -->
  <!-- start interface org.bukkit.inventory.meta.BlockStateMeta -->
  <interface name="BlockStateMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasBlockState" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the item has a block state currently
 attached to it.

 @return whether a block state is already attached]]>
      </doc>
    </method>
    <method name="getBlockState" return="org.bukkit.block.BlockState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the currently attached block state for this
 item or creates a new one if one doesn't exist.

 The state is a copy, it must be set back (or to another
 item) with {@link #setBlockState(org.bukkit.block.BlockState)}

 @return the attached state or a new state]]>
      </doc>
    </method>
    <method name="setBlockState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blockState" type="org.bukkit.block.BlockState"/>
      <doc>
      <![CDATA[Attaches a copy of the passed block state to the item.

 @param blockState the block state to attach to the block.
 @throws IllegalArgumentException if the blockState is null
         or invalid for this item.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.BlockStateMeta -->
  <!-- start interface org.bukkit.inventory.meta.BookMeta -->
  <interface name="BookMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasTitle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of a title in the book.

 @return true if the book has a title]]>
      </doc>
    </method>
    <method name="getTitle" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the title of the book.
 <p>
 Plugins should check that hasTitle() returns true before calling this
 method.

 @return the title of the book]]>
      </doc>
    </method>
    <method name="setTitle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the title of the book.
 <p>
 Limited to 32 characters. Removes title when given null.

 @param title the title to set
 @return true if the title was successfully set]]>
      </doc>
    </method>
    <method name="hasAuthor" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of an author in the book.

 @return true if the book has an author]]>
      </doc>
    </method>
    <method name="getAuthor" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the author of the book.
 <p>
 Plugins should check that hasAuthor() returns true before calling this
 method.

 @return the author of the book]]>
      </doc>
    </method>
    <method name="setAuthor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="author" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the author of the book. Removes author when given null.

 @param author the author to set]]>
      </doc>
    </method>
    <method name="hasGeneration" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of generation level in the book.

 @return true if the book has a generation level]]>
      </doc>
    </method>
    <method name="getGeneration" return="org.bukkit.inventory.meta.BookMeta.Generation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the generation of the book.
 <p>
 Plugins should check that hasGeneration() returns true before calling
 this method.

 @return the generation of the book]]>
      </doc>
    </method>
    <method name="setGeneration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="generation" type="org.bukkit.inventory.meta.BookMeta.Generation"/>
      <doc>
      <![CDATA[Sets the generation of the book. Removes generation when given null.

 @param generation the generation to set]]>
      </doc>
    </method>
    <method name="hasPages" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of pages in the book.

 @return true if the book has pages]]>
      </doc>
    </method>
    <method name="getPage" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="page" type="int"/>
      <doc>
      <![CDATA[Gets the specified page in the book. The given page must exist.
 <p>
 Pages are 1-indexed.

 @param page the page number to get, in range [1, getPageCount()]
 @return the page from the book]]>
      </doc>
    </method>
    <method name="setPage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="page" type="int"/>
      <param name="data" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the specified page in the book. Pages of the book must be
 contiguous.
 <p>
 The data can be up to 256 characters in length, additional characters
 are truncated.
 <p>
 Pages are 1-indexed.

 @param page the page number to set, in range [1, getPageCount()]
 @param data the data to set for that page]]>
      </doc>
    </method>
    <method name="getPages" return="java.util.List&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all the pages in the book.

 @return list of all the pages in the book]]>
      </doc>
    </method>
    <method name="setPages"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pages" type="java.util.List&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Clears the existing book pages, and sets the book to use the provided
 pages. Maximum 100 pages with 256 characters per page.

 @param pages A list of pages to set the book to use]]>
      </doc>
    </method>
    <method name="setPages"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pages" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Clears the existing book pages, and sets the book to use the provided
 pages. Maximum 50 pages with 256 characters per page.

 @param pages A list of strings, each being a page]]>
      </doc>
    </method>
    <method name="addPage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pages" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Adds new pages to the end of the book. Up to a maximum of 50 pages with
 256 characters per page.

 @param pages A list of strings, each being a page]]>
      </doc>
    </method>
    <method name="getPageCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of pages in the book.

 @return the number of pages in the book]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.BookMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="spigot" return="org.bukkit.inventory.meta.BookMeta.Spigot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a book ({@link Material#WRITABLE_BOOK} or {@link
 Material#WRITTEN_BOOK}) that can have a title, an author, and pages.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.BookMeta -->
  <!-- start class org.bukkit.inventory.meta.BookMeta.Generation -->
  <class name="BookMeta.Generation" extends="java.lang.Enum&lt;org.bukkit.inventory.meta.BookMeta.Generation&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.inventory.meta.BookMeta.Generation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.inventory.meta.BookMeta.Generation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the generation (or level of copying) of a written book]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.meta.BookMeta.Generation -->
  <!-- start class org.bukkit.inventory.meta.BookMeta.Spigot -->
  <class name="BookMeta.Spigot" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spigot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPage" return="BaseComponent[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="page" type="int"/>
      <doc>
      <![CDATA[Gets the specified page in the book. The given page must exist.

 @param page the page number to get
 @return the page from the book]]>
      </doc>
    </method>
    <method name="setPage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="page" type="int"/>
      <param name="data" type="BaseComponent[]"/>
      <doc>
      <![CDATA[Sets the specified page in the book. Pages of the book must be
 contiguous.
 <p>
 The data can be up to 256 characters in length, additional characters
 are truncated.

 @param page the page number to set
 @param data the data to set for that page]]>
      </doc>
    </method>
    <method name="getPages" return="java.util.List&lt;BaseComponent[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all the pages in the book.

 @return list of all the pages in the book]]>
      </doc>
    </method>
    <method name="setPages"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pages" type="java.util.List&lt;BaseComponent[]&gt;"/>
      <doc>
      <![CDATA[Clears the existing book pages, and sets the book to use the provided
 pages. Maximum 50 pages with 256 characters per page.

 @param pages A list of pages to set the book to use]]>
      </doc>
    </method>
    <method name="setPages"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pages" type="BaseComponent[][]"/>
      <doc>
      <![CDATA[Clears the existing book pages, and sets the book to use the provided
 pages. Maximum 50 pages with 256 characters per page.

 @param pages A list of component arrays, each being a page]]>
      </doc>
    </method>
    <method name="addPage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pages" type="BaseComponent[][]"/>
      <doc>
      <![CDATA[Adds new pages to the end of the book. Up to a maximum of 50 pages
 with 256 characters per page.

 @param pages A list of component arrays, each being a page]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.inventory.meta.BookMeta.Spigot -->
  <!-- start interface org.bukkit.inventory.meta.CompassMeta -->
  <interface name="CompassMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasLodestone" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this compass has been paired to a lodestone.

 @return paired status]]>
      </doc>
    </method>
    <method name="getLodestone" return="org.bukkit.Location"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location that this compass will point to.

 Check {@link #hasLodestone()} first!

 @return lodestone location]]>
      </doc>
    </method>
    <method name="setLodestone"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lodestone" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets the location this lodestone compass will point to.

 @param lodestone new location or null to clear]]>
      </doc>
    </method>
    <method name="isLodestoneTracked" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets if this compass is tracking a specific lodestone.

 If true the compass will only work if there is a lodestone at the tracked
 location.

 @return lodestone tracked]]>
      </doc>
    </method>
    <method name="setLodestoneTracked"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tracked" type="boolean"/>
      <doc>
      <![CDATA[Sets if this compass is tracking a specific lodestone.

 If true the compass will only work if there is a lodestone at the tracked
 location.

 @param tracked new tracked status]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.CompassMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a compass that can track a specific location.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.CompassMeta -->
  <!-- start interface org.bukkit.inventory.meta.CrossbowMeta -->
  <interface name="CrossbowMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasChargedProjectiles" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the item has any charged projectiles.

 @return whether charged projectiles are present]]>
      </doc>
    </method>
    <method name="getChargedProjectiles" return="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable list of the projectiles charged on this item.

 @return charged projectiles]]>
      </doc>
    </method>
    <method name="setChargedProjectiles"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="projectiles" type="java.util.List&lt;org.bukkit.inventory.ItemStack&gt;"/>
      <doc>
      <![CDATA[Sets the projectiles charged on this item.

 Removes all projectiles when given null.

 @param projectiles the projectiles to set
 @throws IllegalArgumentException if one of the projectiles is not an
 arrow or firework rocket]]>
      </doc>
    </method>
    <method name="addChargedProjectile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Adds a charged projectile to this item.

 @param item projectile
 @throws IllegalArgumentException if the projectile is not an arrow or
 firework rocket]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.CrossbowMeta -->
  <!-- start interface org.bukkit.inventory.meta.Damageable -->
  <interface name="Damageable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hasDamage" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if this item has damage

 @return true if this has damage]]>
      </doc>
    </method>
    <method name="getDamage" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the damage

 @return the damage]]>
      </doc>
    </method>
    <method name="setDamage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="int"/>
      <doc>
      <![CDATA[Sets the damage

 @param damage item damage]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.Damageable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an item that has durability and can take damage.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.Damageable -->
  <!-- start interface org.bukkit.inventory.meta.EnchantmentStorageMeta -->
  <interface name="EnchantmentStorageMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasStoredEnchants" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of any stored enchantments.

 @return true if an enchantment exists on this meta]]>
      </doc>
    </method>
    <method name="hasStoredEnchant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Checks for storage of the specified enchantment.

 @param ench enchantment to check
 @return true if this enchantment is stored in this meta]]>
      </doc>
    </method>
    <method name="getStoredEnchantLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Checks for the level of the stored enchantment.

 @param ench enchantment to check
 @return The level that the specified stored enchantment has, or 0 if
     none]]>
      </doc>
    </method>
    <method name="getStoredEnchants" return="java.util.Map&lt;org.bukkit.enchantments.Enchantment, java.lang.Integer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy the stored enchantments in this ItemMeta.

 @return An immutable copy of the stored enchantments]]>
      </doc>
    </method>
    <method name="addStoredEnchant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <param name="level" type="int"/>
      <param name="ignoreLevelRestriction" type="boolean"/>
      <doc>
      <![CDATA[Stores the specified enchantment in this item meta.

 @param ench Enchantment to store
 @param level Level for the enchantment
 @param ignoreLevelRestriction this indicates the enchantment should be
     applied, ignoring the level limit
 @return true if the item meta changed as a result of this call, false
     otherwise
 @throws IllegalArgumentException if enchantment is null]]>
      </doc>
    </method>
    <method name="removeStoredEnchant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Remove the specified stored enchantment from this item meta.

 @param ench Enchantment to remove
 @return true if the item meta changed as a result of this call, false
     otherwise
 @throws IllegalArgumentException if enchantment is null]]>
      </doc>
    </method>
    <method name="hasConflictingStoredEnchant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Checks if the specified enchantment conflicts with any enchantments in
 this ItemMeta.

 @param ench enchantment to test
 @return true if the enchantment conflicts, false otherwise]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.EnchantmentStorageMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[EnchantmentMeta is specific to items that can <i>store</i> enchantments, as
 opposed to being enchanted. {@link Material#ENCHANTED_BOOK} is an example
 of an item with enchantment storage.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.EnchantmentStorageMeta -->
  <!-- start interface org.bukkit.inventory.meta.FireworkEffectMeta -->
  <interface name="FireworkEffectMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="setEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.FireworkEffect"/>
      <doc>
      <![CDATA[Sets the firework effect for this meta.

 @param effect the effect to set, or null to indicate none.]]>
      </doc>
    </method>
    <method name="hasEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this meta has an effect.

 @return true if this meta has an effect, false otherwise]]>
      </doc>
    </method>
    <method name="getEffect" return="org.bukkit.FireworkEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the firework effect for this meta.

 @return the current effect, or null if none]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.FireworkEffectMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a meta that can store a single FireworkEffect. An example
 includes {@link Material#FIREWORK_STAR}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.FireworkEffectMeta -->
  <!-- start interface org.bukkit.inventory.meta.FireworkMeta -->
  <interface name="FireworkMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="addEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.FireworkEffect"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add another effect to this firework.

 @param effect The firework effect to add
 @throws IllegalArgumentException If effect is null]]>
      </doc>
    </method>
    <method name="addEffects"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effects" type="org.bukkit.FireworkEffect[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add several effects to this firework.

 @param effects The firework effects to add
 @throws IllegalArgumentException If effects is null
 @throws IllegalArgumentException If any effect is null (may be thrown
     after changes have occurred)]]>
      </doc>
    </method>
    <method name="addEffects"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effects" type="java.lang.Iterable&lt;org.bukkit.FireworkEffect&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Add several firework effects to this firework.

 @param effects An iterable object whose iterator yields the desired
     firework effects
 @throws IllegalArgumentException If effects is null
 @throws IllegalArgumentException If any effect is null (may be thrown
     after changes have occurred)]]>
      </doc>
    </method>
    <method name="getEffects" return="java.util.List&lt;org.bukkit.FireworkEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the effects in this firework.

 @return An immutable list of the firework effects]]>
      </doc>
    </method>
    <method name="getEffectsSize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of effects in this firework.

 @return The number of effects]]>
      </doc>
    </method>
    <method name="removeEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <exception name="IndexOutOfBoundsException" type="java.lang.IndexOutOfBoundsException"/>
      <doc>
      <![CDATA[Remove an effect from this firework.

 @param index The index of the effect to remove
 @throws IndexOutOfBoundsException If index {@literal < 0 or index >} {@link
     #getEffectsSize()}]]>
      </doc>
    </method>
    <method name="clearEffects"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Remove all effects from this firework.]]>
      </doc>
    </method>
    <method name="hasEffects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether this firework has any effects.

 @return true if it has effects, false if there are no effects]]>
      </doc>
    </method>
    <method name="getPower" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the approximate height the firework will fly.

 @return approximate flight height of the firework.]]>
      </doc>
    </method>
    <method name="setPower"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="power" type="int"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the approximate power of the firework. Each level of power is half
 a second of flight time.

 @param power the power of the firework, from 0-128
 @throws IllegalArgumentException if {@literal height<0 or height>128}]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.FireworkMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a {@link Material#FIREWORK_ROCKET} and its effects.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.FireworkMeta -->
  <!-- start interface org.bukkit.inventory.meta.ItemMeta -->
  <interface name="ItemMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <implements name="org.bukkit.persistence.PersistentDataHolder"/>
    <method name="hasDisplayName" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of a display name.

 @return true if this has a display name]]>
      </doc>
    </method>
    <method name="getDisplayName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the display name that is set.
 <p>
 Plugins should check that hasDisplayName() returns <code>true</code>
 before calling this method.

 @return the display name that is set]]>
      </doc>
    </method>
    <method name="getDisplayNameComponent" return="net.md_5.bungee.api.chat.BaseComponent[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the display name that is set.
 <p>
 Plugins should check that hasDisplayName() returns <code>true</code>
 before calling this method.

 @return the display name that is set]]>
      </doc>
    </method>
    <method name="setDisplayName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the display name.

 @param name the name to set]]>
      </doc>
    </method>
    <method name="setDisplayNameComponent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="component" type="net.md_5.bungee.api.chat.BaseComponent[]"/>
      <doc>
      <![CDATA[Sets the display name.

 @param component the name component to set]]>
      </doc>
    </method>
    <method name="hasLocalizedName" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of a localized name.

 @return true if this has a localized name]]>
      </doc>
    </method>
    <method name="getLocalizedName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the localized display name that is set.
 <p>
 Plugins should check that hasLocalizedName() returns <code>true</code>
 before calling this method.

 @return the localized name that is set]]>
      </doc>
    </method>
    <method name="setLocalizedName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the localized name.

 @param name the name to set]]>
      </doc>
    </method>
    <method name="hasLore" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of lore.

 @return true if this has lore]]>
      </doc>
    </method>
    <method name="getLore" return="java.util.List&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the lore that is set.
 <p>
 Plugins should check if hasLore() returns <code>true</code> before
 calling this method.

 @return a list of lore that is set]]>
      </doc>
    </method>
    <method name="getLoreComponents" return="java.util.List&lt;net.md_5.bungee.api.chat.BaseComponent[]&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the lore that is set.
 <p>
 Plugins should check if hasLore() returns <code>true</code> before
 calling this method.

 @return a list of lore that is set]]>
      </doc>
    </method>
    <method name="setLore"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lore" type="java.util.List&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Sets the lore for this item.
 Removes lore when given null.

 @param lore the lore that will be set]]>
      </doc>
    </method>
    <method name="setLoreComponents"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lore" type="java.util.List&lt;net.md_5.bungee.api.chat.BaseComponent[]&gt;"/>
      <doc>
      <![CDATA[Sets the lore for this item.
 Removes lore when given null.

 @param lore the lore that will be set]]>
      </doc>
    </method>
    <method name="hasCustomModelData" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of custom model data.
 <p>
 CustomModelData is an integer that may be associated client side with a
 custom item model.

 @return true if this has custom model data]]>
      </doc>
    </method>
    <method name="getCustomModelData" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the custom model data that is set.
 <p>
 CustomModelData is an integer that may be associated client side with a
 custom item model.
 <p>
 Plugins should check that hasCustomModelData() returns <code>true</code>
 before calling this method.

 @return the localized name that is set]]>
      </doc>
    </method>
    <method name="setCustomModelData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Sets the custom model data.
 <p>
 CustomModelData is an integer that may be associated client side with a
 custom item model.

 @param data the data to set, or null to clear]]>
      </doc>
    </method>
    <method name="hasEnchants" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of any enchantments.

 @return true if an enchantment exists on this meta]]>
      </doc>
    </method>
    <method name="hasEnchant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Checks for existence of the specified enchantment.

 @param ench enchantment to check
 @return true if this enchantment exists for this meta]]>
      </doc>
    </method>
    <method name="getEnchantLevel" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Checks for the level of the specified enchantment.

 @param ench enchantment to check
 @return The level that the specified enchantment has, or 0 if none]]>
      </doc>
    </method>
    <method name="getEnchants" return="java.util.Map&lt;org.bukkit.enchantments.Enchantment, java.lang.Integer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a copy the enchantments in this ItemMeta. <br>
 Returns an empty map if none.

 @return An immutable copy of the enchantments]]>
      </doc>
    </method>
    <method name="addEnchant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <param name="level" type="int"/>
      <param name="ignoreLevelRestriction" type="boolean"/>
      <doc>
      <![CDATA[Adds the specified enchantment to this item meta.

 @param ench Enchantment to add
 @param level Level for the enchantment
 @param ignoreLevelRestriction this indicates the enchantment should be
     applied, ignoring the level limit
 @return true if the item meta changed as a result of this call, false
     otherwise]]>
      </doc>
    </method>
    <method name="removeEnchant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Removes the specified enchantment from this item meta.

 @param ench Enchantment to remove
 @return true if the item meta changed as a result of this call, false
     otherwise]]>
      </doc>
    </method>
    <method name="hasConflictingEnchant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ench" type="org.bukkit.enchantments.Enchantment"/>
      <doc>
      <![CDATA[Checks if the specified enchantment conflicts with any enchantments in
 this ItemMeta.

 @param ench enchantment to test
 @return true if the enchantment conflicts, false otherwise]]>
      </doc>
    </method>
    <method name="addItemFlags"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemFlags" type="org.bukkit.inventory.ItemFlag[]"/>
      <doc>
      <![CDATA[Set itemflags which should be ignored when rendering a ItemStack in the Client. This Method does silently ignore double set itemFlags.

 @param itemFlags The hideflags which shouldn't be rendered]]>
      </doc>
    </method>
    <method name="removeItemFlags"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itemFlags" type="org.bukkit.inventory.ItemFlag[]"/>
      <doc>
      <![CDATA[Remove specific set of itemFlags. This tells the Client it should render it again. This Method does silently ignore double removed itemFlags.

 @param itemFlags Hideflags which should be removed]]>
      </doc>
    </method>
    <method name="getItemFlags" return="java.util.Set&lt;org.bukkit.inventory.ItemFlag&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current set itemFlags. The collection returned is unmodifiable.

 @return A set of all itemFlags set]]>
      </doc>
    </method>
    <method name="hasItemFlag" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="org.bukkit.inventory.ItemFlag"/>
      <doc>
      <![CDATA[Check if the specified flag is present on this item.

 @param flag the flag to check
 @return if it is present]]>
      </doc>
    </method>
    <method name="isUnbreakable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return if the unbreakable tag is true. An unbreakable item will not lose
 durability.

 @return true if the unbreakable tag is true]]>
      </doc>
    </method>
    <method name="setUnbreakable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unbreakable" type="boolean"/>
      <doc>
      <![CDATA[Sets the unbreakable tag. An unbreakable item will not lose durability.

 @param unbreakable true if set unbreakable]]>
      </doc>
    </method>
    <method name="hasAttributeModifiers" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of any AttributeModifiers.

 @return true if any AttributeModifiers exist]]>
      </doc>
    </method>
    <method name="getAttributeModifiers" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return an immutable copy of all Attributes and
 their modifiers in this ItemMeta.<br>
 Returns null if none exist.

 @return an immutable {@link Multimap} of Attributes
         and their AttributeModifiers, or null if none exist]]>
      </doc>
    </method>
    <method name="getAttributeModifiers" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <doc>
      <![CDATA[Return an immutable copy of all {@link Attribute}s and their
 {@link AttributeModifier}s for a given {@link EquipmentSlot}.<br>
 Any {@link AttributeModifier} that does have have a given
 {@link EquipmentSlot} will be returned. This is because
 AttributeModifiers without a slot are active in any slot.<br>
 If there are no attributes set for the given slot, an empty map
 will be returned.

 @param slot the {@link EquipmentSlot} to check
 @return the immutable {@link Multimap} with the
         respective Attributes and modifiers, or an empty map
         if no attributes are set.]]>
      </doc>
    </method>
    <method name="getAttributeModifiers" return="java.util.Collection&lt;org.bukkit.attribute.AttributeModifier&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="org.bukkit.attribute.Attribute"/>
      <doc>
      <![CDATA[Return an immutable copy of all {@link AttributeModifier}s
 for a given {@link Attribute}

 @param attribute the {@link Attribute}
 @return an immutable collection of {@link AttributeModifier}s
          or null if no AttributeModifiers exist for the Attribute.
 @throws NullPointerException if Attribute is null]]>
      </doc>
    </method>
    <method name="addAttributeModifier" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="org.bukkit.attribute.Attribute"/>
      <param name="modifier" type="org.bukkit.attribute.AttributeModifier"/>
      <doc>
      <![CDATA[Add an Attribute and it's Modifier.
 AttributeModifiers can now support {@link EquipmentSlot}s.
 If not set, the {@link AttributeModifier} will be active in ALL slots.
 <br>
 Two {@link AttributeModifier}s that have the same {@link java.util.UUID}
 cannot exist on the same Attribute.

 @param attribute the {@link Attribute} to modify
 @param modifier the {@link AttributeModifier} specifying the modification
 @return true if the Attribute and AttributeModifier were
         successfully added
 @throws NullPointerException if Attribute is null
 @throws NullPointerException if AttributeModifier is null
 @throws IllegalArgumentException if AttributeModifier already exists]]>
      </doc>
    </method>
    <method name="setAttributeModifiers"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributeModifiers" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Set all {@link Attribute}s and their {@link AttributeModifier}s.
 To clear all currently set Attributes and AttributeModifiers use
 null or an empty Multimap.
 If not null nor empty, this will filter all entries that are not-null
 and add them to the ItemStack.

 @param attributeModifiers the new Multimap containing the Attributes
                           and their AttributeModifiers]]>
      </doc>
    </method>
    <method name="removeAttributeModifier" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="org.bukkit.attribute.Attribute"/>
      <doc>
      <![CDATA[Remove all {@link AttributeModifier}s associated with the given
 {@link Attribute}.
 This will return false if nothing was removed.

 @param attribute attribute to remove
 @return  true if all modifiers were removed from a given
                  Attribute. Returns false if no attributes were
                  removed.
 @throws NullPointerException if Attribute is null]]>
      </doc>
    </method>
    <method name="removeAttributeModifier" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.inventory.EquipmentSlot"/>
      <doc>
      <![CDATA[Remove all {@link Attribute}s and {@link AttributeModifier}s for a
 given {@link EquipmentSlot}.<br>
 If the given {@link EquipmentSlot} is null, this will remove all
 {@link AttributeModifier}s that do not have an EquipmentSlot set.

 @param slot the {@link EquipmentSlot} to clear all Attributes and
             their modifiers for
 @return true if all modifiers were removed that match the given
         EquipmentSlot.]]>
      </doc>
    </method>
    <method name="removeAttributeModifier" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="org.bukkit.attribute.Attribute"/>
      <param name="modifier" type="org.bukkit.attribute.AttributeModifier"/>
      <doc>
      <![CDATA[Remove a specific {@link Attribute} and {@link AttributeModifier}.
 AttributeModifiers are matched according to their {@link java.util.UUID}.

 @param attribute the {@link Attribute} to remove
 @param modifier the {@link AttributeModifier} to remove
 @return if any attribute modifiers were remove

 @throws NullPointerException if the Attribute is null
 @throws NullPointerException if the AttributeModifier is null

 @see AttributeModifier#getUniqueId()]]>
      </doc>
    </method>
    <method name="getCustomTagContainer" return="org.bukkit.inventory.meta.tags.CustomItemTagContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="this API part has been replaced by the {@link PersistentDataHolder} API.
 Please use {@link PersistentDataHolder#getPersistentDataContainer()} instead of this.">
      <doc>
      <![CDATA[Returns a public custom tag container capable of storing tags on the
 item.

 Those tags will be sent to the client with all of their content, so the
 client is capable of reading them. This will result in the player seeing
 a NBT Tag notification on the item.

 These tags can also be modified by the client once in creative mode

 @return the custom tag container
 @deprecated this API part has been replaced by the {@link PersistentDataHolder} API.
 Please use {@link PersistentDataHolder#getPersistentDataContainer()} instead of this.]]>
      </doc>
    </method>
    <method name="setVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="internal use only">
      <param name="version" type="int"/>
      <doc>
      <![CDATA[Internal use only! Do not use under any circumstances!

 @param version version
 @deprecated internal use only]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.ItemMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCanDestroy" return="java.util.Set&lt;org.bukkit.Material&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Minecraft does not limit this to the material enum, Use {@link #getDestroyableKeys()} as a replacement">
      <doc>
      <![CDATA[Gets set of materials what given item can destroy in {@link org.bukkit.GameMode#ADVENTURE}

 @return Set of materials
 @deprecated Minecraft does not limit this to the material enum, Use {@link #getDestroyableKeys()} as a replacement]]>
      </doc>
    </method>
    <method name="setCanDestroy"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Minecraft does not limit this to the material enum, Use {@link #setDestroyableKeys(Collection)} as a replacement">
      <param name="canDestroy" type="java.util.Set&lt;org.bukkit.Material&gt;"/>
      <doc>
      <![CDATA[Sets set of materials what given item can destroy in {@link org.bukkit.GameMode#ADVENTURE}

 @param canDestroy Set of materials
 @deprecated Minecraft does not limit this to the material enum, Use {@link #setDestroyableKeys(Collection)} as a replacement]]>
      </doc>
    </method>
    <method name="getCanPlaceOn" return="java.util.Set&lt;org.bukkit.Material&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Minecraft does not limit this to the material enum, Use {@link #getPlaceableKeys()} as a replacement">
      <doc>
      <![CDATA[Gets set of materials where given item can be placed on in {@link org.bukkit.GameMode#ADVENTURE}

 @return Set of materials
 @deprecated Minecraft does not limit this to the material enum, Use {@link #getPlaceableKeys()} as a replacement]]>
      </doc>
    </method>
    <method name="setCanPlaceOn"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Minecraft does not limit this to the material enum, Use {@link #setPlaceableKeys(Collection)} as a replacement">
      <param name="canPlaceOn" type="java.util.Set&lt;org.bukkit.Material&gt;"/>
      <doc>
      <![CDATA[Sets set of materials where given item can be placed on in {@link org.bukkit.GameMode#ADVENTURE}

 @param canPlaceOn Set of materials
 @deprecated Minecraft does not limit this to the material enum, Use {@link #setPlaceableKeys(Collection)} as a replacement]]>
      </doc>
    </method>
    <method name="getDestroyableKeys" return="java.util.Set&lt;com.destroystokyo.paper.Namespaced&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the collection of namespaced keys that the item can destroy in {@link org.bukkit.GameMode#ADVENTURE}

 @return Set of {@link com.destroystokyo.paper.Namespaced}]]>
      </doc>
    </method>
    <method name="setDestroyableKeys"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canDestroy" type="java.util.Collection&lt;com.destroystokyo.paper.Namespaced&gt;"/>
      <doc>
      <![CDATA[Sets the collection of namespaced keys that the item can destroy in {@link org.bukkit.GameMode#ADVENTURE}

 @param canDestroy Collection of {@link com.destroystokyo.paper.Namespaced}]]>
      </doc>
    </method>
    <method name="getPlaceableKeys" return="java.util.Set&lt;com.destroystokyo.paper.Namespaced&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the collection of namespaced keys that the item can be placed on in {@link org.bukkit.GameMode#ADVENTURE}

 @return Set of {@link com.destroystokyo.paper.Namespaced}]]>
      </doc>
    </method>
    <method name="setPlaceableKeys"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canPlaceOn" type="java.util.Collection&lt;com.destroystokyo.paper.Namespaced&gt;"/>
      <doc>
      <![CDATA[Sets the set of namespaced keys that the item can be placed on in {@link org.bukkit.GameMode#ADVENTURE}

 @param canPlaceOn Collection of {@link com.destroystokyo.paper.Namespaced}]]>
      </doc>
    </method>
    <method name="hasPlaceableKeys" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of any keys that the item can be placed on

 @return true if this item has placeable keys]]>
      </doc>
    </method>
    <method name="hasDestroyableKeys" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of any keys that the item can destroy

 @return true if this item has destroyable keys]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This type represents the storage mechanism for auxiliary item data.
 <p>
 An implementation will handle the creation and application for ItemMeta.
 This class should not be implemented by a plugin in a live environment.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.ItemMeta -->
  <!-- start interface org.bukkit.inventory.meta.KnowledgeBookMeta -->
  <interface name="KnowledgeBookMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasRecipes" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the existence of recipes in the book.

 @return true if the book has recipes]]>
      </doc>
    </method>
    <method name="getRecipes" return="java.util.List&lt;org.bukkit.NamespacedKey&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all the recipes in the book.

 @return list of all the recipes in the book]]>
      </doc>
    </method>
    <method name="setRecipes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipes" type="java.util.List&lt;org.bukkit.NamespacedKey&gt;"/>
      <doc>
      <![CDATA[Clears the existing book recipes, and sets the book to use the provided
 recipes.

 @param recipes A list of recipes to set the book to use]]>
      </doc>
    </method>
    <method name="addRecipe"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recipes" type="org.bukkit.NamespacedKey[]"/>
      <doc>
      <![CDATA[Adds new recipe to the end of the book.

 @param recipes A list of recipe keys]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.KnowledgeBookMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.KnowledgeBookMeta -->
  <!-- start interface org.bukkit.inventory.meta.LeatherArmorMeta -->
  <interface name="LeatherArmorMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="getColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color of the armor. If it has not been set otherwise, it will
 be {@link ItemFactory#getDefaultLeatherColor()}.

 @return the color of the armor, never null]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Sets the color of the armor.

 @param color the color to set. Setting it to null is equivalent to
     setting it to {@link ItemFactory#getDefaultLeatherColor()}.]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.LeatherArmorMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents leather armor ({@link Material#LEATHER_BOOTS}, {@link
 Material#LEATHER_CHESTPLATE}, {@link Material#LEATHER_HELMET}, or {@link
 Material#LEATHER_LEGGINGS}) that can be colored.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.LeatherArmorMeta -->
  <!-- start interface org.bukkit.inventory.meta.MapMeta -->
  <interface name="MapMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasMapId" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="These methods are poor API: They rely on the caller to pass
 in an only an integer property, and have poorly defined implementation
 behavior if that integer is not a valid map (the current implementation
 for example will generate a new map with a different ID). The xxxMapView
 family of methods should be used instead.">
      <doc>
      <![CDATA[Checks for existence of a map ID number.

 @return true if this has a map ID number.
 @deprecated These methods are poor API: They rely on the caller to pass
 in an only an integer property, and have poorly defined implementation
 behavior if that integer is not a valid map (the current implementation
 for example will generate a new map with a different ID). The xxxMapView
 family of methods should be used instead.
 @see #hasMapView()]]>
      </doc>
    </method>
    <method name="getMapId" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="These methods are poor API: They rely on the caller to pass
 in an only an integer property, and have poorly defined implementation
 behavior if that integer is not a valid map (the current implementation
 for example will generate a new map with a different ID). The xxxMapView
 family of methods should be used instead.">
      <doc>
      <![CDATA[Gets the map ID that is set. This is used to determine what map is
 displayed.
 <p>
 Plugins should check that hasMapId() returns <code>true</code> before
 calling this method.

 @return the map ID that is set
 @deprecated These methods are poor API: They rely on the caller to pass
 in an only an integer property, and have poorly defined implementation
 behavior if that integer is not a valid map (the current implementation
 for example will generate a new map with a different ID). The xxxMapView
 family of methods should be used instead.
 @see #getMapView()]]>
      </doc>
    </method>
    <method name="setMapId"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="These methods are poor API: They rely on the caller to pass
 in an only an integer property, and have poorly defined implementation
 behavior if that integer is not a valid map (the current implementation
 for example will generate a new map with a different ID). The xxxMapView
 family of methods should be used instead.">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Sets the map ID. This is used to determine what map is displayed.

 @param id the map id to set
 @deprecated These methods are poor API: They rely on the caller to pass
 in an only an integer property, and have poorly defined implementation
 behavior if that integer is not a valid map (the current implementation
 for example will generate a new map with a different ID). The xxxMapView
 family of methods should be used instead.
 @see #setMapView(org.bukkit.map.MapView)]]>
      </doc>
    </method>
    <method name="hasMapView" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of an associated map.

 @return true if this item has an associated map]]>
      </doc>
    </method>
    <method name="getMapView" return="org.bukkit.map.MapView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the map view that is associated with this map item.

 <p>
 Plugins should check that hasMapView() returns <code>true</code> before
 calling this method.

 @return the map view, or null if the item hasMapView(), but this map does
 not exist on the server]]>
      </doc>
    </method>
    <method name="setMapView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="org.bukkit.map.MapView"/>
      <doc>
      <![CDATA[Sets the associated map. This is used to determine what map is displayed.

 <p>
 The implementation <b>may</b> allow null to clear the associated map, but
 this is not required and is liable to generate a new (undefined) map when
 the item is first used.

 @param map the map to set]]>
      </doc>
    </method>
    <method name="isScaling" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if this map is scaling.

 @return true if this map is scaling]]>
      </doc>
    </method>
    <method name="setScaling"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets if this map is scaling or not.

 @param value true to scale]]>
      </doc>
    </method>
    <method name="hasLocationName" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of a location name.

 @return true if this has a location name]]>
      </doc>
    </method>
    <method name="getLocationName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the location name that is set.
 <p>
 Plugins should check that hasLocationName() returns <code>true</code>
 before calling this method.

 @return the location name that is set]]>
      </doc>
    </method>
    <method name="setLocationName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the location name. A custom map color will alter the display of the
 map in an inventory slot.

 @param name the name to set]]>
      </doc>
    </method>
    <method name="hasColor" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of a map color.

 @return true if this has a custom map color]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the map color that is set. A custom map color will alter the display
 of the map in an inventory slot.
 <p>
 Plugins should check that hasColor() returns <code>true</code> before
 calling this method.

 @return the map color that is set]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Sets the map color. A custom map color will alter the display of the map
 in an inventory slot.

 @param color the color to set]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.MapMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a map that can be scalable.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.MapMeta -->
  <!-- start interface org.bukkit.inventory.meta.PotionMeta -->
  <interface name="PotionMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="setBasePotionData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="org.bukkit.potion.PotionData"/>
      <doc>
      <![CDATA[Sets the underlying potion data

 @param data PotionData to set the base potion state to]]>
      </doc>
    </method>
    <method name="getBasePotionData" return="org.bukkit.potion.PotionData"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the potion data about the base potion

 @return a PotionData object]]>
      </doc>
    </method>
    <method name="hasCustomEffects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the presence of custom potion effects.

 @return true if custom potion effects are applied]]>
      </doc>
    </method>
    <method name="getCustomEffects" return="java.util.List&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an immutable list containing all custom potion effects applied to
 this potion.
 <p>
 Plugins should check that hasCustomEffects() returns true before calling
 this method.

 @return the immutable list of custom potion effects]]>
      </doc>
    </method>
    <method name="addCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.potion.PotionEffect"/>
      <param name="overwrite" type="boolean"/>
      <doc>
      <![CDATA[Adds a custom potion effect to this potion.

 @param effect the potion effect to add
 @param overwrite true if any existing effect of the same type should be
 overwritten
 @return true if the potion meta changed as a result of this call]]>
      </doc>
    </method>
    <method name="removeCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Removes a custom potion effect from this potion.

 @param type the potion effect type to remove
 @return true if the potion meta changed as a result of this call]]>
      </doc>
    </method>
    <method name="hasCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Checks for a specific custom potion effect type on this potion.

 @param type the potion effect type to check for
 @return true if the potion has this effect]]>
      </doc>
    </method>
    <method name="setMainEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #setBasePotionData(org.bukkit.potion.PotionData)}">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Moves a potion effect to the top of the potion effect list.
 <p>
 This causes the client to display the potion effect in the potion's name.

 @param type the potion effect type to move
 @return true if the potion meta changed as a result of this call
 @deprecated use {@link #setBasePotionData(org.bukkit.potion.PotionData)}]]>
      </doc>
    </method>
    <method name="clearCustomEffects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all custom potion effects from this potion.

 @return true if the potion meta changed as a result of this call]]>
      </doc>
    </method>
    <method name="hasColor" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of a potion color.

 @return true if this has a custom potion color]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the potion color that is set. A custom potion color will alter the
 display of the potion in an inventory slot.
 <p>
 Plugins should check that hasColor() returns <code>true</code> before
 calling this method.

 @return the potion color that is set]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.Color"/>
      <doc>
      <![CDATA[Sets the potion color. A custom potion color will alter the display of
 the potion in an inventory slot.

 @param color the color to set]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.PotionMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a potion or item that can have custom effects.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.PotionMeta -->
  <!-- start interface org.bukkit.inventory.meta.Repairable -->
  <interface name="Repairable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hasRepairCost" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if this has a repair penalty

 @return true if this has a repair penalty]]>
      </doc>
    </method>
    <method name="getRepairCost" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the repair penalty

 @return the repair penalty]]>
      </doc>
    </method>
    <method name="setRepairCost"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cost" type="int"/>
      <doc>
      <![CDATA[Sets the repair penalty

 @param cost repair penalty]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.Repairable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an item that can be repaired at an anvil.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.Repairable -->
  <!-- start interface org.bukkit.inventory.meta.SkullMeta -->
  <interface name="SkullMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="getOwner" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link #getOwningPlayer()}.">
      <doc>
      <![CDATA[Gets the owner of the skull.

 @return the owner if the skull
 @deprecated see {@link #getOwningPlayer()}.]]>
      </doc>
    </method>
    <method name="hasOwner" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks to see if the skull has an owner.

 @return true if the skull has an owner]]>
      </doc>
    </method>
    <method name="setOwner" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link #setOwningPlayer(org.bukkit.OfflinePlayer)}.">
      <param name="owner" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the owner of the skull.

 @param owner the new owner of the skull
 @return true if the owner was successfully set
 @deprecated see {@link #setOwningPlayer(org.bukkit.OfflinePlayer)}.]]>
      </doc>
    </method>
    <method name="setPlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profile" type="com.destroystokyo.paper.profile.PlayerProfile"/>
      <doc>
      <![CDATA[Sets this skull to use the supplied Player Profile, which can include textures already prefilled.
 @param profile The profile to set this Skull to use, or null to clear owner]]>
      </doc>
    </method>
    <method name="getPlayerProfile" return="com.destroystokyo.paper.profile.PlayerProfile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the skull has an owner, per {@link #hasOwner()}, return the owners {@link PlayerProfile}
 @return The profile of the owner, if set]]>
      </doc>
    </method>
    <method name="getOwningPlayer" return="org.bukkit.OfflinePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the owner of the skull.

 @return the owner if the skull]]>
      </doc>
    </method>
    <method name="setOwningPlayer" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="org.bukkit.OfflinePlayer"/>
      <doc>
      <![CDATA[Sets the owner of the skull.
 <p>
 Plugins should check that hasOwner() returns true before calling this
 plugin.

 @param owner the new owner of the skull
 @return true if the owner was successfully set]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.SkullMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a skull that can have an owner.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.SkullMeta -->
  <!-- start interface org.bukkit.inventory.meta.SpawnEggMeta -->
  <interface name="SpawnEggMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="getSpawnedType" return="org.bukkit.entity.EntityType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="different types are different items">
      <doc>
      <![CDATA[Get the type of entity this egg will spawn.

 @return The entity type. May be null for implementation specific default.
 @deprecated different types are different items]]>
      </doc>
    </method>
    <method name="setSpawnedType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="different types are different items">
      <param name="type" type="org.bukkit.entity.EntityType"/>
      <doc>
      <![CDATA[Set the type of entity this egg will spawn.

 @param type The entity type. May be null for implementation specific
 default.
 @deprecated different types are different items]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.SpawnEggMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a spawn egg and it's spawned type.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.SpawnEggMeta -->
  <!-- start interface org.bukkit.inventory.meta.SuspiciousStewMeta -->
  <interface name="SuspiciousStewMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="hasCustomEffects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for the presence of custom potion effects.

 @return true if custom potion effects are applied]]>
      </doc>
    </method>
    <method name="getCustomEffects" return="java.util.List&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets an immutable list containing all custom potion effects applied to
 this suspicious stew.
 <p>
 Plugins should check that hasCustomEffects() returns true before calling
 this method.

 @return the immutable list of custom potion effects]]>
      </doc>
    </method>
    <method name="addCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="effect" type="org.bukkit.potion.PotionEffect"/>
      <param name="overwrite" type="boolean"/>
      <doc>
      <![CDATA[Adds a custom potion effect to this suspicious stew.

 @param effect the potion effect to add
 @param overwrite true if any existing effect of the same type should be
 overwritten
 @return true if the suspicious stew meta changed as a result of this call]]>
      </doc>
    </method>
    <method name="removeCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Removes a custom potion effect from this suspicious stew.

 @param type the potion effect type to remove
 @return true if the suspicious stew meta changed as a result of this call]]>
      </doc>
    </method>
    <method name="hasCustomEffect" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Checks for a specific custom potion effect type on this suspicious stew.

 @param type the potion effect type to check for
 @return true if the suspicious stew has this effect]]>
      </doc>
    </method>
    <method name="clearCustomEffects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all custom potion effects from this suspicious stew.

 @return true if the suspicious stew meta changed as a result of this call]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.SuspiciousStewMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a suspicious stew that can have custom effects.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.SuspiciousStewMeta -->
  <!-- start interface org.bukkit.inventory.meta.TropicalFishBucketMeta -->
  <interface name="TropicalFishBucketMeta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.ItemMeta"/>
    <method name="getPatternColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color of the fish's pattern.
 <p>
 Plugins should check that hasVariant() returns <code>true</code> before
 calling this method.

 @return pattern color]]>
      </doc>
    </method>
    <method name="setPatternColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the color of the fish's pattern.
 <p>
 Setting this when hasVariant() returns <code>false</code> will initialize
 all other values to unspecified defaults.

 @param color pattern color]]>
      </doc>
    </method>
    <method name="getBodyColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color of the fish's body.
 <p>
 Plugins should check that hasVariant() returns <code>true</code> before
 calling this method.

 @return pattern color]]>
      </doc>
    </method>
    <method name="setBodyColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the color of the fish's body.
 <p>
 Setting this when hasVariant() returns <code>false</code> will initialize
 all other values to unspecified defaults.

 @param color body color]]>
      </doc>
    </method>
    <method name="getPattern" return="org.bukkit.entity.TropicalFish.Pattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the fish's pattern.
 <p>
 Plugins should check that hasVariant() returns <code>true</code> before
 calling this method.

 @return pattern]]>
      </doc>
    </method>
    <method name="setPattern"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="org.bukkit.entity.TropicalFish.Pattern"/>
      <doc>
      <![CDATA[Sets the fish's pattern.
 <p>
 Setting this when hasVariant() returns <code>false</code> will initialize
 all other values to unspecified defaults.

 @param pattern new pattern]]>
      </doc>
    </method>
    <method name="hasVariant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks for existence of a variant tag indicating a specific fish will be
 spawned.

 @return if there is a variant]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.inventory.meta.TropicalFishBucketMeta"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a bucket of tropical fish.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.TropicalFishBucketMeta -->
</package>
<package name="org.bukkit.inventory.meta.tags">
  <!-- start interface org.bukkit.inventory.meta.tags.CustomItemTagContainer -->
  <interface name="CustomItemTagContainer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="this API part has been replaced by the
 {@link org.bukkit.persistence.PersistentDataHolder} API. Please use
 {@link org.bukkit.persistence.PersistentDataHolder} instead of this.">
    <method name="setCustomTag"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="type" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;T, Z&gt;"/>
      <param name="value" type="Z"/>
      <doc>
      <![CDATA[Stores a custom value on the {@link ItemMeta}.

 This API cannot be used to manipulate minecraft tags, as the values will
 be stored using your namespace. This method will override any existing
 value the meta may have stored under the provided key.

 @param key the key this value will be stored under
 @param type the type this item tag uses
 @param value the value stored in the tag
 @param <T> the generic java type of the tag value
 @param <Z> the generic type of the object to store
 @throws NullPointerException if the key is null
 @throws NullPointerException if the type is null
 @throws NullPointerException if the value is null. Removing a custom tag
 should be done using {@link #removeCustomTag(org.bukkit.NamespacedKey)}
 @throws IllegalArgumentException if no suitable adapter will be found for
 the {@link ItemTagType#getPrimitiveType()}]]>
      </doc>
    </method>
    <method name="hasCustomTag" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="type" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;T, Z&gt;"/>
      <doc>
      <![CDATA[Returns if the item meta has a custom tag registered matching the
 provided parameters.

 This method will only return if the found value has the same primitive
 data type as the provided key.

 Storing a value using a custom {@link ItemTagType} implementation will
 not store the complex data type. Therefore storing a UUID (by storing a
 byte[]) will match hasCustomTag("key" , {@link ItemTagType#BYTE_ARRAY}).
 Likewise a stored byte[] will always match your UUID {@link ItemTagType}
 even if it is not 16 bytes long.

 This method is only usable for custom object keys. Overwriting existing
 tags, like the the display name, will not work as the values are stored
 using your namespace.

 @param key the key the value is stored under
 @param type the type which primitive storage type has to match the value
 @param <T> the generic type of the stored primitive
 @param <Z> the generic type of the eventually created complex object
 @return if a value
 @throws NullPointerException if the key to look up is null
 @throws NullPointerException if the type to cast the found object to is
 null]]>
      </doc>
    </method>
    <method name="getCustomTag" return="Z"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="type" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;T, Z&gt;"/>
      <doc>
      <![CDATA[Returns the custom tag's value that is stored on the item.

 @param key the key to look up in the custom tag map
 @param type the type the value must have and will be casted to
 @param <T> the generic type of the stored primitive
 @param <Z> the generic type of the eventually created complex object
 @return the value or {@code null} if no value was mapped under the given
 value
 @throws NullPointerException if the key to look up is null
 @throws NullPointerException if the type to cast the found object to is
 null
 @throws IllegalArgumentException if the value exists under the given key,
 but cannot be access using the given type
 @throws IllegalArgumentException if no suitable adapter will be found for
 the {@link ItemTagType#getPrimitiveType()}]]>
      </doc>
    </method>
    <method name="removeCustomTag"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Removes a custom key from the item meta.

 @param key the key
 @throws NullPointerException if the provided key is null]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if the container instance is empty, therefore has no entries
 inside it.

 @return the boolean]]>
      </doc>
    </method>
    <method name="getAdapterContext" return="org.bukkit.inventory.meta.tags.ItemTagAdapterContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the adapter context this tag container uses.

 @return the tag context]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface represents a map like object, capable of storing custom tags
 in it.

 @deprecated this API part has been replaced by the
 {@link org.bukkit.persistence.PersistentDataHolder} API. Please use
 {@link org.bukkit.persistence.PersistentDataHolder} instead of this.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.tags.CustomItemTagContainer -->
  <!-- start interface org.bukkit.inventory.meta.tags.ItemTagAdapterContext -->
  <interface name="ItemTagAdapterContext"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="this API part has been replaced by {@link PersistentDataHolder}.
 Please use {@link PersistentDataAdapterContext} instead of this.">
    <method name="newTagContainer" return="org.bukkit.inventory.meta.tags.CustomItemTagContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new and empty tag container instance.

 @return the fresh container instance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface represents the context in which the {@link ItemTagType} can
 serialize and deserialize the passed values.

 @deprecated this API part has been replaced by {@link PersistentDataHolder}.
 Please use {@link PersistentDataAdapterContext} instead of this.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.tags.ItemTagAdapterContext -->
  <!-- start interface org.bukkit.inventory.meta.tags.ItemTagType -->
  <interface name="ItemTagType"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="please use {@link PersistentDataType} as this part of the api is being replaced">
    <method name="getPrimitiveType" return="java.lang.Class&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the primitive data type of this tag.

 @return the class]]>
      </doc>
    </method>
    <method name="getComplexType" return="java.lang.Class&lt;Z&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the complex object type the primitive value resembles.

 @return the class type]]>
      </doc>
    </method>
    <method name="toPrimitive" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="complex" type="Z"/>
      <param name="context" type="org.bukkit.inventory.meta.tags.ItemTagAdapterContext"/>
      <doc>
      <![CDATA[Returns the primitive data that resembles the complex object passed to
 this method.

 @param complex the complex object instance
 @param context the context this operation is running in
 @return the primitive value]]>
      </doc>
    </method>
    <method name="fromPrimitive" return="Z"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="primitive" type="T"/>
      <param name="context" type="org.bukkit.inventory.meta.tags.ItemTagAdapterContext"/>
      <doc>
      <![CDATA[Creates a complex object based of the passed primitive value

 @param primitive the primitive value
 @param context the context this operation is running in
 @return the complex object instance]]>
      </doc>
    </method>
    <field name="BYTE" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;java.lang.Byte, java.lang.Byte&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SHORT" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;java.lang.Short, java.lang.Short&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INTEGER" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;java.lang.Integer, java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;java.lang.Long, java.lang.Long&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOAT" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;java.lang.Float, java.lang.Float&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOUBLE" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;java.lang.Double, java.lang.Double&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRING" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;java.lang.String, java.lang.String&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BYTE_ARRAY" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;byte[], byte[]&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INTEGER_ARRAY" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;int[], int[]&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG_ARRAY" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;long[], long[]&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TAG_CONTAINER" type="org.bukkit.inventory.meta.tags.ItemTagType&lt;org.bukkit.inventory.meta.tags.CustomItemTagContainer, org.bukkit.inventory.meta.tags.CustomItemTagContainer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class represents an enum with a generic content type. It defines the
 types a custom item tag can have.
 <p>
 This interface can be used to create your own custom {@link ItemTagType} with
 different complex types. This may be useful for the likes of a
 UUIDItemTagType:
 <pre>
 {@code
 public class UUIDItemTagType implements ItemTagType<byte[], UUID> {

         {@literal @Override}
         public Class<byte[]> getPrimitiveType() {
             return byte[].class;
         }

         {@literal @Override}
         public Class<UUID> getComplexType() {
             return UUID.class;
         }

         {@literal @Override}
         public byte[] toPrimitive(UUID complex, ItemTagAdapterContext context) {
             ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
             bb.putLong(complex.getMostSignificantBits());
             bb.putLong(complex.getLeastSignificantBits());
             return bb.array();
         }

         {@literal @Override}
         public UUID fromPrimitive(byte[] primitive, ItemTagAdapterContext context) {
             ByteBuffer bb = ByteBuffer.wrap(primitive);
             long firstLong = bb.getLong();
             long secondLong = bb.getLong();
             return new UUID(firstLong, secondLong);
         }
     }}</pre>

 @param <T> the primary object type that is stored in the given tag
 @param <Z> the retrieved object type when applying this item tag type

 @deprecated please use {@link PersistentDataType} as this part of the api is being replaced]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.inventory.meta.tags.ItemTagType -->
  <!-- start class org.bukkit.inventory.meta.tags.ItemTagType.PrimitiveTagType -->
  <class name="ItemTagType.PrimitiveTagType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.inventory.meta.tags.ItemTagType&lt;T, T&gt;"/>
    <method name="getPrimitiveType" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getComplexType" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toPrimitive" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="complex" type="T"/>
      <param name="context" type="org.bukkit.inventory.meta.tags.ItemTagAdapterContext"/>
    </method>
    <method name="fromPrimitive" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="primitive" type="T"/>
      <param name="context" type="org.bukkit.inventory.meta.tags.ItemTagAdapterContext"/>
    </method>
    <doc>
    <![CDATA[A default implementation that simply exists to pass on the retrieved or
 inserted value to the next layer.

 This implementation does not add any kind of logic, but is used to
 provide default implementations for the primitive types.

 @param <T> the generic type of the primitive objects]]>
    </doc>
  </class>
  <!-- end class org.bukkit.inventory.meta.tags.ItemTagType.PrimitiveTagType -->
</package>
<package name="org.bukkit.loot">
  <!-- start interface org.bukkit.loot.Lootable -->
  <interface name="Lootable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setLootTable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="org.bukkit.loot.LootTable"/>
      <doc>
      <![CDATA[Set the loot table for a container or entity.
 <br>
 To remove a loot table use null. Do not use {@link LootTables#EMPTY} to
 clear a LootTable.

 @param table the Loot Table this {@link org.bukkit.block.Container} or
 {@link org.bukkit.entity.Mob} will have.]]>
      </doc>
    </method>
    <method name="getLootTable" return="org.bukkit.loot.LootTable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Loot Table attached to this block or entity.
 <br>

 If an block/entity does not have a loot table, this will return null, NOT
 an empty loot table.

 @return the Loot Table attached to this block or entity.]]>
      </doc>
    </method>
    <method name="setLootTable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="org.bukkit.loot.LootTable"/>
      <param name="seed" type="long"/>
      <doc>
      <![CDATA[Set the loot table and seed for a container or entity at the same time.

 @param table the Loot Table this {@link org.bukkit.block.Container} or {@link org.bukkit.entity.Mob} will have.
 @param seed the seed to used to generate loot. Default is 0.]]>
      </doc>
    </method>
    <method name="hasLootTable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether or not this object has a Loot Table
 @return Has a loot table]]>
      </doc>
    </method>
    <method name="clearLootTable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the associated Loot Table to this object]]>
      </doc>
    </method>
    <method name="setSeed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="long"/>
      <doc>
      <![CDATA[Set the seed used when this Loot Table generates loot.

 @param seed the seed to used to generate loot. Default is 0.]]>
      </doc>
    </method>
    <method name="getSeed" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Loot Table's seed.
 <br>
 The seed is used when generating loot.

 @return the seed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a {@link org.bukkit.block.Container} or a
 {@link org.bukkit.entity.Mob} that can have a loot table.
 <br>
 Container loot will only generate upon opening, and only when the container
 is <i>first</i> opened.
 <br>
 Entities will only generate loot upon death.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.loot.Lootable -->
  <!-- start class org.bukkit.loot.LootContext -->
  <class name="LootContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The {@link Location} to store where the loot will be generated.

 @return the Location of where the loot will be generated]]>
      </doc>
    </method>
    <method name="getLuck" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Represents the {@link org.bukkit.potion.PotionEffectType#LUCK} that an
 entity can have. The higher the value the better chance of receiving more
 loot.

 @return luck]]>
      </doc>
    </method>
    <method name="getLootingModifier" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Represents the
 {@link org.bukkit.enchantments.Enchantment#LOOT_BONUS_MOBS} the
 {@link #getKiller()} entity has on their equipped item.

 This value is only set via
 {@link LootContext.Builder#lootingModifier(int)}. If not set, the
 {@link #getKiller()} entity's looting level will be used instead.

 @return the looting level]]>
      </doc>
    </method>
    <method name="getLootedEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link Entity} that was killed. Can be null.

 @return the looted entity or null]]>
      </doc>
    </method>
    <method name="getKiller" return="org.bukkit.entity.HumanEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link HumanEntity} who killed the {@link #getLootedEntity()}.
 Can be null.

 @return the killer entity, or null.]]>
      </doc>
    </method>
    <field name="DEFAULT_LOOT_MODIFIER" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents additional information a {@link LootTable} can use to modify it's
 generated loot.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.loot.LootContext -->
  <!-- start class org.bukkit.loot.LootContext.Builder -->
  <class name="LootContext.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder" type="org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new LootContext.Builder instance to facilitate easy
 creation of {@link LootContext}s.

 @param location the location the LootContext should use]]>
      </doc>
    </constructor>
    <method name="luck" return="org.bukkit.loot.LootContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="luck" type="float"/>
      <doc>
      <![CDATA[Set how much luck to have when generating loot.

 @param luck the luck level
 @return the Builder]]>
      </doc>
    </method>
    <method name="lootingModifier" return="org.bukkit.loot.LootContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modifier" type="int"/>
      <doc>
      <![CDATA[Set the {@link org.bukkit.enchantments.Enchantment#LOOT_BONUS_MOBS}
 level equivalent to use when generating loot. Values less than or
 equal to 0 will force the {@link LootTable} to only return a single
 {@link org.bukkit.inventory.ItemStack} per pool.

 @param modifier the looting level modifier
 @return the Builder]]>
      </doc>
    </method>
    <method name="lootedEntity" return="org.bukkit.loot.LootContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lootedEntity" type="org.bukkit.entity.Entity"/>
      <doc>
      <![CDATA[The entity that was killed.

 @param lootedEntity the looted entity
 @return the Builder]]>
      </doc>
    </method>
    <method name="killer" return="org.bukkit.loot.LootContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="killer" type="org.bukkit.entity.HumanEntity"/>
      <doc>
      <![CDATA[Set the {@link org.bukkit.entity.HumanEntity} that killed
 {@link #getLootedEntity()}. This entity will be used to get the
 looting level if {@link #lootingModifier(int)} is not set.

 @param killer the killer entity
 @return the Builder]]>
      </doc>
    </method>
    <method name="build" return="org.bukkit.loot.LootContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link LootContext} instance using the supplied
 parameters.

 @return a new {@link LootContext} instance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class to make building {@link LootContext} easier. The only
 required argument is {@link Location} with a valid (non-null)
 {@link org.bukkit.World}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.loot.LootContext.Builder -->
  <!-- start interface org.bukkit.loot.LootTable -->
  <interface name="LootTable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="populateLoot" return="java.util.Collection&lt;org.bukkit.inventory.ItemStack&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="random" type="java.util.Random"/>
      <param name="context" type="org.bukkit.loot.LootContext"/>
      <doc>
      <![CDATA[Returns a mutable list of loot generated by this LootTable.

 @param random the random instance to use to generate loot
 @param context context within to populate loot
 @return a list of ItemStacks]]>
      </doc>
    </method>
    <method name="fillInventory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inventory" type="org.bukkit.inventory.Inventory"/>
      <param name="random" type="java.util.Random"/>
      <param name="context" type="org.bukkit.loot.LootContext"/>
      <doc>
      <![CDATA[Attempt to fill an inventory with this LootTable's loot.

 @param inventory the inventory to fill
 @param random the random instance to use to generate loot
 @param context context within to populate loot]]>
      </doc>
    </method>
    <doc>
    <![CDATA[LootTables are technical files that represent what items should be in
 naturally generated containers, what items should be dropped when killing a
 mob, or what items can be fished.

 See the <a href="https://minecraft.gamepedia.com/Loot_table">
 Minecraft Wiki</a> for more information.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.loot.LootTable -->
  <!-- start class org.bukkit.loot.LootTables -->
  <class name="LootTables" extends="java.lang.Enum&lt;org.bukkit.loot.LootTables&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.Keyed"/>
    <method name="values" return="org.bukkit.loot.LootTables[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.loot.LootTables"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getKey" return="org.bukkit.NamespacedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLootTable" return="org.bukkit.loot.LootTable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link LootTable} corresponding to this constant. This is
 equivalent to calling {@code Bukkit.getLootTable(this.getKey());}.

 @return the associated LootTable]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This enum holds a list of all known {@link LootTable}s offered by Mojang.
 This list is not guaranteed to be accurate in future versions.

 See the
 <a href="https://minecraft.gamepedia.com/Loot_table#List_of_loot_tables">
 Minecraft Wiki</a> for more information on loot tables.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.loot.LootTables -->
</package>
<package name="org.bukkit.map">
  <!-- start interface org.bukkit.map.MapCanvas -->
  <interface name="MapCanvas"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMapView" return="org.bukkit.map.MapView"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the map this canvas is attached to.

 @return The MapView this canvas is attached to.]]>
      </doc>
    </method>
    <method name="getCursors" return="org.bukkit.map.MapCursorCollection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the cursor collection associated with this canvas.

 @return The MapCursorCollection associated with this canvas.]]>
      </doc>
    </method>
    <method name="setCursors"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cursors" type="org.bukkit.map.MapCursorCollection"/>
      <doc>
      <![CDATA[Set the cursor collection associated with this canvas. This does not
 usually need to be called since a MapCursorCollection is already
 provided.

 @param cursors The MapCursorCollection to associate with this canvas.]]>
      </doc>
    </method>
    <method name="setPixel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="color" type="byte"/>
      <doc>
      <![CDATA[Draw a pixel to the canvas.

 @param x The x coordinate, from 0 to 127.
 @param y The y coordinate, from 0 to 127.
 @param color The color. See {@link MapPalette}.]]>
      </doc>
    </method>
    <method name="getPixel" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <doc>
      <![CDATA[Get a pixel from the canvas.

 @param x The x coordinate, from 0 to 127.
 @param y The y coordinate, from 0 to 127.
 @return The color. See {@link MapPalette}.]]>
      </doc>
    </method>
    <method name="getBasePixel" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <doc>
      <![CDATA[Get a pixel from the layers below this canvas.

 @param x The x coordinate, from 0 to 127.
 @param y The y coordinate, from 0 to 127.
 @return The color. See {@link MapPalette}.]]>
      </doc>
    </method>
    <method name="drawImage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="image" type="java.awt.Image"/>
      <doc>
      <![CDATA[Draw an image to the map. The image will be clipped if necessary.

 @param x The x coordinate of the image.
 @param y The y coordinate of the image.
 @param image The Image to draw.]]>
      </doc>
    </method>
    <method name="drawText"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="font" type="org.bukkit.map.MapFont"/>
      <param name="text" type="java.lang.String"/>
      <doc>
      <![CDATA[Render text to the map using fancy formatting. Newline (\n) characters
 will move down one line and return to the original column, and the text
 color can be changed using sequences such as "�#12;", replacing 12 with
 the palette index of the color (see {@link MapPalette}).

 @param x The column to start rendering on.
 @param y The row to start rendering on.
 @param font The font to use.
 @param text The formatted text to render.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a canvas for drawing to a map. Each canvas is associated with a
 specific {@link MapRenderer} and represents that renderer's layer on the
 map.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.map.MapCanvas -->
  <!-- start class org.bukkit.map.MapCursor -->
  <class name="MapCursor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapCursor" type="byte, byte, byte, byte, boolean"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Initialize the map cursor.

 @param x The x coordinate, from -128 to 127.
 @param y The y coordinate, from -128 to 127.
 @param direction The facing of the cursor, from 0 to 15.
 @param type The type (color/style) of the map cursor.
 @param visible Whether the cursor is visible by default.
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="MapCursor" type="byte, byte, byte, org.bukkit.map.MapCursor.Type, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initialize the map cursor.

 @param x The x coordinate, from -128 to 127.
 @param y The y coordinate, from -128 to 127.
 @param direction The facing of the cursor, from 0 to 15.
 @param type The type (color/style) of the map cursor.
 @param visible Whether the cursor is visible by default.]]>
      </doc>
    </constructor>
    <constructor name="MapCursor" type="byte, byte, byte, byte, boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Initialize the map cursor.

 @param x The x coordinate, from -128 to 127.
 @param y The y coordinate, from -128 to 127.
 @param direction The facing of the cursor, from 0 to 15.
 @param type The type (color/style) of the map cursor.
 @param visible Whether the cursor is visible by default.
 @param caption cursor caption
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="MapCursor" type="byte, byte, byte, org.bukkit.map.MapCursor.Type, boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initialize the map cursor.

 @param x The x coordinate, from -128 to 127.
 @param y The y coordinate, from -128 to 127.
 @param direction The facing of the cursor, from 0 to 15.
 @param type The type (color/style) of the map cursor.
 @param visible Whether the cursor is visible by default.
 @param caption cursor caption]]>
      </doc>
    </constructor>
    <method name="getX" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the X position of this cursor.

 @return The X coordinate.]]>
      </doc>
    </method>
    <method name="getY" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Y position of this cursor.

 @return The Y coordinate.]]>
      </doc>
    </method>
    <method name="getDirection" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the direction of this cursor.

 @return The facing of the cursor, from 0 to 15.]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.map.MapCursor.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of this cursor.

 @return The type (color/style) of the map cursor.]]>
      </doc>
    </method>
    <method name="getRawType" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Get the type of this cursor.

 @return The type (color/style) of the map cursor.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="isVisible" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the visibility status of this cursor.

 @return True if visible, false otherwise.]]>
      </doc>
    </method>
    <method name="setX"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="byte"/>
      <doc>
      <![CDATA[Set the X position of this cursor.

 @param x The X coordinate.]]>
      </doc>
    </method>
    <method name="setY"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="y" type="byte"/>
      <doc>
      <![CDATA[Set the Y position of this cursor.

 @param y The Y coordinate.]]>
      </doc>
    </method>
    <method name="setDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="direction" type="byte"/>
      <doc>
      <![CDATA[Set the direction of this cursor.

 @param direction The facing of the cursor, from 0 to 15.]]>
      </doc>
    </method>
    <method name="setType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.map.MapCursor.Type"/>
      <doc>
      <![CDATA[Set the type of this cursor.

 @param type The type (color/style) of the map cursor.]]>
      </doc>
    </method>
    <method name="setRawType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="type" type="byte"/>
      <doc>
      <![CDATA[Set the type of this cursor.

 @param type The type (color/style) of the map cursor.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setVisible"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visible" type="boolean"/>
      <doc>
      <![CDATA[Set the visibility status of this cursor.

 @param visible True if visible.]]>
      </doc>
    </method>
    <method name="getCaption" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the caption on this cursor.

 @return caption]]>
      </doc>
    </method>
    <method name="setCaption"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="caption" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the caption on this cursor.

 @param caption new caption]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a cursor on a map.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MapCursor -->
  <!-- start class org.bukkit.map.MapCursor.Type -->
  <class name="MapCursor.Type" extends="java.lang.Enum&lt;org.bukkit.map.MapCursor.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.map.MapCursor.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.map.MapCursor.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getValue" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the internal value of the cursor.

 @return the value
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="byValue" return="org.bukkit.map.MapCursor.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Get a cursor by its internal value.

 @param value the value
 @return the matching type
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the standard types of map cursors. More may be made
 available by resource packs - the value is used by the client as an
 index in the file './misc/mapicons.png' from minecraft.jar or from a
 resource pack.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MapCursor.Type -->
  <!-- start class org.bukkit.map.MapCursorCollection -->
  <class name="MapCursorCollection" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapCursorCollection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the amount of cursors in this collection.

 @return The size of this collection.]]>
      </doc>
    </method>
    <method name="getCursor" return="org.bukkit.map.MapCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Get a cursor from this collection.

 @param index The index of the cursor.
 @return The MapCursor.]]>
      </doc>
    </method>
    <method name="removeCursor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cursor" type="org.bukkit.map.MapCursor"/>
      <doc>
      <![CDATA[Remove a cursor from the collection.

 @param cursor The MapCursor to remove.
 @return Whether the cursor was removed successfully.]]>
      </doc>
    </method>
    <method name="addCursor" return="org.bukkit.map.MapCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cursor" type="org.bukkit.map.MapCursor"/>
      <doc>
      <![CDATA[Add a cursor to the collection.

 @param cursor The MapCursor to add.
 @return The MapCursor that was passed.]]>
      </doc>
    </method>
    <method name="addCursor" return="org.bukkit.map.MapCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="direction" type="byte"/>
      <doc>
      <![CDATA[Add a cursor to the collection.

 @param x The x coordinate, from -128 to 127.
 @param y The y coordinate, from -128 to 127.
 @param direction The facing of the cursor, from 0 to 15.
 @return The newly added MapCursor.]]>
      </doc>
    </method>
    <method name="addCursor" return="org.bukkit.map.MapCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="direction" type="byte"/>
      <param name="type" type="byte"/>
      <doc>
      <![CDATA[Add a cursor to the collection.

 @param x The x coordinate, from -128 to 127.
 @param y The y coordinate, from -128 to 127.
 @param direction The facing of the cursor, from 0 to 15.
 @param type The type (color/style) of the map cursor.
 @return The newly added MapCursor.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="addCursor" return="org.bukkit.map.MapCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="direction" type="byte"/>
      <param name="type" type="byte"/>
      <param name="visible" type="boolean"/>
      <doc>
      <![CDATA[Add a cursor to the collection.

 @param x The x coordinate, from -128 to 127.
 @param y The y coordinate, from -128 to 127.
 @param direction The facing of the cursor, from 0 to 15.
 @param type The type (color/style) of the map cursor.
 @param visible Whether the cursor is visible.
 @return The newly added MapCursor.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="addCursor" return="org.bukkit.map.MapCursor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="direction" type="byte"/>
      <param name="type" type="byte"/>
      <param name="visible" type="boolean"/>
      <param name="caption" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a cursor to the collection.

 @param x The x coordinate, from -128 to 127.
 @param y The y coordinate, from -128 to 127.
 @param direction The facing of the cursor, from 0 to 15.
 @param type The type (color/style) of the map cursor.
 @param visible Whether the cursor is visible.
 @param caption banner caption
 @return The newly added MapCursor.
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents all the map cursors on a {@link MapCanvas}. Like MapCanvas, a
 MapCursorCollection is linked to a specific {@link MapRenderer}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MapCursorCollection -->
  <!-- start class org.bukkit.map.MapFont -->
  <class name="MapFont" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapFont"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setChar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ch" type="char"/>
      <param name="sprite" type="org.bukkit.map.MapFont.CharacterSprite"/>
      <doc>
      <![CDATA[Set the sprite for a given character.

 @param ch The character to set the sprite for.
 @param sprite The CharacterSprite to set.
 @throws IllegalStateException if this font is static.]]>
      </doc>
    </method>
    <method name="getChar" return="org.bukkit.map.MapFont.CharacterSprite"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ch" type="char"/>
      <doc>
      <![CDATA[Get the sprite for a given character.

 @param ch The character to get the sprite for.
 @return The CharacterSprite associated with the character, or null if
     there is none.]]>
      </doc>
    </method>
    <method name="getWidth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the width of the given text as it would be rendered using this
 font.

 @param text The text.
 @return The width in pixels.]]>
      </doc>
    </method>
    <method name="getHeight" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the height of this font.

 @return The height of the font.]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
      <doc>
      <![CDATA[Check whether the given text is valid.

 @param text The text.
 @return True if the string contains only defined characters, false
     otherwise.]]>
      </doc>
    </method>
    <field name="malleable" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a bitmap font drawable to a map.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MapFont -->
  <!-- start class org.bukkit.map.MapFont.CharacterSprite -->
  <class name="MapFont.CharacterSprite" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharacterSprite" type="int, int, boolean[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="row" type="int"/>
      <param name="col" type="int"/>
      <doc>
      <![CDATA[Get the value of a pixel of the character.

 @param row The row, in the range [0,8).
 @param col The column, in the range [0,8).
 @return True if the pixel is solid, false if transparent.]]>
      </doc>
    </method>
    <method name="getWidth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the width of the character sprite.

 @return The width of the character.]]>
      </doc>
    </method>
    <method name="getHeight" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the height of the character sprite.

 @return The height of the character.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the graphics for a single character in a MapFont.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MapFont.CharacterSprite -->
  <!-- start class org.bukkit.map.MapPalette -->
  <class name="MapPalette" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="resizeImage" return="java.awt.image.BufferedImage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="image" type="java.awt.Image"/>
      <doc>
      <![CDATA[Resize an image to 128x128.

 @param image The image to resize.
 @return The resized image.]]>
      </doc>
    </method>
    <method name="imageToBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="image" type="java.awt.Image"/>
      <doc>
      <![CDATA[Convert an Image to a byte[] using the palette.

 @param image The image to convert.
 @return A byte[] containing the pixels of the image.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="matchColor" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="r" type="int"/>
      <param name="g" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Get the index of the closest matching color in the palette to the given
 color.

 @param r The red component of the color.
 @param b The blue component of the color.
 @param g The green component of the color.
 @return The index in the palette.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="matchColor" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="color" type="java.awt.Color"/>
      <doc>
      <![CDATA[Get the index of the closest matching color in the palette to the given
 color.

 @param color The Color to match.
 @return The index in the palette.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getColor" return="java.awt.Color"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="index" type="byte"/>
      <doc>
      <![CDATA[Get the value of the given color in the palette.

 @param index The index in the palette.
 @return The Color of the palette entry.
 @deprecated Magic value]]>
      </doc>
    </method>
    <field name="TRANSPARENT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="LIGHT_GREEN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="LIGHT_BROWN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="GRAY_1" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="RED" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="PALE_BLUE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="GRAY_2" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="DARK_GREEN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="WHITE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="LIGHT_GRAY" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="BROWN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="DARK_GRAY" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="BLUE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <field name="DARK_BROWN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@deprecated Magic value]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents the palette that map items use.
 <p>
 These fields are hee base color ranges. Each entry corresponds to four
 colors of varying shades with values entry to entry + 3.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MapPalette -->
  <!-- start class org.bukkit.map.MapRenderer -->
  <class name="MapRenderer" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapRenderer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initialize the map renderer base to be non-contextual. See {@link
 #isContextual()}.]]>
      </doc>
    </constructor>
    <constructor name="MapRenderer" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initialize the map renderer base with the given contextual status.

 @param contextual Whether the renderer is contextual. See {@link
     #isContextual()}.]]>
      </doc>
    </constructor>
    <method name="isContextual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get whether the renderer is contextual, i.e. has different canvases for
 different players.

 @return True if contextual, false otherwise.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="org.bukkit.map.MapView"/>
      <doc>
      <![CDATA[Initialize this MapRenderer for the given map.

 @param map The MapView being initialized.]]>
      </doc>
    </method>
    <method name="render"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="org.bukkit.map.MapView"/>
      <param name="canvas" type="org.bukkit.map.MapCanvas"/>
      <param name="player" type="org.bukkit.entity.Player"/>
      <doc>
      <![CDATA[Render to the given map.

 @param map The MapView being rendered to.
 @param canvas The canvas to use for rendering.
 @param player The player who triggered the rendering.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a renderer for a map.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MapRenderer -->
  <!-- start interface org.bukkit.map.MapView -->
  <interface name="MapView"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getId" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the ID of this map item for use with {@link MapMeta}.

 @return The ID of the map.]]>
      </doc>
    </method>
    <method name="isVirtual" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check whether this map is virtual. A map is virtual if its lowermost
 MapRenderer is plugin-provided.

 @return Whether the map is virtual.]]>
      </doc>
    </method>
    <method name="getScale" return="org.bukkit.map.MapView.Scale"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the scale of this map.

 @return The scale of the map.]]>
      </doc>
    </method>
    <method name="setScale"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="org.bukkit.map.MapView.Scale"/>
      <doc>
      <![CDATA[Set the scale of this map.

 @param scale The scale to set.]]>
      </doc>
    </method>
    <method name="getCenterX" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the center X position of this map.

 @return The center X position.]]>
      </doc>
    </method>
    <method name="getCenterZ" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the center Z position of this map.

 @return The center Z position.]]>
      </doc>
    </method>
    <method name="setCenterX"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Set the center X position of this map.

 @param x The center X position.]]>
      </doc>
    </method>
    <method name="setCenterZ"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Set the center Z position of this map.

 @param z The center Z position.]]>
      </doc>
    </method>
    <method name="getWorld" return="org.bukkit.World"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the world that this map is associated with. Primarily used by the
 internal renderer, but may be used by external renderers. May return
 null if the world the map is associated with is not loaded.

 @return The World this map is associated with.]]>
      </doc>
    </method>
    <method name="setWorld"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Set the world that this map is associated with. The world is used by
 the internal renderer, and may also be used by external renderers.

 @param world The World to associate this map with.]]>
      </doc>
    </method>
    <method name="getRenderers" return="java.util.List&lt;org.bukkit.map.MapRenderer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of MapRenderers currently in effect.

 @return A {@code List<MapRenderer>} containing each map renderer.]]>
      </doc>
    </method>
    <method name="addRenderer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renderer" type="org.bukkit.map.MapRenderer"/>
      <doc>
      <![CDATA[Add a renderer to this map.

 @param renderer The MapRenderer to add.]]>
      </doc>
    </method>
    <method name="removeRenderer" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renderer" type="org.bukkit.map.MapRenderer"/>
      <doc>
      <![CDATA[Remove a renderer from this map.

 @param renderer The MapRenderer to remove.
 @return True if the renderer was successfully removed.]]>
      </doc>
    </method>
    <method name="isTrackingPosition" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether a position cursor should be shown when the map is near its
 center.

 @return tracking status]]>
      </doc>
    </method>
    <method name="setTrackingPosition"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trackingPosition" type="boolean"/>
      <doc>
      <![CDATA[Sets whether a position cursor should be shown when the map is near its
 center.

 @param trackingPosition tracking status]]>
      </doc>
    </method>
    <method name="isUnlimitedTracking" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the map will show a smaller position cursor (true), or no
 position cursor (false) when cursor is outside of map's range.

 @return unlimited tracking state]]>
      </doc>
    </method>
    <method name="setUnlimitedTracking"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unlimited" type="boolean"/>
      <doc>
      <![CDATA[Whether the map will show a smaller position cursor (true), or no
 position cursor (false) when cursor is outside of map's range.

 @param unlimited tracking state]]>
      </doc>
    </method>
    <method name="isLocked" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether the map is locked or not.

 A locked map may not be explored further.

 @return lock status]]>
      </doc>
    </method>
    <method name="setLocked"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="locked" type="boolean"/>
      <doc>
      <![CDATA[Gets whether the map is locked or not.

 A locked map may not be explored further.

 @param locked status]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a map item.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.map.MapView -->
  <!-- start class org.bukkit.map.MapView.Scale -->
  <class name="MapView.Scale" extends="java.lang.Enum&lt;org.bukkit.map.MapView.Scale&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.map.MapView.Scale[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.map.MapView.Scale"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="valueOf" return="org.bukkit.map.MapView.Scale"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Get the scale given the raw value.

 @param value The raw scale
 @return The enum scale, or null for an invalid input
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getValue" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Get the raw value of this scale level.

 @return The scale value
 @deprecated Magic value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An enum representing all possible scales a map can be set to.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MapView.Scale -->
  <!-- start class org.bukkit.map.MinecraftFont -->
  <class name="MinecraftFont" extends="org.bukkit.map.MapFont"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MinecraftFont"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initialize a new MinecraftFont.]]>
      </doc>
    </constructor>
    <field name="Font" type="org.bukkit.map.MinecraftFont"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A static non-malleable MinecraftFont.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents the built-in Minecraft font.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.map.MinecraftFont -->
</package>
<package name="org.bukkit.material">
  <!-- start interface org.bukkit.material.Attachable -->
  <interface name="Attachable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.material.Directional"/>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the face that this block is attached on

 @return BlockFace attached to]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Indicates that a block can be attached to another block]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.material.Attachable -->
  <!-- start class org.bukkit.material.Banner -->
  <class name="Banner" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Attachable"/>
    <constructor name="Banner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Banner" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Banner" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isWallBanner" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Banner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Banner -->
  <!-- start class org.bukkit.material.Bed -->
  <class name="Bed" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <constructor name="Bed"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor for a bed.]]>
      </doc>
    </constructor>
    <constructor name="Bed" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate a bed facing in a particular direction.

 @param direction the direction the bed's head is facing]]>
      </doc>
    </constructor>
    <constructor name="Bed" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Bed" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isHeadOfBed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determine if this block represents the head of the bed

 @return true if this is the head of the bed, false if it is the foot]]>
      </doc>
    </method>
    <method name="setHeadOfBed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isHeadOfBed" type="boolean"/>
      <doc>
      <![CDATA[Configure this to be either the head or the foot of the bed

 @param isHeadOfBed True to make it the head.]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Set which direction the head of the bed is facing. Note that this will
 only affect one of the two blocks the bed is made of.]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the direction that this bed's head is facing toward

 @return the direction the head of the bed is facing]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Bed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a bed.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Bed -->
  <!-- start class org.bukkit.material.Button -->
  <class name="Button" extends="org.bukkit.material.SimpleAttachableMaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="Button"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Button" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Button" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current state of this Material, indicating if it's powered or
 unpowered

 @return true if powered, otherwise false]]>
      </doc>
    </method>
    <method name="setPowered"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bool" type="boolean"/>
      <doc>
      <![CDATA[Sets the current state of this button

 @param bool
            whether or not the button is powered]]>
      </doc>
    </method>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the face that this block is attached on

 @return BlockFace attached to]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the direction this button is pointing toward]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Button"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a button

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Button -->
  <!-- start class org.bukkit.material.Cake -->
  <class name="Cake" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Cake"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Cake" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Cake" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getSlicesEaten" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of slices eaten from this cake

 @return The number of slices eaten]]>
      </doc>
    </method>
    <method name="getSlicesRemaining" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the number of slices remaining on this cake

 @return The number of slices remaining]]>
      </doc>
    </method>
    <method name="setSlicesEaten"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Sets the number of slices eaten from this cake

 @param n The number of slices eaten]]>
      </doc>
    </method>
    <method name="setSlicesRemaining"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Sets the number of slices remaining on this cake

 @param n The number of slices remaining]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Cake"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Cake -->
  <!-- start class org.bukkit.material.Cauldron -->
  <class name="Cauldron" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Cauldron"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Cauldron" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="Cauldron" type="byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isFull" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the cauldron is full.

 @return True if it is full.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if the cauldron is empty.

 @return True if it is empty.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Cauldron"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a cauldron

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Cauldron -->
  <!-- start class org.bukkit.material.Chest -->
  <class name="Chest" extends="org.bukkit.material.DirectionalContainer"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Chest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Chest" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate a chest facing in a particular direction.

 @param direction the direction the chest's lit opens towards]]>
      </doc>
    </constructor>
    <constructor name="Chest" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Chest" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="clone" return="org.bukkit.material.Chest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a chest

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Chest -->
  <!-- start class org.bukkit.material.Coal -->
  <class name="Coal" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Coal"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Coal" type="org.bukkit.CoalType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Coal" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Coal" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getType" return="org.bukkit.CoalType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current type of this coal

 @return CoalType of this coal]]>
      </doc>
    </method>
    <method name="setType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.CoalType"/>
      <doc>
      <![CDATA[Sets the type of this coal

 @param type New type of this coal]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Coal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the different types of coals.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Coal -->
  <!-- start class org.bukkit.material.CocoaPlant -->
  <class name="CocoaPlant" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <implements name="org.bukkit.material.Attachable"/>
    <constructor name="CocoaPlant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CocoaPlant" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="CocoaPlant" type="org.bukkit.material.CocoaPlant.CocoaPlantSize"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CocoaPlant" type="org.bukkit.material.CocoaPlant.CocoaPlantSize, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSize" return="org.bukkit.material.CocoaPlant.CocoaPlantSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get size of plant

 @return size]]>
      </doc>
    </method>
    <method name="setSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sz" type="org.bukkit.material.CocoaPlant.CocoaPlantSize"/>
      <doc>
      <![CDATA[Set size of plant

 @param sz - size of plant]]>
      </doc>
    </method>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.CocoaPlant"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the cocoa plant

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.CocoaPlant -->
  <!-- start class org.bukkit.material.CocoaPlant.CocoaPlantSize -->
  <class name="CocoaPlant.CocoaPlantSize" extends="java.lang.Enum&lt;org.bukkit.material.CocoaPlant.CocoaPlantSize&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.material.CocoaPlant.CocoaPlantSize[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.material.CocoaPlant.CocoaPlantSize"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.bukkit.material.CocoaPlant.CocoaPlantSize -->
  <!-- start interface org.bukkit.material.Colorable -->
  <interface name="Colorable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getColor" return="org.bukkit.DyeColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the color of this object.
 <br>
 This may be null to represent the default color of an object, if the
 object has a special default color (e.g Shulkers).

 @return The DyeColor of this object.]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the color of this object to the specified DyeColor.
 <br>
 This may be null to represent the default color of an object, if the
 object has a special default color (e.g Shulkers).

 @param color The color of the object, as a DyeColor.
 @throws NullPointerException if argument is null and this implementation does not support null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that can be colored.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.material.Colorable -->
  <!-- start class org.bukkit.material.Command -->
  <class name="Command" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="Command"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Command" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Command" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current state of this Material, indicating if it's powered or
 unpowered

 @return true if powered, otherwise false]]>
      </doc>
    </method>
    <method name="setPowered"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bool" type="boolean"/>
      <doc>
      <![CDATA[Sets the current state of this Material

 @param bool
            whether or not the command block is powered]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a command block

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Command -->
  <!-- start class org.bukkit.material.Comparator -->
  <class name="Comparator" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a comparator switched off, with the default mode (normal) and facing the default direction (north).]]>
      </doc>
    </constructor>
    <constructor name="Comparator" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a comparator switched off, with the default mode (normal) and facing the specified direction.

 @param facingDirection the direction the comparator is facing

 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Comparator" type="org.bukkit.block.BlockFace, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a comparator switched off, with the specified mode and facing the specified direction.

 @param facingDirection the direction the comparator is facing
 @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation

 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Comparator" type="org.bukkit.block.BlockFace, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a comparator switched on or off, with the specified mode and facing the specified direction.

 @param facingDirection the direction the comparator is facing
 @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation
 @param state True if the comparator is in the on state

 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Comparator" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Comparator" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="setSubtractionMode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isSubtraction" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the comparator is in subtraction mode.

 @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation]]>
      </doc>
    </method>
    <method name="isSubtractionMode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the comparator is in subtraction mode

 @return True if the comparator is in subtraction mode, false if normal comparator operation]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the direction this comparator is facing

 @param face The direction to set this comparator to

 @see BlockFace]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the direction this comparator is facing

 @return The direction this comparator is facing

 @see BlockFace]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the comparator is powered

 @return true if the comparator is powered]]>
      </doc>
    </method>
    <method name="isBeingPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the comparator is being powered

 @return true if the comparator is being powered]]>
      </doc>
    </method>
    <field name="DEFAULT_DIRECTION" type="org.bukkit.block.BlockFace"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_SUBTRACTION_MODE" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_STATE" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a comparator in the on or off state, in normal or subtraction mode and facing in a specific direction.

 @see Material#LEGACY_REDSTONE_COMPARATOR_OFF
 @see Material#LEGACY_REDSTONE_COMPARATOR_ON

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Comparator -->
  <!-- start class org.bukkit.material.Crops -->
  <class name="Crops" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Crops"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wheat crop block in the seeded state.]]>
      </doc>
    </constructor>
    <constructor name="Crops" type="org.bukkit.CropState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wheat crop block in the given growth state

 @param state The growth state of the crops]]>
      </doc>
    </constructor>
    <constructor name="Crops" type="org.bukkit.Material, org.bukkit.CropState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a crop block of the given type and in the given growth state

 @param type The type of crops
 @param state The growth state of the crops]]>
      </doc>
    </constructor>
    <constructor name="Crops" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a crop block of the given type and in the seeded state

 @param type The type of crops]]>
      </doc>
    </constructor>
    <constructor name="Crops" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getState" return="org.bukkit.CropState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current growth state of this crop

 For crops with only four growth states such as beetroot, only the values SEEDED, SMALL, TALL and RIPE will be
 returned.

 @return CropState of this crop]]>
      </doc>
    </method>
    <method name="setState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="org.bukkit.CropState"/>
      <doc>
      <![CDATA[Sets the growth state of this crop

 For crops with only four growth states such as beetroot, the 8 CropStates are mapped into four states:

 SEEDED, SMALL, TALL and RIPE

 GERMINATED will change to SEEDED
 VERY_SMALL will change to SMALL
 MEDIUM will change to TALL
 VERY_TALL will change to RIPE

 @param state New growth state of this crop]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Crops"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_TYPE" type="org.bukkit.Material"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_STATE" type="org.bukkit.CropState"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents the different types of crops in different states of growth.

 @see Material#LEGACY_CROPS
 @see Material#LEGACY_CARROT
 @see Material#LEGACY_POTATO
 @see Material#LEGACY_BEETROOT_BLOCK
 @see Material#LEGACY_NETHER_WARTS

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Crops -->
  <!-- start class org.bukkit.material.DetectorRail -->
  <class name="DetectorRail" extends="org.bukkit.material.ExtendedRails"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.PressureSensor"/>
    <constructor name="DetectorRail"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DetectorRail" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DetectorRail" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPressed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPressed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isPressed" type="boolean"/>
    </method>
    <method name="clone" return="org.bukkit.material.DetectorRail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a detector rail

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.DetectorRail -->
  <!-- start class org.bukkit.material.Diode -->
  <class name="Diode" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="Diode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a diode switched on, with a delay of 1 and facing the default
 direction (north).

 By default this constructor creates a diode that is switched on for
 backwards compatibility with past implementations.]]>
      </doc>
    </constructor>
    <constructor name="Diode" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a diode switched off, with a delay of 1 and facing the
 specified direction.

 @param facingDirection the direction the diode is facing

 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Diode" type="org.bukkit.block.BlockFace, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a diode switched off, with the specified delay and facing the
 specified direction.

 @param facingDirection the direction the diode is facing
 @param delay The number of ticks (1-4) before the diode turns on after
 being powered

 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Diode" type="org.bukkit.block.BlockFace, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a diode switched on or off, with the specified delay and
 facing the specified direction.

 @param facingDirection the direction the diode is facing
 @param delay The number of ticks (1-4) before the diode turns on after
 being powered
 @param state True if the diode is in the on state

 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Diode" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Diode" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="setDelay"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="int"/>
      <doc>
      <![CDATA[Sets the delay of the repeater.

 @param delay The new delay (1-4)]]>
      </doc>
    </method>
    <method name="getDelay" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the delay of the repeater in ticks.

 @return The delay (1-4)]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the direction this diode is facing.

 @param face The direction to set this diode to

 @see BlockFace]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the direction this diode is facing

 @return The direction this diode is facing

 @see BlockFace]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Diode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the diode is powered.

 @return true if the diode is powered]]>
      </doc>
    </method>
    <field name="DEFAULT_DIRECTION" type="org.bukkit.block.BlockFace"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_DELAY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_STATE" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a diode/repeater in the on or off state, with a delay and facing
 in a specific direction.

 @see Material#LEGACY_DIODE_BLOCK_OFF
 @see Material#LEGACY_DIODE_BLOCK_ON

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Diode -->
  <!-- start interface org.bukkit.material.Directional -->
  <interface name="Directional"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setFacingDirection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the direction that this block is facing in

 @param face The facing direction]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the direction this block is facing

 @return the direction this block is facing]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.material.Directional -->
  <!-- start class org.bukkit.material.DirectionalContainer -->
  <class name="DirectionalContainer" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <constructor name="DirectionalContainer" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DirectionalContainer" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.DirectionalContainer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a furnace or a dispenser.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.DirectionalContainer -->
  <!-- start class org.bukkit.material.Dispenser -->
  <class name="Dispenser" extends="org.bukkit.material.FurnaceAndDispenser"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Dispenser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Dispenser" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Dispenser" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Dispenser" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Dispenser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a dispenser.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Dispenser -->
  <!-- start class org.bukkit.material.Door -->
  <class name="Door" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <implements name="org.bukkit.material.Openable"/>
    <constructor name="Door"
      static="false" final="false" visibility="public"
      deprecated="Artifact of old API, equivalent to new lEsS_tHaNcode>Door(Material.LEGACY_WOODEN_DOOR);lEsS_tHaN/code>">
      <doc>
      <![CDATA[@deprecated Artifact of old API, equivalent to new <code>Door(Material.LEGACY_WOODEN_DOOR);</code>]]>
      </doc>
    </constructor>
    <constructor name="Door" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Door" type="org.bukkit.Material, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the bottom half of a door of the given material type, facing the specified direction and set to closed

 @param type The type of material this door is made of. This must match the type of the block above.
 @param face The direction the door is facing.

 @see Material#LEGACY_WOODEN_DOOR
 @see Material#LEGACY_IRON_DOOR_BLOCK
 @see Material#LEGACY_SPRUCE_DOOR
 @see Material#LEGACY_BIRCH_DOOR
 @see Material#LEGACY_JUNGLE_DOOR
 @see Material#LEGACY_ACACIA_DOOR
 @see Material#LEGACY_DARK_OAK_DOOR

 @see BlockFace#WEST
 @see BlockFace#NORTH
 @see BlockFace#EAST
 @see BlockFace#SOUTH]]>
      </doc>
    </constructor>
    <constructor name="Door" type="org.bukkit.Material, org.bukkit.block.BlockFace, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the bottom half of a door of the given material type, facing the specified direction and set to open
 or closed

 @param type The type of material this door is made of. This must match the type of the block above.
 @param face The direction the door is facing.
 @param isOpen Whether the door is currently opened.

 @see Material#LEGACY_WOODEN_DOOR
 @see Material#LEGACY_IRON_DOOR_BLOCK
 @see Material#LEGACY_SPRUCE_DOOR
 @see Material#LEGACY_BIRCH_DOOR
 @see Material#LEGACY_JUNGLE_DOOR
 @see Material#LEGACY_ACACIA_DOOR
 @see Material#LEGACY_DARK_OAK_DOOR

 @see BlockFace#WEST
 @see BlockFace#NORTH
 @see BlockFace#EAST
 @see BlockFace#SOUTH]]>
      </doc>
    </constructor>
    <constructor name="Door" type="org.bukkit.Material, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the top half of door of the given material type and with the hinge on the left or right

 @param type The type of material this door is made of. This must match the type of the block below.
 @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.

 @see Material#LEGACY_WOODEN_DOOR
 @see Material#LEGACY_IRON_DOOR_BLOCK
 @see Material#LEGACY_SPRUCE_DOOR
 @see Material#LEGACY_BIRCH_DOOR
 @see Material#LEGACY_JUNGLE_DOOR
 @see Material#LEGACY_ACACIA_DOOR
 @see Material#LEGACY_DARK_OAK_DOOR]]>
      </doc>
    </constructor>
    <constructor name="Door" type="org.bukkit.TreeSpecies, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the bottom half of a wooden door of the given species, facing the specified direction and set to
 closed

 @param species The species this wooden door is made of. This must match the species of the block above.
 @param face The direction the door is facing.

 @see TreeSpecies

 @see BlockFace#WEST
 @see BlockFace#NORTH
 @see BlockFace#EAST
 @see BlockFace#SOUTH]]>
      </doc>
    </constructor>
    <constructor name="Door" type="org.bukkit.TreeSpecies, org.bukkit.block.BlockFace, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the bottom half of a wooden door of the given species, facing the specified direction and set to open
 or closed

 @param species The species this wooden door is made of. This must match the species of the block above.
 @param face The direction the door is facing.
 @param isOpen Whether the door is currently opened.

 @see TreeSpecies

 @see BlockFace#WEST
 @see BlockFace#NORTH
 @see BlockFace#EAST
 @see BlockFace#SOUTH]]>
      </doc>
    </constructor>
    <constructor name="Door" type="org.bukkit.TreeSpecies, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the top half of a wooden door of the given species and with the hinge on the left or right

 @param species The species this wooden door is made of. This must match the species of the block below.
 @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.

 @see TreeSpecies]]>
      </doc>
    </constructor>
    <constructor name="Door" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getWoodDoorOfSpecies" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="species" type="org.bukkit.TreeSpecies"/>
      <doc>
      <![CDATA[Returns the item type of a wooden door for the given tree species.

 @param species The species of wood door required.
 @return The item type for the given species.

 @see Material#LEGACY_WOODEN_DOOR
 @see Material#LEGACY_SPRUCE_DOOR
 @see Material#LEGACY_BIRCH_DOOR
 @see Material#LEGACY_JUNGLE_DOOR
 @see Material#LEGACY_ACACIA_DOOR
 @see Material#LEGACY_DARK_OAK_DOOR]]>
      </doc>
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Result is undefined if <code>isTopHalf()</code> is true.]]>
      </doc>
    </method>
    <method name="setOpen"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isOpen" type="boolean"/>
      <doc>
      <![CDATA[Set whether the door is open. Undefined if <code>isTopHalf()</code> is true.]]>
      </doc>
    </method>
    <method name="isTopHalf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return whether this is the top half of the door]]>
      </doc>
    </method>
    <method name="setTopHalf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isTopHalf" type="boolean"/>
      <doc>
      <![CDATA[Configure this part of the door to be either the top or the bottom half

 @param isTopHalf True to make it the top half.]]>
      </doc>
    </method>
    <method name="getHingeCorner" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method should not be used; use hinge and facing accessors instead.">
      <doc>
      <![CDATA[@return BlockFace.SELF
 @deprecated This method should not be used; use hinge and facing accessors instead.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Set the direction that this door should is facing.

 Undefined if <code>isTopHalf()</code> is true.

 @param face the direction]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the direction that this door is facing.

 Undefined if <code>isTopHalf()</code> is true.

 @return the direction]]>
      </doc>
    </method>
    <method name="getHinge" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the side of the door the hinge is on.

 Undefined if <code>isTopHalf()</code> is false.

 @return false for left hinge, true for right hinge]]>
      </doc>
    </method>
    <method name="setHinge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isHingeRight" type="boolean"/>
      <doc>
      <![CDATA[Set whether the hinge is on the left or right side. Left is false, right is true.

 Undefined if <code>isTopHalf()</code> is false.

 @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.material.Door"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a door.

 This class was previously deprecated, but has been retrofitted to
 work with modern doors. Some methods are undefined dependant on <code>isTopHalf()</code>
 due to Minecraft's internal representation of doors.

 @see Material#LEGACY_WOODEN_DOOR
 @see Material#LEGACY_IRON_DOOR_BLOCK
 @see Material#LEGACY_SPRUCE_DOOR
 @see Material#LEGACY_BIRCH_DOOR
 @see Material#LEGACY_JUNGLE_DOOR
 @see Material#LEGACY_ACACIA_DOOR
 @see Material#LEGACY_DARK_OAK_DOOR

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Door -->
  <!-- start class org.bukkit.material.Dye -->
  <class name="Dye" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Colorable"/>
    <constructor name="Dye"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Dye" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Dye" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="Dye" type="org.bukkit.DyeColor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param color color of the dye]]>
      </doc>
    </constructor>
    <method name="getColor" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current color of this dye

 @return DyeColor of this dye]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the color of this dye

 @param color New color of this dye]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Dye"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents dye

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Dye -->
  <!-- start class org.bukkit.material.EnderChest -->
  <class name="EnderChest" extends="org.bukkit.material.DirectionalContainer"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="EnderChest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EnderChest" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate an ender chest facing in a particular direction.

 @param direction the direction the ender chest's lid opens towards]]>
      </doc>
    </constructor>
    <constructor name="EnderChest" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EnderChest" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="clone" return="org.bukkit.material.EnderChest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an ender chest

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.EnderChest -->
  <!-- start class org.bukkit.material.ExtendedRails -->
  <class name="ExtendedRails" extends="org.bukkit.material.Rails"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="ExtendedRails" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ExtendedRails" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isCurve" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getConvertedData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="Magic value">
      <doc>
      <![CDATA[{@inheritDoc}

 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <param name="isOnSlope" type="boolean"/>
    </method>
    <method name="clone" return="org.bukkit.material.ExtendedRails"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is the superclass for the {@link DetectorRail} and {@link PoweredRail}
 classes

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.ExtendedRails -->
  <!-- start class org.bukkit.material.FlowerPot -->
  <class name="FlowerPot" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="FlowerPot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor for a flower pot.]]>
      </doc>
    </constructor>
    <constructor name="FlowerPot" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FlowerPot" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getContents" return="org.bukkit.material.MaterialData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the material in the flower pot

 @return material MaterialData for the block currently in the flower pot
     or null if empty]]>
      </doc>
    </method>
    <method name="setContents"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="materialData" type="org.bukkit.material.MaterialData"/>
      <doc>
      <![CDATA[Set the contents of the flower pot

 @param materialData MaterialData of the block to put in the flower pot.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.FlowerPot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a flower pot.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.FlowerPot -->
  <!-- start class org.bukkit.material.Furnace -->
  <class name="Furnace" extends="org.bukkit.material.FurnaceAndDispenser"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Furnace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Furnace" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate a furnace facing in a particular direction.

 @param direction the direction the furnace's "opening" is facing]]>
      </doc>
    </constructor>
    <constructor name="Furnace" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Furnace" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="clone" return="org.bukkit.material.Furnace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a furnace.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Furnace -->
  <!-- start class org.bukkit.material.FurnaceAndDispenser -->
  <class name="FurnaceAndDispenser" extends="org.bukkit.material.DirectionalContainer"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="FurnaceAndDispenser" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FurnaceAndDispenser" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="clone" return="org.bukkit.material.FurnaceAndDispenser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a furnace or dispenser, two types of directional containers

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.FurnaceAndDispenser -->
  <!-- start class org.bukkit.material.Gate -->
  <class name="Gate" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <implements name="org.bukkit.material.Openable"/>
    <constructor name="Gate"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Gate" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="Gate" type="byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setOpen"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isOpen" type="boolean"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Gate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a fence gate

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Gate -->
  <!-- start class org.bukkit.material.Hopper -->
  <class name="Hopper" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="Hopper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a hopper facing the default direction (down) and initially
 active.]]>
      </doc>
    </constructor>
    <constructor name="Hopper" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a hopper facing the specified direction and initially active.

 @param facingDirection the direction the hopper is facing

 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Hopper" type="org.bukkit.block.BlockFace, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a hopper facing the specified direction and either active or
 not.

 @param facingDirection the direction the hopper is facing
 @param isActive True if the hopper is initially active, false if
 deactivated

 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Hopper" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Hopper" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="setActive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isActive" type="boolean"/>
      <doc>
      <![CDATA[Sets whether the hopper is active or not.

 @param isActive True if the hopper is active, false if deactivated as if
 powered by redstone]]>
      </doc>
    </method>
    <method name="isActive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the hopper is active or not.

 @return True if the hopper is active, false if deactivated]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the direction this hopper is facing

 @param face The direction to set this hopper to

 @see BlockFace]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the direction this hopper is facing

 @return The direction this hopper is facing

 @see BlockFace]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Hopper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the hopper is powered.

 @return true if the hopper is powered]]>
      </doc>
    </method>
    <field name="DEFAULT_DIRECTION" type="org.bukkit.block.BlockFace"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_ACTIVE" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a hopper in an active or deactivated state and facing in a
 specific direction.

 @see Material#HOPPER

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Hopper -->
  <!-- start class org.bukkit.material.Ladder -->
  <class name="Ladder" extends="org.bukkit.material.SimpleAttachableMaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Ladder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Ladder" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Ladder" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the face that this block is attached on

 @return BlockFace attached to]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the direction this ladder is facing]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.material.Ladder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents Ladder data

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Ladder -->
  <!-- start class org.bukkit.material.Leaves -->
  <class name="Leaves" extends="org.bukkit.material.Wood"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Leaves"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a leaf block.]]>
      </doc>
    </constructor>
    <constructor name="Leaves" type="org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a leaf block of the given tree species.

 @param species the species of the wood block]]>
      </doc>
    </constructor>
    <constructor name="Leaves" type="org.bukkit.TreeSpecies, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a leaf block of the given tree species and flag for whether
 this leaf block will disappear when too far from a log.

 @param species the species of the wood block
 @param isDecayable whether the block is permanent or can disappear]]>
      </doc>
    </constructor>
    <constructor name="Leaves" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a leaf block of the given type.

 @param type the type of leaf block]]>
      </doc>
    </constructor>
    <constructor name="Leaves" type="org.bukkit.Material, org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a leaf block of the given type and tree species.

 @param type the type of leaf block
 @param species the species of the wood block]]>
      </doc>
    </constructor>
    <constructor name="Leaves" type="org.bukkit.Material, org.bukkit.TreeSpecies, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a leaf block of the given type and tree species and flag for
 whether this leaf block will disappear when too far from a log.

 @param type the type of leaf block
 @param species the species of the wood block
 @param isDecayable whether the block is permanent or can disappear]]>
      </doc>
    </constructor>
    <constructor name="Leaves" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isDecaying" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this leaf block is in the process of decaying

 @return true if the leaf block is in the process of decaying]]>
      </doc>
    </method>
    <method name="setDecaying"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isDecaying" type="boolean"/>
      <doc>
      <![CDATA[Set whether this leaf block is in the process of decaying

 @param isDecaying whether the block is decaying or not]]>
      </doc>
    </method>
    <method name="isDecayable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this leaf block is permanent or can decay when too far from a
 log

 @return true if the leaf block is permanent or can decay when too far
 from a log]]>
      </doc>
    </method>
    <method name="setDecayable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isDecayable" type="boolean"/>
      <doc>
      <![CDATA[Set whether this leaf block will disappear when too far from a log

 @param isDecayable whether the block is permanent or can disappear]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Leaves"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_TYPE" type="org.bukkit.Material"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_DECAYABLE" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents the different types of leaf block that may be permanent or can
 decay when too far from a log.

 @see Material#LEGACY_LEAVES
 @see Material#LEGACY_LEAVES_2

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Leaves -->
  <!-- start class org.bukkit.material.Lever -->
  <class name="Lever" extends="org.bukkit.material.SimpleAttachableMaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="Lever"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Lever" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Lever" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current state of this Material, indicating if it's powered or
 unpowered

 @return true if powered, otherwise false]]>
      </doc>
    </method>
    <method name="setPowered"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isPowered" type="boolean"/>
      <doc>
      <![CDATA[Set this lever to be powered or not.

 @param isPowered whether the lever should be powered or not]]>
      </doc>
    </method>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the face that this block is attached on

 @return BlockFace attached to]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Sets the direction this lever is pointing in]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Lever"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a lever

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Lever -->
  <!-- start class org.bukkit.material.LongGrass -->
  <class name="LongGrass" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="LongGrass"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LongGrass" type="org.bukkit.GrassSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LongGrass" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LongGrass" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getSpecies" return="org.bukkit.GrassSpecies"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current species of this grass

 @return GrassSpecies of this grass]]>
      </doc>
    </method>
    <method name="setSpecies"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="species" type="org.bukkit.GrassSpecies"/>
      <doc>
      <![CDATA[Sets the species of this grass

 @param species New species of this grass]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.LongGrass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the different types of long grasses.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.LongGrass -->
  <!-- start class org.bukkit.material.MaterialData -->
  <class name="MaterialData" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="java.lang.Cloneable"/>
    <constructor name="MaterialData" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MaterialData" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the raw data in this material

 @return Raw data
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Sets the raw data of this material

 @param data New raw data
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getItemType" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Material that this MaterialData represents

 @return Material represented by this MaterialData]]>
      </doc>
    </method>
    <method name="toItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="this method creates an ItemStack of size 0 which is not
 generally useful. Consider {@link #toItemStack(int)}.">
      <doc>
      <![CDATA[Creates a new ItemStack based on this MaterialData

 @return New ItemStack containing a copy of this MaterialData
 @deprecated this method creates an ItemStack of size 0 which is not
 generally useful. Consider {@link #toItemStack(int)}.]]>
      </doc>
    </method>
    <method name="toItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Creates a new ItemStack based on this MaterialData

 @param amount The stack size of the new stack
 @return New ItemStack containing a copy of this MaterialData]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="clone" return="org.bukkit.material.MaterialData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Handles specific metadata for certain items or blocks

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.MaterialData -->
  <!-- start class org.bukkit.material.MonsterEggs -->
  <class name="MonsterEggs" extends="org.bukkit.material.TexturedMaterial"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="MonsterEggs"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MonsterEggs" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MonsterEggs" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getTextures" return="java.util.List&lt;org.bukkit.Material&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.MonsterEggs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the different types of monster eggs

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.MonsterEggs -->
  <!-- start class org.bukkit.material.Mushroom -->
  <class name="Mushroom" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Mushroom" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a brown/red mushroom block with all sides set to pores.

 @param shroom A brown or red mushroom material type.

 @see Material#LEGACY_HUGE_MUSHROOM_1
 @see Material#LEGACY_HUGE_MUSHROOM_2]]>
      </doc>
    </constructor>
    <constructor name="Mushroom" type="org.bukkit.Material, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a brown/red mushroom cap block with the specified face or
 faces set to cap texture.

 Setting any of the four sides will also set the top to cap.

 To set two side faces at once use e.g. north-west.

 Specify self to set all six faces at once.

 @param shroom A brown or red mushroom material type.
 @param capFace The face or faces to set to mushroom cap texture.

 @see Material#LEGACY_HUGE_MUSHROOM_1
 @see Material#LEGACY_HUGE_MUSHROOM_2
 @see BlockFace]]>
      </doc>
    </constructor>
    <constructor name="Mushroom" type="org.bukkit.Material, org.bukkit.material.types.MushroomBlockTexture"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a brown/red mushroom block with the specified textures.

 @param shroom A brown or red mushroom material type.
 @param texture The textured mushroom faces.

 @see Material#LEGACY_HUGE_MUSHROOM_1
 @see Material#LEGACY_HUGE_MUSHROOM_2]]>
      </doc>
    </constructor>
    <constructor name="Mushroom" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param shroom the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isStem" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Whether this is a mushroom stem.]]>
      </doc>
    </method>
    <method name="setStem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use
 {@link #setBlockTexture(org.bukkit.material.types.MushroomBlockTexture)}
 with {@link MushroomBlockTexture#STEM_SIDES } or
 {@link MushroomBlockTexture#ALL_STEM}">
      <doc>
      <![CDATA[Sets this to be a mushroom stem.

 @see MushroomBlockTexture#STEM_SIDES
 @see MushroomBlockTexture#ALL_STEM

 @deprecated Use
 {@link #setBlockTexture(org.bukkit.material.types.MushroomBlockTexture)}
 with {@link MushroomBlockTexture#STEM_SIDES } or
 {@link MushroomBlockTexture#ALL_STEM}]]>
      </doc>
    </method>
    <method name="getBlockTexture" return="org.bukkit.material.types.MushroomBlockTexture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the mushroom texture of this block.

 @return The mushroom texture of this block]]>
      </doc>
    </method>
    <method name="setBlockTexture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="texture" type="org.bukkit.material.types.MushroomBlockTexture"/>
      <doc>
      <![CDATA[Sets the mushroom texture of this block.

 @param texture The mushroom texture to set]]>
      </doc>
    </method>
    <method name="isFacePainted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Checks whether a face of the block is painted with cap texture.

 @param face The face to check.
 @return True if it is painted.]]>
      </doc>
    </method>
    <method name="setFacePainted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use MushroomBlockType cap options">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <param name="painted" type="boolean"/>
      <doc>
      <![CDATA[Set a face of the block to be painted or not. Note that due to the
 nature of how the data is stored, setting a face painted or not is not
 guaranteed to leave the other faces unchanged.

 @param face The face to paint or unpaint.
 @param painted True if you want to paint it, false if you want the
     pores to show.

 @deprecated Use MushroomBlockType cap options]]>
      </doc>
    </method>
    <method name="getPaintedFaces" return="java.util.Set&lt;org.bukkit.block.BlockFace&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return A set of all faces that are currently painted (an empty set if
     it is a stem)]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Mushroom"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a huge mushroom block with certain combinations of faces set to
 cap, pores or stem.

 @see Material#LEGACY_HUGE_MUSHROOM_1
 @see Material#LEGACY_HUGE_MUSHROOM_2

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Mushroom -->
  <!-- start class org.bukkit.material.NetherWarts -->
  <class name="NetherWarts" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="NetherWarts"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NetherWarts" type="org.bukkit.NetherWartsState"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NetherWarts" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NetherWarts" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getState" return="org.bukkit.NetherWartsState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current growth state of this nether wart

 @return NetherWartsState of this nether wart]]>
      </doc>
    </method>
    <method name="setState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="org.bukkit.NetherWartsState"/>
      <doc>
      <![CDATA[Sets the growth state of this nether wart

 @param state New growth state of this nether wart]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.NetherWarts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents nether wart

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.NetherWarts -->
  <!-- start class org.bukkit.material.Observer -->
  <class name="Observer" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="Observer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Observer" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Observer" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Observer" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Observer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an observer.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Observer -->
  <!-- start interface org.bukkit.material.Openable -->
  <interface name="Openable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isOpen" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check to see if the door is open.

 @return true if the door has swung counterclockwise around its hinge.]]>
      </doc>
    </method>
    <method name="setOpen"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isOpen" type="boolean"/>
      <doc>
      <![CDATA[Configure this door to be either open or closed;

 @param isOpen True to open the door.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.material.Openable -->
  <!-- start class org.bukkit.material.PistonBaseMaterial -->
  <class name="PistonBaseMaterial" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="PistonBaseMaterial" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PistonBaseMaterial" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Constructs a PistonBaseMaterial.

 @param type the material type to use
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPowered"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="powered" type="boolean"/>
      <doc>
      <![CDATA[Sets the current state of this piston

 @param powered true if the piston is extended {@literal &} powered, or false]]>
      </doc>
    </method>
    <method name="isSticky" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this piston base is sticky, and returns true if so

 @return true if this piston is "sticky", or false]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.material.PistonBaseMaterial"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Material data for the piston base block

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.PistonBaseMaterial -->
  <!-- start class org.bukkit.material.PistonExtensionMaterial -->
  <class name="PistonExtensionMaterial" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Attachable"/>
    <constructor name="PistonExtensionMaterial" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PistonExtensionMaterial" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isSticky" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this piston extension is sticky, and returns true if so

 @return true if this piston is "sticky", or false]]>
      </doc>
    </method>
    <method name="setSticky"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sticky" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not this extension is sticky

 @param sticky true if sticky, otherwise false]]>
      </doc>
    </method>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.PistonExtensionMaterial"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Material data for the piston extension block

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.PistonExtensionMaterial -->
  <!-- start class org.bukkit.material.PoweredRail -->
  <class name="PoweredRail" extends="org.bukkit.material.ExtendedRails"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="PoweredRail"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PoweredRail" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PoweredRail" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPowered"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isPowered" type="boolean"/>
      <doc>
      <![CDATA[Set whether this PoweredRail should be powered or not.

 @param isPowered whether or not the rail is powered]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.material.PoweredRail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a powered rail

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.PoweredRail -->
  <!-- start class org.bukkit.material.PressurePlate -->
  <class name="PressurePlate" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.PressureSensor"/>
    <constructor name="PressurePlate"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PressurePlate" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PressurePlate" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPressed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.PressurePlate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a pressure plate

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.PressurePlate -->
  <!-- start interface org.bukkit.material.PressureSensor -->
  <interface name="PressureSensor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isPressed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface org.bukkit.material.PressureSensor -->
  <!-- start class org.bukkit.material.Pumpkin -->
  <class name="Pumpkin" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <constructor name="Pumpkin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Pumpkin" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate a pumpkin facing in a particular direction.

 @param direction the direction the pumkin's face is facing]]>
      </doc>
    </constructor>
    <constructor name="Pumpkin" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Pumpkin" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isLit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Pumpkin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a pumpkin.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Pumpkin -->
  <!-- start class org.bukkit.material.Rails -->
  <class name="Rails" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Rails"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Rails" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Rails" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isOnSlope" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the whether this track is set on a slope]]>
      </doc>
    </method>
    <method name="isCurve" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the whether this track is set as a curve]]>
      </doc>
    </method>
    <method name="getDirection" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the direction these tracks are set
     <p>
     Note that tracks are bidirectional and that the direction returned
     is the ascending direction if the track is set on a slope. If it is
     set as a curve, the corner of the track is returned.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getConvertedData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="Magic value">
      <doc>
      <![CDATA[Return the data without the extended properties used by {@link
 PoweredRail} and {@link DetectorRail}. Overridden in {@link
 ExtendedRails}

 @return the data without the extended part
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <param name="isOnSlope" type="boolean"/>
      <doc>
      <![CDATA[Set the direction of these tracks
 <p>
 Note that tracks are bidirectional and that the direction returned is
 the ascending direction if the track is set on a slope. If it is set as
 a curve, the corner of the track should be supplied.

 @param face the direction the track should be facing
 @param isOnSlope whether or not the track should be on a slope]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.material.Rails"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents minecart rails.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Rails -->
  <!-- start interface org.bukkit.material.Redstone -->
  <interface name="Redstone"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isPowered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current state of this Material, indicating if it's powered or
 unpowered

 @return true if powered, otherwise false]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Indicated a Material that may carry or create a Redstone current]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.material.Redstone -->
  <!-- start class org.bukkit.material.RedstoneTorch -->
  <class name="RedstoneTorch" extends="org.bukkit.material.Torch"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="RedstoneTorch"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RedstoneTorch" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RedstoneTorch" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current state of this Material, indicating if it's powered or
 unpowered

 @return true if powered, otherwise false]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.RedstoneTorch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a redstone torch

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.RedstoneTorch -->
  <!-- start class org.bukkit.material.RedstoneWire -->
  <class name="RedstoneWire" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="RedstoneWire"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RedstoneWire" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RedstoneWire" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current state of this Material, indicating if it's powered or
 unpowered

 @return true if powered, otherwise false]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.RedstoneWire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents redstone wire

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.RedstoneWire -->
  <!-- start class org.bukkit.material.Sandstone -->
  <class name="Sandstone" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Sandstone"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sandstone" type="org.bukkit.SandstoneType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sandstone" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sandstone" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getType" return="org.bukkit.SandstoneType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current type of this sandstone

 @return SandstoneType of this sandstone]]>
      </doc>
    </method>
    <method name="setType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.SandstoneType"/>
      <doc>
      <![CDATA[Sets the type of this sandstone

 @param type New type of this sandstone]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Sandstone"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the different types of sandstone.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Sandstone -->
  <!-- start class org.bukkit.material.Sapling -->
  <class name="Sapling" extends="org.bukkit.material.Wood"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Sapling"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a sapling.]]>
      </doc>
    </constructor>
    <constructor name="Sapling" type="org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a sapling of the given tree species.

 @param species the species of the sapling]]>
      </doc>
    </constructor>
    <constructor name="Sapling" type="org.bukkit.TreeSpecies, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a sapling of the given tree species and if is it instant
 growable

 @param species the species of the tree block
 @param isInstantGrowable true if the Sapling should grow when next ticked with bonemeal]]>
      </doc>
    </constructor>
    <constructor name="Sapling" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a sapling of the given type.

 @param type the type of tree block]]>
      </doc>
    </constructor>
    <constructor name="Sapling" type="org.bukkit.Material, org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a sapling of the given type and tree species.

 @param type the type of sapling
 @param species the species of the sapling]]>
      </doc>
    </constructor>
    <constructor name="Sapling" type="org.bukkit.Material, org.bukkit.TreeSpecies, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a sapling of the given type and tree species and if is it
 instant growable

 @param type the type of sapling
 @param species the species of the sapling
 @param isInstantGrowable true if the Sapling should grow when next ticked
 with bonemeal]]>
      </doc>
    </constructor>
    <constructor name="Sapling" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isInstantGrowable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the Sapling would grow when next ticked with bonemeal

 @return true if the Sapling would grow when next ticked with bonemeal]]>
      </doc>
    </method>
    <method name="setIsInstantGrowable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isInstantGrowable" type="boolean"/>
      <doc>
      <![CDATA[Set whether this sapling will grow when next ticked with bonemeal

 @param isInstantGrowable true if the Sapling should grow when next ticked
 with bonemeal]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Sapling"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the different types of Tree block that face a direction.

 @see Material#LEGACY_SAPLING

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Sapling -->
  <!-- start class org.bukkit.material.Sign -->
  <class name="Sign" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Attachable"/>
    <constructor name="Sign"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sign" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sign" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the raw type id
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isWallSign" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if this sign is attached to a wall

 @return true if this sign is attached to a wall, false if set on top of
     a block]]>
      </doc>
    </method>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the face that this block is attached on

 @return BlockFace attached to]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the direction that this sign is currently facing

 @return BlockFace indicating where this sign is facing]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Sign"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[MaterialData for signs

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Sign -->
  <!-- start class org.bukkit.material.SimpleAttachableMaterialData -->
  <class name="SimpleAttachableMaterialData" extends="org.bukkit.material.MaterialData"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Attachable"/>
    <constructor name="SimpleAttachableMaterialData" type="org.bukkit.Material, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleAttachableMaterialData" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleAttachableMaterialData" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.SimpleAttachableMaterialData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Simple utility class for attachable MaterialData subclasses

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.SimpleAttachableMaterialData -->
  <!-- start class org.bukkit.material.Skull -->
  <class name="Skull" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <constructor name="Skull"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Skull" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate a skull facing in a particular direction.

 @param direction the direction the skull's face is facing]]>
      </doc>
    </constructor>
    <constructor name="Skull" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Skull" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Skull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a skull.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Skull -->
  <!-- start class org.bukkit.material.SmoothBrick -->
  <class name="SmoothBrick" extends="org.bukkit.material.TexturedMaterial"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="SmoothBrick"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SmoothBrick" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SmoothBrick" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getTextures" return="java.util.List&lt;org.bukkit.Material&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.SmoothBrick"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the different types of smooth bricks.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.SmoothBrick -->
  <!-- start class org.bukkit.material.SpawnEgg -->
  <class name="SpawnEgg" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="use {@link SpawnEggMeta}">
    <constructor name="SpawnEgg"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SpawnEgg" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="SpawnEgg" type="byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="SpawnEgg" type="org.bukkit.entity.EntityType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSpawnedType" return="org.bukkit.entity.EntityType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This is now stored in {@link SpawnEggMeta}.">
      <doc>
      <![CDATA[Get the type of entity this egg will spawn.

 @return The entity type.
 @deprecated This is now stored in {@link SpawnEggMeta}.]]>
      </doc>
    </method>
    <method name="setSpawnedType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This is now stored in {@link SpawnEggMeta}.">
      <param name="type" type="org.bukkit.entity.EntityType"/>
      <doc>
      <![CDATA[Set the type of entity this egg will spawn.

 @param type The entity type.
 @deprecated This is now stored in {@link SpawnEggMeta}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.SpawnEgg"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a spawn egg that can be used to spawn mobs
 @deprecated use {@link SpawnEggMeta}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.SpawnEgg -->
  <!-- start class org.bukkit.material.Stairs -->
  <class name="Stairs" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Directional"/>
    <constructor name="Stairs" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Stairs" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getAscendingDirection" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the direction the stairs ascend towards]]>
      </doc>
    </method>
    <method name="getDescendingDirection" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the direction the stairs descend towards]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Set the direction the stair part of the block is facing]]>
      </doc>
    </method>
    <method name="getFacing" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the direction the stair part of the block is facing]]>
      </doc>
    </method>
    <method name="isInverted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Test if step is inverted

 @return true if inverted (top half), false if normal (bottom half)]]>
      </doc>
    </method>
    <method name="setInverted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inv" type="boolean"/>
      <doc>
      <![CDATA[Set step inverted state

 @param inv - true if step is inverted (top half), false if step is
     normal (bottom half)]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Stairs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents stairs.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Stairs -->
  <!-- start class org.bukkit.material.Step -->
  <class name="Step" extends="org.bukkit.material.TexturedMaterial"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Step"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Step" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Step" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getTextures" return="java.util.List&lt;org.bukkit.Material&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isInverted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Test if step is inverted

 @return true if inverted (top half), false if normal (bottom half)]]>
      </doc>
    </method>
    <method name="setInverted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inv" type="boolean"/>
      <doc>
      <![CDATA[Set step inverted state

 @param inv - true if step is inverted (top half), false if step is
     normal (bottom half)]]>
      </doc>
    </method>
    <method name="getTextureIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="Magic value">
      <doc>
      <![CDATA[{@inheritDoc}

 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setTextureIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="Magic value">
      <param name="idx" type="int"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.material.Step"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the different types of steps.

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Step -->
  <!-- start class org.bukkit.material.TexturedMaterial -->
  <class name="TexturedMaterial" extends="org.bukkit.material.MaterialData"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="TexturedMaterial" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TexturedMaterial" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getTextures" return="java.util.List&lt;org.bukkit.Material&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve a list of possible textures. The first element of the list
 will be used as a default.

 @return a list of possible textures for this block]]>
      </doc>
    </method>
    <method name="getMaterial" return="org.bukkit.Material"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current Material this block is made of

 @return Material of this block]]>
      </doc>
    </method>
    <method name="setMaterial"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="material" type="org.bukkit.Material"/>
      <doc>
      <![CDATA[Sets the material this block is made of

 @param material
            New material of this block]]>
      </doc>
    </method>
    <method name="getTextureIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="Magic value">
      <doc>
      <![CDATA[Get material index from data

 @return index of data in textures list
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="setTextureIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="Magic value">
      <param name="idx" type="int"/>
      <doc>
      <![CDATA[Set material index

 @param idx - index of data in textures list
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.TexturedMaterial"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents textured materials like steps and smooth bricks

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.TexturedMaterial -->
  <!-- start class org.bukkit.material.Torch -->
  <class name="Torch" extends="org.bukkit.material.SimpleAttachableMaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Torch"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Torch" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Torch" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the face that this block is attached on

 @return BlockFace attached to]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="clone" return="org.bukkit.material.Torch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[MaterialData for torches

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Torch -->
  <!-- start class org.bukkit.material.TrapDoor -->
  <class name="TrapDoor" extends="org.bukkit.material.SimpleAttachableMaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Openable"/>
    <constructor name="TrapDoor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TrapDoor" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TrapDoor" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setOpen"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isOpen" type="boolean"/>
    </method>
    <method name="isInverted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Test if trapdoor is inverted

 @return true if inverted (top half), false if normal (bottom half)]]>
      </doc>
    </method>
    <method name="setInverted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inv" type="boolean"/>
      <doc>
      <![CDATA[Set trapdoor inverted state

 @param inv - true if inverted (top half), false if normal (bottom half)]]>
      </doc>
    </method>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.TrapDoor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a trap door

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.TrapDoor -->
  <!-- start class org.bukkit.material.Tree -->
  <class name="Tree" extends="org.bukkit.material.Wood"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Tree"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a tree block.]]>
      </doc>
    </constructor>
    <constructor name="Tree" type="org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a tree block of the given tree species.

 @param species the species of the tree block]]>
      </doc>
    </constructor>
    <constructor name="Tree" type="org.bukkit.TreeSpecies, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a tree block of the given tree species, and facing the given
 direction.

 @param species the species of the tree block
 @param dir the direction the tree block is facing]]>
      </doc>
    </constructor>
    <constructor name="Tree" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a tree block of the given type.

 @param type the type of tree block]]>
      </doc>
    </constructor>
    <constructor name="Tree" type="org.bukkit.Material, org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a tree block of the given type and tree species.

 @param type the type of tree block
 @param species the species of the tree block]]>
      </doc>
    </constructor>
    <constructor name="Tree" type="org.bukkit.Material, org.bukkit.TreeSpecies, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a tree block of the given type and tree species, and facing
 the given direction.

 @param type the type of tree block
 @param species the species of the tree block
 @param dir the direction the tree block is facing]]>
      </doc>
    </constructor>
    <constructor name="Tree" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getDirection" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get direction of the log

 @return one of:
 <ul>
 <li>BlockFace.TOP for upright (default)
 <li>BlockFace.NORTH (east-west)
 <li>BlockFace.WEST (north-south)
 <li>BlockFace.SELF (directionless)
 </ul>]]>
      </doc>
    </method>
    <method name="setDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Set direction of the log

 @param dir - direction of end of log (BlockFace.SELF for no direction)]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Tree"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_TYPE" type="org.bukkit.Material"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_DIRECTION" type="org.bukkit.block.BlockFace"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents the different types of Tree block that face a direction.

 @see Material#LEGACY_LOG
 @see Material#LEGACY_LOG_2

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Tree -->
  <!-- start class org.bukkit.material.Tripwire -->
  <class name="Tripwire" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Tripwire"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Tripwire" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isActivated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Test if tripwire is currently activated

 @return true if activated, false if not]]>
      </doc>
    </method>
    <method name="setActivated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="act" type="boolean"/>
      <doc>
      <![CDATA[Set tripwire activated state

 @param act - true if activated, false if not]]>
      </doc>
    </method>
    <method name="isObjectTriggering" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Test if object triggering this tripwire directly

 @return true if object activating tripwire, false if not]]>
      </doc>
    </method>
    <method name="setObjectTriggering"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trig" type="boolean"/>
      <doc>
      <![CDATA[Set object triggering state for this tripwire

 @param trig - true if object activating tripwire, false if not]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.material.Tripwire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the tripwire

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Tripwire -->
  <!-- start class org.bukkit.material.TripwireHook -->
  <class name="TripwireHook" extends="org.bukkit.material.SimpleAttachableMaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Redstone"/>
    <constructor name="TripwireHook"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TripwireHook" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="TripwireHook" type="org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isConnected" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Test if tripwire is connected

 @return true if connected, false if not]]>
      </doc>
    </method>
    <method name="setConnected"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="connected" type="boolean"/>
      <doc>
      <![CDATA[Set tripwire connection state

 @param connected - true if connected, false if not]]>
      </doc>
    </method>
    <method name="isActivated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Test if hook is currently activated

 @return true if activated, false if not]]>
      </doc>
    </method>
    <method name="setActivated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="act" type="boolean"/>
      <doc>
      <![CDATA[Set hook activated state

 @param act - true if activated, false if not]]>
      </doc>
    </method>
    <method name="setFacingDirection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
    </method>
    <method name="getAttachedFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPowered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.TripwireHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the tripwire hook

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.TripwireHook -->
  <!-- start class org.bukkit.material.Vine -->
  <class name="Vine" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Vine"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Vine" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="Vine" type="byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <constructor name="Vine" type="org.bukkit.block.BlockFace[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Vine" type="java.util.EnumSet&lt;org.bukkit.block.BlockFace&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isOnFace" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Check if the vine is attached to the specified face of an adjacent
 block. You can check two faces at once by passing e.g. {@link
 BlockFace#NORTH_EAST}.

 @param face The face to check.
 @return Whether it is attached to that face.]]>
      </doc>
    </method>
    <method name="putOnFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Attach the vine to the specified face of an adjacent block.

 @param face The face to attach.]]>
      </doc>
    </method>
    <method name="removeFromFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Detach the vine from the specified face of an adjacent block.

 @param face The face to detach.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Vine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a vine

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Vine -->
  <!-- start class org.bukkit.material.Wood -->
  <class name="Wood" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="Wood"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wood block.]]>
      </doc>
    </constructor>
    <constructor name="Wood" type="org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wood block of the given tree species.

 @param species the species of the wood block]]>
      </doc>
    </constructor>
    <constructor name="Wood" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wood block of the given type.

 @param type the type of wood block]]>
      </doc>
    </constructor>
    <constructor name="Wood" type="org.bukkit.Material, org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wood block of the given type and tree species.

 @param type the type of wood block
 @param species the species of the wood block]]>
      </doc>
    </constructor>
    <constructor name="Wood" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getSpecies" return="org.bukkit.TreeSpecies"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current species of this wood block

 @return TreeSpecies of this wood block]]>
      </doc>
    </method>
    <method name="setSpecies"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="species" type="org.bukkit.TreeSpecies"/>
      <doc>
      <![CDATA[Sets the species of this wood block

 @param species New species of this wood block]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Wood"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_TYPE" type="org.bukkit.Material"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_SPECIES" type="org.bukkit.TreeSpecies"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents wood blocks of different species.

 @see Material#LEGACY_WOOD
 @see Material#LEGACY_SAPLING
 @see Material#LEGACY_WOOD_DOUBLE_STEP

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Wood -->
  <!-- start class org.bukkit.material.WoodenStep -->
  <class name="WoodenStep" extends="org.bukkit.material.Wood"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <constructor name="WoodenStep"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wooden step.]]>
      </doc>
    </constructor>
    <constructor name="WoodenStep" type="org.bukkit.TreeSpecies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wooden step of the given tree species.

 @param species the species of the wooden step]]>
      </doc>
    </constructor>
    <constructor name="WoodenStep" type="org.bukkit.TreeSpecies, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a wooden step of the given type and tree species, either
 inverted or not.

 @param species the species of the wooden step
 @param inv true the step is at the top of the block]]>
      </doc>
    </constructor>
    <constructor name="WoodenStep" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="isInverted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Test if step is inverted

 @return true if inverted (top half), false if normal (bottom half)]]>
      </doc>
    </method>
    <method name="setInverted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inv" type="boolean"/>
      <doc>
      <![CDATA[Set step inverted state

 @param inv - true if step is inverted (top half), false if step is normal
 (bottom half)]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.material.WoodenStep"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_TYPE" type="org.bukkit.Material"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_INVERTED" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents the different types of wooden steps.

 @see Material#LEGACY_WOOD_STEP

 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.WoodenStep -->
  <!-- start class org.bukkit.material.Wool -->
  <class name="Wool" extends="org.bukkit.material.MaterialData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.">
    <implements name="org.bukkit.material.Colorable"/>
    <constructor name="Wool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Wool" type="org.bukkit.DyeColor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Wool" type="org.bukkit.Material"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Wool" type="org.bukkit.Material, byte"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[@param type the type
 @param data the raw data value
 @deprecated Magic value]]>
      </doc>
    </constructor>
    <method name="getColor" return="org.bukkit.DyeColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current color of this dye

 @return DyeColor of this dye]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.DyeColor"/>
      <doc>
      <![CDATA[Sets the color of this dye

 @param color New color of this dye]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.material.Wool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a Wool/Cloth block
 @deprecated all usage of MaterialData is deprecated and subject to removal.
 Use {@link org.bukkit.block.data.BlockData}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.Wool -->
</package>
<package name="org.bukkit.material.types">
  <!-- start class org.bukkit.material.types.MushroomBlockTexture -->
  <class name="MushroomBlockTexture" extends="java.lang.Enum&lt;org.bukkit.material.types.MushroomBlockTexture&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.material.types.MushroomBlockTexture[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.material.types.MushroomBlockTexture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getData" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Gets the associated data value representing this mushroom block face.

 @return A byte containing the data value of this mushroom block face
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getCapFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the face that has cap texture.

 @return The cap face]]>
      </doc>
    </method>
    <method name="getByData" return="org.bukkit.material.types.MushroomBlockTexture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="data" type="byte"/>
      <doc>
      <![CDATA[Gets the MushroomBlockType with the given data value.

 @param data Data value to fetch
 @return The {@link MushroomBlockTexture} representing the given value, or
 null if it doesn't exist
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getCapByFace" return="org.bukkit.material.types.MushroomBlockTexture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="face" type="org.bukkit.block.BlockFace"/>
      <doc>
      <![CDATA[Gets the MushroomBlockType with cap texture on the given block face.

 @param face the required block face with cap texture
 @return The {@link MushroomBlockTexture} representing the given block
 face, or null if it doesn't exist

 @see BlockFace]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents the different textured blocks of mushroom.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.material.types.MushroomBlockTexture -->
</package>
<package name="org.bukkit.metadata">
  <!-- start class org.bukkit.metadata.FixedMetadataValue -->
  <class name="FixedMetadataValue" extends="org.bukkit.metadata.LazyMetadataValue"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FixedMetadataValue" type="org.bukkit.plugin.Plugin, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initializes a FixedMetadataValue with an Object

 @param owningPlugin the {@link Plugin} that created this metadata value
 @param value the value assigned to this metadata value]]>
      </doc>
    </constructor>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="value" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A FixedMetadataValue is a special case metadata item that contains the same
 value forever after initialization. Invalidating a FixedMetadataValue has
 no effect.
 <p>
 This class extends LazyMetadataValue for historical reasons, even though it
 overrides all the implementation methods. it is possible that in the future
 that the inheritance hierarchy may change.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.metadata.FixedMetadataValue -->
  <!-- start class org.bukkit.metadata.LazyMetadataValue -->
  <class name="LazyMetadataValue" extends="org.bukkit.metadata.MetadataValueAdapter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LazyMetadataValue" type="org.bukkit.plugin.Plugin, java.util.concurrent.Callable&lt;java.lang.Object&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initialized a LazyMetadataValue object with the default
 CACHE_AFTER_FIRST_EVAL cache strategy.

 @param owningPlugin the {@link Plugin} that created this metadata
     value.
 @param lazyValue the lazy value assigned to this metadata value.]]>
      </doc>
    </constructor>
    <constructor name="LazyMetadataValue" type="org.bukkit.plugin.Plugin, org.bukkit.metadata.LazyMetadataValue.CacheStrategy, java.util.concurrent.Callable&lt;java.lang.Object&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initializes a LazyMetadataValue object with a specific cache strategy.

 @param owningPlugin the {@link Plugin} that created this metadata
     value.
 @param cacheStrategy determines the rules for caching this metadata
     value.
 @param lazyValue the lazy value assigned to this metadata value.]]>
      </doc>
    </constructor>
    <constructor name="LazyMetadataValue" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Protected special constructor used by FixedMetadataValue to bypass
 standard setup.

 @param owningPlugin the owning plugin]]>
      </doc>
    </constructor>
    <method name="value" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The LazyMetadataValue class implements a type of metadata that is not
 computed until another plugin asks for it.
 <p>
 By making metadata values lazy, no computation is done by the providing
 plugin until absolutely necessary (if ever). Additionally,
 LazyMetadataValue objects cache their values internally unless overridden
 by a {@link CacheStrategy} or invalidated at the individual or plugin
 level. Once invalidated, the LazyMetadataValue will recompute its value
 when asked.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.metadata.LazyMetadataValue -->
  <!-- start class org.bukkit.metadata.LazyMetadataValue.CacheStrategy -->
  <class name="LazyMetadataValue.CacheStrategy" extends="java.lang.Enum&lt;org.bukkit.metadata.LazyMetadataValue.CacheStrategy&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.metadata.LazyMetadataValue.CacheStrategy[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.metadata.LazyMetadataValue.CacheStrategy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Describes possible caching strategies for metadata.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.metadata.LazyMetadataValue.CacheStrategy -->
  <!-- start interface org.bukkit.metadata.Metadatable -->
  <interface name="Metadatable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setMetadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadataKey" type="java.lang.String"/>
      <param name="newMetadataValue" type="org.bukkit.metadata.MetadataValue"/>
      <doc>
      <![CDATA[Sets a metadata value in the implementing object's metadata store.

 @param metadataKey A unique key to identify this metadata.
 @param newMetadataValue The metadata value to apply.
 @throws IllegalArgumentException If value is null, or the owning plugin
     is null]]>
      </doc>
    </method>
    <method name="getMetadata" return="java.util.List&lt;org.bukkit.metadata.MetadataValue&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadataKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a list of previously set metadata values from the implementing
 object's metadata store.

 @param metadataKey the unique metadata key being sought.
 @return A list of values, one for each plugin that has set the
     requested value.]]>
      </doc>
    </method>
    <method name="hasMetadata" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadataKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Tests to see whether the implementing object contains the given
 metadata value in its metadata store.

 @param metadataKey the unique metadata key being queried.
 @return the existence of the metadataKey within subject.]]>
      </doc>
    </method>
    <method name="removeMetadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadataKey" type="java.lang.String"/>
      <param name="owningPlugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Removes the given metadata value from the implementing object's
 metadata store.

 @param metadataKey the unique metadata key identifying the metadata to
     remove.
 @param owningPlugin This plugin's metadata value will be removed. All
     other values will be left untouched.
 @throws IllegalArgumentException If plugin is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface is implemented by all objects that can provide metadata
 about themselves.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.metadata.Metadatable -->
  <!-- start class org.bukkit.metadata.MetadataConversionException -->
  <class name="MetadataConversionException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[A MetadataConversionException is thrown any time a {@link
 LazyMetadataValue} attempts to convert a metadata value to an inappropriate
 data type.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.metadata.MetadataConversionException -->
  <!-- start class org.bukkit.metadata.MetadataEvaluationException -->
  <class name="MetadataEvaluationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[A MetadataEvaluationException is thrown any time a {@link
 LazyMetadataValue} fails to evaluate its value due to an exception. The
 originating exception will be included as this exception's cause.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.metadata.MetadataEvaluationException -->
  <!-- start interface org.bukkit.metadata.MetadataStore -->
  <interface name="MetadataStore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setMetadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <param name="newMetadataValue" type="org.bukkit.metadata.MetadataValue"/>
      <doc>
      <![CDATA[Adds a metadata value to an object.

 @param subject The object receiving the metadata.
 @param metadataKey A unique key to identify this metadata.
 @param newMetadataValue The metadata value to apply.
 @throws IllegalArgumentException If value is null, or the owning plugin
     is null]]>
      </doc>
    </method>
    <method name="getMetadata" return="java.util.List&lt;org.bukkit.metadata.MetadataValue&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns all metadata values attached to an object. If multiple plugins
 have attached metadata, each will value will be included.

 @param subject the object being interrogated.
 @param metadataKey the unique metadata key being sought.
 @return A list of values, one for each plugin that has set the
     requested value.]]>
      </doc>
    </method>
    <method name="hasMetadata" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Tests to see if a metadata attribute has been set on an object.

 @param subject the object upon which the has-metadata test is
     performed.
 @param metadataKey the unique metadata key being queried.
 @return the existence of the metadataKey within subject.]]>
      </doc>
    </method>
    <method name="removeMetadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <param name="owningPlugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Removes a metadata item owned by a plugin from a subject.

 @param subject the object to remove the metadata from.
 @param metadataKey the unique metadata key identifying the metadata to
     remove.
 @param owningPlugin the plugin attempting to remove a metadata item.
 @throws IllegalArgumentException If plugin is null]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owningPlugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Invalidates all metadata in the metadata store that originates from the
 given plugin. Doing this will force each invalidated metadata item to
 be recalculated the next time it is accessed.

 @param owningPlugin the plugin requesting the invalidation.
 @throws IllegalArgumentException If plugin is null]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.metadata.MetadataStore -->
  <!-- start class org.bukkit.metadata.MetadataStoreBase -->
  <class name="MetadataStoreBase" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetadataStoreBase"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setMetadata"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <param name="newMetadataValue" type="org.bukkit.metadata.MetadataValue"/>
      <doc>
      <![CDATA[Adds a metadata value to an object. Each metadata value is owned by a
 specific {@link Plugin}. If a plugin has already added a metadata value
 to an object, that value will be replaced with the value of {@code
 newMetadataValue}. Multiple plugins can set independent values for the
 same {@code metadataKey} without conflict.
 <p>
 Implementation note: I considered using a {@link
 java.util.concurrent.locks.ReadWriteLock} for controlling access to
 {@code metadataMap}, but decided that the added overhead wasn't worth
 the finer grained access control.
 <p>
 Bukkit is almost entirely single threaded so locking overhead shouldn't
 pose a problem.

 @param subject The object receiving the metadata.
 @param metadataKey A unique key to identify this metadata.
 @param newMetadataValue The metadata value to apply.
 @throws IllegalArgumentException If value is null, or the owning plugin
     is null
 @see MetadataStore#setMetadata(Object, String, MetadataValue)]]>
      </doc>
    </method>
    <method name="getMetadata" return="java.util.List&lt;org.bukkit.metadata.MetadataValue&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns all metadata values attached to an object. If multiple
 have attached metadata, each will value will be included.

 @param subject the object being interrogated.
 @param metadataKey the unique metadata key being sought.
 @return A list of values, one for each plugin that has set the
     requested value.
 @see MetadataStore#getMetadata(Object, String)]]>
      </doc>
    </method>
    <method name="hasMetadata" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Tests to see if a metadata attribute has been set on an object.

 @param subject the object upon which the has-metadata test is
     performed.
 @param metadataKey the unique metadata key being queried.
 @return the existence of the metadataKey within subject.]]>
      </doc>
    </method>
    <method name="removeMetadata"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <param name="owningPlugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Removes a metadata item owned by a plugin from a subject.

 @param subject the object to remove the metadata from.
 @param metadataKey the unique metadata key identifying the metadata to
     remove.
 @param owningPlugin the plugin attempting to remove a metadata item.
 @throws IllegalArgumentException If plugin is null
 @see MetadataStore#removeMetadata(Object, String,
     org.bukkit.plugin.Plugin)]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owningPlugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Invalidates all metadata in the metadata store that originates from the
 given plugin. Doing this will force each invalidated metadata item to
 be recalculated the next time it is accessed.

 @param owningPlugin the plugin requesting the invalidation.
 @throws IllegalArgumentException If plugin is null
 @see MetadataStore#invalidateAll(org.bukkit.plugin.Plugin)]]>
      </doc>
    </method>
    <method name="removeAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owningPlugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Removes all metadata in the metadata store that originates from the
 given plugin.

 @param owningPlugin the plugin requesting the invalidation.
 @throws IllegalArgumentException If plugin is null]]>
      </doc>
    </method>
    <method name="disambiguate" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="subject" type="T"/>
      <param name="metadataKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a unique name for the object receiving metadata by combining
 unique data from the subject with a metadataKey.
 <p>
 The name created must be globally unique for the given object and any
 two equivalent objects must generate the same unique name. For example,
 two Player objects must generate the same string if they represent the
 same player, even if the objects would fail a reference equality test.

 @param subject The object for which this key is being generated.
 @param metadataKey The name identifying the metadata value.
 @return a unique metadata key for the given subject.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.metadata.MetadataStoreBase -->
  <!-- start interface org.bukkit.metadata.MetadataValue -->
  <interface name="MetadataValue"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="value" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Fetches the value of this metadata item.

 @return the metadata value.]]>
      </doc>
    </method>
    <method name="asInt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to convert the value of this metadata item into an int.

 @return the value as an int.]]>
      </doc>
    </method>
    <method name="asFloat" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to convert the value of this metadata item into a float.

 @return the value as a float.]]>
      </doc>
    </method>
    <method name="asDouble" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to convert the value of this metadata item into a double.

 @return the value as a double.]]>
      </doc>
    </method>
    <method name="asLong" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to convert the value of this metadata item into a long.

 @return the value as a long.]]>
      </doc>
    </method>
    <method name="asShort" return="short"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to convert the value of this metadata item into a short.

 @return the value as a short.]]>
      </doc>
    </method>
    <method name="asByte" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to convert the value of this metadata item into a byte.

 @return the value as a byte.]]>
      </doc>
    </method>
    <method name="asBoolean" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to convert the value of this metadata item into a boolean.

 @return the value as a boolean.]]>
      </doc>
    </method>
    <method name="asString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempts to convert the value of this metadata item into a string.

 @return the value as a string.]]>
      </doc>
    </method>
    <method name="getOwningPlugin" return="org.bukkit.plugin.Plugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Plugin} that created this metadata item.

 @return the plugin that owns this metadata value. Could be null if the plugin was already unloaded.]]>
      </doc>
    </method>
    <method name="invalidate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invalidates this metadata item, forcing it to recompute when next
 accessed.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.metadata.MetadataValue -->
  <!-- start class org.bukkit.metadata.MetadataValueAdapter -->
  <class name="MetadataValueAdapter" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.metadata.MetadataValue"/>
    <constructor name="MetadataValueAdapter" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getOwningPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="owningPlugin" type="java.lang.ref.WeakReference&lt;org.bukkit.plugin.Plugin&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Optional base class for facilitating MetadataValue implementations.
 <p>
 This provides all the conversion functions for MetadataValue so that
 writing an implementation of MetadataValue is as simple as implementing
 value() and invalidate().]]>
    </doc>
  </class>
  <!-- end class org.bukkit.metadata.MetadataValueAdapter -->
</package>
<package name="org.bukkit.permissions">
  <!-- start interface org.bukkit.permissions.Permissible -->
  <interface name="Permissible"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.permissions.ServerOperator"/>
    <method name="isPermissionSet" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if this object contains an override for the specified
 permission, by fully qualified name

 @param name Name of the permission
 @return true if the permission is set, otherwise false]]>
      </doc>
    </method>
    <method name="isPermissionSet" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <doc>
      <![CDATA[Checks if this object contains an override for the specified {@link
 Permission}

 @param perm Permission to check
 @return true if the permission is set, otherwise false]]>
      </doc>
    </method>
    <method name="hasPermission" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the value of the specified permission, if set.
 <p>
 If a permission override is not set on this object, the default value
 of the permission will be returned.

 @param name Name of the permission
 @return Value of the permission]]>
      </doc>
    </method>
    <method name="hasPermission" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <doc>
      <![CDATA[Gets the value of the specified permission, if set.
 <p>
 If a permission override is not set on this object, the default value
 of the permission will be returned

 @param perm Permission to get
 @return Value of the permission]]>
      </doc>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Adds a new {@link PermissionAttachment} with a single permission by
 name and value

 @param plugin Plugin responsible for this attachment, may not be null
     or disabled
 @param name Name of the permission to attach
 @param value Value of the permission
 @return The PermissionAttachment that was just created]]>
      </doc>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Adds a new empty {@link PermissionAttachment} to this object

 @param plugin Plugin responsible for this attachment, may not be null
     or disabled
 @return The PermissionAttachment that was just created]]>
      </doc>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Temporarily adds a new {@link PermissionAttachment} with a single
 permission by name and value

 @param plugin Plugin responsible for this attachment, may not be null
     or disabled
 @param name Name of the permission to attach
 @param value Value of the permission
 @param ticks Amount of ticks to automatically remove this attachment
     after
 @return The PermissionAttachment that was just created]]>
      </doc>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="ticks" type="int"/>
      <doc>
      <![CDATA[Temporarily adds a new empty {@link PermissionAttachment} to this
 object

 @param plugin Plugin responsible for this attachment, may not be null
     or disabled
 @param ticks Amount of ticks to automatically remove this attachment
     after
 @return The PermissionAttachment that was just created]]>
      </doc>
    </method>
    <method name="removeAttachment"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attachment" type="org.bukkit.permissions.PermissionAttachment"/>
      <doc>
      <![CDATA[Removes the given {@link PermissionAttachment} from this object

 @param attachment Attachment to remove
 @throws IllegalArgumentException Thrown when the specified attachment
     isn't part of this object]]>
      </doc>
    </method>
    <method name="recalculatePermissions"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Recalculates the permissions for this object, if the attachments have
 changed values.
 <p>
 This should very rarely need to be called from a plugin.]]>
      </doc>
    </method>
    <method name="getEffectivePermissions" return="java.util.Set&lt;org.bukkit.permissions.PermissionAttachmentInfo&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all of the permissions currently in effect by
 this object

 @return Set of currently effective permissions]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an object that may be assigned permissions]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.permissions.Permissible -->
  <!-- start class org.bukkit.permissions.PermissibleBase -->
  <class name="PermissibleBase" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.permissions.Permissible"/>
    <constructor name="PermissibleBase" type="org.bukkit.permissions.ServerOperator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isOp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setOp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
    </method>
    <method name="isPermissionSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="isPermissionSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="hasPermission" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inName" type="java.lang.String"/>
    </method>
    <method name="hasPermission" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="removeAttachment"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attachment" type="org.bukkit.permissions.PermissionAttachment"/>
    </method>
    <method name="recalculatePermissions"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clearPermissions"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <param name="ticks" type="int"/>
    </method>
    <method name="addAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="ticks" type="int"/>
    </method>
    <method name="getEffectivePermissions" return="java.util.Set&lt;org.bukkit.permissions.PermissionAttachmentInfo&gt;"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base Permissible for use in any Permissible object via proxy or extension]]>
    </doc>
  </class>
  <!-- end class org.bukkit.permissions.PermissibleBase -->
  <!-- start class org.bukkit.permissions.Permission -->
  <class name="Permission" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Permission" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Permission" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Permission" type="java.lang.String, org.bukkit.permissions.PermissionDefault"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Permission" type="java.lang.String, java.lang.String, org.bukkit.permissions.PermissionDefault"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Permission" type="java.lang.String, java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Permission" type="java.lang.String, java.lang.String, java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Permission" type="java.lang.String, org.bukkit.permissions.PermissionDefault, java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Permission" type="java.lang.String, java.lang.String, org.bukkit.permissions.PermissionDefault, java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the unique fully qualified name of this Permission

 @return Fully qualified name]]>
      </doc>
    </method>
    <method name="getChildren" return="java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the children of this permission.
 <p>
 If you change this map in any form, you must call {@link
 #recalculatePermissibles()} to recalculate all {@link Permissible}s

 @return Permission children]]>
      </doc>
    </method>
    <method name="getDefault" return="org.bukkit.permissions.PermissionDefault"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the default value of this permission.

 @return Default value of this permission.]]>
      </doc>
    </method>
    <method name="setDefault"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.bukkit.permissions.PermissionDefault"/>
      <doc>
      <![CDATA[Sets the default value of this permission.
 <p>
 This will not be saved to disk, and is a temporary operation until the
 server reloads permissions. Changing this default will cause all {@link
 Permissible}s that contain this permission to recalculate their
 permissions

 @param value The new default to set]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a brief description of this permission, may be empty

 @return Brief description of this permission]]>
      </doc>
    </method>
    <method name="setDescription"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the description of this permission.
 <p>
 This will not be saved to disk, and is a temporary operation until the
 server reloads permissions.

 @param value The new description to set]]>
      </doc>
    </method>
    <method name="getPermissibles" return="java.util.Set&lt;org.bukkit.permissions.Permissible&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing every {@link Permissible} that has this
 permission.
 <p>
 This set cannot be modified.

 @return Set containing permissibles with this permission]]>
      </doc>
    </method>
    <method name="recalculatePermissibles"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Recalculates all {@link Permissible}s that contain this permission.
 <p>
 This should be called after modifying the children, and is
 automatically called after modifying the default value]]>
      </doc>
    </method>
    <method name="addParent" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Adds this permission to the specified parent permission.
 <p>
 If the parent permission does not exist, it will be created and
 registered.

 @param name Name of the parent permission
 @param value The value to set this permission to
 @return Parent permission it created or loaded]]>
      </doc>
    </method>
    <method name="addParent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Adds this permission to the specified parent permission.

 @param perm Parent permission to register with
 @param value The value to set this permission to]]>
      </doc>
    </method>
    <method name="loadPermissions" return="java.util.List&lt;org.bukkit.permissions.Permission&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.util.Map&lt;?, ?&gt;"/>
      <param name="error" type="java.lang.String"/>
      <param name="def" type="org.bukkit.permissions.PermissionDefault"/>
      <doc>
      <![CDATA[Loads a list of Permissions from a map of data, usually used from
 retrieval from a yaml file.
 <p>
 The data may contain a list of name:data, where the data contains the
 following keys:
 <ul>
 <li>default: Boolean true or false. If not specified, false.
 <li>children: {@code Map<String, Boolean>} of child permissions. If not
     specified, empty list.
 <li>description: Short string containing a very small description of
     this description. If not specified, empty string.
 </ul>

 @param data Map of permissions
 @param error An error message to show if a permission is invalid. May contain "%s" format tag, which will be replaced with the name of invalid permission.
 @param def Default permission value to use if missing
 @return Permission object]]>
      </doc>
    </method>
    <method name="loadPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="data" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Loads a Permission from a map of data, usually used from retrieval from
 a yaml file.
 <p>
 The data may contain the following keys:
 <ul>
 <li>default: Boolean true or false. If not specified, false.
 <li>children: {@code Map<String, Boolean>} of child permissions. If not
     specified, empty list.
 <li>description: Short string containing a very small description of
     this description. If not specified, empty string.
 </ul>

 @param name Name of the permission
 @param data Map of keys
 @return Permission object]]>
      </doc>
    </method>
    <method name="loadPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="data" type="java.util.Map&lt;?, ?&gt;"/>
      <param name="def" type="org.bukkit.permissions.PermissionDefault"/>
      <param name="output" type="java.util.List&lt;org.bukkit.permissions.Permission&gt;"/>
      <doc>
      <![CDATA[Loads a Permission from a map of data, usually used from retrieval from
 a yaml file.
 <p>
 The data may contain the following keys:
 <ul>
 <li>default: Boolean true or false. If not specified, false.
 <li>children: {@code Map<String, Boolean>} of child permissions. If not
     specified, empty list.
 <li>description: Short string containing a very small description of
     this description. If not specified, empty string.
 </ul>

 @param name Name of the permission
 @param data Map of keys
 @param def Default permission value to use if not set
 @param output A list to append any created child-Permissions to, may be null
 @return Permission object]]>
      </doc>
    </method>
    <field name="DEFAULT_PERMISSION" type="org.bukkit.permissions.PermissionDefault"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a unique permission that may be attached to a {@link
 Permissible}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.permissions.Permission -->
  <!-- start class org.bukkit.permissions.PermissionAttachment -->
  <class name="PermissionAttachment" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PermissionAttachment" type="org.bukkit.plugin.Plugin, org.bukkit.permissions.Permissible"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin responsible for this attachment

 @return Plugin responsible for this permission attachment]]>
      </doc>
    </method>
    <method name="setRemovalCallback"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ex" type="org.bukkit.permissions.PermissionRemovedExecutor"/>
      <doc>
      <![CDATA[Sets an object to be called for when this attachment is removed from a
 {@link Permissible}. May be null.

 @param ex Object to be called when this is removed]]>
      </doc>
    </method>
    <method name="getRemovalCallback" return="org.bukkit.permissions.PermissionRemovedExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the class that was previously set to be called when this
 attachment was removed from a {@link Permissible}. May be null.

 @return Object to be called when this is removed]]>
      </doc>
    </method>
    <method name="getPermissible" return="org.bukkit.permissions.Permissible"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Permissible that this is attached to

 @return Permissible containing this attachment]]>
      </doc>
    </method>
    <method name="getPermissions" return="java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a copy of all set permissions and values contained within this
 attachment.
 <p>
 This map may be modified but will not affect the attachment, as it is a
 copy.

 @return Copy of all permissions and values expressed by this attachment]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets a permission to the given value, by its fully qualified name

 @param name Name of the permission
 @param value New value of the permission]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets a permission to the given value

 @param perm Permission to set
 @param value New value of the permission]]>
      </doc>
    </method>
    <method name="unsetPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes the specified permission from this attachment.
 <p>
 If the permission does not exist in this attachment, nothing will
 happen.

 @param name Name of the permission to remove]]>
      </doc>
    </method>
    <method name="unsetPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <doc>
      <![CDATA[Removes the specified permission from this attachment.
 <p>
 If the permission does not exist in this attachment, nothing will
 happen.

 @param perm Permission to remove]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes this attachment from its registered {@link Permissible}

 @return true if the permissible was removed successfully, false if it
     did not exist]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Holds information about a permission attachment on a {@link Permissible}
 object]]>
    </doc>
  </class>
  <!-- end class org.bukkit.permissions.PermissionAttachment -->
  <!-- start class org.bukkit.permissions.PermissionAttachmentInfo -->
  <class name="PermissionAttachmentInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PermissionAttachmentInfo" type="org.bukkit.permissions.Permissible, java.lang.String, org.bukkit.permissions.PermissionAttachment, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPermissible" return="org.bukkit.permissions.Permissible"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the permissible this is attached to

 @return Permissible this permission is for]]>
      </doc>
    </method>
    <method name="getPermission" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the permission being set

 @return Name of the permission]]>
      </doc>
    </method>
    <method name="getAttachment" return="org.bukkit.permissions.PermissionAttachment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the attachment providing this permission. This may be null for
 default permissions (usually parent permissions).

 @return Attachment]]>
      </doc>
    </method>
    <method name="getValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of this permission

 @return Value of the permission]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Holds information on a permission and which {@link PermissionAttachment}
 provides it]]>
    </doc>
  </class>
  <!-- end class org.bukkit.permissions.PermissionAttachmentInfo -->
  <!-- start class org.bukkit.permissions.PermissionDefault -->
  <class name="PermissionDefault" extends="java.lang.Enum&lt;org.bukkit.permissions.PermissionDefault&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.permissions.PermissionDefault[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.permissions.PermissionDefault"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
      <doc>
      <![CDATA[Calculates the value of this PermissionDefault for the given operator
 value

 @param op If the target is op
 @return True if the default should be true, or false]]>
      </doc>
    </method>
    <method name="getByName" return="org.bukkit.permissions.PermissionDefault"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Looks up a PermissionDefault by name

 @param name Name of the default
 @return Specified value, or null if not found]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the possible default values for permissions]]>
    </doc>
  </class>
  <!-- end class org.bukkit.permissions.PermissionDefault -->
  <!-- start interface org.bukkit.permissions.PermissionRemovedExecutor -->
  <interface name="PermissionRemovedExecutor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="attachmentRemoved"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attachment" type="org.bukkit.permissions.PermissionAttachment"/>
      <doc>
      <![CDATA[Called when a {@link PermissionAttachment} is removed from a {@link
 Permissible}

 @param attachment Attachment which was removed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a class which is to be notified when a {@link
 PermissionAttachment} is removed from a {@link Permissible}]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.permissions.PermissionRemovedExecutor -->
  <!-- start interface org.bukkit.permissions.ServerOperator -->
  <interface name="ServerOperator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isOp" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this object is a server operator

 @return true if this is an operator, otherwise false]]>
      </doc>
    </method>
    <method name="setOp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Sets the operator status of this object

 @param value New operator value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an object that may become a server operator, such as a {@link
 Player}]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.permissions.ServerOperator -->
</package>
<package name="org.bukkit.persistence">
  <!-- start interface org.bukkit.persistence.PersistentDataAdapterContext -->
  <interface name="PersistentDataAdapterContext"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newPersistentDataContainer" return="org.bukkit.persistence.PersistentDataContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new and empty meta container instance.

 @return the fresh container instance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface represents the context in which the {@link PersistentDataType} can
 serialize and deserialize the passed values.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.persistence.PersistentDataAdapterContext -->
  <!-- start interface org.bukkit.persistence.PersistentDataContainer -->
  <interface name="PersistentDataContainer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="type" type="org.bukkit.persistence.PersistentDataType&lt;T, Z&gt;"/>
      <param name="value" type="Z"/>
      <doc>
      <![CDATA[Stores a metadata value on the {@link PersistentDataHolder} instance.
 <p>
 This API cannot be used to manipulate minecraft data, as the values will
 be stored using your namespace. This method will override any existing
 value the {@link PersistentDataHolder} may have stored under the provided
 key.

 @param key the key this value will be stored under
 @param type the type this tag uses
 @param value the value stored in the tag
 @param <T> the generic java type of the tag value
 @param <Z> the generic type of the object to store

 @throws NullPointerException if the key is null
 @throws NullPointerException if the type is null
 @throws NullPointerException if the value is null. Removing a tag should
 be done using {@link #remove(NamespacedKey)}
 @throws IllegalArgumentException if no suitable adapter will be found for
 the {@link PersistentDataType#getPrimitiveType()}]]>
      </doc>
    </method>
    <method name="has" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="type" type="org.bukkit.persistence.PersistentDataType&lt;T, Z&gt;"/>
      <doc>
      <![CDATA[Returns if the persistent metadata provider has metadata registered
 matching the provided parameters.
 <p>
 This method will only return if the found value has the same primitive
 data type as the provided key.
 <p>
 Storing a value using a custom {@link PersistentDataType} implementation
 will not store the complex data type. Therefore storing a UUID (by
 storing a byte[]) will match has("key" ,
 {@link PersistentDataType#BYTE_ARRAY}). Likewise a stored byte[] will
 always match your UUID {@link PersistentDataType} even if it is not 16
 bytes long.
 <p>
 This method is only usable for custom object keys. Overwriting existing
 tags, like the the display name, will not work as the values are stored
 using your namespace.

 @param key the key the value is stored under
 @param type the type which primitive storage type has to match the value
 @param <T> the generic type of the stored primitive
 @param <Z> the generic type of the eventually created complex object

 @return if a value

 @throws NullPointerException if the key to look up is null
 @throws NullPointerException if the type to cast the found object to is
 null]]>
      </doc>
    </method>
    <method name="get" return="Z"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="type" type="org.bukkit.persistence.PersistentDataType&lt;T, Z&gt;"/>
      <doc>
      <![CDATA[Returns the metadata value that is stored on the
 {@link PersistentDataHolder} instance.

 @param key the key to look up in the custom tag map
 @param type the type the value must have and will be casted to
 @param <T> the generic type of the stored primitive
 @param <Z> the generic type of the eventually created complex object

 @return the value or {@code null} if no value was mapped under the given
 value

 @throws NullPointerException if the key to look up is null
 @throws NullPointerException if the type to cast the found object to is
 null
 @throws IllegalArgumentException if the value exists under the given key,
 but cannot be access using the given type
 @throws IllegalArgumentException if no suitable adapter will be found for
 the {@link
 PersistentDataType#getPrimitiveType()}]]>
      </doc>
    </method>
    <method name="getOrDefault" return="Z"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <param name="type" type="org.bukkit.persistence.PersistentDataType&lt;T, Z&gt;"/>
      <param name="defaultValue" type="Z"/>
      <doc>
      <![CDATA[Returns the metadata value that is stored on the
 {@link PersistentDataHolder} instance. If the value does not exist in the
 container, the default value provided is returned.

 @param key the key to look up in the custom tag map
 @param type the type the value must have and will be casted to
 @param defaultValue the default value to return if no value was found for
 the provided key
 @param <T> the generic type of the stored primitive
 @param <Z> the generic type of the eventually created complex object

 @return the value or the default value if no value was mapped under the
 given value

 @throws NullPointerException if the key to look up is null
 @throws NullPointerException if the type to cast the found object to is
 null
 @throws IllegalArgumentException if the value exists under the given key,
 but cannot be access using the given type
 @throws IllegalArgumentException if no suitable adapter will be found for
 the {@link PersistentDataType#getPrimitiveType()}]]>
      </doc>
    </method>
    <method name="getKeys" return="java.util.Set&lt;org.bukkit.NamespacedKey&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a set of keys present on this {@link PersistentDataContainer}
 instance.

 Any changes made to the returned set will not be reflected on the
 instance.

 @return the key set]]>
      </doc>
    </method>
    <method name="remove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.bukkit.NamespacedKey"/>
      <doc>
      <![CDATA[Removes a custom key from the {@link PersistentDataHolder} instance.

 @param key the key

 @throws NullPointerException if the provided key is null]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if the container instance is empty, therefore has no entries
 inside it.

 @return the boolean]]>
      </doc>
    </method>
    <method name="getAdapterContext" return="org.bukkit.persistence.PersistentDataAdapterContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the adapter context this tag container uses.

 @return the tag context]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface represents a map like object, capable of storing custom tags
 in it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.persistence.PersistentDataContainer -->
  <!-- start interface org.bukkit.persistence.PersistentDataHolder -->
  <interface name="PersistentDataHolder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPersistentDataContainer" return="org.bukkit.persistence.PersistentDataContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a custom tag container capable of storing tags on the object.

 Note that the tags stored on this container are all stored under their
 own custom namespace therefore modifying default tags using this
 {@link PersistentDataHolder} is impossible.

 @return the persistent metadata container]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The {@link PersistentDataHolder} interface defines an object that can store
 custom persistent meta data on it.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.persistence.PersistentDataHolder -->
  <!-- start interface org.bukkit.persistence.PersistentDataType -->
  <interface name="PersistentDataType"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPrimitiveType" return="java.lang.Class&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the primitive data type of this tag.

 @return the class]]>
      </doc>
    </method>
    <method name="getComplexType" return="java.lang.Class&lt;Z&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the complex object type the primitive value resembles.

 @return the class type]]>
      </doc>
    </method>
    <method name="toPrimitive" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="complex" type="Z"/>
      <param name="context" type="org.bukkit.persistence.PersistentDataAdapterContext"/>
      <doc>
      <![CDATA[Returns the primitive data that resembles the complex object passed to
 this method.

 @param complex the complex object instance
 @param context the context this operation is running in
 @return the primitive value]]>
      </doc>
    </method>
    <method name="fromPrimitive" return="Z"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="primitive" type="T"/>
      <param name="context" type="org.bukkit.persistence.PersistentDataAdapterContext"/>
      <doc>
      <![CDATA[Creates a complex object based of the passed primitive value

 @param primitive the primitive value
 @param context the context this operation is running in
 @return the complex object instance]]>
      </doc>
    </method>
    <field name="BYTE" type="org.bukkit.persistence.PersistentDataType&lt;java.lang.Byte, java.lang.Byte&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SHORT" type="org.bukkit.persistence.PersistentDataType&lt;java.lang.Short, java.lang.Short&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INTEGER" type="org.bukkit.persistence.PersistentDataType&lt;java.lang.Integer, java.lang.Integer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG" type="org.bukkit.persistence.PersistentDataType&lt;java.lang.Long, java.lang.Long&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOAT" type="org.bukkit.persistence.PersistentDataType&lt;java.lang.Float, java.lang.Float&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOUBLE" type="org.bukkit.persistence.PersistentDataType&lt;java.lang.Double, java.lang.Double&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRING" type="org.bukkit.persistence.PersistentDataType&lt;java.lang.String, java.lang.String&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BYTE_ARRAY" type="org.bukkit.persistence.PersistentDataType&lt;byte[], byte[]&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INTEGER_ARRAY" type="org.bukkit.persistence.PersistentDataType&lt;int[], int[]&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG_ARRAY" type="org.bukkit.persistence.PersistentDataType&lt;long[], long[]&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TAG_CONTAINER_ARRAY" type="org.bukkit.persistence.PersistentDataType&lt;org.bukkit.persistence.PersistentDataContainer[], org.bukkit.persistence.PersistentDataContainer[]&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TAG_CONTAINER" type="org.bukkit.persistence.PersistentDataType&lt;org.bukkit.persistence.PersistentDataContainer, org.bukkit.persistence.PersistentDataContainer&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class represents an enum with a generic content type. It defines the
 types a custom tag can have.
 <p>
 This interface can be used to create your own custom
 {@link PersistentDataType} with different complex types. This may be useful
 for the likes of a UUIDTagType:
 <pre>
 {@code
 public class UUIDTagType implements PersistentDataType<byte[], UUID> {

         {@literal @Override}
         public Class<byte[]> getPrimitiveType() {
             return byte[].class;
         }

         {@literal @Override}
         public Class<UUID> getComplexType() {
             return UUID.class;
         }

         {@literal @Override}
         public byte[] toPrimitive(UUID complex, PersistentDataAdapterContext context) {
             ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
             bb.putLong(complex.getMostSignificantBits());
             bb.putLong(complex.getLeastSignificantBits());
             return bb.array();
         }

         {@literal @Override}
         public UUID fromPrimitive(byte[] primitive, PersistentDataAdapterContext context) {
             ByteBuffer bb = ByteBuffer.wrap(primitive);
             long firstLong = bb.getLong();
             long secondLong = bb.getLong();
             return new UUID(firstLong, secondLong);
         }
     }}</pre>

 @param <T> the primary object type that is stored in the given tag
 @param <Z> the retrieved object type when applying this tag type]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.persistence.PersistentDataType -->
  <!-- start class org.bukkit.persistence.PersistentDataType.PrimitivePersistentDataType -->
  <class name="PersistentDataType.PrimitivePersistentDataType" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.persistence.PersistentDataType&lt;T, T&gt;"/>
    <method name="getPrimitiveType" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getComplexType" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toPrimitive" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="complex" type="T"/>
      <param name="context" type="org.bukkit.persistence.PersistentDataAdapterContext"/>
    </method>
    <method name="fromPrimitive" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="primitive" type="T"/>
      <param name="context" type="org.bukkit.persistence.PersistentDataAdapterContext"/>
    </method>
    <doc>
    <![CDATA[A default implementation that simply exists to pass on the retrieved or
 inserted value to the next layer.
 <p>
 This implementation does not add any kind of logic, but is used to
 provide default implementations for the primitive types.

 @param <T> the generic type of the primitive objects]]>
    </doc>
  </class>
  <!-- end class org.bukkit.persistence.PersistentDataType.PrimitivePersistentDataType -->
</package>
<package name="org.bukkit.plugin">
  <!-- start class org.bukkit.plugin.AuthorNagException -->
  <class name="AuthorNagException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthorNagException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new AuthorNagException based on the given Exception

 @param message Brief message explaining the cause of the exception]]>
      </doc>
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.plugin.AuthorNagException -->
  <!-- start interface org.bukkit.plugin.EventExecutor -->
  <interface name="EventExecutor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="execute"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="event" type="org.bukkit.event.Event"/>
      <exception name="EventException" type="org.bukkit.event.EventException"/>
    </method>
    <method name="create" return="org.bukkit.plugin.EventExecutor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.reflect.Method"/>
      <param name="eventClass" type="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;"/>
    </method>
    <field name="eventExecutorMap" type="java.util.concurrent.ConcurrentMap&lt;java.lang.reflect.Method, java.lang.Class&lt;? extends org.bukkit.plugin.EventExecutor&gt;&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Interface which defines the class for event call backs to plugins]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.EventExecutor -->
  <!-- start class org.bukkit.plugin.IllegalPluginAccessException -->
  <class name="IllegalPluginAccessException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IllegalPluginAccessException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of <code>IllegalPluginAccessException</code>
 without detail message.]]>
      </doc>
    </constructor>
    <constructor name="IllegalPluginAccessException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an instance of <code>IllegalPluginAccessException</code>
 with the specified detail message.

 @param msg the detail message.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Thrown when a plugin attempts to interact with the server when it is not
 enabled]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.IllegalPluginAccessException -->
  <!-- start class org.bukkit.plugin.InvalidDescriptionException -->
  <class name="InvalidDescriptionException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidDescriptionException" type="java.lang.Throwable, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new InvalidDescriptionException based on the given
 Exception

 @param message Brief message explaining the cause of the exception
 @param cause Exception that triggered this Exception]]>
      </doc>
    </constructor>
    <constructor name="InvalidDescriptionException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new InvalidDescriptionException based on the given
 Exception

 @param cause Exception that triggered this Exception]]>
      </doc>
    </constructor>
    <constructor name="InvalidDescriptionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new InvalidDescriptionException with the given message

 @param message Brief message explaining the cause of the exception]]>
      </doc>
    </constructor>
    <constructor name="InvalidDescriptionException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new InvalidDescriptionException]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Thrown when attempting to load an invalid PluginDescriptionFile]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.InvalidDescriptionException -->
  <!-- start class org.bukkit.plugin.InvalidPluginException -->
  <class name="InvalidPluginException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidPluginException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new InvalidPluginException based on the given Exception

 @param cause Exception that triggered this Exception]]>
      </doc>
    </constructor>
    <constructor name="InvalidPluginException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new InvalidPluginException]]>
      </doc>
    </constructor>
    <constructor name="InvalidPluginException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new InvalidPluginException with the specified detail
 message and cause.

 @param message the detail message (which is saved for later retrieval
     by the getMessage() method).
 @param cause the cause (which is saved for later retrieval by the
     getCause() method). (A null value is permitted, and indicates that
     the cause is nonexistent or unknown.)]]>
      </doc>
    </constructor>
    <constructor name="InvalidPluginException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new InvalidPluginException with the specified detail
 message

 @param message TThe detail message is saved for later retrieval by the
     getMessage() method.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Thrown when attempting to load an invalid Plugin file]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.InvalidPluginException -->
  <!-- start interface org.bukkit.plugin.Plugin -->
  <interface name="Plugin"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.command.TabExecutor"/>
    <method name="getDataFolder" return="java.io.File"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the folder that the plugin data's files are located in. The
 folder may not yet exist.

 @return The folder]]>
      </doc>
    </method>
    <method name="getDescription" return="org.bukkit.plugin.PluginDescriptionFile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the plugin.yaml file containing the details for this plugin

 @return Contents of the plugin.yaml file]]>
      </doc>
    </method>
    <method name="getConfig" return="org.bukkit.configuration.file.FileConfiguration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a {@link FileConfiguration} for this plugin, read through
 "config.yml"
 <p>
 If there is a default config.yml embedded in this plugin, it will be
 provided as a default for this Configuration.

 @return Plugin configuration]]>
      </doc>
    </method>
    <method name="getResource" return="java.io.InputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets an embedded resource in this plugin

 @param filename Filename of the resource
 @return File if found, otherwise null]]>
      </doc>
    </method>
    <method name="saveConfig"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Saves the {@link FileConfiguration} retrievable by {@link #getConfig()}.]]>
      </doc>
    </method>
    <method name="saveDefaultConfig"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Saves the raw contents of the default config.yml file to the location
 retrievable by {@link #getConfig()}.
 <p>
 This should fail silently if the config.yml already exists.]]>
      </doc>
    </method>
    <method name="saveResource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resourcePath" type="java.lang.String"/>
      <param name="replace" type="boolean"/>
      <doc>
      <![CDATA[Saves the raw contents of any resource embedded with a plugin's .jar
 file assuming it can be found using {@link #getResource(String)}.
 <p>
 The resource is saved into the plugin's data folder using the same
 hierarchy as the .jar file (subdirectories are preserved).

 @param resourcePath the embedded resource path to look for within the
     plugin's .jar file. (No preceding slash).
 @param replace if true, the embedded resource will overwrite the
     contents of an existing file.
 @throws IllegalArgumentException if the resource path is null, empty,
     or points to a nonexistent resource.]]>
      </doc>
    </method>
    <method name="reloadConfig"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Discards any data in {@link #getConfig()} and reloads from disk.]]>
      </doc>
    </method>
    <method name="getPluginLoader" return="org.bukkit.plugin.PluginLoader"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the associated PluginLoader responsible for this plugin

 @return PluginLoader that controls this plugin]]>
      </doc>
    </method>
    <method name="getServer" return="org.bukkit.Server"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Server instance currently running this plugin

 @return Server running this plugin]]>
      </doc>
    </method>
    <method name="isEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a value indicating whether or not this plugin is currently
 enabled

 @return true if this plugin is enabled, otherwise false]]>
      </doc>
    </method>
    <method name="onDisable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when this plugin is disabled]]>
      </doc>
    </method>
    <method name="onLoad"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called after a plugin is loaded but before it has been enabled.
 <p>
 When multiple plugins are loaded, the onLoad() for all plugins is
 called before any onEnable() is called.]]>
      </doc>
    </method>
    <method name="onEnable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when this plugin is enabled]]>
      </doc>
    </method>
    <method name="isNaggable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Simple boolean if we can still nag to the logs about things

 @return boolean whether we can nag]]>
      </doc>
    </method>
    <method name="setNaggable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="canNag" type="boolean"/>
      <doc>
      <![CDATA[Set naggable state

 @param canNag is this plugin still naggable?]]>
      </doc>
    </method>
    <method name="getDefaultWorldGenerator" return="org.bukkit.generator.ChunkGenerator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="worldName" type="java.lang.String"/>
      <param name="id" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a {@link ChunkGenerator} for use in a default world, as specified
 in the server configuration

 @param worldName Name of the world that this will be applied to
 @param id Unique ID, if any, that was specified to indicate which
     generator was requested
 @return ChunkGenerator for use in the default world generation]]>
      </doc>
    </method>
    <method name="getLogger" return="java.util.logging.Logger"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the plugin logger associated with this server's logger. The
 returned logger automatically tags all log messages with the plugin's
 name.

 @return Logger associated with this plugin]]>
      </doc>
    </method>
    <method name="getSLF4JLogger" return="org.slf4j.Logger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the plugin.
 <p>
 This should return the bare name of the plugin and should be used for
 comparison.

 @return name of the plugin]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Plugin
 <p>
 The use of {@link PluginBase} is recommended for actual Implementation]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.Plugin -->
  <!-- start interface org.bukkit.plugin.PluginAwareness -->
  <interface name="PluginAwareness"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Represents a concept that a plugin is aware of.
 <p>
 The internal representation may be singleton, or be a parameterized
 instance, but must be immutable.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.PluginAwareness -->
  <!-- start class org.bukkit.plugin.PluginAwareness.Flags -->
  <class name="PluginAwareness.Flags" extends="java.lang.Enum&lt;org.bukkit.plugin.PluginAwareness.Flags&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.PluginAwareness"/>
    <method name="values" return="org.bukkit.plugin.PluginAwareness.Flags[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.plugin.PluginAwareness.Flags"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Each entry here represents a particular plugin's awareness. These can
 be checked by using {@link PluginDescriptionFile#getAwareness()}.{@link
 Set#contains(Object) contains(flag)}.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.PluginAwareness.Flags -->
  <!-- start class org.bukkit.plugin.PluginBase -->
  <class name="PluginBase" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.Plugin"/>
    <constructor name="PluginBase"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a base {@link Plugin}
 <p>
 Extend this class if your plugin is not a {@link
 org.bukkit.plugin.java.JavaPlugin}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.PluginBase -->
  <!-- start class org.bukkit.plugin.PluginDescriptionFile -->
  <class name="PluginDescriptionFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginDescriptionFile" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InvalidDescriptionException" type="org.bukkit.plugin.InvalidDescriptionException"/>
    </constructor>
    <constructor name="PluginDescriptionFile" type="java.io.Reader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InvalidDescriptionException" type="org.bukkit.plugin.InvalidDescriptionException"/>
      <doc>
      <![CDATA[Loads a PluginDescriptionFile from the specified reader

 @param reader The reader
 @throws InvalidDescriptionException If the PluginDescriptionFile is
     invalid]]>
      </doc>
    </constructor>
    <constructor name="PluginDescriptionFile" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new PluginDescriptionFile with the given detailed

 @param pluginName Name of this plugin
 @param pluginVersion Version of this plugin
 @param mainClass Full location of the main class of this plugin]]>
      </doc>
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the name of the plugin. This name is a unique identifier for
 plugins.
 <ul>
 <li>Must consist of all alphanumeric characters, underscores, hyphon,
     and period (a-z,A-Z,0-9, _.-). Any other character will cause the
     plugin.yml to fail loading.
 <li>Used to determine the name of the plugin's data folder. Data
     folders are placed in the ./plugins/ directory by default, but this
     behavior should not be relied on. {@link Plugin#getDataFolder()}
     should be used to reference the data folder.
 <li>It is good practice to name your jar the same as this, for example
     'MyPlugin.jar'.
 <li>Case sensitive.
 <li>The is the token referenced in {@link #getDepend()}, {@link
     #getSoftDepend()}, and {@link #getLoadBefore()}.
 <li>Using spaces in the plugin's name is deprecated.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>name</code>.
 <p>
 Example:<blockquote><pre>name: MyPlugin</pre></blockquote>

 @return the name of the plugin]]>
      </doc>
    </method>
    <method name="getProvides" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the list of other plugin APIs which this plugin provides.
 These are usable for other plugins to depend on.
 <ul>
 <li>Must consist of all alphanumeric characters, underscores, hyphon,
     and period (a-z,A-Z,0-9, _.-). Any other character will cause the
     plugin.yml to fail loading.
 <li>A different plugin providing the same one or using it as their name
     will not result in the plugin to fail loading.
 <li>Case sensitive.
 <li>An entry of this list can be referenced in {@link #getDepend()},
    {@link #getSoftDepend()}, and {@link #getLoadBefore()}.
 <li><code>provides</code> must be in <a
     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
     format</a>.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>provides</code>.
 <p>
 Example:
 <blockquote><pre>provides:
- OtherPluginName
- OldPluginName</pre></blockquote>

 @return immutable list of the plugin APIs which this plugin provides]]>
      </doc>
    </method>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the version of the plugin.
 <ul>
 <li>Version is an arbitrary string, however the most common format is
     MajorRelease.MinorRelease.Build (eg: 1.4.1).
 <li>Typically you will increment this every time you release a new
     feature or bug fix.
 <li>Displayed when a user types <code>/version PluginName</code>
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>version</code>.
 <p>
 Example:<blockquote><pre>version: 1.4.1</pre></blockquote>

 @return the version of the plugin]]>
      </doc>
    </method>
    <method name="getMain" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the fully qualified name of the main class for a plugin. The
 format should follow the {@link ClassLoader#loadClass(String)} syntax
 to successfully be resolved at runtime. For most plugins, this is the
 class that extends {@link JavaPlugin}.
 <ul>
 <li>This must contain the full namespace including the class file
     itself.
 <li>If your namespace is <code>org.bukkit.plugin</code>, and your class
     file is called <code>MyPlugin</code> then this must be
     <code>org.bukkit.plugin.MyPlugin</code>
 <li>No plugin can use <code>org.bukkit.</code> as a base package for
     <b>any class</b>, including the main class.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>main</code>.
 <p>
 Example:
 <blockquote><pre>main: org.bukkit.plugin.MyPlugin</pre></blockquote>

 @return the fully qualified main class for the plugin]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives a human-friendly description of the functionality the plugin
 provides.
 <ul>
 <li>The description can have multiple lines.
 <li>Displayed when a user types <code>/version PluginName</code>
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>description</code>.
 <p>
 Example:
 <blockquote><pre>description: This plugin is so 31337. You can set yourself on fire.</pre></blockquote>

 @return description of this plugin, or null if not specified]]>
      </doc>
    </method>
    <method name="getLoad" return="org.bukkit.plugin.PluginLoadOrder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the phase of server startup that the plugin should be loaded.
 <ul>
 <li>Possible values are in {@link PluginLoadOrder}.
 <li>Defaults to {@link PluginLoadOrder#POSTWORLD}.
 <li>Certain caveats apply to each phase.
 <li>When different, {@link #getDepend()}, {@link #getSoftDepend()}, and
     {@link #getLoadBefore()} become relative in order loaded per-phase.
     If a plugin loads at <code>STARTUP</code>, but a dependency loads
     at <code>POSTWORLD</code>, the dependency will not be loaded before
     the plugin is loaded.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>load</code>.
 <p>
 Example:<blockquote><pre>load: STARTUP</pre></blockquote>

 @return the phase when the plugin should be loaded]]>
      </doc>
    </method>
    <method name="getAuthors" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the list of authors for the plugin.
 <ul>
 <li>Gives credit to the developer.
 <li>Used in some server error messages to provide helpful feedback on
     who to contact when an error occurs.
 <li>A SpigotMC forum handle or email address is recommended.
 <li>Is displayed when a user types <code>/version PluginName</code>
 <li><code>authors</code> must be in <a
     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
     format</a>.
 </ul>
 <p>
 In the plugin.yml, this has two entries, <code>author</code> and
 <code>authors</code>.
 <p>
 Single author example:
 <blockquote><pre>author: CaptainInflamo</pre></blockquote>
 Multiple author example:
 <blockquote><pre>authors: [Cogito, verrier, EvilSeph]</pre></blockquote>
 When both are specified, author will be the first entry in the list, so
 this example:
 <blockquote><pre>author: Grum
authors:
- feildmaster
- amaranth</pre></blockquote>
 Is equivilant to this example:
 <pre>authors: [Grum, feildmaster, aramanth]</pre>

 @return an immutable list of the plugin's authors]]>
      </doc>
    </method>
    <method name="getContributors" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the list of contributors for the plugin.
 <ul>
 <li>Gives credit to those that have contributed to the plugin, though
     not enough so to warrant authorship.
 <li>Unlike {@link #getAuthors()}, contributors will not be mentioned in
 server error messages as a means of contact.
 <li>A SpigotMC forum handle or email address is recommended.
 <li>Is displayed when a user types <code>/version PluginName</code>
 <li><code>contributors</code> must be in <a
     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
     format</a>.
 </ul>
 <p>
 Example:
 <blockquote><pre>authors: [Choco, md_5]</pre></blockquote>

 @return an immutable list of the plugin's contributors]]>
      </doc>
    </method>
    <method name="getWebsite" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the plugin's or plugin's author's website.
 <ul>
 <li>A link to the Curse page that includes documentation and downloads
     is highly recommended.
 <li>Displayed when a user types <code>/version PluginName</code>
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>website</code>.
 <p>
 Example:
 <blockquote><pre>website: http://www.curse.com/server-mods/minecraft/myplugin</pre></blockquote>

 @return description of this plugin, or null if not specified]]>
      </doc>
    </method>
    <method name="getDepend" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives a list of other plugins that the plugin requires.
 <ul>
 <li>Use the value in the {@link #getName()} of the target plugin to
     specify the dependency.
 <li>If any plugin listed here is not found, your plugin will fail to
     load at startup.
 <li>If multiple plugins list each other in <code>depend</code>,
     creating a network with no individual plugin does not list another
     plugin in the <a
     href=https://en.wikipedia.org/wiki/Circular_dependency>network</a>,
     all plugins in that network will fail.
 <li><code>depend</code> must be in <a
     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
     format</a>.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>depend</code>.
 <p>
 Example:
 <blockquote><pre>depend:
- OnePlugin
- AnotherPlugin</pre></blockquote>

 @return immutable list of the plugin's dependencies]]>
      </doc>
    </method>
    <method name="getSoftDepend" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives a list of other plugins that the plugin requires for full
 functionality. The {@link PluginManager} will make best effort to treat
 all entries here as if they were a {@link #getDepend() dependency}, but
 will never fail because of one of these entries.
 <ul>
 <li>Use the value in the {@link #getName()} of the target plugin to
     specify the dependency.
 <li>When an unresolvable plugin is listed, it will be ignored and does
     not affect load order.
 <li>When a circular dependency occurs (a network of plugins depending
     or soft-dependending each other), it will arbitrarily choose a
     plugin that can be resolved when ignoring soft-dependencies.
 <li><code>softdepend</code> must be in <a
     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
     format</a>.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>softdepend</code>.
 <p>
 Example:
 <blockquote><pre>softdepend: [OnePlugin, AnotherPlugin]</pre></blockquote>

 @return immutable list of the plugin's preferred dependencies]]>
      </doc>
    </method>
    <method name="getLoadBefore" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the list of plugins that should consider this plugin a
 soft-dependency.
 <ul>
 <li>Use the value in the {@link #getName()} of the target plugin to
     specify the dependency.
 <li>The plugin should load before any other plugins listed here.
 <li>Specifying another plugin here is strictly equivalent to having the
     specified plugin's {@link #getSoftDepend()} include {@link
     #getName() this plugin}.
 <li><code>loadbefore</code> must be in <a
     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
     format</a>.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>loadbefore</code>.
 <p>
 Example:
 <blockquote><pre>loadbefore:
- OnePlugin
- AnotherPlugin</pre></blockquote>

 @return immutable list of plugins that should consider this plugin a
     soft-dependency]]>
      </doc>
    </method>
    <method name="getPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the token to prefix plugin-specific logging messages with.
 <ul>
 <li>This includes all messages using {@link Plugin#getLogger()}.
 <li>If not specified, the server uses the plugin's {@link #getName()
     name}.
 <li>This should clearly indicate what plugin is being logged.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>prefix</code>.
 <p>
 Example:<blockquote><pre>prefix: ex-why-zee</pre></blockquote>

 @return the prefixed logging token, or null if not specified]]>
      </doc>
    </method>
    <method name="getCommands" return="java.util.Map&lt;java.lang.String, java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the map of command-name to command-properties. Each entry in this
 map corresponds to a single command and the respective values are the
 properties of the command. Each property, <i>with the exception of
 aliases</i>, can be defined at runtime using methods in {@link
 PluginCommand} and are defined here only as a convenience.
 <table border=1>
 <caption>The command section's description</caption>
 <tr>
     <th>Node</th>
     <th>Method</th>
     <th>Type</th>
     <th>Description</th>
     <th>Example</th>
 </tr><tr>
     <td><code>description</code></td>
     <td>{@link PluginCommand#setDescription(String)}</td>
     <td>String</td>
     <td>A user-friendly description for a command. It is useful for
         documentation purposes as well as in-game help.</td>
     <td><blockquote><pre>description: Set yourself on fire</pre></blockquote></td>
 </tr><tr>
     <td><code>aliases</code></td>
     <td>{@link PluginCommand#setAliases(List)}</td>
     <td>String or <a
         href="http://en.wikipedia.org/wiki/YAML#Lists">List</a> of
         strings</td>
     <td>Alternative command names, with special usefulness for commands
         that are already registered. <i>Aliases are not effective when
         defined at runtime,</i> so the plugin description file is the
         only way to have them properly defined.
         <p>
         Note: Command aliases may not have a colon in them.</td>
     <td>Single alias format:
         <blockquote><pre>aliases: combust_me</pre></blockquote> or
         multiple alias format:
         <blockquote><pre>aliases: [combust_me, combustMe]</pre></blockquote></td>
 </tr><tr>
     <td><code>permission</code></td>
     <td>{@link PluginCommand#setPermission(String)}</td>
     <td>String</td>
     <td>The name of the {@link Permission} required to use the command.
         A user without the permission will receive the specified
         message (see {@linkplain
         PluginCommand#setPermissionMessage(String) below}), or a
         standard one if no specific message is defined. Without the
         permission node, no {@link
         PluginCommand#setExecutor(CommandExecutor) CommandExecutor} or
         {@link PluginCommand#setTabCompleter(TabCompleter)} will be called.</td>
     <td><blockquote><pre>permission: inferno.flagrate</pre></blockquote></td>
 </tr><tr>
     <td><code>permission-message</code></td>
     <td>{@link PluginCommand#setPermissionMessage(String)}</td>
     <td>String</td>
     <td><ul>
         <li>Displayed to a player that attempts to use a command, but
             does not have the required permission. See {@link
             PluginCommand#getPermission() above}.
         <li>&lt;permission&gt; is a macro that is replaced with the
             permission node required to use the command.
         <li>Using empty quotes is a valid way to indicate nothing
             should be displayed to a player.
         </ul></td>
     <td><blockquote><pre>permission-message: You do not have /&lt;permission&gt;</pre></blockquote></td>
 </tr><tr>
     <td><code>usage</code></td>
     <td>{@link PluginCommand#setUsage(String)}</td>
     <td>String</td>
     <td>This message is displayed to a player when the {@link
         PluginCommand#setExecutor(CommandExecutor)} {@linkplain
         CommandExecutor#onCommand(CommandSender, Command, String, String[]) returns false}.
         &lt;command&gt; is a macro that is replaced the command issued.</td>
     <td><blockquote><pre>usage: Syntax error! Perhaps you meant /&lt;command&gt; PlayerName?</pre></blockquote>
         It is worth noting that to use a colon in a yaml, like
         <code>`usage: Usage: /god [player]'</code>, you need to
         <a href="http://yaml.org/spec/current.html#id2503232">surround
         the message with double-quote</a>:
         <blockquote><pre>usage: "Usage: /god [player]"</pre></blockquote></td>
 </tr>
 </table>
 The commands are structured as a hiearchy of <a
 href="http://yaml.org/spec/current.html#id2502325">nested mappings</a>.
 The primary (top-level, no intendentation) node is
 `<code>commands</code>', while each individual command name is
 indented, indicating it maps to some value (in our case, the
 properties of the table above).
 <p>
 Here is an example bringing together the piecemeal examples above, as
 well as few more definitions:<blockquote><pre>
commands:
  flagrate:
    description: Set yourself on fire.
    aliases: [combust_me, combustMe]
    permission: inferno.flagrate
    permission-message: You do not have /&lt;permission&gt;
    usage: Syntax error! Perhaps you meant /&lt;command&gt; PlayerName?
  burningdeaths:
    description: List how many times you have died by fire.
    aliases:
    - burning_deaths
    - burningDeaths
    permission: inferno.burningdeaths
    usage: |
      /&lt;command&gt; [player]
      Example: /&lt;command&gt; - see how many times you have burned to death
      Example: /&lt;command&gt; CaptainIce - see how many times CaptainIce has burned to death
  # The next command has no description, aliases, etc. defined, but is still valid
  # Having an empty declaration is useful for defining the description, permission, and messages from a configuration dynamically
  apocalypse:
</pre></blockquote>
 Note: Command names may not have a colon in their name.

 @return the commands this plugin will register]]>
      </doc>
    </method>
    <method name="getPermissions" return="java.util.List&lt;org.bukkit.permissions.Permission&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the list of permissions the plugin will register at runtime,
 immediately proceding enabling. The format for defining permissions is
 a map from permission name to properties. To represent a map without
 any specific property, empty <a
 href="http://yaml.org/spec/current.html#id2502702">curly-braces</a> (
 <code>&#123;&#125;</code> ) may be used (as a null value is not
 accepted, unlike the {@link #getCommands() commands} above).
 <p>
 A list of optional properties for permissions:
 <table border=1>
 <caption>The permission section's description</caption>
 <tr>
     <th>Node</th>
     <th>Description</th>
     <th>Example</th>
 </tr><tr>
     <td><code>description</code></td>
     <td>Plaintext (user-friendly) description of what the permission
         is for.</td>
     <td><blockquote><pre>description: Allows you to set yourself on fire</pre></blockquote></td>
 </tr><tr>
     <td><code>default</code></td>
     <td>The default state for the permission, as defined by {@link
         Permission#getDefault()}. If not defined, it will be set to
         the value of {@link PluginDescriptionFile#getPermissionDefault()}.
         <p>
         For reference:<ul>
         <li><code>true</code> - Represents a positive assignment to
             {@link Permissible permissibles}.
         <li><code>false</code> - Represents no assignment to {@link
             Permissible permissibles}.
         <li><code>op</code> - Represents a positive assignment to
             {@link Permissible#isOp() operator permissibles}.
         <li><code>notop</code> - Represents a positive assignment to
             {@link Permissible#isOp() non-operator permissibiles}.
         </ul></td>
     <td><blockquote><pre>default: true</pre></blockquote></td>
 </tr><tr>
     <td><code>children</code></td>
     <td>Allows other permissions to be set as a {@linkplain
         Permission#getChildren() relation} to the parent permission.
         When a parent permissions is assigned, child permissions are
         respectively assigned as well.
         <ul>
         <li>When a parent permission is assigned negatively, child
             permissions are assigned based on an inversion of their
             association.
         <li>When a parent permission is assigned positively, child
             permissions are assigned based on their association.
         </ul>
         <p>
         Child permissions may be defined in a number of ways:<ul>
         <li>Children may be defined as a <a
             href="http://en.wikipedia.org/wiki/YAML#Lists">list</a> of
             names. Using a list will treat all children associated
             positively to their parent.
         <li>Children may be defined as a map. Each permission name maps
             to either a boolean (representing the association), or a
             nested permission definition (just as another permission).
             Using a nested definition treats the child as a positive
             association.
         <li>A nested permission definition must be a map of these same
             properties. To define a valid nested permission without
             defining any specific property, empty curly-braces (
             <code>&#123;&#125;</code> ) must be used.
          <li>A nested permission may carry it's own nested permissions
              as children, as they may also have nested permissions, and
              so forth. There is no direct limit to how deep the
              permission tree is defined.
         </ul></td>
     <td>As a list:
         <blockquote><pre>children: [inferno.flagrate, inferno.burningdeaths]</pre></blockquote>
         Or as a mapping:
         <blockquote><pre>children:
  inferno.flagrate: true
  inferno.burningdeaths: true</pre></blockquote>
         An additional example showing basic nested values can be seen
         <a href="doc-files/permissions-example_plugin.yml">here</a>.
         </td>
 </tr>
 </table>
 The permissions are structured as a hiearchy of <a
 href="http://yaml.org/spec/current.html#id2502325">nested mappings</a>.
 The primary (top-level, no intendentation) node is
 `<code>permissions</code>', while each individual permission name is
 indented, indicating it maps to some value (in our case, the
 properties of the table above).
 <p>
 Here is an example using some of the properties:<blockquote><pre>
permissions:
  inferno.*:
    description: Gives access to all Inferno commands
    children:
      inferno.flagrate: true
      inferno.burningdeaths: true
  inferno.flagate:
    description: Allows you to ignite yourself
    default: true
  inferno.burningdeaths:
    description: Allows you to see how many times you have burned to death
    default: true
</pre></blockquote>
 Another example, with nested definitions, can be found <a
 href="doc-files/permissions-example_plugin.yml">here</a>.

 @return the permissions this plugin will register]]>
      </doc>
    </method>
    <method name="getPermissionDefault" return="org.bukkit.permissions.PermissionDefault"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the default {@link Permission#getDefault() default} state of
 {@link #getPermissions() permissions} registered for the plugin.
 <ul>
 <li>If not specified, it will be {@link PermissionDefault#OP}.
 <li>It is matched using {@link PermissionDefault#getByName(String)}
 <li>It only affects permissions that do not define the
     <code>default</code> node.
 <li>It may be any value in {@link PermissionDefault}.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>default-permission</code>.
 <p>
 Example:<blockquote><pre>default-permission: NOT_OP</pre></blockquote>

 @return the default value for the plugin's permissions]]>
      </doc>
    </method>
    <method name="getAwareness" return="java.util.Set&lt;org.bukkit.plugin.PluginAwareness&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives a set of every {@link PluginAwareness} for a plugin. An awareness
 dictates something that a plugin developer acknowledges when the plugin
 is compiled. Some implementions may define extra awarenesses that are
 not included in the API. Any unrecognized
 awareness (one unsupported or in a future version) will cause a dummy
 object to be created instead of failing.

 <ul>
 <li>Currently only supports the enumerated values in {@link
     PluginAwareness.Flags}.
 <li>Each awareness starts the identifier with bang-at
     (<code>!@</code>).
 <li>Unrecognized (future / unimplemented) entries are quietly replaced
     by a generic object that implements PluginAwareness.
 <li>A type of awareness must be defined by the runtime and acknowledged
     by the API, effectively discluding any derived type from any
     plugin's classpath.
 <li><code>awareness</code> must be in <a
     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
     format</a>.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>awareness</code>.
 <p>
 Example:<blockquote><pre>awareness:
- !@UTF8</pre></blockquote>
 <p>
 <b>Note:</b> Although unknown versions of some future awareness are
 gracefully substituted, previous versions of Bukkit (ones prior to the
 first implementation of awareness) will fail to load a plugin that
 defines any awareness.

 @return a set containing every awareness for the plugin]]>
      </doc>
    </method>
    <method name="getFullName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of a plugin, including the version. This method is
 provided for convenience; it uses the {@link #getName()} and {@link
 #getVersion()} entries.

 @return a descriptive name of the plugin and respective version]]>
      </doc>
    </method>
    <method name="getAPIVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gives the API version which this plugin is designed to support. No
 specific format is guaranteed.
 <ul>
 <li>Refer to release notes for supported API versions.
 </ul>
 <p>
 In the plugin.yml, this entry is named <code>api-version</code>.
 <p>
 Example:<blockquote><pre>api-version: 1.13</pre></blockquote>

 @return the version of the plugin]]>
      </doc>
    </method>
    <method name="getClassLoaderOf" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="unused">
      <doc>
      <![CDATA[@return unused
 @deprecated unused]]>
      </doc>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <doc>
      <![CDATA[Saves this PluginDescriptionFile to the given writer

 @param writer Writer to output this file to]]>
      </doc>
    </method>
    <method name="getRawName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Internal use">
      <doc>
      <![CDATA[@return internal use
 @deprecated Internal use]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This type is the runtime-container for the information in the plugin.yml.
 All plugins must have a respective plugin.yml. For plugins written in java
 using the standard plugin loader, this file must be in the root of the jar
 file.
 <p>
 When Bukkit loads a plugin, it needs to know some basic information about
 it. It reads this information from a YAML file, 'plugin.yml'. This file
 consists of a set of attributes, each defined on a new line and with no
 indentation.
 <p>
 Every (almost* every) method corresponds with a specific entry in the
 plugin.yml. These are the <b>required</b> entries for every plugin.yml:
 <ul>
 <li>{@link #getName()} - <code>name</code>
 <li>{@link #getVersion()} - <code>version</code>
 <li>{@link #getMain()} - <code>main</code>
 </ul>
 <p>
 Failing to include any of these items will throw an exception and cause the
 server to ignore your plugin.
 <p>
 This is a list of the possible yaml keys, with specific details included in
 the respective method documentations:
 <table border=1>
 <caption>The description of the plugin.yml layout</caption>
 <tr>
     <th>Node</th>
     <th>Method</th>
     <th>Summary</th>
 </tr><tr>
     <td><code>name</code></td>
     <td>{@link #getName()}</td>
     <td>The unique name of plugin</td>
 </tr><tr>
     <td><code>provides</code></td>
     <td>{@link #getProvides()}</td>
     <td>The plugin APIs which this plugin provides</td>
 </tr><tr>
     <td><code>version</code></td>
     <td>{@link #getVersion()}</td>
     <td>A plugin revision identifier</td>
 </tr><tr>
     <td><code>main</code></td>
     <td>{@link #getMain()}</td>
     <td>The plugin's initial class file</td>
 </tr><tr>
     <td><code>author</code><br><code>authors</code></td>
     <td>{@link #getAuthors()}</td>
     <td>The plugin authors</td>
 </tr><tr>
     <td><code>contributors</code></td>
     <td>{@link #getContributors()}</td>
     <td>The plugin contributors</td>
 </tr><tr>
     <td><code>description</code></td>
     <td>{@link #getDescription()}</td>
     <td>Human readable plugin summary</td>
 </tr><tr>
     <td><code>website</code></td>
     <td>{@link #getWebsite()}</td>
     <td>The URL to the plugin's site</td>
 </tr><tr>
     <td><code>prefix</code></td>
     <td>{@link #getPrefix()}</td>
     <td>The token to prefix plugin log entries</td>
 </tr><tr>
     <td><code>load</code></td>
     <td>{@link #getLoad()}</td>
     <td>The phase of server-startup this plugin will load during</td>
 </tr><tr>
     <td><code>depend</code></td>
     <td>{@link #getDepend()}</td>
     <td>Other required plugins</td>
 </tr><tr>
     <td><code>softdepend</code></td>
     <td>{@link #getSoftDepend()}</td>
     <td>Other plugins that add functionality</td>
 </tr><tr>
     <td><code>loadbefore</code></td>
     <td>{@link #getLoadBefore()}</td>
     <td>The inverse softdepend</td>
 </tr><tr>
     <td><code>commands</code></td>
     <td>{@link #getCommands()}</td>
     <td>The commands the plugin will register</td>
 </tr><tr>
     <td><code>permissions</code></td>
     <td>{@link #getPermissions()}</td>
     <td>The permissions the plugin will register</td>
 </tr><tr>
     <td><code>default-permission</code></td>
     <td>{@link #getPermissionDefault()}</td>
     <td>The default {@link Permission#getDefault() default} permission
         state for defined {@link #getPermissions() permissions} the plugin
         will register</td>
 </tr><tr>
     <td><code>awareness</code></td>
     <td>{@link #getAwareness()}</td>
     <td>The concepts that the plugin acknowledges</td>
 </tr><tr>
     <td><code>api-version</code></td>
     <td>{@link #getAPIVersion()}</td>
     <td>The API version which this plugin was programmed against</td>
 </tr>
 </table>
 <p>
 A plugin.yml example:<blockquote><pre>
name: Inferno
provides: [Hell]
version: 1.4.1
description: This plugin is so 31337. You can set yourself on fire.
# We could place every author in the authors list, but chose not to for illustrative purposes
# Also, having an author distinguishes that person as the project lead, and ensures their
# name is displayed first
author: CaptainInflamo
authors: [Cogito, verrier, EvilSeph]
contributors: [Choco, md_5]
website: http://www.curse.com/server-mods/minecraft/myplugin

main: com.captaininflamo.bukkit.inferno.Inferno
depend: [NewFire, FlameWire]
api-version: 1.13

commands:
  flagrate:
    description: Set yourself on fire.
    aliases: [combust_me, combustMe]
    permission: inferno.flagrate
    usage: Syntax error! Simply type /&lt;command&gt; to ignite yourself.
  burningdeaths:
    description: List how many times you have died by fire.
    aliases: [burning_deaths, burningDeaths]
    permission: inferno.burningdeaths
    usage: |
      /&lt;command&gt; [player]
      Example: /&lt;command&gt; - see how many times you have burned to death
      Example: /&lt;command&gt; CaptainIce - see how many times CaptainIce has burned to death

permissions:
  inferno.*:
    description: Gives access to all Inferno commands
    children:
      inferno.flagrate: true
      inferno.burningdeaths: true
      inferno.burningdeaths.others: true
  inferno.flagrate:
    description: Allows you to ignite yourself
    default: true
  inferno.burningdeaths:
    description: Allows you to see how many times you have burned to death
    default: true
  inferno.burningdeaths.others:
    description: Allows you to see how many times others have burned to death
    default: op
    children:
      inferno.burningdeaths: true
</pre></blockquote>]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.PluginDescriptionFile -->
  <!-- start interface org.bukkit.plugin.PluginLoader -->
  <interface name="PluginLoader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="loadPlugin" return="org.bukkit.plugin.Plugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="InvalidPluginException" type="org.bukkit.plugin.InvalidPluginException"/>
      <exception name="UnknownDependencyException" type="org.bukkit.plugin.UnknownDependencyException"/>
      <doc>
      <![CDATA[Loads the plugin contained in the specified file

 @param file File to attempt to load
 @return Plugin that was contained in the specified file, or null if
     unsuccessful
 @throws InvalidPluginException Thrown when the specified file is not a
     plugin
 @throws UnknownDependencyException If a required dependency could not
     be found]]>
      </doc>
    </method>
    <method name="getPluginDescription" return="org.bukkit.plugin.PluginDescriptionFile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="InvalidDescriptionException" type="org.bukkit.plugin.InvalidDescriptionException"/>
      <doc>
      <![CDATA[Loads a PluginDescriptionFile from the specified file

 @param file File to attempt to load from
 @return A new PluginDescriptionFile loaded from the plugin.yml in the
     specified file
 @throws InvalidDescriptionException If the plugin description file
     could not be created]]>
      </doc>
    </method>
    <method name="getPluginFileFilters" return="java.util.regex.Pattern[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of all filename filters expected by this PluginLoader

 @return The filters]]>
      </doc>
    </method>
    <method name="createRegisteredListeners" return="java.util.Map&lt;java.lang.Class&lt;? extends org.bukkit.event.Event&gt;, java.util.Set&lt;org.bukkit.plugin.RegisteredListener&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Creates and returns registered listeners for the event classes used in
 this listener

 @param listener The object that will handle the eventual call back
 @param plugin The plugin to use when creating registered listeners
 @return The registered listeners.]]>
      </doc>
    </method>
    <method name="enablePlugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Enables the specified plugin
 <p>
 Attempting to enable a plugin that is already enabled will have no
 effect

 @param plugin Plugin to enable]]>
      </doc>
    </method>
    <method name="disablePlugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Disables the specified plugin
 <p>
 Attempting to disable a plugin that is not enabled will have no effect

 @param plugin Plugin to disable]]>
      </doc>
    </method>
    <method name="disablePlugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="closeClassloader" type="boolean"/>
      <doc>
      <![CDATA[Disables the specified plugin
 <p>
 Attempting to disable a plugin that is not enabled will have no effect

 @param plugin Plugin to disable
 @param closeClassloader if the classloader for the Plugin should be closed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a plugin loader, which handles direct access to specific types
 of plugins]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.PluginLoader -->
  <!-- start class org.bukkit.plugin.PluginLoadOrder -->
  <class name="PluginLoadOrder" extends="java.lang.Enum&lt;org.bukkit.plugin.PluginLoadOrder&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.plugin.PluginLoadOrder[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.plugin.PluginLoadOrder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the order in which a plugin should be initialized and enabled]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.PluginLoadOrder -->
  <!-- start class org.bukkit.plugin.PluginLogger -->
  <class name="PluginLogger" extends="java.util.logging.Logger"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginLogger" type="org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new PluginLogger that extracts the name from a plugin.

 @param context A reference to the plugin]]>
      </doc>
    </constructor>
    <method name="log"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="logRecord" type="java.util.logging.LogRecord"/>
    </method>
    <doc>
    <![CDATA[The PluginLogger class is a modified {@link Logger} that prepends all
 logging calls with the name of the plugin doing the logging. The API for
 PluginLogger is exactly the same as {@link Logger}.

 @see Logger]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.PluginLogger -->
  <!-- start interface org.bukkit.plugin.PluginManager -->
  <interface name="PluginManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="registerInterface"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="java.lang.Class&lt;? extends org.bukkit.plugin.PluginLoader&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Registers the specified plugin loader

 @param loader Class name of the PluginLoader to register
 @throws IllegalArgumentException Thrown when the given Class is not a
     valid PluginLoader]]>
      </doc>
    </method>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the given plugin is loaded and returns it when applicable
 <p>
 Please note that the name of the plugin is case-sensitive

 @param name Name of the plugin to check
 @return Plugin if it exists, otherwise null]]>
      </doc>
    </method>
    <method name="getPlugins" return="org.bukkit.plugin.Plugin[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a list of all currently loaded plugins

 @return Array of Plugins]]>
      </doc>
    </method>
    <method name="isPluginEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the given plugin is enabled or not
 <p>
 Please note that the name of the plugin is case-sensitive.

 @param name Name of the plugin to check
 @return true if the plugin is enabled, otherwise false]]>
      </doc>
    </method>
    <method name="isPluginEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Checks if the given plugin is enabled or not

 @param plugin Plugin to check
 @return true if the plugin is enabled, otherwise false]]>
      </doc>
    </method>
    <method name="loadPlugin" return="org.bukkit.plugin.Plugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="InvalidPluginException" type="org.bukkit.plugin.InvalidPluginException"/>
      <exception name="InvalidDescriptionException" type="org.bukkit.plugin.InvalidDescriptionException"/>
      <exception name="UnknownDependencyException" type="org.bukkit.plugin.UnknownDependencyException"/>
      <doc>
      <![CDATA[Loads the plugin in the specified file
 <p>
 File must be valid according to the current enabled Plugin interfaces

 @param file File containing the plugin to load
 @return The Plugin loaded, or null if it was invalid
 @throws InvalidPluginException Thrown when the specified file is not a
     valid plugin
 @throws InvalidDescriptionException Thrown when the specified file
     contains an invalid description
 @throws UnknownDependencyException If a required dependency could not
     be resolved]]>
      </doc>
    </method>
    <method name="loadPlugins" return="org.bukkit.plugin.Plugin[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="directory" type="java.io.File"/>
      <doc>
      <![CDATA[Loads the plugins contained within the specified directory

 @param directory Directory to check for plugins
 @return A list of all plugins loaded]]>
      </doc>
    </method>
    <method name="disablePlugins"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Disables all the loaded plugins]]>
      </doc>
    </method>
    <method name="clearPlugins"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Disables and removes all plugins]]>
      </doc>
    </method>
    <method name="callEvent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.bukkit.event.Event"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Calls an event with the given details

 @param event Event details
 @throws IllegalStateException Thrown when an asynchronous event is
     fired from synchronous code.
     <p>
     <i>Note: This is best-effort basis, and should not be used to test
     synchronized state. This is an indicator for flawed flow logic.</i>]]>
      </doc>
    </method>
    <method name="registerEvents"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Registers all the events in the given listener class

 @param listener Listener to register
 @param plugin Plugin to register]]>
      </doc>
    </method>
    <method name="registerEvent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;"/>
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="priority" type="org.bukkit.event.EventPriority"/>
      <param name="executor" type="org.bukkit.plugin.EventExecutor"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Registers the specified executor to the given event class

 @param event Event type to register
 @param listener Listener to register
 @param priority Priority to register this event at
 @param executor EventExecutor to register
 @param plugin Plugin to register]]>
      </doc>
    </method>
    <method name="registerEvent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;"/>
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="priority" type="org.bukkit.event.EventPriority"/>
      <param name="executor" type="org.bukkit.plugin.EventExecutor"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="ignoreCancelled" type="boolean"/>
      <doc>
      <![CDATA[Registers the specified executor to the given event class

 @param event Event type to register
 @param listener Listener to register
 @param priority Priority to register this event at
 @param executor EventExecutor to register
 @param plugin Plugin to register
 @param ignoreCancelled Whether to pass cancelled events or not]]>
      </doc>
    </method>
    <method name="enablePlugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Enables the specified plugin
 <p>
 Attempting to enable a plugin that is already enabled will have no
 effect

 @param plugin Plugin to enable]]>
      </doc>
    </method>
    <method name="disablePlugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Disables the specified plugin
 <p>
 Attempting to disable a plugin that is not enabled will have no effect

 @param plugin Plugin to disable]]>
      </doc>
    </method>
    <method name="disablePlugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="closeClassloader" type="boolean"/>
      <doc>
      <![CDATA[Disables the specified plugin
 <p>
 Attempting to disable a plugin that is not enabled will have no effect

 @param plugin Plugin to disable
 @param closeClassloader if the classloader for the Plugin should be closed]]>
      </doc>
    </method>
    <method name="getPermission" return="org.bukkit.permissions.Permission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a {@link Permission} from its fully qualified name

 @param name Name of the permission
 @return Permission, or null if none]]>
      </doc>
    </method>
    <method name="addPermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <doc>
      <![CDATA[Adds a {@link Permission} to this plugin manager.
 <p>
 If a permission is already defined with the given name of the new
 permission, an exception will be thrown.

 @param perm Permission to add
 @throws IllegalArgumentException Thrown when a permission with the same
     name already exists]]>
      </doc>
    </method>
    <method name="removePermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <doc>
      <![CDATA[Removes a {@link Permission} registration from this plugin manager.
 <p>
 If the specified permission does not exist in this plugin manager,
 nothing will happen.
 <p>
 Removing a permission registration will <b>not</b> remove the
 permission from any {@link Permissible}s that have it.

 @param perm Permission to remove]]>
      </doc>
    </method>
    <method name="removePermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes a {@link Permission} registration from this plugin manager.
 <p>
 If the specified permission does not exist in this plugin manager,
 nothing will happen.
 <p>
 Removing a permission registration will <b>not</b> remove the
 permission from any {@link Permissible}s that have it.

 @param name Permission to remove]]>
      </doc>
    </method>
    <method name="getDefaultPermissions" return="java.util.Set&lt;org.bukkit.permissions.Permission&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
      <doc>
      <![CDATA[Gets the default permissions for the given op status

 @param op Which set of default permissions to get
 @return The default permissions]]>
      </doc>
    </method>
    <method name="recalculatePermissionDefaults"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <doc>
      <![CDATA[Recalculates the defaults for the given {@link Permission}.
 <p>
 This will have no effect if the specified permission is not registered
 here.

 @param perm Permission to recalculate]]>
      </doc>
    </method>
    <method name="subscribeToPermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.lang.String"/>
      <param name="permissible" type="org.bukkit.permissions.Permissible"/>
      <doc>
      <![CDATA[Subscribes the given Permissible for information about the requested
 Permission, by name.
 <p>
 If the specified Permission changes in any form, the Permissible will
 be asked to recalculate.

 @param permission Permission to subscribe to
 @param permissible Permissible subscribing]]>
      </doc>
    </method>
    <method name="unsubscribeFromPermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.lang.String"/>
      <param name="permissible" type="org.bukkit.permissions.Permissible"/>
      <doc>
      <![CDATA[Unsubscribes the given Permissible for information about the requested
 Permission, by name.

 @param permission Permission to unsubscribe from
 @param permissible Permissible subscribing]]>
      </doc>
    </method>
    <method name="getPermissionSubscriptions" return="java.util.Set&lt;org.bukkit.permissions.Permissible&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a set containing all subscribed {@link Permissible}s to the given
 permission, by name

 @param permission Permission to query for
 @return Set containing all subscribed permissions]]>
      </doc>
    </method>
    <method name="subscribeToDefaultPerms"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
      <param name="permissible" type="org.bukkit.permissions.Permissible"/>
      <doc>
      <![CDATA[Subscribes to the given Default permissions by operator status
 <p>
 If the specified defaults change in any form, the Permissible will be
 asked to recalculate.

 @param op Default list to subscribe to
 @param permissible Permissible subscribing]]>
      </doc>
    </method>
    <method name="unsubscribeFromDefaultPerms"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
      <param name="permissible" type="org.bukkit.permissions.Permissible"/>
      <doc>
      <![CDATA[Unsubscribes from the given Default permissions by operator status

 @param op Default list to unsubscribe from
 @param permissible Permissible subscribing]]>
      </doc>
    </method>
    <method name="getDefaultPermSubscriptions" return="java.util.Set&lt;org.bukkit.permissions.Permissible&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
      <doc>
      <![CDATA[Gets a set containing all subscribed {@link Permissible}s to the given
 default list, by op status

 @param op Default list to query for
 @return Set containing all subscribed permissions]]>
      </doc>
    </method>
    <method name="getPermissions" return="java.util.Set&lt;org.bukkit.permissions.Permission&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set of all registered permissions.
 <p>
 This set is a copy and will not be modified live.

 @return Set containing all current registered permissions]]>
      </doc>
    </method>
    <method name="useTimings" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether or not timing code should be used for event calls

 @return True if event timings are to be used]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Handles all plugin management from the Server]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.PluginManager -->
  <!-- start class org.bukkit.plugin.RegisteredListener -->
  <class name="RegisteredListener" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RegisteredListener" type="org.bukkit.event.Listener, org.bukkit.plugin.EventExecutor, org.bukkit.event.EventPriority, org.bukkit.plugin.Plugin, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getListener" return="org.bukkit.event.Listener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the listener for this registration

 @return Registered Listener]]>
      </doc>
    </method>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin for this registration

 @return Registered Plugin]]>
      </doc>
    </method>
    <method name="getPriority" return="org.bukkit.event.EventPriority"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the priority for this registration

 @return Registered Priority]]>
      </doc>
    </method>
    <method name="callEvent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.bukkit.event.Event"/>
      <exception name="EventException" type="org.bukkit.event.EventException"/>
      <doc>
      <![CDATA[Calls the event executor

 @param event The event
 @throws EventException If an event handler throws an exception.]]>
      </doc>
    </method>
    <method name="isIgnoringCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether this listener accepts cancelled events

 @return True when ignoring cancelled events]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stores relevant information for plugin listeners]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.RegisteredListener -->
  <!-- start class org.bukkit.plugin.RegisteredServiceProvider -->
  <class name="RegisteredServiceProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable&lt;org.bukkit.plugin.RegisteredServiceProvider&lt;?&gt;&gt;"/>
    <constructor name="RegisteredServiceProvider" type="java.lang.Class&lt;T&gt;, T, org.bukkit.plugin.ServicePriority, org.bukkit.plugin.Plugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getService" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProvider" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPriority" return="org.bukkit.plugin.ServicePriority"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.plugin.RegisteredServiceProvider&lt;?&gt;"/>
    </method>
    <doc>
    <![CDATA[A registered service provider.

 @param <T> Service]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.RegisteredServiceProvider -->
  <!-- start class org.bukkit.plugin.ServicePriority -->
  <class name="ServicePriority" extends="java.lang.Enum&lt;org.bukkit.plugin.ServicePriority&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.plugin.ServicePriority[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.plugin.ServicePriority"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents various priorities of a provider.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.ServicePriority -->
  <!-- start interface org.bukkit.plugin.ServicesManager -->
  <interface name="ServicesManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="register"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <param name="provider" type="T"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="priority" type="org.bukkit.plugin.ServicePriority"/>
      <doc>
      <![CDATA[Register a provider of a service.

 @param <T> Provider
 @param service service class
 @param provider provider to register
 @param plugin plugin with the provider
 @param priority priority of the provider]]>
      </doc>
    </method>
    <method name="unregisterAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Unregister all the providers registered by a particular plugin.

 @param plugin The plugin]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;?&gt;"/>
      <param name="provider" type="java.lang.Object"/>
      <doc>
      <![CDATA[Unregister a particular provider for a particular service.

 @param service The service interface
 @param provider The service provider implementation]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="java.lang.Object"/>
      <doc>
      <![CDATA[Unregister a particular provider.

 @param provider The service provider implementation]]>
      </doc>
    </method>
    <method name="load" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Queries for a provider. This may return if no provider has been
 registered for a service. The highest priority provider is returned.

 @param <T> The service interface
 @param service The service interface
 @return provider or null]]>
      </doc>
    </method>
    <method name="getRegistration" return="org.bukkit.plugin.RegisteredServiceProvider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Queries for a provider registration. This may return if no provider
 has been registered for a service.

 @param <T> The service interface
 @param service The service interface
 @return provider registration or null]]>
      </doc>
    </method>
    <method name="getRegistrations" return="java.util.List&lt;org.bukkit.plugin.RegisteredServiceProvider&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Get registrations of providers for a plugin.

 @param plugin The plugin
 @return provider registrations]]>
      </doc>
    </method>
    <method name="getRegistrations" return="java.util.Collection&lt;org.bukkit.plugin.RegisteredServiceProvider&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Get registrations of providers for a service. The returned list is
 unmodifiable.

 @param <T> The service interface
 @param service The service interface
 @return list of registrations]]>
      </doc>
    </method>
    <method name="getKnownServices" return="java.util.Collection&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of known services. A service is known if it has registered
 providers for it.

 @return list of known services]]>
      </doc>
    </method>
    <method name="isProvidedFor" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns whether a provider has been registered for a service. Do not
 check this first only to call <code>load(service)</code> later, as that
 would be a non-thread safe situation.

 @param <T> service
 @param service service to check
 @return whether there has been a registered provider]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Manages services and service providers. Services are an interface
 specifying a list of methods that a provider must implement. Providers are
 implementations of these services. A provider can be queried from the
 services manager in order to use a service (if one is available). If
 multiple plugins register a service, then the service with the highest
 priority takes precedence.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.ServicesManager -->
  <!-- start class org.bukkit.plugin.SimplePluginManager -->
  <class name="SimplePluginManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.PluginManager"/>
    <constructor name="SimplePluginManager" type="org.bukkit.Server, org.bukkit.command.SimpleCommandMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="registerInterface"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="java.lang.Class&lt;? extends org.bukkit.plugin.PluginLoader&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Registers the specified plugin loader

 @param loader Class name of the PluginLoader to register
 @throws IllegalArgumentException Thrown when the given Class is not a
     valid PluginLoader]]>
      </doc>
    </method>
    <method name="loadPlugins" return="org.bukkit.plugin.Plugin[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="directory" type="java.io.File"/>
      <doc>
      <![CDATA[Loads the plugins contained within the specified directory

 @param directory Directory to check for plugins
 @return A list of all plugins loaded]]>
      </doc>
    </method>
    <method name="loadPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="InvalidPluginException" type="org.bukkit.plugin.InvalidPluginException"/>
      <exception name="UnknownDependencyException" type="org.bukkit.plugin.UnknownDependencyException"/>
      <doc>
      <![CDATA[Loads the plugin in the specified file
 <p>
 File must be valid according to the current enabled Plugin interfaces

 @param file File containing the plugin to load
 @return The Plugin loaded, or null if it was invalid
 @throws InvalidPluginException Thrown when the specified file is not a
     valid plugin
 @throws UnknownDependencyException If a required dependency could not
     be found]]>
      </doc>
    </method>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the given plugin is loaded and returns it when applicable
 <p>
 Please note that the name of the plugin is case-sensitive

 @param name Name of the plugin to check
 @return Plugin if it exists, otherwise null]]>
      </doc>
    </method>
    <method name="getPlugins" return="org.bukkit.plugin.Plugin[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPluginEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the given plugin is enabled or not
 <p>
 Please note that the name of the plugin is case-sensitive.

 @param name Name of the plugin to check
 @return true if the plugin is enabled, otherwise false]]>
      </doc>
    </method>
    <method name="isPluginEnabled" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Checks if the given plugin is enabled or not

 @param plugin Plugin to check
 @return true if the plugin is enabled, otherwise false]]>
      </doc>
    </method>
    <method name="enablePlugin"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="disablePlugins"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="disablePlugins"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeClassloaders" type="boolean"/>
    </method>
    <method name="disablePlugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="disablePlugin"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="closeClassloader" type="boolean"/>
    </method>
    <method name="clearPlugins"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="callEvent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.bukkit.event.Event"/>
      <doc>
      <![CDATA[Calls an event with the given details.

 @param event Event details]]>
      </doc>
    </method>
    <method name="registerEvents"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="registerEvent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;"/>
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="priority" type="org.bukkit.event.EventPriority"/>
      <param name="executor" type="org.bukkit.plugin.EventExecutor"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="registerEvent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;"/>
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="priority" type="org.bukkit.event.EventPriority"/>
      <param name="executor" type="org.bukkit.plugin.EventExecutor"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="ignoreCancelled" type="boolean"/>
      <doc>
      <![CDATA[Registers the given event to the specified listener using a directly
 passed EventExecutor

 @param event Event class to register
 @param listener PlayerListener to register
 @param priority Priority of this event
 @param executor EventExecutor to register
 @param plugin Plugin to register
 @param ignoreCancelled Do not call executor if event was already
     cancelled]]>
      </doc>
    </method>
    <method name="getPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="addPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="addPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <param name="dirty" type="boolean"/>
    </method>
    <method name="getDefaultPermissions" return="java.util.Set&lt;org.bukkit.permissions.Permission&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
    </method>
    <method name="removePermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="removePermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="recalculatePermissionDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="dirtyPermissibles"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subscribeToPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.lang.String"/>
      <param name="permissible" type="org.bukkit.permissions.Permissible"/>
    </method>
    <method name="unsubscribeFromPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.lang.String"/>
      <param name="permissible" type="org.bukkit.permissions.Permissible"/>
    </method>
    <method name="getPermissionSubscriptions" return="java.util.Set&lt;org.bukkit.permissions.Permissible&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.lang.String"/>
    </method>
    <method name="subscribeToDefaultPerms"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
      <param name="permissible" type="org.bukkit.permissions.Permissible"/>
    </method>
    <method name="unsubscribeFromDefaultPerms"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
      <param name="permissible" type="org.bukkit.permissions.Permissible"/>
    </method>
    <method name="getDefaultPermSubscriptions" return="java.util.Set&lt;org.bukkit.permissions.Permissible&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="boolean"/>
    </method>
    <method name="getPermissions" return="java.util.Set&lt;org.bukkit.permissions.Permission&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTransitiveDepend" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.PluginDescriptionFile"/>
      <param name="depend" type="org.bukkit.plugin.PluginDescriptionFile"/>
    </method>
    <method name="useTimings" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="useTimings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="use" type="boolean"/>
      <doc>
      <![CDATA[Sets whether or not per event timing code should be used

 @param use True if per event timing code should be used]]>
      </doc>
    </method>
    <method name="clearPermissions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Handles all plugin management from the Server]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.SimplePluginManager -->
  <!-- start class org.bukkit.plugin.SimpleServicesManager -->
  <class name="SimpleServicesManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.ServicesManager"/>
    <constructor name="SimpleServicesManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <param name="provider" type="T"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="priority" type="org.bukkit.plugin.ServicePriority"/>
      <doc>
      <![CDATA[Register a provider of a service.

 @param <T> Provider
 @param service service class
 @param provider provider to register
 @param plugin plugin with the provider
 @param priority priority of the provider]]>
      </doc>
    </method>
    <method name="unregisterAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Unregister all the providers registered by a particular plugin.

 @param plugin The plugin]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;?&gt;"/>
      <param name="provider" type="java.lang.Object"/>
      <doc>
      <![CDATA[Unregister a particular provider for a particular service.

 @param service The service interface
 @param provider The service provider implementation]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="java.lang.Object"/>
      <doc>
      <![CDATA[Unregister a particular provider.

 @param provider The service provider implementation]]>
      </doc>
    </method>
    <method name="load" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Queries for a provider. This may return if no provider has been
 registered for a service. The highest priority provider is returned.

 @param <T> The service interface
 @param service The service interface
 @return provider or null]]>
      </doc>
    </method>
    <method name="getRegistration" return="org.bukkit.plugin.RegisteredServiceProvider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Queries for a provider registration. This may return if no provider
 has been registered for a service.

 @param <T> The service interface
 @param service The service interface
 @return provider registration or null]]>
      </doc>
    </method>
    <method name="getRegistrations" return="java.util.List&lt;org.bukkit.plugin.RegisteredServiceProvider&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Get registrations of providers for a plugin.

 @param plugin The plugin
 @return provider registrations]]>
      </doc>
    </method>
    <method name="getRegistrations" return="java.util.List&lt;org.bukkit.plugin.RegisteredServiceProvider&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Get registrations of providers for a service. The returned list is
 an unmodifiable copy.

 @param <T> The service interface
 @param service The service interface
 @return a copy of the list of registrations]]>
      </doc>
    </method>
    <method name="getKnownServices" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a list of known services. A service is known if it has registered
 providers for it.

 @return a copy of the set of known services]]>
      </doc>
    </method>
    <method name="isProvidedFor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns whether a provider has been registered for a service.

 @param <T> service
 @param service service to check
 @return true if and only if there are registered providers]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A simple services manager.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.SimpleServicesManager -->
  <!-- start class org.bukkit.plugin.TimedRegisteredListener -->
  <class name="TimedRegisteredListener" extends="org.bukkit.plugin.RegisteredListener"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimedRegisteredListener" type="org.bukkit.event.Listener, org.bukkit.plugin.EventExecutor, org.bukkit.event.EventPriority, org.bukkit.plugin.Plugin, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="callEvent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.bukkit.event.Event"/>
      <exception name="EventException" type="org.bukkit.event.EventException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the call count and total time for this listener]]>
      </doc>
    </method>
    <method name="getCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the total times this listener has been called

 @return Times this listener has been called]]>
      </doc>
    </method>
    <method name="getTotalTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the total time calls to this listener have taken

 @return Total time for all calls of this listener]]>
      </doc>
    </method>
    <method name="getEventClass" return="java.lang.Class&lt;? extends org.bukkit.event.Event&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the class of the events this listener handled. If it handled
 multiple classes of event, the closest shared superclass will be
 returned, such that for any event this listener has handled,
 <code>this.getEventClass().isAssignableFrom(event.getClass())</code>
 and no class <code>this.getEventClass().isAssignableFrom(clazz)
 {@literal && this.getEventClass() != clazz &&}
 event.getClass().isAssignableFrom(clazz)</code> for all handled events.

 @return the event class handled by this RegisteredListener]]>
      </doc>
    </method>
    <method name="hasMultiple" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets whether this listener has handled multiple events, such that for
 some two events, <code>eventA.getClass() != eventB.getClass()</code>.

 @return true if this listener has handled multiple events]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Extends RegisteredListener to include timing information]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.TimedRegisteredListener -->
  <!-- start class org.bukkit.plugin.UnknownDependencyException -->
  <class name="UnknownDependencyException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnknownDependencyException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new UnknownDependencyException based on the given
 Exception

 @param throwable Exception that triggered this Exception]]>
      </doc>
    </constructor>
    <constructor name="UnknownDependencyException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new UnknownDependencyException with the given message

 @param message Brief message explaining the cause of the exception]]>
      </doc>
    </constructor>
    <constructor name="UnknownDependencyException" type="java.lang.Throwable, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new UnknownDependencyException based on the given
 Exception

 @param message Brief message explaining the cause of the exception
 @param throwable Exception that triggered this Exception]]>
      </doc>
    </constructor>
    <constructor name="UnknownDependencyException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new UnknownDependencyException]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Thrown when attempting to load an invalid Plugin file]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.UnknownDependencyException -->
</package>
<package name="org.bukkit.plugin.java">
  <!-- start class org.bukkit.plugin.java.JavaPlugin -->
  <class name="JavaPlugin" extends="org.bukkit.plugin.PluginBase"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JavaPlugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="JavaPlugin" type="org.bukkit.plugin.java.JavaPluginLoader, org.bukkit.plugin.PluginDescriptionFile, java.io.File, java.io.File"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getDataFolder" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the folder that the plugin data's files are located in. The
 folder may not yet exist.

 @return The folder.]]>
      </doc>
    </method>
    <method name="getPluginLoader" return="org.bukkit.plugin.PluginLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the associated PluginLoader responsible for this plugin

 @return PluginLoader that controls this plugin]]>
      </doc>
    </method>
    <method name="getServer" return="org.bukkit.Server"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Server instance currently running this plugin

 @return Server running this plugin]]>
      </doc>
    </method>
    <method name="isEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a value indicating whether or not this plugin is currently
 enabled

 @return true if this plugin is enabled, otherwise false]]>
      </doc>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the file which contains this plugin

 @return File containing this plugin]]>
      </doc>
    </method>
    <method name="getDescription" return="org.bukkit.plugin.PluginDescriptionFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the plugin.yaml file containing the details for this plugin

 @return Contents of the plugin.yaml file]]>
      </doc>
    </method>
    <method name="getConfig" return="org.bukkit.configuration.file.FileConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTextResource" return="java.io.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <doc>
      <![CDATA[Provides a reader for a text file located inside the jar.
 <p>
 The returned reader will read text with the UTF-8 charset.

 @param file the filename of the resource to load
 @return null if {@link #getResource(String)} returns null
 @throws IllegalArgumentException if file is null
 @see ClassLoader#getResourceAsStream(String)]]>
      </doc>
    </method>
    <method name="reloadConfig"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="saveConfig"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="saveDefaultConfig"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="saveResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resourcePath" type="java.lang.String"/>
      <param name="replace" type="boolean"/>
    </method>
    <method name="getResource" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
    </method>
    <method name="getClassLoader" return="java.lang.ClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ClassLoader which holds this plugin

 @return ClassLoader holding this plugin]]>
      </doc>
    </method>
    <method name="setEnabled"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <doc>
      <![CDATA[Sets the enabled state of this plugin

 @param enabled true if enabled, otherwise false]]>
      </doc>
    </method>
    <method name="onCommand" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <param name="label" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="onTabComplete" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sender" type="org.bukkit.command.CommandSender"/>
      <param name="command" type="org.bukkit.command.Command"/>
      <param name="alias" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getCommand" return="org.bukkit.command.PluginCommand"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the command with the given name, specific to this plugin. Commands
 need to be registered in the {@link PluginDescriptionFile#getCommands()
 PluginDescriptionFile} to exist at runtime.

 @param name name or alias of the command
 @return the plugin command if found, otherwise null]]>
      </doc>
    </method>
    <method name="onLoad"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="onDisable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="onEnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultWorldGenerator" return="org.bukkit.generator.ChunkGenerator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="worldName" type="java.lang.String"/>
      <param name="id" type="java.lang.String"/>
    </method>
    <method name="isNaggable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setNaggable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="canNag" type="boolean"/>
    </method>
    <method name="getLogger" return="java.util.logging.Logger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPlugin" return="T extends org.bukkit.plugin.java.JavaPlugin"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[This method provides fast access to the plugin that has {@link
 #getProvidingPlugin(Class) provided} the given plugin class, which is
 usually the plugin that implemented it.
 <p>
 An exception to this would be if plugin's jar that contained the class
 does not extend the class, where the intended plugin would have
 resided in a different jar / classloader.

 @param <T> a class that extends JavaPlugin
 @param clazz the class desired
 @return the plugin that provides and implements said class
 @throws IllegalArgumentException if clazz is null
 @throws IllegalArgumentException if clazz does not extend {@link
     JavaPlugin}
 @throws IllegalStateException if clazz was not provided by a plugin,
     for example, if called with
     <code>JavaPlugin.getPlugin(JavaPlugin.class)</code>
 @throws IllegalStateException if called from the static initializer for
     given JavaPlugin
 @throws ClassCastException if plugin that provided the class does not
     extend the class]]>
      </doc>
    </method>
    <method name="getProvidingPlugin" return="org.bukkit.plugin.java.JavaPlugin"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[This method provides fast access to the plugin that has provided the
 given class.

 @param clazz a class belonging to a plugin
 @return the plugin that provided the class
 @throws IllegalArgumentException if the class is not provided by a
     JavaPlugin
 @throws IllegalArgumentException if class is null
 @throws IllegalStateException if called from the static initializer for
     given JavaPlugin]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a Java plugin]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.java.JavaPlugin -->
  <!-- start class org.bukkit.plugin.java.JavaPluginLoader -->
  <class name="JavaPluginLoader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.PluginLoader"/>
    <constructor name="JavaPluginLoader" type="org.bukkit.Server"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This class was not meant to be constructed explicitly

 @param instance the server instance]]>
      </doc>
    </constructor>
    <method name="loadPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="InvalidPluginException" type="org.bukkit.plugin.InvalidPluginException"/>
    </method>
    <method name="getPluginDescription" return="org.bukkit.plugin.PluginDescriptionFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="InvalidDescriptionException" type="org.bukkit.plugin.InvalidDescriptionException"/>
    </method>
    <method name="getPluginFileFilters" return="java.util.regex.Pattern[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createRegisteredListeners" return="java.util.Map&lt;java.lang.Class&lt;? extends org.bukkit.event.Event&gt;, java.util.Set&lt;org.bukkit.plugin.RegisteredListener&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.bukkit.event.Listener"/>
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="enablePlugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="disablePlugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="disablePlugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="closeClassloader" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Represents a Java plugin loader, allowing plugins in the form of .jar]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.java.JavaPluginLoader -->
  <!-- start class org.bukkit.plugin.java.PluginClassLoader -->
  <class name="PluginClassLoader" extends="java.net.URLClassLoader"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getPlugin" return="org.bukkit.plugin.java.JavaPlugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getResources" return="java.util.Enumeration&lt;java.net.URL&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="findClass" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A ClassLoader for plugins, to allow shared classes across multiple plugins]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.java.PluginClassLoader -->
</package>
<package name="org.bukkit.plugin.messaging">
  <!-- start class org.bukkit.plugin.messaging.ChannelNameTooLongException -->
  <class name="ChannelNameTooLongException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChannelNameTooLongException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ChannelNameTooLongException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown if a Plugin Channel is too long.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.messaging.ChannelNameTooLongException -->
  <!-- start class org.bukkit.plugin.messaging.ChannelNotRegisteredException -->
  <class name="ChannelNotRegisteredException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChannelNotRegisteredException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ChannelNotRegisteredException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown if a Plugin attempts to send a message on an unregistered channel.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.messaging.ChannelNotRegisteredException -->
  <!-- start class org.bukkit.plugin.messaging.MessageTooLargeException -->
  <class name="MessageTooLargeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MessageTooLargeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MessageTooLargeException" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MessageTooLargeException" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MessageTooLargeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown if a Plugin Message is sent that is too large to be sent.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.messaging.MessageTooLargeException -->
  <!-- start interface org.bukkit.plugin.messaging.Messenger -->
  <interface name="Messenger"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isReservedChannel" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified channel is a reserved name.
 <br>
 All channels within the "minecraft" namespace except for
 "minecraft:brand" are reserved.

 @param channel Channel name to check.
 @return True if the channel is reserved, otherwise false.
 @throws IllegalArgumentException Thrown if channel is null.]]>
      </doc>
    </method>
    <method name="registerOutgoingPluginChannel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Registers the specific plugin to the requested outgoing plugin channel,
 allowing it to send messages through that channel to any clients.

 @param plugin Plugin that wishes to send messages through the channel.
 @param channel Channel to register.
 @throws IllegalArgumentException Thrown if plugin or channel is null.]]>
      </doc>
    </method>
    <method name="unregisterOutgoingPluginChannel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Unregisters the specific plugin from the requested outgoing plugin
 channel, no longer allowing it to send messages through that channel to
 any clients.

 @param plugin Plugin that no longer wishes to send messages through the
     channel.
 @param channel Channel to unregister.
 @throws IllegalArgumentException Thrown if plugin or channel is null.]]>
      </doc>
    </method>
    <method name="unregisterOutgoingPluginChannel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Unregisters the specific plugin from all outgoing plugin channels, no
 longer allowing it to send any plugin messages.

 @param plugin Plugin that no longer wishes to send plugin messages.
 @throws IllegalArgumentException Thrown if plugin is null.]]>
      </doc>
    </method>
    <method name="registerIncomingPluginChannel" return="org.bukkit.plugin.messaging.PluginMessageListenerRegistration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <param name="listener" type="org.bukkit.plugin.messaging.PluginMessageListener"/>
      <doc>
      <![CDATA[Registers the specific plugin for listening on the requested incoming
 plugin channel, allowing it to act upon any plugin messages.

 @param plugin Plugin that wishes to register to this channel.
 @param channel Channel to register.
 @param listener Listener to receive messages on.
 @return The resulting registration that was made as a result of this
     method.
 @throws IllegalArgumentException Thrown if plugin, channel or listener
     is null, or the listener is already registered for this channel.]]>
      </doc>
    </method>
    <method name="unregisterIncomingPluginChannel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <param name="listener" type="org.bukkit.plugin.messaging.PluginMessageListener"/>
      <doc>
      <![CDATA[Unregisters the specific plugin's listener from listening on the
 requested incoming plugin channel, no longer allowing it to act upon
 any plugin messages.

 @param plugin Plugin that wishes to unregister from this channel.
 @param channel Channel to unregister.
 @param listener Listener to stop receiving messages on.
 @throws IllegalArgumentException Thrown if plugin, channel or listener
     is null.]]>
      </doc>
    </method>
    <method name="unregisterIncomingPluginChannel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Unregisters the specific plugin from listening on the requested
 incoming plugin channel, no longer allowing it to act upon any plugin
 messages.

 @param plugin Plugin that wishes to unregister from this channel.
 @param channel Channel to unregister.
 @throws IllegalArgumentException Thrown if plugin or channel is null.]]>
      </doc>
    </method>
    <method name="unregisterIncomingPluginChannel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Unregisters the specific plugin from listening on all plugin channels
 through all listeners.

 @param plugin Plugin that wishes to unregister from this channel.
 @throws IllegalArgumentException Thrown if plugin is null.]]>
      </doc>
    </method>
    <method name="getOutgoingChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all the outgoing plugin channels.

 @return List of all registered outgoing plugin channels.]]>
      </doc>
    </method>
    <method name="getOutgoingChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Gets a set containing all the outgoing plugin channels that the
 specified plugin is registered to.

 @param plugin Plugin to retrieve channels for.
 @return List of all registered outgoing plugin channels that a plugin
     is registered to.
 @throws IllegalArgumentException Thrown if plugin is null.]]>
      </doc>
    </method>
    <method name="getIncomingChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all the incoming plugin channels.

 @return List of all registered incoming plugin channels.]]>
      </doc>
    </method>
    <method name="getIncomingChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Gets a set containing all the incoming plugin channels that the
 specified plugin is registered for.

 @param plugin Plugin to retrieve channels for.
 @return List of all registered incoming plugin channels that the plugin
     is registered for.
 @throws IllegalArgumentException Thrown if plugin is null.]]>
      </doc>
    </method>
    <method name="getIncomingChannelRegistrations" return="java.util.Set&lt;org.bukkit.plugin.messaging.PluginMessageListenerRegistration&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Gets a set containing all the incoming plugin channel registrations
 that the specified plugin has.

 @param plugin Plugin to retrieve registrations for.
 @return List of all registrations that the plugin has.
 @throws IllegalArgumentException Thrown if plugin is null.]]>
      </doc>
    </method>
    <method name="getIncomingChannelRegistrations" return="java.util.Set&lt;org.bukkit.plugin.messaging.PluginMessageListenerRegistration&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a set containing all the incoming plugin channel registrations
 that are on the requested channel.

 @param channel Channel to retrieve registrations for.
 @return List of all registrations that are on the channel.
 @throws IllegalArgumentException Thrown if channel is null.]]>
      </doc>
    </method>
    <method name="getIncomingChannelRegistrations" return="java.util.Set&lt;org.bukkit.plugin.messaging.PluginMessageListenerRegistration&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets a set containing all the incoming plugin channel registrations
 that the specified plugin has on the requested channel.

 @param plugin Plugin to retrieve registrations for.
 @param channel Channel to filter registrations by.
 @return List of all registrations that the plugin has.
 @throws IllegalArgumentException Thrown if plugin or channel is null.]]>
      </doc>
    </method>
    <method name="isRegistrationValid" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="registration" type="org.bukkit.plugin.messaging.PluginMessageListenerRegistration"/>
      <doc>
      <![CDATA[Checks if the specified plugin message listener registration is valid.
 <p>
 A registration is considered valid if it has not be unregistered and
 that the plugin is still enabled.

 @param registration Registration to check.
 @return True if the registration is valid, otherwise false.]]>
      </doc>
    </method>
    <method name="isIncomingChannelRegistered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified plugin has registered to receive incoming
 messages through the requested channel.

 @param plugin Plugin to check registration for.
 @param channel Channel to test for.
 @return True if the channel is registered, else false.]]>
      </doc>
    </method>
    <method name="isOutgoingChannelRegistered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Checks if the specified plugin has registered to send outgoing messages
 through the requested channel.

 @param plugin Plugin to check registration for.
 @param channel Channel to test for.
 @return True if the channel is registered, else false.]]>
      </doc>
    </method>
    <method name="dispatchIncomingMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Player"/>
      <param name="channel" type="java.lang.String"/>
      <param name="message" type="byte[]"/>
      <doc>
      <![CDATA[Dispatches the specified incoming message to any registered listeners.

 @param source Source of the message.
 @param channel Channel that the message was sent by.
 @param message Raw payload of the message.]]>
      </doc>
    </method>
    <field name="MAX_MESSAGE_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Represents the largest size that an individual Plugin Message may be.]]>
      </doc>
    </field>
    <field name="MAX_CHANNEL_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Represents the largest size that a Plugin Channel may be.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A class responsible for managing the registrations of plugin channels and
 their listeners.

 Channel names must contain a colon separator and consist of only [a-z0-9/._-]
 - i.e. they MUST be valid {@link NamespacedKey}. The "BungeeCord" channel is
 an exception and may only take this form.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.messaging.Messenger -->
  <!-- start class org.bukkit.plugin.messaging.PluginChannelDirection -->
  <class name="PluginChannelDirection" extends="java.lang.Enum&lt;org.bukkit.plugin.messaging.PluginChannelDirection&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.plugin.messaging.PluginChannelDirection[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.plugin.messaging.PluginChannelDirection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents the different directions a plugin channel may go.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.messaging.PluginChannelDirection -->
  <!-- start interface org.bukkit.plugin.messaging.PluginMessageListener -->
  <interface name="PluginMessageListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onPluginMessageReceived"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.lang.String"/>
      <param name="player" type="org.bukkit.entity.Player"/>
      <param name="message" type="byte[]"/>
      <doc>
      <![CDATA[A method that will be thrown when a PluginMessageSource sends a plugin
 message on a registered channel.

 @param channel Channel that the message was sent through.
 @param player Source of the message.
 @param message The raw message that was sent.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A listener for a specific Plugin Channel, which will receive notifications
 of messages sent from a client.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.messaging.PluginMessageListener -->
  <!-- start class org.bukkit.plugin.messaging.PluginMessageListenerRegistration -->
  <class name="PluginMessageListenerRegistration" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PluginMessageListenerRegistration" type="org.bukkit.plugin.messaging.Messenger, org.bukkit.plugin.Plugin, java.lang.String, org.bukkit.plugin.messaging.PluginMessageListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getChannel" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin channel that this registration is about.

 @return Plugin channel.]]>
      </doc>
    </method>
    <method name="getListener" return="org.bukkit.plugin.messaging.PluginMessageListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the registered listener described by this registration.

 @return Registered listener.]]>
      </doc>
    </method>
    <method name="getPlugin" return="org.bukkit.plugin.Plugin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the plugin that this registration is for.

 @return Registered plugin.]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if this registration is still valid.

 @return True if this registration is still valid, otherwise false.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Contains information about a {@link Plugin}s registration to a plugin
 channel.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.messaging.PluginMessageListenerRegistration -->
  <!-- start interface org.bukkit.plugin.messaging.PluginMessageRecipient -->
  <interface name="PluginMessageRecipient"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="sendPluginMessage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <param name="message" type="byte[]"/>
      <doc>
      <![CDATA[Sends this recipient a Plugin Message on the specified outgoing
 channel.
 <p>
 The message may not be larger than {@link Messenger#MAX_MESSAGE_SIZE}
 bytes, and the plugin must be registered to send messages on the
 specified channel.

 @param source The plugin that sent this message.
 @param channel The channel to send this message on.
 @param message The raw message to send.
 @throws IllegalArgumentException Thrown if the source plugin is
     disabled.
 @throws IllegalArgumentException Thrown if source, channel or message
     is null.
 @throws MessageTooLargeException Thrown if the message is too big.
 @throws ChannelNotRegisteredException Thrown if the channel is not
     registered for this plugin.]]>
      </doc>
    </method>
    <method name="getListeningPluginChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a set containing all the Plugin Channels that this client is
 listening on.

 @return Set containing all the channels that this client may accept.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a possible recipient for a Plugin Message.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.plugin.messaging.PluginMessageRecipient -->
  <!-- start class org.bukkit.plugin.messaging.ReservedChannelException -->
  <class name="ReservedChannelException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReservedChannelException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ReservedChannelException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown if a plugin attempts to register for a reserved channel (such as
 "REGISTER")]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.messaging.ReservedChannelException -->
  <!-- start class org.bukkit.plugin.messaging.StandardMessenger -->
  <class name="StandardMessenger" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.plugin.messaging.Messenger"/>
    <constructor name="StandardMessenger"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isReservedChannel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.lang.String"/>
    </method>
    <method name="registerOutgoingPluginChannel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
    </method>
    <method name="unregisterOutgoingPluginChannel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
    </method>
    <method name="unregisterOutgoingPluginChannel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="registerIncomingPluginChannel" return="org.bukkit.plugin.messaging.PluginMessageListenerRegistration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <param name="listener" type="org.bukkit.plugin.messaging.PluginMessageListener"/>
    </method>
    <method name="unregisterIncomingPluginChannel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <param name="listener" type="org.bukkit.plugin.messaging.PluginMessageListener"/>
    </method>
    <method name="unregisterIncomingPluginChannel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
    </method>
    <method name="unregisterIncomingPluginChannel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="getOutgoingChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOutgoingChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="getIncomingChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIncomingChannels" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="getIncomingChannelRegistrations" return="java.util.Set&lt;org.bukkit.plugin.messaging.PluginMessageListenerRegistration&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
    </method>
    <method name="getIncomingChannelRegistrations" return="java.util.Set&lt;org.bukkit.plugin.messaging.PluginMessageListenerRegistration&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.lang.String"/>
    </method>
    <method name="getIncomingChannelRegistrations" return="java.util.Set&lt;org.bukkit.plugin.messaging.PluginMessageListenerRegistration&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
    </method>
    <method name="isRegistrationValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="registration" type="org.bukkit.plugin.messaging.PluginMessageListenerRegistration"/>
    </method>
    <method name="isIncomingChannelRegistered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
    </method>
    <method name="isOutgoingChannelRegistered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
    </method>
    <method name="dispatchIncomingMessage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.bukkit.entity.Player"/>
      <param name="channel" type="java.lang.String"/>
      <param name="message" type="byte[]"/>
    </method>
    <method name="validateChannel"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not an API method">
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Validates a Plugin Channel name.

 @param channel Channel name to validate.
 @deprecated not an API method]]>
      </doc>
    </method>
    <method name="validateAndCorrectChannel" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not an API method">
      <param name="channel" type="java.lang.String"/>
      <doc>
      <![CDATA[Validates and corrects a Plugin Channel name. Method is not reentrant / idempotent.

 @param channel Channel name to validate.
 @return corrected channel name
 @deprecated not an API method]]>
      </doc>
    </method>
    <method name="validatePluginMessage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messenger" type="org.bukkit.plugin.messaging.Messenger"/>
      <param name="source" type="org.bukkit.plugin.Plugin"/>
      <param name="channel" type="java.lang.String"/>
      <param name="message" type="byte[]"/>
      <doc>
      <![CDATA[Validates the input of a Plugin Message, ensuring the arguments are all
 valid.

 @param messenger Messenger to use for validation.
 @param source Source plugin of the Message.
 @param channel Plugin Channel to send the message by.
 @param message Raw message payload to send.
 @throws IllegalArgumentException Thrown if the source plugin is
     disabled.
 @throws IllegalArgumentException Thrown if source, channel or message
     is null.
 @throws MessageTooLargeException Thrown if the message is too big.
 @throws ChannelNameTooLongException Thrown if the channel name is too
     long.
 @throws ChannelNotRegisteredException Thrown if the channel is not
     registered for this plugin.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Standard implementation to {@link Messenger}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.plugin.messaging.StandardMessenger -->
</package>
<package name="org.bukkit.potion">
  <!-- start class org.bukkit.potion.Potion -->
  <class name="Potion" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Potion" type="org.bukkit.potion.PotionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new potion of the given type. Unless the type is {@link
 PotionType#WATER}, it will be level one, without extended duration.
 Don't use this constructor to create a no-effect potion other than
 water bottle.

 @param type The potion type]]>
      </doc>
    </constructor>
    <constructor name="Potion" type="org.bukkit.potion.PotionType, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new potion of the given type and level.

 @param type The type of potion.
 @param level The potion's level.]]>
      </doc>
    </constructor>
    <constructor name="Potion" type="org.bukkit.potion.PotionType, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="In favour of using {@link #Potion(PotionType)} with {@link
     #splash()}.">
      <doc>
      <![CDATA[Create a new potion of the given type and level.

 @param type The type of potion.
 @param level The potion's level.
 @param splash Whether it is a splash potion.
 @deprecated In favour of using {@link #Potion(PotionType)} with {@link
     #splash()}.]]>
      </doc>
    </constructor>
    <constructor name="Potion" type="org.bukkit.potion.PotionType, int, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="In favour of using {@link #Potion(PotionType)} with {@link
     #extend()} and possibly {@link #splash()}.">
      <doc>
      <![CDATA[Create a new potion of the given type and level.

 @param type The type of potion.
 @param level The potion's level.
 @param splash Whether it is a splash potion.
 @param extended Whether it has an extended duration.
 @deprecated In favour of using {@link #Potion(PotionType)} with {@link
     #extend()} and possibly {@link #splash()}.]]>
      </doc>
    </constructor>
    <method name="splash" return="org.bukkit.potion.Potion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Chain this to the constructor to make the potion a splash potion.

 @return The potion.]]>
      </doc>
    </method>
    <method name="extend" return="org.bukkit.potion.Potion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Chain this to the constructor to extend the potion's duration.

 @return The potion.]]>
      </doc>
    </method>
    <method name="apply"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="org.bukkit.inventory.ItemStack"/>
      <doc>
      <![CDATA[Applies the effects of this potion to the given {@link ItemStack}. The
 ItemStack must be a potion.

 @param to The itemstack to apply to]]>
      </doc>
    </method>
    <method name="apply"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="org.bukkit.entity.LivingEntity"/>
      <doc>
      <![CDATA[Applies the effects that would be applied by this potion to the given
 {@link LivingEntity}.

 @param to The entity to apply the effects to
 @see LivingEntity#addPotionEffects(Collection)]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getEffects" return="java.util.Collection&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of {@link PotionEffect}s that this {@link Potion}
 would confer upon a {@link LivingEntity}.

 @see PotionBrewer#getEffectsFromDamage(int)
 @see Potion#toDamageValue()
 @return The effects that this potion applies]]>
      </doc>
    </method>
    <method name="getLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the level of this potion.

 @return The level of this potion]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.potion.PotionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link PotionType} of this potion.

 @return The type of this potion]]>
      </doc>
    </method>
    <method name="hasExtendedDuration" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this potion has an extended duration.

 @return Whether this potion has extended duration]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isSplash" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this potion is a splash potion.

 @return Whether this is a splash potion]]>
      </doc>
    </method>
    <method name="setHasExtendedDuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isExtended" type="boolean"/>
      <doc>
      <![CDATA[Set whether this potion has extended duration. This will cause the
 potion to have roughly 8/3 more duration than a regular potion.

 @param isExtended Whether the potion should have extended duration]]>
      </doc>
    </method>
    <method name="setSplash"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isSplash" type="boolean"/>
      <doc>
      <![CDATA[Sets whether this potion is a splash potion. Splash potions can be
 thrown for a radius effect.

 @param isSplash Whether this is a splash potion]]>
      </doc>
    </method>
    <method name="setType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionType"/>
      <doc>
      <![CDATA[Sets the {@link PotionType} of this potion.

 @param type The new type of this potion]]>
      </doc>
    </method>
    <method name="setLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Sets the level of this potion.

 @param level The new level of this potion]]>
      </doc>
    </method>
    <method name="toDamageValue" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Non-functional">
      <doc>
      <![CDATA[Converts this potion to a valid potion damage short, usable for potion
 item stacks.

 @return The damage value of this potion
 @deprecated Non-functional]]>
      </doc>
    </method>
    <method name="toItemStack" return="org.bukkit.inventory.ItemStack"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
      <doc>
      <![CDATA[Converts this potion to an {@link ItemStack} with the specified amount
 and a correct damage value.

 @param amount The amount of the ItemStack
 @return The created ItemStack]]>
      </doc>
    </method>
    <method name="fromDamage" return="org.bukkit.potion.Potion"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="damage" type="int"/>
      <doc>
      <![CDATA[Gets the potion from its damage value.

 @param damage the damage value
 @return the produced potion]]>
      </doc>
    </method>
    <method name="fromItemStack" return="org.bukkit.potion.Potion"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="org.bukkit.inventory.ItemStack"/>
    </method>
    <method name="getBrewer" return="org.bukkit.potion.PotionBrewer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an instance of {@link PotionBrewer}.

 @return An instance of PotionBrewer]]>
      </doc>
    </method>
    <method name="setPotionBrewer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.potion.PotionBrewer"/>
      <doc>
      <![CDATA[Sets the current instance of {@link PotionBrewer}. Generally not to be
 used from within a plugin.

 @param other The new PotionBrewer]]>
      </doc>
    </method>
    <method name="getNameId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Non-functional">
      <doc>
      <![CDATA[Gets the potion from its name id.

 @return the name id
 @deprecated Non-functional]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Potion Adapter for pre-1.9 data values
 see @PotionMeta for 1.9+]]>
    </doc>
  </class>
  <!-- end class org.bukkit.potion.Potion -->
  <!-- start interface org.bukkit.potion.PotionBrewer -->
  <interface name="PotionBrewer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createEffect" return="org.bukkit.potion.PotionEffect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="potion" type="org.bukkit.potion.PotionEffectType"/>
      <param name="duration" type="int"/>
      <param name="amplifier" type="int"/>
      <doc>
      <![CDATA[Creates a {@link PotionEffect} from the given {@link PotionEffectType},
 applying duration modifiers and checks.

 @param potion The type of potion
 @param duration The duration in ticks
 @param amplifier The amplifier of the effect
 @return The resulting potion effect]]>
      </doc>
    </method>
    <method name="getEffectsFromDamage" return="java.util.Collection&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Non-Functional">
      <param name="damage" type="int"/>
      <doc>
      <![CDATA[Returns a collection of {@link PotionEffect} that would be applied from
 a potion with the given data value.

 @param damage The data value of the potion
 @return The list of effects
 @deprecated Non-Functional]]>
      </doc>
    </method>
    <method name="getEffects" return="java.util.Collection&lt;org.bukkit.potion.PotionEffect&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionType"/>
      <param name="upgraded" type="boolean"/>
      <param name="extended" type="boolean"/>
      <doc>
      <![CDATA[Returns a collection of {@link PotionEffect} that would be applied from
 a potion with the given type.

 @param type The type of the potion
 @param upgraded Whether the potion is upgraded
 @param extended Whether the potion is extended
 @return The list of effects]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a brewer that can create {@link PotionEffect}s.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.potion.PotionBrewer -->
  <!-- start class org.bukkit.potion.PotionData -->
  <class name="PotionData" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PotionData" type="org.bukkit.potion.PotionType, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiates a final PotionData object to contain information about a
 Potion

 @param type the type of the Potion
 @param extended whether the potion is extended PotionType#isExtendable()
 must be true
 @param upgraded whether the potion is upgraded PotionType#isUpgradable()
 must be true]]>
      </doc>
    </constructor>
    <constructor name="PotionData" type="org.bukkit.potion.PotionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getType" return="org.bukkit.potion.PotionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type of the potion, Type matches up with each kind of craftable
 potion

 @return the potion type]]>
      </doc>
    </method>
    <method name="isUpgraded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the potion is in an upgraded state. This refers to whether or
 not the potion is Tier 2, such as Potion of Fire Resistance II.

 @return true if the potion is upgraded;]]>
      </doc>
    </method>
    <method name="isExtended" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the potion is in an extended state. This refers to the extended
 duration potions

 @return true if the potion is extended]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class org.bukkit.potion.PotionData -->
  <!-- start class org.bukkit.potion.PotionEffect -->
  <class name="PotionEffect" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <constructor name="PotionEffect" type="org.bukkit.potion.PotionEffectType, int, int, boolean, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a potion effect.
 @param type effect type
 @param duration measured in ticks, see {@link
     PotionEffect#getDuration()}
 @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
 @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
 @param particles the particle status, see {@link PotionEffect#hasParticles()}
 @param icon the icon status, see {@link PotionEffect#hasIcon()}]]>
      </doc>
    </constructor>
    <constructor name="PotionEffect" type="org.bukkit.potion.PotionEffectType, int, int, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a potion effect with no defined color.

 @param type effect type
 @param duration measured in ticks, see {@link
     PotionEffect#getDuration()}
 @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
 @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
 @param particles the particle status, see {@link PotionEffect#hasParticles()}]]>
      </doc>
    </constructor>
    <constructor name="PotionEffect" type="org.bukkit.potion.PotionEffectType, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a potion effect. Assumes that particles are visible

 @param type effect type
 @param duration measured in ticks, see {@link
     PotionEffect#getDuration()}
 @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
 @param ambient the ambient status, see {@link PotionEffect#isAmbient()}]]>
      </doc>
    </constructor>
    <constructor name="PotionEffect" type="org.bukkit.potion.PotionEffectType, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a potion effect. Assumes ambient is true.

 @param type Effect type
 @param duration measured in ticks
 @param amplifier the amplifier for the effect
 @see PotionEffect#PotionEffect(PotionEffectType, int, int, boolean)]]>
      </doc>
    </constructor>
    <constructor name="PotionEffect" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for deserialization.

 @param map the map to deserialize from]]>
      </doc>
    </constructor>
    <method name="withType" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
    </method>
    <method name="withDuration" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="int"/>
    </method>
    <method name="withAmplifier" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amplifier" type="int"/>
    </method>
    <method name="withAmbient" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ambient" type="boolean"/>
    </method>
    <method name="withParticles" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="particles" type="boolean"/>
    </method>
    <method name="withIcon" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="icon" type="boolean"/>
    </method>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="org.bukkit.entity.LivingEntity"/>
      <doc>
      <![CDATA[Attempts to add the effect represented by this object to the given
 {@link LivingEntity}.

 @param entity The entity to add this effect to
 @return Whether the effect could be added
 @see LivingEntity#addPotionEffect(PotionEffect)]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getAmplifier" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the amplifier of this effect. A higher amplifier means the
 potion effect happens more often over its duration and in some cases
 has more effect on its target.

 @return The effect amplifier]]>
      </doc>
    </method>
    <method name="getDuration" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the duration (in ticks) that this effect will run for when
 applied to a {@link LivingEntity}.

 @return The duration of the effect]]>
      </doc>
    </method>
    <method name="getType" return="org.bukkit.potion.PotionEffectType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link PotionEffectType} of this effect.

 @return The potion type of this effect]]>
      </doc>
    </method>
    <method name="isAmbient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Makes potion effect produce more, translucent, particles.

 @return if this effect is ambient]]>
      </doc>
    </method>
    <method name="hasParticles" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return whether this effect has particles or not]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="color is not part of potion effects">
      <doc>
      <![CDATA[@return color of this potion's particles. May be null if the potion has no particles or defined color.
 @deprecated color is not part of potion effects]]>
      </doc>
    </method>
    <method name="hasIcon" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return whether this effect has an icon or not]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a potion effect, that can be added to a {@link LivingEntity}. A
 potion effect has a duration that it will last for, an amplifier that will
 enhance its effects, and a {@link PotionEffectType}, that represents its
 effect on an entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.potion.PotionEffect -->
  <!-- start class org.bukkit.potion.PotionEffectType -->
  <class name="PotionEffectType" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PotionEffectType" type="int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createEffect" return="org.bukkit.potion.PotionEffect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="int"/>
      <param name="amplifier" type="int"/>
      <doc>
      <![CDATA[Creates a PotionEffect from this PotionEffectType, applying duration
 modifiers and checks.

 @see PotionBrewer#createEffect(PotionEffectType, int, int)
 @param duration time in ticks
 @param amplifier the effect's amplifier
 @return a resulting potion effect]]>
      </doc>
    </method>
    <method name="getDurationModifier" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="unused, always 1.0">
      <doc>
      <![CDATA[Returns the duration modifier applied to effects of this type.

 @return duration modifier
 @deprecated unused, always 1.0]]>
      </doc>
    </method>
    <method name="getId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Magic value">
      <doc>
      <![CDATA[Returns the unique ID of this type.

 @return Unique ID
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this effect type.

 @return The name of this effect type]]>
      </doc>
    </method>
    <method name="isInstant" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the effect of this type happens once, immediately.

 @return whether this type is normally instant]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the color of this effect type.

 @return the color]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getById" return="org.bukkit.potion.PotionEffectType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Magic value">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[Gets the effect type specified by the unique id.

 @param id Unique ID to fetch
 @return Resulting type, or null if not found.
 @deprecated Magic value]]>
      </doc>
    </method>
    <method name="getByName" return="org.bukkit.potion.PotionEffectType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets the effect type specified by the given name.

 @param name Name of PotionEffectType to fetch
 @return Resulting PotionEffectType, or null if not found.]]>
      </doc>
    </method>
    <method name="registerPotionEffectType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[Registers an effect type with the given object.
 <p>
 Generally not to be used from within a plugin.

 @param type PotionType to register]]>
      </doc>
    </method>
    <method name="stopAcceptingRegistrations"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops accepting any effect type registrations.]]>
      </doc>
    </method>
    <method name="values" return="org.bukkit.potion.PotionEffectType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array of all the registered {@link PotionEffectType}s.
 This array is not necessarily in any particular order.

 @return Array of types.]]>
      </doc>
    </method>
    <field name="SPEED" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases movement speed.]]>
      </doc>
    </field>
    <field name="SLOW" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decreases movement speed.]]>
      </doc>
    </field>
    <field name="FAST_DIGGING" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases dig speed.]]>
      </doc>
    </field>
    <field name="SLOW_DIGGING" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decreases dig speed.]]>
      </doc>
    </field>
    <field name="INCREASE_DAMAGE" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases damage dealt.]]>
      </doc>
    </field>
    <field name="HEAL" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Heals an entity.]]>
      </doc>
    </field>
    <field name="HARM" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Hurts an entity.]]>
      </doc>
    </field>
    <field name="JUMP" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases jump height.]]>
      </doc>
    </field>
    <field name="CONFUSION" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Warps vision on the client.]]>
      </doc>
    </field>
    <field name="REGENERATION" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Regenerates health.]]>
      </doc>
    </field>
    <field name="DAMAGE_RESISTANCE" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decreases damage dealt to an entity.]]>
      </doc>
    </field>
    <field name="FIRE_RESISTANCE" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops fire damage.]]>
      </doc>
    </field>
    <field name="WATER_BREATHING" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows breathing underwater.]]>
      </doc>
    </field>
    <field name="INVISIBILITY" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Grants invisibility.]]>
      </doc>
    </field>
    <field name="BLINDNESS" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Blinds an entity.]]>
      </doc>
    </field>
    <field name="NIGHT_VISION" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allows an entity to see in the dark.]]>
      </doc>
    </field>
    <field name="HUNGER" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases hunger.]]>
      </doc>
    </field>
    <field name="WEAKNESS" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decreases damage dealt by an entity.]]>
      </doc>
    </field>
    <field name="POISON" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Deals damage to an entity over time.]]>
      </doc>
    </field>
    <field name="WITHER" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Deals damage to an entity over time and gives the health to the
 shooter.]]>
      </doc>
    </field>
    <field name="HEALTH_BOOST" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases the maximum health of an entity.]]>
      </doc>
    </field>
    <field name="ABSORPTION" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases the maximum health of an entity with health that cannot be
 regenerated, but is refilled every 30 seconds.]]>
      </doc>
    </field>
    <field name="SATURATION" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increases the food level of an entity each tick.]]>
      </doc>
    </field>
    <field name="GLOWING" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Outlines the entity so that it can be seen from afar.]]>
      </doc>
    </field>
    <field name="LEVITATION" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Causes the entity to float into the air.]]>
      </doc>
    </field>
    <field name="LUCK" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Loot table luck.]]>
      </doc>
    </field>
    <field name="UNLUCK" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Loot table unluck.]]>
      </doc>
    </field>
    <field name="SLOW_FALLING" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Slows entity fall rate.]]>
      </doc>
    </field>
    <field name="CONDUIT_POWER" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Effects granted by a nearby conduit. Includes enhanced underwater abilities.]]>
      </doc>
    </field>
    <field name="DOLPHINS_GRACE" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Squee'ek uh'k kk'kkkk squeek eee'eek.]]>
      </doc>
    </field>
    <field name="BAD_OMEN" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[oof.]]>
      </doc>
    </field>
    <field name="HERO_OF_THE_VILLAGE" type="org.bukkit.potion.PotionEffectType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[\o/.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents a type of potion and its effect on an entity.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.potion.PotionEffectType -->
  <!-- start class org.bukkit.potion.PotionEffectTypeWrapper -->
  <class name="PotionEffectTypeWrapper" extends="org.bukkit.potion.PotionEffectType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PotionEffectTypeWrapper" type="int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getDurationModifier" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="org.bukkit.potion.PotionEffectType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the potion type bound to this wrapper.

 @return The potion effect type]]>
      </doc>
    </method>
    <method name="isInstant" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getColor" return="org.bukkit.Color"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.potion.PotionEffectTypeWrapper -->
  <!-- start class org.bukkit.potion.PotionType -->
  <class name="PotionType" extends="java.lang.Enum&lt;org.bukkit.potion.PotionType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.potion.PotionType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.potion.PotionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getEffectType" return="org.bukkit.potion.PotionEffectType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isInstant" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isUpgradeable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the potion type has an upgraded state.
 This refers to whether or not the potion type can be Tier 2,
 such as Potion of Fire Resistance II.

 @return true if the potion type can be upgraded;]]>
      </doc>
    </method>
    <method name="isExtendable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the potion type has an extended state.
 This refers to the extended duration potions

 @return true if the potion type can be extended]]>
      </doc>
    </method>
    <method name="getMaxLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getByEffect" return="org.bukkit.potion.PotionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Misleading">
      <param name="effectType" type="org.bukkit.potion.PotionEffectType"/>
      <doc>
      <![CDATA[@param effectType the effect to get by
 @return the matching potion type
 @deprecated Misleading]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This enum reflects and matches each potion state that can be obtained from
 the Creative mode inventory]]>
    </doc>
  </class>
  <!-- end class org.bukkit.potion.PotionType -->
</package>
<package name="org.bukkit.projectiles">
  <!-- start interface org.bukkit.projectiles.BlockProjectileSource -->
  <interface name="BlockProjectileSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.projectiles.ProjectileSource"/>
    <method name="getBlock" return="org.bukkit.block.Block"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the block this projectile source belongs to.

 @return Block for the projectile source]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.projectiles.BlockProjectileSource -->
  <!-- start interface org.bukkit.projectiles.ProjectileSource -->
  <interface name="ProjectileSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="launchProjectile" return="T extends org.bukkit.entity.Projectile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="projectile" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Launches a {@link Projectile} from the ProjectileSource.

 @param <T> a projectile subclass
 @param projectile class of the projectile to launch
 @return the launched projectile]]>
      </doc>
    </method>
    <method name="launchProjectile" return="T extends org.bukkit.entity.Projectile"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="projectile" type="java.lang.Class&lt;? extends T&gt;"/>
      <param name="velocity" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Launches a {@link Projectile} from the ProjectileSource with an
 initial velocity.

 @param <T> a projectile subclass
 @param projectile class of the projectile to launch
 @param velocity the velocity with which to launch
 @return the launched projectile]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a valid source of a projectile.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.projectiles.ProjectileSource -->
</package>
<package name="org.bukkit.scheduler">
  <!-- start class org.bukkit.scheduler.BukkitRunnable -->
  <class name="BukkitRunnable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Runnable"/>
    <constructor name="BukkitRunnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Returns true if this task has been cancelled.

 @return true if the task has been cancelled
 @throws IllegalStateException if task was not scheduled yet]]>
      </doc>
    </method>
    <method name="cancel"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Attempts to cancel this task.

 @throws IllegalStateException if task was not scheduled yet]]>
      </doc>
    </method>
    <method name="runTask" return="org.bukkit.scheduler.BukkitTask"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Schedules this in the Bukkit scheduler to run on next tick.

 @param plugin the reference to the plugin scheduling task
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalStateException if this was already scheduled
 @see BukkitScheduler#runTask(Plugin, Runnable)]]>
      </doc>
    </method>
    <method name="runTaskAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Schedules this in the Bukkit scheduler to run asynchronously.

 @param plugin the reference to the plugin scheduling task
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalStateException if this was already scheduled
 @see BukkitScheduler#runTaskAsynchronously(Plugin, Runnable)]]>
      </doc>
    </method>
    <method name="runTaskLater" return="org.bukkit.scheduler.BukkitTask"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="delay" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Schedules this to run after the specified number of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param delay the ticks to wait before running the task
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalStateException if this was already scheduled
 @see BukkitScheduler#runTaskLater(Plugin, Runnable, long)]]>
      </doc>
    </method>
    <method name="runTaskLaterAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="delay" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Schedules this to run asynchronously after the specified number of
 server ticks.

 @param plugin the reference to the plugin scheduling task
 @param delay the ticks to wait before running the task
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalStateException if this was already scheduled
 @see BukkitScheduler#runTaskLaterAsynchronously(Plugin, Runnable, long)]]>
      </doc>
    </method>
    <method name="runTaskTimer" return="org.bukkit.scheduler.BukkitTask"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Schedules this to repeatedly run until cancelled, starting after the
 specified number of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param delay the ticks to wait before running the task
 @param period the ticks to wait between runs
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalStateException if this was already scheduled
 @see BukkitScheduler#runTaskTimer(Plugin, Runnable, long, long)]]>
      </doc>
    </method>
    <method name="runTaskTimerAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Schedules this to repeatedly run asynchronously until cancelled,
 starting after the specified number of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param delay the ticks to wait before running the task for the first
     time
 @param period the ticks to wait between runs
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalStateException if this was already scheduled
 @see BukkitScheduler#runTaskTimerAsynchronously(Plugin, Runnable, long,
     long)]]>
      </doc>
    </method>
    <method name="getTaskId" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the task id for this runnable.

 @return the task id that this runnable was scheduled as
 @throws IllegalStateException if task was not scheduled yet]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class is provided as an easy way to handle scheduling tasks.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.scheduler.BukkitRunnable -->
  <!-- start interface org.bukkit.scheduler.BukkitScheduler -->
  <interface name="BukkitScheduler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="scheduleSyncDelayedTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <doc>
      <![CDATA[Schedules a once off task to occur after a delay.
 <p>
 This task will be executed by the main server thread.

 @param plugin Plugin that owns the task
 @param task Task to be executed
 @param delay Delay in server ticks before executing task
 @return Task id number (-1 if scheduling failed)]]>
      </doc>
    </method>
    <method name="scheduleSyncDelayedTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTaskLater(Plugin, long)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <param name="delay" type="long"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTaskLater(Plugin, long)}
 @param plugin Plugin that owns the task
 @param task Task to be executed
 @param delay Delay in server ticks before executing task
 @return Task id number (-1 if scheduling failed)]]>
      </doc>
    </method>
    <method name="scheduleSyncDelayedTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[Schedules a once off task to occur as soon as possible.
 <p>
 This task will be executed by the main server thread.

 @param plugin Plugin that owns the task
 @param task Task to be executed
 @return Task id number (-1 if scheduling failed)]]>
      </doc>
    </method>
    <method name="scheduleSyncDelayedTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTask(Plugin)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTask(Plugin)}
 @param plugin Plugin that owns the task
 @param task Task to be executed
 @return Task id number (-1 if scheduling failed)]]>
      </doc>
    </method>
    <method name="scheduleSyncRepeatingTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <doc>
      <![CDATA[Schedules a repeating task.
 <p>
 This task will be executed by the main server thread.

 @param plugin Plugin that owns the task
 @param task Task to be executed
 @param delay Delay in server ticks before executing first repeat
 @param period Period in server ticks of the task
 @return Task id number (-1 if scheduling failed)]]>
      </doc>
    </method>
    <method name="scheduleSyncRepeatingTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTaskTimer(Plugin, long, long)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTaskTimer(Plugin, long, long)}
 @param plugin Plugin that owns the task
 @param task Task to be executed
 @param delay Delay in server ticks before executing first repeat
 @param period Period in server ticks of the task
 @return Task id number (-1 if scheduling failed)]]>
      </doc>
    </method>
    <method name="scheduleAsyncDelayedTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This name is misleading, as it does not schedule quote_cHaRa syncquote_cHaR
     task, but rather, quote_cHaRan asyncquote_cHaR task">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Schedules a once off task to occur after a delay. This task will be
 executed by a thread managed by the scheduler.

 @param plugin Plugin that owns the task
 @param task Task to be executed
 @param delay Delay in server ticks before executing task
 @return Task id number (-1 if scheduling failed)
 @deprecated This name is misleading, as it does not schedule "a sync"
     task, but rather, "an async" task]]>
      </doc>
    </method>
    <method name="scheduleAsyncDelayedTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This name is misleading, as it does not schedule quote_cHaRa syncquote_cHaR
     task, but rather, quote_cHaRan asyncquote_cHaR task">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Schedules a once off task to occur as soon as possible. This task will
 be executed by a thread managed by the scheduler.

 @param plugin Plugin that owns the task
 @param task Task to be executed
 @return Task id number (-1 if scheduling failed)
 @deprecated This name is misleading, as it does not schedule "a sync"
     task, but rather, "an async" task]]>
      </doc>
    </method>
    <method name="scheduleAsyncRepeatingTask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This name is misleading, as it does not schedule quote_cHaRa syncquote_cHaR
     task, but rather, quote_cHaRan asyncquote_cHaR task">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Schedules a repeating task. This task will be executed by a thread
 managed by the scheduler.

 @param plugin Plugin that owns the task
 @param task Task to be executed
 @param delay Delay in server ticks before executing first repeat
 @param period Period in server ticks of the task
 @return Task id number (-1 if scheduling failed)
 @deprecated This name is misleading, as it does not schedule "a sync"
     task, but rather, "an async" task]]>
      </doc>
    </method>
    <method name="callSyncMethod" return="java.util.concurrent.Future&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <doc>
      <![CDATA[Calls a method on the main thread and returns a Future object. This
 task will be executed by the main server thread.
 <ul>
 <li>Note: The Future.get() methods must NOT be called from the main
     thread.
 <li>Note2: There is at least an average of 10ms latency until the
     isDone() method returns true.
 </ul>
 @param <T> The callable's return type
 @param plugin Plugin that owns the task
 @param task Task to be executed
 @return Future Future object related to the task]]>
      </doc>
    </method>
    <method name="cancelTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="taskId" type="int"/>
      <doc>
      <![CDATA[Removes task from scheduler.

 @param taskId Id number of task to be removed]]>
      </doc>
    </method>
    <method name="cancelTasks"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <doc>
      <![CDATA[Removes all tasks associated with a particular plugin from the
 scheduler.

 @param plugin Owner of tasks to be removed]]>
      </doc>
    </method>
    <method name="isCurrentlyRunning" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="taskId" type="int"/>
      <doc>
      <![CDATA[Check if the task currently running.
 <p>
 A repeating task might not be running currently, but will be running in
 the future. A task that has finished, and does not repeat, will not be
 running ever again.
 <p>
 Explicitly, a task is running if there exists a thread for it, and that
 thread is alive.

 @param taskId The task to check.
 <p>
 @return If the task is currently running.]]>
      </doc>
    </method>
    <method name="isQueued" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="taskId" type="int"/>
      <doc>
      <![CDATA[Check if the task queued to be run later.
 <p>
 If a repeating task is currently running, it might not be queued now
 but could be in the future. A task that is not queued, and not running,
 will not be queued again.

 @param taskId The task to check.
 <p>
 @return If the task is queued to be run.]]>
      </doc>
    </method>
    <method name="getActiveWorkers" return="java.util.List&lt;org.bukkit.scheduler.BukkitWorker&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of all active workers.
 <p>
 This list contains asynch tasks that are being executed by separate
 threads.

 @return Active workers]]>
      </doc>
    </method>
    <method name="getPendingTasks" return="java.util.List&lt;org.bukkit.scheduler.BukkitTask&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list of all pending tasks. The ordering of the tasks is not
 related to their order of execution.

 @return Active workers]]>
      </doc>
    </method>
    <method name="runTask" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns a task that will run on the next server tick.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.util.function.Consumer&lt;org.bukkit.scheduler.BukkitTask&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns a task that will run on the next server tick.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTask" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTask(Plugin)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTask(Plugin)}

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Returns a task that will run asynchronously.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskAsynchronously"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.util.function.Consumer&lt;org.bukkit.scheduler.BukkitTask&gt;"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Returns a task that will run asynchronously.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTaskAsynchronously(Plugin)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTaskAsynchronously(Plugin)}
 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskLater" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns a task that will run after the specified number of server
 ticks.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskLater"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.util.function.Consumer&lt;org.bukkit.scheduler.BukkitTask&gt;"/>
      <param name="delay" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns a task that will run after the specified number of server
 ticks.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskLater" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTaskLater(Plugin, long)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <param name="delay" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTaskLater(Plugin, long)}
 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskLaterAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Returns a task that will run asynchronously after the specified number
 of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskLaterAsynchronously"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.util.function.Consumer&lt;org.bukkit.scheduler.BukkitTask&gt;"/>
      <param name="delay" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Returns a task that will run asynchronously after the specified number
 of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskLaterAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTaskLaterAsynchronously(Plugin, long)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <param name="delay" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTaskLaterAsynchronously(Plugin, long)}
 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskTimer" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns a task that will repeatedly run until cancelled, starting after
 the specified number of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @param period the ticks to wait between runs
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskTimer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.util.function.Consumer&lt;org.bukkit.scheduler.BukkitTask&gt;"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Returns a task that will repeatedly run until cancelled, starting after
 the specified number of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @param period the ticks to wait between runs
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskTimer" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTaskTimer(Plugin, long, long)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTaskTimer(Plugin, long, long)}
 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task
 @param period the ticks to wait between runs
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskTimerAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Returns a task that will repeatedly run asynchronously until cancelled,
 starting after the specified number of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task for the first
     time
 @param period the ticks to wait between runs
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskTimerAsynchronously"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="java.util.function.Consumer&lt;org.bukkit.scheduler.BukkitTask&gt;"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[<b>Asynchronous tasks should never access any API in Bukkit. Great care
 should be taken to assure the thread-safety of asynchronous tasks.</b>
 <p>
 Returns a task that will repeatedly run asynchronously until cancelled,
 starting after the specified number of server ticks.

 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task for the first
     time
 @param period the ticks to wait between runs
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
    <method name="runTaskTimerAsynchronously" return="org.bukkit.scheduler.BukkitTask"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link BukkitRunnable#runTaskTimerAsynchronously(Plugin, long, long)}">
      <param name="plugin" type="org.bukkit.plugin.Plugin"/>
      <param name="task" type="org.bukkit.scheduler.BukkitRunnable"/>
      <param name="delay" type="long"/>
      <param name="period" type="long"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[@deprecated Use {@link BukkitRunnable#runTaskTimerAsynchronously(Plugin, long, long)}
 @param plugin the reference to the plugin scheduling task
 @param task the task to be run
 @param delay the ticks to wait before running the task for the first
     time
 @param period the ticks to wait between runs
 @return a BukkitTask that contains the id number
 @throws IllegalArgumentException if plugin is null
 @throws IllegalArgumentException if task is null]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.bukkit.scheduler.BukkitScheduler -->
  <!-- start interface org.bukkit.scheduler.BukkitTask -->
  <interface name="BukkitTask"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTaskId" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the taskId for the task.

 @return Task id number]]>
      </doc>
    </method>
    <method name="getOwner" return="org.bukkit.plugin.Plugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Plugin that owns this task.

 @return The Plugin that owns the task]]>
      </doc>
    </method>
    <method name="isSync" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the Task is a sync task.

 @return true if the task is run by main thread]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this task has been cancelled.

 @return true if the task has been cancelled]]>
      </doc>
    </method>
    <method name="cancel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Will attempt to cancel this task.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a task being executed by the scheduler]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.scheduler.BukkitTask -->
  <!-- start interface org.bukkit.scheduler.BukkitWorker -->
  <interface name="BukkitWorker"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTaskId" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the taskId for the task being executed by this worker.

 @return Task id number]]>
      </doc>
    </method>
    <method name="getOwner" return="org.bukkit.plugin.Plugin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Plugin that owns this task.

 @return The Plugin that owns the task]]>
      </doc>
    </method>
    <method name="getThread" return="java.lang.Thread"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the thread for the worker.

 @return The Thread object for the worker]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a worker thread for the scheduler. This gives information about
 the Thread object for the task, owner of the task and the taskId.
 <p>
 Workers are used to execute async tasks.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.scheduler.BukkitWorker -->
</package>
<package name="org.bukkit.scoreboard">
  <!-- start class org.bukkit.scoreboard.Criterias -->
  <class name="Criterias" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="HEALTH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PLAYER_KILLS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TOTAL_KILLS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEATHS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Criteria names which trigger an objective to be modified by actions in-game]]>
    </doc>
  </class>
  <!-- end class org.bukkit.scoreboard.Criterias -->
  <!-- start class org.bukkit.scoreboard.DisplaySlot -->
  <class name="DisplaySlot" extends="java.lang.Enum&lt;org.bukkit.scoreboard.DisplaySlot&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.scoreboard.DisplaySlot[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.scoreboard.DisplaySlot"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Locations for displaying objectives to the player]]>
    </doc>
  </class>
  <!-- end class org.bukkit.scoreboard.DisplaySlot -->
  <!-- start class org.bukkit.scoreboard.NameTagVisibility -->
  <class name="NameTagVisibility" extends="java.lang.Enum&lt;org.bukkit.scoreboard.NameTagVisibility&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="replaced by {@link Team.OptionStatus}">
    <method name="values" return="org.bukkit.scoreboard.NameTagVisibility[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.scoreboard.NameTagVisibility"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[@deprecated replaced by {@link Team.OptionStatus}]]>
    </doc>
  </class>
  <!-- end class org.bukkit.scoreboard.NameTagVisibility -->
  <!-- start interface org.bukkit.scoreboard.Objective -->
  <interface name="Objective"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the name of this Objective

 @return this objective's name
 @throws IllegalStateException if this objective has been unregistered]]>
      </doc>
    </method>
    <method name="getDisplayName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the name displayed to players for this objective

 @return this objective's display name
 @throws IllegalStateException if this objective has been unregistered]]>
      </doc>
    </method>
    <method name="setDisplayName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="displayName" type="java.lang.String"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the name displayed to players for this objective.

 @param displayName Display name to set
 @throws IllegalStateException if this objective has been unregistered
 @throws IllegalArgumentException if displayName is null
 @throws IllegalArgumentException if displayName is longer than 128
     characters.]]>
      </doc>
    </method>
    <method name="getCriteria" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the criteria this objective tracks.

 @return this objective's criteria
 @throws IllegalStateException if this objective has been unregistered]]>
      </doc>
    </method>
    <method name="isModifiable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets if the objective's scores can be modified directly by a plugin.

 @return true if scores are modifiable
 @throws IllegalStateException if this objective has been unregistered
 @see Criterias#HEALTH]]>
      </doc>
    </method>
    <method name="getScoreboard" return="org.bukkit.scoreboard.Scoreboard"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the scoreboard to which this objective is attached.

 @return Owning scoreboard, or null if it has been {@link #unregister()
     unregistered}]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Unregisters this objective from the {@link Scoreboard scoreboard.}

 @throws IllegalStateException if this objective has been unregistered]]>
      </doc>
    </method>
    <method name="setDisplaySlot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.scoreboard.DisplaySlot"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Sets this objective to display on the specified slot for the
 scoreboard, removing it from any other display slot.

 @param slot display slot to change, or null to not display
 @throws IllegalStateException if this objective has been unregistered]]>
      </doc>
    </method>
    <method name="getDisplaySlot" return="org.bukkit.scoreboard.DisplaySlot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the display slot this objective is displayed at.

 @return the display slot for this objective, or null if not displayed
 @throws IllegalStateException if this objective has been unregistered]]>
      </doc>
    </method>
    <method name="setRenderType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renderType" type="org.bukkit.scoreboard.RenderType"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Sets manner in which this objective will be rendered.

 @param renderType new render type
 @throws IllegalStateException if this objective has been unregistered]]>
      </doc>
    </method>
    <method name="getRenderType" return="org.bukkit.scoreboard.RenderType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Sets manner in which this objective will be rendered.

 @return the render type
 @throws IllegalStateException if this objective has been unregistered]]>
      </doc>
    </method>
    <method name="getScore" return="org.bukkit.scoreboard.Score"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Scoreboards can contain entries that aren't players">
      <param name="player" type="org.bukkit.OfflinePlayer"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets a player's Score for an Objective on this Scoreboard

 @param player Player for the Score
 @return Score tracking the Objective and player specified
 @throws IllegalArgumentException if player is null
 @throws IllegalStateException if this objective has been unregistered
 @deprecated Scoreboards can contain entries that aren't players
 @see #getScore(String)]]>
      </doc>
    </method>
    <method name="getScore" return="org.bukkit.scoreboard.Score"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets an entry's Score for an Objective on this Scoreboard.

 @param entry Entry for the Score
 @return Score tracking the Objective and entry specified
 @throws IllegalArgumentException if entry is null
 @throws IllegalStateException if this objective has been unregistered
 @throws IllegalArgumentException if entry is longer than 40 characters.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An objective on a scoreboard that can show scores specific to entries. This
 objective is only relevant to the display of the associated {@link
 #getScoreboard() scoreboard}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.scoreboard.Objective -->
  <!-- start class org.bukkit.scoreboard.RenderType -->
  <class name="RenderType" extends="java.lang.Enum&lt;org.bukkit.scoreboard.RenderType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.scoreboard.RenderType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.scoreboard.RenderType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Controls the way in which an {@link Objective} is rendered client side.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.scoreboard.RenderType -->
  <!-- start interface org.bukkit.scoreboard.Score -->
  <interface name="Score"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPlayer" return="org.bukkit.OfflinePlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Scoreboards can contain entries that aren't players">
      <doc>
      <![CDATA[Gets the OfflinePlayer being tracked by this Score

 @return this Score's tracked player
 @deprecated Scoreboards can contain entries that aren't players
 @see #getEntry()]]>
      </doc>
    </method>
    <method name="getEntry" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the entry being tracked by this Score

 @return this Score's tracked entry]]>
      </doc>
    </method>
    <method name="getObjective" return="org.bukkit.scoreboard.Objective"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Objective being tracked by this Score

 @return this Score's tracked objective]]>
      </doc>
    </method>
    <method name="getScore" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the current score

 @return the current score
 @throws IllegalStateException if the associated objective has been
     unregistered]]>
      </doc>
    </method>
    <method name="setScore"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="score" type="int"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Sets the current score.

 @param score New score
 @throws IllegalStateException if the associated objective has been
     unregistered]]>
      </doc>
    </method>
    <method name="isScoreSet" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Shows if this score has been set at any point in time.

 @return if this score has been set before
 @throws IllegalStateException if the associated objective has been
     unregistered]]>
      </doc>
    </method>
    <method name="getScoreboard" return="org.bukkit.scoreboard.Scoreboard"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the scoreboard for the associated objective.

 @return the owning objective's scoreboard, or null if it has been
     {@link Objective#unregister() unregistered}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A score entry for an {@link #getEntry() entry} on an {@link
 #getObjective() objective}. Changing this will not affect any other
 objective or scoreboard.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.scoreboard.Score -->
  <!-- start interface org.bukkit.scoreboard.Scoreboard -->
  <interface name="Scoreboard"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="registerNewObjective" return="org.bukkit.scoreboard.Objective"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="a displayName should be explicitly specified">
      <param name="name" type="java.lang.String"/>
      <param name="criteria" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Registers an Objective on this Scoreboard

 @param name Name of the Objective
 @param criteria Criteria for the Objective
 @return The registered Objective
 @throws IllegalArgumentException if name is null
 @throws IllegalArgumentException if name is longer than 16
     characters.
 @throws IllegalArgumentException if criteria is null
 @throws IllegalArgumentException if an objective by that name already
     exists
 @deprecated a displayName should be explicitly specified]]>
      </doc>
    </method>
    <method name="registerNewObjective" return="org.bukkit.scoreboard.Objective"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="criteria" type="java.lang.String"/>
      <param name="displayName" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Registers an Objective on this Scoreboard

 @param name Name of the Objective
 @param criteria Criteria for the Objective
 @param displayName Name displayed to players for the Objective.
 @return The registered Objective
 @throws IllegalArgumentException if name is null
 @throws IllegalArgumentException if name is longer than 16
     characters.
 @throws IllegalArgumentException if criteria is null
 @throws IllegalArgumentException if displayName is null
 @throws IllegalArgumentException if displayName is longer than 128
     characters.
 @throws IllegalArgumentException if an objective by that name already
     exists]]>
      </doc>
    </method>
    <method name="registerNewObjective" return="org.bukkit.scoreboard.Objective"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="criteria" type="java.lang.String"/>
      <param name="displayName" type="java.lang.String"/>
      <param name="renderType" type="org.bukkit.scoreboard.RenderType"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Registers an Objective on this Scoreboard

 @param name Name of the Objective
 @param criteria Criteria for the Objective
 @param displayName Name displayed to players for the Objective.
 @param renderType Manner of rendering the Objective
 @return The registered Objective
 @throws IllegalArgumentException if name is null
 @throws IllegalArgumentException if name is longer than 16
     characters.
 @throws IllegalArgumentException if criteria is null
 @throws IllegalArgumentException if displayName is null
 @throws IllegalArgumentException if displayName is longer than 128
     characters.
 @throws IllegalArgumentException if renderType is null
 @throws IllegalArgumentException if an objective by that name already
     exists]]>
      </doc>
    </method>
    <method name="getObjective" return="org.bukkit.scoreboard.Objective"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets an Objective on this Scoreboard by name

 @param name Name of the Objective
 @return the Objective or null if it does not exist
 @throws IllegalArgumentException if name is null]]>
      </doc>
    </method>
    <method name="getObjectivesByCriteria" return="java.util.Set&lt;org.bukkit.scoreboard.Objective&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="criteria" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets all Objectives of a Criteria on the Scoreboard

 @param criteria Criteria to search by
 @return an immutable set of Objectives using the specified Criteria
 @throws IllegalArgumentException if criteria is null]]>
      </doc>
    </method>
    <method name="getObjectives" return="java.util.Set&lt;org.bukkit.scoreboard.Objective&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all Objectives on this Scoreboard

 @return An immutable set of all Objectives on this Scoreboard]]>
      </doc>
    </method>
    <method name="getObjective" return="org.bukkit.scoreboard.Objective"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.scoreboard.DisplaySlot"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets the Objective currently displayed in a DisplaySlot on this
 Scoreboard

 @param slot The DisplaySlot
 @return the Objective currently displayed or null if nothing is
     displayed in that DisplaySlot
 @throws IllegalArgumentException if slot is null]]>
      </doc>
    </method>
    <method name="getScores" return="java.util.Set&lt;org.bukkit.scoreboard.Score&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Scoreboards can contain entries that aren't players">
      <param name="player" type="org.bukkit.OfflinePlayer"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets all scores for a player on this Scoreboard

 @param player the player whose scores are being retrieved
 @return immutable set of all scores tracked for the player
 @throws IllegalArgumentException if player is null
 @deprecated Scoreboards can contain entries that aren't players
 @see #getScores(String)]]>
      </doc>
    </method>
    <method name="getScores" return="java.util.Set&lt;org.bukkit.scoreboard.Score&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets all scores for an entry on this Scoreboard

 @param entry the entry whose scores are being retrieved
 @return immutable set of all scores tracked for the entry
 @throws IllegalArgumentException if entry is null]]>
      </doc>
    </method>
    <method name="resetScores"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Scoreboards can contain entries that aren't players">
      <param name="player" type="org.bukkit.OfflinePlayer"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Removes all scores for a player on this Scoreboard

 @param player the player to drop all current scores for
 @throws IllegalArgumentException if player is null
 @deprecated Scoreboards can contain entries that aren't players
 @see #resetScores(String)]]>
      </doc>
    </method>
    <method name="resetScores"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Removes all scores for an entry on this Scoreboard

 @param entry the entry to drop all current scores for
 @throws IllegalArgumentException if entry is null]]>
      </doc>
    </method>
    <method name="getPlayerTeam" return="org.bukkit.scoreboard.Team"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Scoreboards can contain entries that aren't players">
      <param name="player" type="org.bukkit.OfflinePlayer"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets a player's Team on this Scoreboard

 @param player the player to search for
 @return the player's Team or null if the player is not on a team
 @throws IllegalArgumentException if player is null
 @deprecated Scoreboards can contain entries that aren't players
 @see #getEntryTeam(String)]]>
      </doc>
    </method>
    <method name="getEntryTeam" return="org.bukkit.scoreboard.Team"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets a entries Team on this Scoreboard

 @param entry the entry to search for
 @return the entries Team or null if the entry is not on a team
 @throws IllegalArgumentException if entry is null]]>
      </doc>
    </method>
    <method name="getTeam" return="org.bukkit.scoreboard.Team"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="teamName" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets a Team by name on this Scoreboard

 @param teamName Team name
 @return the matching Team or null if no matches
 @throws IllegalArgumentException if teamName is null]]>
      </doc>
    </method>
    <method name="getTeams" return="java.util.Set&lt;org.bukkit.scoreboard.Team&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all teams on this Scoreboard

 @return an immutable set of Teams]]>
      </doc>
    </method>
    <method name="registerNewTeam" return="org.bukkit.scoreboard.Team"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Registers a Team on this Scoreboard

 @param name Team name
 @return registered Team
 @throws IllegalArgumentException if name is null
 @throws IllegalArgumentException if team by that name already exists]]>
      </doc>
    </method>
    <method name="getPlayers" return="java.util.Set&lt;org.bukkit.OfflinePlayer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Scoreboards can contain entries that aren't players">
      <doc>
      <![CDATA[Gets all players tracked by this Scoreboard

 @return immutable set of all tracked players
 @deprecated Scoreboards can contain entries that aren't players
 @see #getEntries()]]>
      </doc>
    </method>
    <method name="getEntries" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all entries tracked by this Scoreboard

 @return immutable set of all tracked entries]]>
      </doc>
    </method>
    <method name="clearSlot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slot" type="org.bukkit.scoreboard.DisplaySlot"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Clears any objective in the specified slot.

 @param slot the slot to remove objectives
 @throws IllegalArgumentException if slot is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A scoreboard]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.scoreboard.Scoreboard -->
  <!-- start interface org.bukkit.scoreboard.ScoreboardManager -->
  <interface name="ScoreboardManager"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMainScoreboard" return="org.bukkit.scoreboard.Scoreboard"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the primary Scoreboard controlled by the server.
 <p>
 This Scoreboard is saved by the server, is affected by the /scoreboard
 command, and is the scoreboard shown by default to players.

 @return the default sever scoreboard]]>
      </doc>
    </method>
    <method name="getNewScoreboard" return="org.bukkit.scoreboard.Scoreboard"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a new Scoreboard to be tracked by the server. This scoreboard will
 be tracked as long as a reference is kept, either by a player or by a
 plugin.

 @return the registered Scoreboard
 @see WeakReference]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Manager of Scoreboards]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.scoreboard.ScoreboardManager -->
  <!-- start interface org.bukkit.scoreboard.Team -->
  <interface name="Team"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the name of this Team

 @return Objective name
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="getDisplayName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the name displayed to entries for this team

 @return Team display name
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="setDisplayName"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="displayName" type="java.lang.String"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the name displayed to entries for this team

 @param displayName New display name
 @throws IllegalArgumentException if displayName is longer than 128
     characters.
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="getPrefix" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the prefix prepended to the display of entries on this team.

 @return Team prefix
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="setPrefix"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the prefix prepended to the display of entries on this team.

 @param prefix New prefix
 @throws IllegalArgumentException if prefix is null
 @throws IllegalArgumentException if prefix is longer than 64
     characters
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="getSuffix" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the suffix appended to the display of entries on this team.

 @return the team's current suffix
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="setSuffix"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suffix" type="java.lang.String"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Sets the suffix appended to the display of entries on this team.

 @param suffix the new suffix for this team.
 @throws IllegalArgumentException if suffix is null
 @throws IllegalArgumentException if suffix is longer than 64
     characters
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="getColor" return="org.bukkit.ChatColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the color of the team.
 <br>
 This only sets the team outline, other occurrences of colors such as in
 names are handled by prefixes / suffixes.

 @return team color, defaults to {@link ChatColor#RESET}
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="setColor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="color" type="org.bukkit.ChatColor"/>
      <doc>
      <![CDATA[Sets the color of the team.
 <br>
 This only sets the team outline, other occurrences of colors such as in
 names are handled by prefixes / suffixes.

 @param color new color, must be non-null. Use {@link ChatColor#RESET} for
 no color]]>
      </doc>
    </method>
    <method name="allowFriendlyFire" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the team friendly fire state

 @return true if friendly fire is enabled
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="setAllowFriendlyFire"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Sets the team friendly fire state

 @param enabled true if friendly fire is to be allowed
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="canSeeFriendlyInvisibles" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the team's ability to see {@link PotionEffectType#INVISIBILITY
 invisible} teammates.

 @return true if team members can see invisible members
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="setCanSeeFriendlyInvisibles"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Sets the team's ability to see {@link PotionEffectType#INVISIBILITY
 invisible} teammates.

 @param enabled true if invisible teammates are to be visible
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="getNameTagVisibility" return="org.bukkit.scoreboard.NameTagVisibility"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see {@link #getOption(org.bukkit.scoreboard.Team.Option)}">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Gets the team's ability to see name tags

 @return the current name tag visibility for the team
 @throws IllegalArgumentException if this team has been unregistered
 @deprecated see {@link #getOption(org.bukkit.scoreboard.Team.Option)}]]>
      </doc>
    </method>
    <method name="setNameTagVisibility"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="see
 {@link #setOption(org.bukkit.scoreboard.Team.Option, org.bukkit.scoreboard.Team.OptionStatus)}">
      <param name="visibility" type="org.bukkit.scoreboard.NameTagVisibility"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Set's the team's ability to see name tags

 @param visibility The nameTagVisibility to set
 @throws IllegalArgumentException if this team has been unregistered
 @deprecated see
 {@link #setOption(org.bukkit.scoreboard.Team.Option, org.bukkit.scoreboard.Team.OptionStatus)}]]>
      </doc>
    </method>
    <method name="getPlayers" return="java.util.Set&lt;org.bukkit.OfflinePlayer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Teams can contain entries that aren't players">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the Set of players on the team

 @return players on the team
 @throws IllegalStateException if this team has been unregistered\
 @deprecated Teams can contain entries that aren't players
 @see #getEntries()]]>
      </doc>
    </method>
    <method name="getEntries" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the Set of entries on the team

 @return entries on the team
 @throws IllegalStateException if this entries has been unregistered\]]>
      </doc>
    </method>
    <method name="getSize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Gets the size of the team

 @return number of entries on the team
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="getScoreboard" return="org.bukkit.scoreboard.Scoreboard"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Scoreboard to which this team is attached

 @return Owning scoreboard, or null if this team has been {@link
     #unregister() unregistered}]]>
      </doc>
    </method>
    <method name="addPlayer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Teams can contain entries that aren't players">
      <param name="player" type="org.bukkit.OfflinePlayer"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[This puts the specified player onto this team for the scoreboard.
 <p>
 This will remove the player from any other team on the scoreboard.

 @param player the player to add
 @throws IllegalArgumentException if player is null
 @throws IllegalStateException if this team has been unregistered
 @deprecated Teams can contain entries that aren't players
 @see #addEntry(String)]]>
      </doc>
    </method>
    <method name="addEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.lang.String"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[This puts the specified entry onto this team for the scoreboard.
 <p>
 This will remove the entry from any other team on the scoreboard.

 @param entry the entry to add
 @throws IllegalArgumentException if entry is null
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="removePlayer" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Teams can contain entries that aren't players">
      <param name="player" type="org.bukkit.OfflinePlayer"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Removes the player from this team.

 @param player the player to remove
 @return if the player was on this team
 @throws IllegalArgumentException if player is null
 @throws IllegalStateException if this team has been unregistered
 @deprecated Teams can contain entries that aren't players
 @see #removeEntry(String)]]>
      </doc>
    </method>
    <method name="removeEntry" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.lang.String"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Removes the entry from this team.

 @param entry the entry to remove
 @return if the entry was a part of this team
 @throws IllegalArgumentException if entry is null
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Unregisters this team from the Scoreboard

 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="hasPlayer" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Teams can contain entries that aren't players">
      <param name="player" type="org.bukkit.OfflinePlayer"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Checks to see if the specified player is a member of this team.

 @param player the player to search for
 @return true if the player is a member of this team
 @throws IllegalArgumentException if player is null
 @throws IllegalStateException if this team has been unregistered
 @deprecated Teams can contain entries that aren't players
 @see #hasEntry(String)]]>
      </doc>
    </method>
    <method name="hasEntry" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Checks to see if the specified entry is a member of this team.

 @param entry the entry to search for
 @return true if the entry is a member of this team
 @throws IllegalArgumentException if entry is null
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="getOption" return="org.bukkit.scoreboard.Team.OptionStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="org.bukkit.scoreboard.Team.Option"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Get an option for this team

 @param option the option to get
 @return the option status
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <method name="setOption"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="org.bukkit.scoreboard.Team.Option"/>
      <param name="status" type="org.bukkit.scoreboard.Team.OptionStatus"/>
      <exception name="IllegalStateException" type="java.lang.IllegalStateException"/>
      <doc>
      <![CDATA[Set an option for this team

 @param option the option to set
 @param status the new option status
 @throws IllegalStateException if this team has been unregistered]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A team on a scoreboard that has a common display theme and other
 properties. This team is only relevant to the display of the associated
 {@link #getScoreboard() scoreboard}.]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.scoreboard.Team -->
  <!-- start class org.bukkit.scoreboard.Team.Option -->
  <class name="Team.Option" extends="java.lang.Enum&lt;org.bukkit.scoreboard.Team.Option&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.scoreboard.Team.Option[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.scoreboard.Team.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Represents an option which may be applied to this team.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.scoreboard.Team.Option -->
  <!-- start class org.bukkit.scoreboard.Team.OptionStatus -->
  <class name="Team.OptionStatus" extends="java.lang.Enum&lt;org.bukkit.scoreboard.Team.OptionStatus&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.bukkit.scoreboard.Team.OptionStatus[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.bukkit.scoreboard.Team.OptionStatus"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[How an option may be applied to members of this team.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.scoreboard.Team.OptionStatus -->
</package>
<package name="org.bukkit.util">
  <!-- start class org.bukkit.util.BlockIterator -->
  <class name="BlockIterator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;org.bukkit.block.Block&gt;"/>
    <constructor name="BlockIterator" type="org.bukkit.World, org.bukkit.util.Vector, org.bukkit.util.Vector, double, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the BlockIterator.
 <p>
 This considers all blocks as 1x1x1 in size.

 @param world The world to use for tracing
 @param start A Vector giving the initial location for the trace
 @param direction A Vector pointing in the direction for the trace
 @param yOffset The trace begins vertically offset from the start vector
     by this value
 @param maxDistance This is the maximum distance in blocks for the
     trace. Setting this value above 140 may lead to problems with
     unloaded chunks. A value of 0 indicates no limit]]>
      </doc>
    </constructor>
    <constructor name="BlockIterator" type="org.bukkit.Location, double, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the BlockIterator.
 <p>
 This considers all blocks as 1x1x1 in size.

 @param loc The location for the start of the ray trace
 @param yOffset The trace begins vertically offset from the start vector
     by this value
 @param maxDistance This is the maximum distance in blocks for the
     trace. Setting this value above 140 may lead to problems with
     unloaded chunks. A value of 0 indicates no limit]]>
      </doc>
    </constructor>
    <constructor name="BlockIterator" type="org.bukkit.Location, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the BlockIterator.
 <p>
 This considers all blocks as 1x1x1 in size.

 @param loc The location for the start of the ray trace
 @param yOffset The trace begins vertically offset from the start vector
     by this value]]>
      </doc>
    </constructor>
    <constructor name="BlockIterator" type="org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the BlockIterator.
 <p>
 This considers all blocks as 1x1x1 in size.

 @param loc The location for the start of the ray trace]]>
      </doc>
    </constructor>
    <constructor name="BlockIterator" type="org.bukkit.entity.LivingEntity, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the BlockIterator.
 <p>
 This considers all blocks as 1x1x1 in size.

 @param entity Information from the entity is used to set up the trace
 @param maxDistance This is the maximum distance in blocks for the
     trace. Setting this value above 140 may lead to problems with
     unloaded chunks. A value of 0 indicates no limit]]>
      </doc>
    </constructor>
    <constructor name="BlockIterator" type="org.bukkit.entity.LivingEntity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the BlockIterator.
 <p>
 This considers all blocks as 1x1x1 in size.

 @param entity Information from the entity is used to set up the trace]]>
      </doc>
    </constructor>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the iteration has more elements]]>
      </doc>
    </method>
    <method name="next" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="NoSuchElementException" type="java.util.NoSuchElementException"/>
      <doc>
      <![CDATA[Returns the next Block in the trace

 @return the next Block in the trace]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class performs ray tracing and iterates along blocks on a line]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.BlockIterator -->
  <!-- start class org.bukkit.util.BlockVector -->
  <class name="BlockVector" extends="org.bukkit.util.Vector"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockVector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with all components as 0.]]>
      </doc>
    </constructor>
    <constructor name="BlockVector" type="org.bukkit.util.Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with another vector.

 @param vec The other vector.]]>
      </doc>
    </constructor>
    <constructor name="BlockVector" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with provided integer components.

 @param x X component
 @param y Y component
 @param z Z component]]>
      </doc>
    </constructor>
    <constructor name="BlockVector" type="double, double, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with provided double components.

 @param x X component
 @param y Y component
 @param z Z component]]>
      </doc>
    </constructor>
    <constructor name="BlockVector" type="float, float, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with provided float components.

 @param x X component
 @param y Y component
 @param z Z component]]>
      </doc>
    </constructor>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Checks if another object is equivalent.

 @param obj The other object
 @return whether the other object is equivalent]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code for this vector.

 @return hash code]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.util.BlockVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a new block vector.

 @return vector]]>
      </doc>
    </method>
    <method name="deserialize" return="org.bukkit.util.BlockVector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <doc>
    <![CDATA[A vector with a hash function that floors the X, Y, Z components, a la
 BlockVector in WorldEdit. BlockVectors can be used in hash sets and
 hash maps. Be aware that BlockVectors are mutable, but it is important
 that BlockVectors are never changed once put into a hash set or hash map.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.BlockVector -->
  <!-- start class org.bukkit.util.BoundingBox -->
  <class name="BoundingBox" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <constructor name="BoundingBox"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new (degenerate) bounding box with all corner coordinates at
 <code>0</code>.]]>
      </doc>
    </constructor>
    <constructor name="BoundingBox" type="double, double, double, double, double, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new bounding box from the given corner coordinates.

 @param x1 the first corner's x value
 @param y1 the first corner's y value
 @param z1 the first corner's z value
 @param x2 the second corner's x value
 @param y2 the second corner's y value
 @param z2 the second corner's z value]]>
      </doc>
    </constructor>
    <method name="of" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="corner1" type="org.bukkit.util.Vector"/>
      <param name="corner2" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Creates a new bounding box using the coordinates of the given vectors as
 corners.

 @param corner1 the first corner
 @param corner2 the second corner
 @return the bounding box]]>
      </doc>
    </method>
    <method name="of" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="corner1" type="org.bukkit.Location"/>
      <param name="corner2" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Creates a new bounding box using the coordinates of the given locations
 as corners.

 @param corner1 the first corner
 @param corner2 the second corner
 @return the bounding box]]>
      </doc>
    </method>
    <method name="of" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="corner1" type="org.bukkit.block.Block"/>
      <param name="corner2" type="org.bukkit.block.Block"/>
      <doc>
      <![CDATA[Creates a new bounding box using the coordinates of the given blocks as
 corners.
 <p>
 The bounding box will be sized to fully contain both blocks.

 @param corner1 the first corner block
 @param corner2 the second corner block
 @return the bounding box]]>
      </doc>
    </method>
    <method name="of" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.bukkit.block.Block"/>
      <doc>
      <![CDATA[Creates a new 1x1x1 sized bounding box containing the given block.

 @param block the block
 @return the bounding box]]>
      </doc>
    </method>
    <method name="of" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="center" type="org.bukkit.util.Vector"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Creates a new bounding box using the given center and extents.

 @param center the center
 @param x 1/2 the size of the bounding box along the x axis
 @param y 1/2 the size of the bounding box along the y axis
 @param z 1/2 the size of the bounding box along the z axis
 @return the bounding box]]>
      </doc>
    </method>
    <method name="of" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="center" type="org.bukkit.Location"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Creates a new bounding box using the given center and extents.

 @param center the center
 @param x 1/2 the size of the bounding box along the x axis
 @param y 1/2 the size of the bounding box along the y axis
 @param z 1/2 the size of the bounding box along the z axis
 @return the bounding box]]>
      </doc>
    </method>
    <method name="resize" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x1" type="double"/>
      <param name="y1" type="double"/>
      <param name="z1" type="double"/>
      <param name="x2" type="double"/>
      <param name="y2" type="double"/>
      <param name="z2" type="double"/>
      <doc>
      <![CDATA[Resizes this bounding box.

 @param x1 the first corner's x value
 @param y1 the first corner's y value
 @param z1 the first corner's z value
 @param x2 the second corner's x value
 @param y2 the second corner's y value
 @param z2 the second corner's z value
 @return this bounding box (resized)]]>
      </doc>
    </method>
    <method name="getMinX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum x value.

 @return the minimum x value]]>
      </doc>
    </method>
    <method name="getMinY" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum y value.

 @return the minimum y value]]>
      </doc>
    </method>
    <method name="getMinZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum z value.

 @return the minimum z value]]>
      </doc>
    </method>
    <method name="getMin" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the minimum corner as vector.

 @return the minimum corner as vector]]>
      </doc>
    </method>
    <method name="getMaxX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum x value.

 @return the maximum x value]]>
      </doc>
    </method>
    <method name="getMaxY" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum y value.

 @return the maximum y value]]>
      </doc>
    </method>
    <method name="getMaxZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum z value.

 @return the maximum z value]]>
      </doc>
    </method>
    <method name="getMax" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the maximum corner as vector.

 @return the maximum corner vector]]>
      </doc>
    </method>
    <method name="getWidthX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the width of the bounding box in the x direction.

 @return the width in the x direction]]>
      </doc>
    </method>
    <method name="getWidthZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the width of the bounding box in the z direction.

 @return the width in the z direction]]>
      </doc>
    </method>
    <method name="getHeight" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the height of the bounding box.

 @return the height]]>
      </doc>
    </method>
    <method name="getVolume" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the volume of the bounding box.

 @return the volume]]>
      </doc>
    </method>
    <method name="getCenterX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the x coordinate of the center of the bounding box.

 @return the center's x coordinate]]>
      </doc>
    </method>
    <method name="getCenterY" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the y coordinate of the center of the bounding box.

 @return the center's y coordinate]]>
      </doc>
    </method>
    <method name="getCenterZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the z coordinate of the center of the bounding box.

 @return the center's z coordinate]]>
      </doc>
    </method>
    <method name="getCenter" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the center of the bounding box.

 @return the center]]>
      </doc>
    </method>
    <method name="copy" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.BoundingBox"/>
      <doc>
      <![CDATA[Copies another bounding box.

 @param other the other bounding box
 @return this bounding box]]>
      </doc>
    </method>
    <method name="expand" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="negativeX" type="double"/>
      <param name="negativeY" type="double"/>
      <param name="negativeZ" type="double"/>
      <param name="positiveX" type="double"/>
      <param name="positiveY" type="double"/>
      <param name="positiveZ" type="double"/>
      <doc>
      <![CDATA[Expands this bounding box by the given values in the corresponding
 directions.
 <p>
 Negative values will shrink the bounding box in the corresponding
 direction. Shrinking will be limited to the point where the affected
 opposite faces would meet if the they shrank at uniform speeds.

 @param negativeX the amount of expansion in the negative x direction
 @param negativeY the amount of expansion in the negative y direction
 @param negativeZ the amount of expansion in the negative z direction
 @param positiveX the amount of expansion in the positive x direction
 @param positiveY the amount of expansion in the positive y direction
 @param positiveZ the amount of expansion in the positive z direction
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="expand" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Expands this bounding box uniformly by the given values in both positive
 and negative directions.
 <p>
 Negative values will shrink the bounding box. Shrinking will be limited
 to the bounding box's current size.

 @param x the amount of expansion in both positive and negative x
 direction
 @param y the amount of expansion in both positive and negative y
 direction
 @param z the amount of expansion in both positive and negative z
 direction
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="expand" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expansion" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Expands this bounding box uniformly by the given values in both positive
 and negative directions.
 <p>
 Negative values will shrink the bounding box. Shrinking will be limited
 to the bounding box's current size.

 @param expansion the expansion values
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="expand" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expansion" type="double"/>
      <doc>
      <![CDATA[Expands this bounding box uniformly by the given value in all directions.
 <p>
 A negative value will shrink the bounding box. Shrinking will be limited
 to the bounding box's current size.

 @param expansion the amount of expansion
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="expand" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirX" type="double"/>
      <param name="dirY" type="double"/>
      <param name="dirZ" type="double"/>
      <param name="expansion" type="double"/>
      <doc>
      <![CDATA[Expands this bounding box in the specified direction.
 <p>
 The magnitude of the direction will scale the expansion. A negative
 expansion value will shrink the bounding box in this direction. Shrinking
 will be limited to the bounding box's current size.

 @param dirX the x direction component
 @param dirY the y direction component
 @param dirZ the z direction component
 @param expansion the amount of expansion
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="expand" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="expansion" type="double"/>
      <doc>
      <![CDATA[Expands this bounding box in the specified direction.
 <p>
 The magnitude of the direction will scale the expansion. A negative
 expansion value will shrink the bounding box in this direction. Shrinking
 will be limited to the bounding box's current size.

 @param direction the direction
 @param expansion the amount of expansion
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="expand" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blockFace" type="org.bukkit.block.BlockFace"/>
      <param name="expansion" type="double"/>
      <doc>
      <![CDATA[Expands this bounding box in the direction specified by the given block
 face.
 <p>
 A negative expansion value will shrink the bounding box in this
 direction. Shrinking will be limited to the bounding box's current size.

 @param blockFace the block face
 @param expansion the amount of expansion
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="expandDirectional" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirX" type="double"/>
      <param name="dirY" type="double"/>
      <param name="dirZ" type="double"/>
      <doc>
      <![CDATA[Expands this bounding box in the specified direction.
 <p>
 Negative values will expand the bounding box in the negative direction,
 positive values will expand it in the positive direction. The magnitudes
 of the direction components determine the corresponding amounts of
 expansion.

 @param dirX the x direction component
 @param dirY the y direction component
 @param dirZ the z direction component
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="expandDirectional" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="direction" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Expands this bounding box in the specified direction.
 <p>
 Negative values will expand the bounding box in the negative direction,
 positive values will expand it in the positive direction. The magnitude
 of the direction vector determines the amount of expansion.

 @param direction the direction and magnitude of the expansion
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="union" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="posX" type="double"/>
      <param name="posY" type="double"/>
      <param name="posZ" type="double"/>
      <doc>
      <![CDATA[Expands this bounding box to contain (or border) the specified position.

 @param posX the x position value
 @param posY the y position value
 @param posZ the z position value
 @return this bounding box (now expanded)
 @see #contains(double, double, double)]]>
      </doc>
    </method>
    <method name="union" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Expands this bounding box to contain (or border) the specified position.

 @param position the position
 @return this bounding box (now expanded)
 @see #contains(double, double, double)]]>
      </doc>
    </method>
    <method name="union" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Expands this bounding box to contain (or border) the specified position.

 @param position the position
 @return this bounding box (now expanded)
 @see #contains(double, double, double)]]>
      </doc>
    </method>
    <method name="union" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.BoundingBox"/>
      <doc>
      <![CDATA[Expands this bounding box to contain both this and the given bounding
 box.

 @param other the other bounding box
 @return this bounding box (now expanded)]]>
      </doc>
    </method>
    <method name="intersection" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.BoundingBox"/>
      <doc>
      <![CDATA[Resizes this bounding box to represent the intersection of this and the
 given bounding box.

 @param other the other bounding box
 @return this bounding box (now representing the intersection)
 @throws IllegalArgumentException if the bounding boxes don't overlap]]>
      </doc>
    </method>
    <method name="shift" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shiftX" type="double"/>
      <param name="shiftY" type="double"/>
      <param name="shiftZ" type="double"/>
      <doc>
      <![CDATA[Shifts this bounding box by the given amounts.

 @param shiftX the shift in x direction
 @param shiftY the shift in y direction
 @param shiftZ the shift in z direction
 @return this bounding box (now shifted)]]>
      </doc>
    </method>
    <method name="shift" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shift" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Shifts this bounding box by the given amounts.

 @param shift the shift
 @return this bounding box (now shifted)]]>
      </doc>
    </method>
    <method name="shift" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shift" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Shifts this bounding box by the given amounts.

 @param shift the shift
 @return this bounding box (now shifted)]]>
      </doc>
    </method>
    <method name="overlaps" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.BoundingBox"/>
      <doc>
      <![CDATA[Checks if this bounding box overlaps with the given bounding box.
 <p>
 Bounding boxes that are only intersecting at the borders are not
 considered overlapping.

 @param other the other bounding box
 @return <code>true</code> if overlapping]]>
      </doc>
    </method>
    <method name="overlaps" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="min" type="org.bukkit.util.Vector"/>
      <param name="max" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Checks if this bounding box overlaps with the bounding box that is
 defined by the given corners.
 <p>
 Bounding boxes that are only intersecting at the borders are not
 considered overlapping.

 @param min the first corner
 @param max the second corner
 @return <code>true</code> if overlapping]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Checks if this bounding box contains the specified position.
 <p>
 Positions exactly on the minimum borders of the bounding box are
 considered to be inside the bounding box, while positions exactly on the
 maximum borders are considered to be outside. This allows bounding boxes
 to reside directly next to each other with positions always only residing
 in exactly one of them.

 @param x the position's x coordinates
 @param y the position's y coordinates
 @param z the position's z coordinates
 @return <code>true</code> if the bounding box contains the position]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Checks if this bounding box contains the specified position.
 <p>
 Positions exactly on the minimum borders of the bounding box are
 considered to be inside the bounding box, while positions exactly on the
 maximum borders are considered to be outside. This allows bounding boxes
 to reside directly next to each other with positions always only residing
 in exactly one of them.

 @param position the position
 @return <code>true</code> if the bounding box contains the position]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.BoundingBox"/>
      <doc>
      <![CDATA[Checks if this bounding box fully contains the given bounding box.

 @param other the other bounding box
 @return <code>true</code> if the bounding box contains the given bounding
 box]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="min" type="org.bukkit.util.Vector"/>
      <param name="max" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Checks if this bounding box fully contains the bounding box that is
 defined by the given corners.

 @param min the first corner
 @param max the second corner
 @return <code>true</code> if the bounding box contains the specified
     bounding box]]>
      </doc>
    </method>
    <method name="rayTrace" return="org.bukkit.util.RayTraceResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="org.bukkit.util.Vector"/>
      <param name="direction" type="org.bukkit.util.Vector"/>
      <param name="maxDistance" type="double"/>
      <doc>
      <![CDATA[Calculates the intersection of this bounding box with the specified line
 segment.
 <p>
 Intersections at edges and corners yield one of the affected block faces
 as hit result, but it is not defined which of them.

 @param start the start position
 @param direction the ray direction
 @param maxDistance the maximum distance
 @return the ray trace hit result, or <code>null</code> if there is no hit]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a copy of this bounding box.

 @return the cloned bounding box]]>
      </doc>
    </method>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="deserialize" return="org.bukkit.util.BoundingBox"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <doc>
    <![CDATA[A mutable axis aligned bounding box (AABB).
 <p>
 This basically represents a rectangular box (specified by minimum and maximum
 corners) that can for example be used to describe the position and extents of
 an object (such as an entity, block, or rectangular region) in 3D space. Its
 edges and faces are parallel to the axes of the cartesian coordinate system.
 <p>
 The bounding box may be degenerate (one or more sides having the length 0).
 <p>
 Because bounding boxes are mutable, storing them long term may be dangerous
 if they get modified later. If you want to keep around a bounding box, it may
 be wise to call {@link #clone()} in order to get a copy.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.BoundingBox -->
  <!-- start interface org.bukkit.util.CachedServerIcon -->
  <interface name="CachedServerIcon"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getData" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is a cached version of a server-icon. It's internal representation
 and implementation is undefined.

 @see Server#getServerIcon()
 @see Server#loadServerIcon(java.awt.image.BufferedImage)
 @see Server#loadServerIcon(java.io.File)
 @see ServerListPingEvent#setServerIcon(CachedServerIcon)]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.util.CachedServerIcon -->
  <!-- start class org.bukkit.util.ChatPaginator -->
  <class name="ChatPaginator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChatPaginator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="paginate" return="org.bukkit.util.ChatPaginator.ChatPage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unpaginatedString" type="java.lang.String"/>
      <param name="pageNumber" type="int"/>
      <doc>
      <![CDATA[Breaks a raw string up into pages using the default width and height.

 @param unpaginatedString The raw string to break.
 @param pageNumber The page number to fetch.
 @return A single chat page.]]>
      </doc>
    </method>
    <method name="paginate" return="org.bukkit.util.ChatPaginator.ChatPage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unpaginatedString" type="java.lang.String"/>
      <param name="pageNumber" type="int"/>
      <param name="lineLength" type="int"/>
      <param name="pageHeight" type="int"/>
      <doc>
      <![CDATA[Breaks a raw string up into pages using a provided width and height.

 @param unpaginatedString The raw string to break.
 @param pageNumber The page number to fetch.
 @param lineLength The desired width of a chat line.
 @param pageHeight The desired number of lines in a page.
 @return A single chat page.]]>
      </doc>
    </method>
    <method name="wordWrap" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rawString" type="java.lang.String"/>
      <param name="lineLength" type="int"/>
      <doc>
      <![CDATA[Breaks a raw string up into a series of lines. Words are wrapped using
 spaces as decimeters and the newline character is respected.

 @param rawString The raw string to break.
 @param lineLength The length of a line of text.
 @return An array of word-wrapped lines.]]>
      </doc>
    </method>
    <field name="GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AVERAGE_CHAT_PAGE_WIDTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNBOUNDED_PAGE_WIDTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPEN_CHAT_PAGE_HEIGHT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CLOSED_CHAT_PAGE_HEIGHT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNBOUNDED_PAGE_HEIGHT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The ChatPaginator takes a raw string of arbitrary length and breaks it down
 into an array of strings appropriate for displaying on the Minecraft player
 console.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.ChatPaginator -->
  <!-- start class org.bukkit.util.ChatPaginator.ChatPage -->
  <class name="ChatPaginator.ChatPage" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChatPage" type="java.lang.String[], int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPageNumber" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTotalPages" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLines" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.util.ChatPaginator.ChatPage -->
  <!-- start interface org.bukkit.util.Consumer -->
  <interface name="Consumer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Performs this operation on the given argument.

 @param t the input argument]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an operation that accepts a single input argument and returns no
 result.

 @param <T> the type of the input to the operation]]>
    </doc>
  </interface>
  <!-- end interface org.bukkit.util.Consumer -->
  <!-- start class org.bukkit.util.EulerAngle -->
  <class name="EulerAngle" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EulerAngle" type="double, double, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a EularAngle with each axis set to the
 passed angle in radians

 @param x the angle for the x axis in radians
 @param y the angle for the y axis in radians
 @param z the angle for the z axis in radians]]>
      </doc>
    </constructor>
    <method name="getX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the angle on the x axis in radians

 @return the angle in radians]]>
      </doc>
    </method>
    <method name="getY" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the angle on the y axis in radians

 @return the angle in radians]]>
      </doc>
    </method>
    <method name="getZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the angle on the z axis in radians

 @return the angle in radians]]>
      </doc>
    </method>
    <method name="setX" return="org.bukkit.util.EulerAngle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Return a EulerAngle which is the result of changing
 the x axis to the passed angle

 @param x the angle in radians
 @return the resultant EulerAngle]]>
      </doc>
    </method>
    <method name="setY" return="org.bukkit.util.EulerAngle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="y" type="double"/>
      <doc>
      <![CDATA[Return a EulerAngle which is the result of changing
 the y axis to the passed angle

 @param y the angle in radians
 @return the resultant EulerAngle]]>
      </doc>
    </method>
    <method name="setZ" return="org.bukkit.util.EulerAngle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Return a EulerAngle which is the result of changing
 the z axis to the passed angle

 @param z the angle in radians
 @return the resultant EulerAngle]]>
      </doc>
    </method>
    <method name="add" return="org.bukkit.util.EulerAngle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Creates a new EulerAngle which is the result of adding
 the x, y, z components to this EulerAngle

 @param x the angle to add to the x axis in radians
 @param y the angle to add to the y axis in radians
 @param z the angle to add to the z axis in radians
 @return the resultant EulerAngle]]>
      </doc>
    </method>
    <method name="subtract" return="org.bukkit.util.EulerAngle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Creates a new EulerAngle which is the result of subtracting
 the x, y, z components to this EulerAngle

 @param x the angle to subtract to the x axis in radians
 @param y the angle to subtract to the y axis in radians
 @param z the angle to subtract to the z axis in radians
 @return the resultant EulerAngle]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="ZERO" type="org.bukkit.util.EulerAngle"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A EulerAngle with every axis set to 0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[EulerAngle is used to represent 3 angles, one for each
 axis (x, y, z). The angles are in radians]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.EulerAngle -->
  <!-- start class org.bukkit.util.FileUtil -->
  <class name="FileUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="java.io.File"/>
      <param name="outFile" type="java.io.File"/>
      <doc>
      <![CDATA[This method copies one file to another location

 @param inFile the source filename
 @param outFile the target filename
 @return true on success]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Class containing file utilities]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.FileUtil -->
  <!-- start class org.bukkit.util.NumberConversions -->
  <class name="NumberConversions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="floor" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="num" type="double"/>
    </method>
    <method name="ceil" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="num" type="double"/>
    </method>
    <method name="round" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="num" type="double"/>
    </method>
    <method name="square" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="num" type="double"/>
    </method>
    <method name="toInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="isFinite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
    </method>
    <method name="isFinite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
    </method>
    <method name="checkFinite"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="message" type="java.lang.String"/>
    </method>
    <method name="checkFinite"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="float"/>
      <param name="message" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Utils for casting number types to other number types]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.NumberConversions -->
  <!-- start class org.bukkit.util.RayTraceResult -->
  <class name="RayTraceResult" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RayTraceResult" type="org.bukkit.util.Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a RayTraceResult.

 @param hitPosition the hit position]]>
      </doc>
    </constructor>
    <constructor name="RayTraceResult" type="org.bukkit.util.Vector, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a RayTraceResult.

 @param hitPosition the hit position
 @param hitBlockFace the hit block face]]>
      </doc>
    </constructor>
    <constructor name="RayTraceResult" type="org.bukkit.util.Vector, org.bukkit.block.Block, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a RayTraceResult.

 @param hitPosition the hit position
 @param hitBlock the hit block
 @param hitBlockFace the hit block face]]>
      </doc>
    </constructor>
    <constructor name="RayTraceResult" type="org.bukkit.util.Vector, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a RayTraceResult.

 @param hitPosition the hit position
 @param hitEntity the hit entity]]>
      </doc>
    </constructor>
    <constructor name="RayTraceResult" type="org.bukkit.util.Vector, org.bukkit.entity.Entity, org.bukkit.block.BlockFace"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a RayTraceResult.

 @param hitPosition the hit position
 @param hitEntity the hit entity
 @param hitBlockFace the hit block face]]>
      </doc>
    </constructor>
    <method name="getHitPosition" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the exact position of the hit.

 @return a copy of the exact hit position]]>
      </doc>
    </method>
    <method name="getHitBlock" return="org.bukkit.block.Block"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the hit block.

 @return the hit block, or <code>null</code> if not available]]>
      </doc>
    </method>
    <method name="getHitBlockFace" return="org.bukkit.block.BlockFace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the hit block face.

 @return the hit block face, or <code>null</code> if not available]]>
      </doc>
    </method>
    <method name="getHitEntity" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the hit entity.

 @return the hit entity, or <code>null</code> if not available]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The hit result of a ray trace.
 <p>
 Only the hit position is guaranteed to always be available. The availability
 of the other attributes depends on what got hit and on the context in which
 the ray trace was performed.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.RayTraceResult -->
  <!-- start class org.bukkit.util.StringUtil -->
  <class name="StringUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StringUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="copyPartialMatches" return="T extends java.util.Collection&lt;? super java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="java.lang.String"/>
      <param name="originals" type="java.lang.Iterable&lt;java.lang.String&gt;"/>
      <param name="collection" type="T extends java.util.Collection&lt;? super java.lang.String&gt;"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Copies all elements from the iterable collection of originals to the
 collection provided.

 @param <T> the collection of strings
 @param token String to search for
 @param originals An iterable collection of strings to filter.
 @param collection The collection to add matches to
 @return the collection provided that would have the elements copied
     into
 @throws UnsupportedOperationException if the collection is immutable
     and originals contains a string which starts with the specified
     search string.
 @throws IllegalArgumentException if any parameter is is null
 @throws IllegalArgumentException if originals contains a null element.
     <b>Note: the collection may be modified before this is thrown</b>]]>
      </doc>
    </method>
    <method name="startsWithIgnoreCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="NullPointerException" type="java.lang.NullPointerException"/>
      <doc>
      <![CDATA[This method uses a region to check case-insensitive equality. This
 means the internal array does not need to be copied like a
 toLowerCase() call would.

 @param string String to check
 @param prefix Prefix of string to compare
 @return true if provided string starts with, ignoring case, the prefix
     provided
 @throws NullPointerException if prefix is null
 @throws IllegalArgumentException if string is null]]>
      </doc>
    </method>
  </class>
  <!-- end class org.bukkit.util.StringUtil -->
  <!-- start class org.bukkit.util.Vector -->
  <class name="Vector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <implements name="org.bukkit.configuration.serialization.ConfigurationSerializable"/>
    <constructor name="Vector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with all components as 0.]]>
      </doc>
    </constructor>
    <constructor name="Vector" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with provided integer components.

 @param x X component
 @param y Y component
 @param z Z component]]>
      </doc>
    </constructor>
    <constructor name="Vector" type="double, double, double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with provided double components.

 @param x X component
 @param y Y component
 @param z Z component]]>
      </doc>
    </constructor>
    <constructor name="Vector" type="float, float, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the vector with provided float components.

 @param x X component
 @param y Y component
 @param z Z component]]>
      </doc>
    </constructor>
    <method name="add" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Adds a vector to this one

 @param vec The other vector
 @return the same vector]]>
      </doc>
    </method>
    <method name="subtract" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Subtracts a vector from this one.

 @param vec The other vector
 @return the same vector]]>
      </doc>
    </method>
    <method name="multiply" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Multiplies the vector by another.

 @param vec The other vector
 @return the same vector]]>
      </doc>
    </method>
    <method name="divide" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Divides the vector by another.

 @param vec The other vector
 @return the same vector]]>
      </doc>
    </method>
    <method name="copy" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vec" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Copies another vector

 @param vec The other vector
 @return the same vector]]>
      </doc>
    </method>
    <method name="length" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the magnitude of the vector, defined as sqrt(x^2+y^2+z^2). The
 value of this method is not cached and uses a costly square-root
 function, so do not repeatedly call this method to get the vector's
 magnitude. NaN will be returned if the inner result of the sqrt()
 function overflows, which will be caused if the length is too long.

 @return the magnitude]]>
      </doc>
    </method>
    <method name="lengthSquared" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the magnitude of the vector squared.

 @return the magnitude]]>
      </doc>
    </method>
    <method name="distance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Get the distance between this vector and another. The value of this
 method is not cached and uses a costly square-root function, so do not
 repeatedly call this method to get the vector's magnitude. NaN will be
 returned if the inner result of the sqrt() function overflows, which
 will be caused if the distance is too long.

 @param o The other vector
 @return the distance]]>
      </doc>
    </method>
    <method name="distanceSquared" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Get the squared distance between this vector and another.

 @param o The other vector
 @return the distance]]>
      </doc>
    </method>
    <method name="angle" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Gets the angle between this vector and another in radians.

 @param other The other vector
 @return angle in radians]]>
      </doc>
    </method>
    <method name="midpoint" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Sets this vector to the midpoint between this vector and another.

 @param other The other vector
 @return this same vector (now a midpoint)]]>
      </doc>
    </method>
    <method name="getMidpoint" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Gets a new midpoint vector between this vector and another.

 @param other The other vector
 @return a new midpoint vector]]>
      </doc>
    </method>
    <method name="multiply" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="int"/>
      <doc>
      <![CDATA[Performs scalar multiplication, multiplying all components with a
 scalar.

 @param m The factor
 @return the same vector]]>
      </doc>
    </method>
    <method name="multiply" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="double"/>
      <doc>
      <![CDATA[Performs scalar multiplication, multiplying all components with a
 scalar.

 @param m The factor
 @return the same vector]]>
      </doc>
    </method>
    <method name="multiply" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="float"/>
      <doc>
      <![CDATA[Performs scalar multiplication, multiplying all components with a
 scalar.

 @param m The factor
 @return the same vector]]>
      </doc>
    </method>
    <method name="dot" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Calculates the dot product of this vector with another. The dot product
 is defined as x1*x2+y1*y2+z1*z2. The returned value is a scalar.

 @param other The other vector
 @return dot product]]>
      </doc>
    </method>
    <method name="crossProduct" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Calculates the cross product of this vector with another. The cross
 product is defined as:
 <ul>
 <li>x = y1 * z2 - y2 * z1
 <li>y = z1 * x2 - z2 * x1
 <li>z = x1 * y2 - x2 * y1
 </ul>

 @param o The other vector
 @return the same vector]]>
      </doc>
    </method>
    <method name="getCrossProduct" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Calculates the cross product of this vector with another without mutating
 the original. The cross product is defined as:
 <ul>
 <li>x = y1 * z2 - y2 * z1
 <li>y = z1 * x2 - z2 * x1
 <li>z = x1 * y2 - x2 * y1
 </ul>

 @param o The other vector
 @return a new vector]]>
      </doc>
    </method>
    <method name="normalize" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Converts this vector to a unit vector (a vector with length of 1).

 @return the same vector]]>
      </doc>
    </method>
    <method name="zero" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Zero this vector's components.

 @return the same vector]]>
      </doc>
    </method>
    <method name="isInAABB" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="min" type="org.bukkit.util.Vector"/>
      <param name="max" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Returns whether this vector is in an axis-aligned bounding box.
 <p>
 The minimum and maximum vectors given must be truly the minimum and
 maximum X, Y and Z components.

 @param min Minimum vector
 @param max Maximum vector
 @return whether this vector is in the AABB]]>
      </doc>
    </method>
    <method name="isInSphere" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="origin" type="org.bukkit.util.Vector"/>
      <param name="radius" type="double"/>
      <doc>
      <![CDATA[Returns whether this vector is within a sphere.

 @param origin Sphere origin.
 @param radius Sphere radius
 @return whether this vector is in the sphere]]>
      </doc>
    </method>
    <method name="isNormalized" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if a vector is normalized

 @return whether the vector is normalised]]>
      </doc>
    </method>
    <method name="rotateAroundX" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="angle" type="double"/>
      <doc>
      <![CDATA[Rotates the vector around the x axis.
 <p>
 This piece of math is based on the standard rotation matrix for vectors
 in three dimensional space. This matrix can be found here:
 <a href="https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations">Rotation
 Matrix</a>.

 @param angle the angle to rotate the vector about. This angle is passed
 in radians
 @return the same vector]]>
      </doc>
    </method>
    <method name="rotateAroundY" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="angle" type="double"/>
      <doc>
      <![CDATA[Rotates the vector around the y axis.
 <p>
 This piece of math is based on the standard rotation matrix for vectors
 in three dimensional space. This matrix can be found here:
 <a href="https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations">Rotation
 Matrix</a>.

 @param angle the angle to rotate the vector about. This angle is passed
 in radians
 @return the same vector]]>
      </doc>
    </method>
    <method name="rotateAroundZ" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="angle" type="double"/>
      <doc>
      <![CDATA[Rotates the vector around the z axis
 <p>
 This piece of math is based on the standard rotation matrix for vectors
 in three dimensional space. This matrix can be found here:
 <a href="https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations">Rotation
 Matrix</a>.

 @param angle the angle to rotate the vector about. This angle is passed
 in radians
 @return the same vector]]>
      </doc>
    </method>
    <method name="rotateAroundAxis" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="axis" type="org.bukkit.util.Vector"/>
      <param name="angle" type="double"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Rotates the vector around a given arbitrary axis in 3 dimensional space.

 <p>
 Rotation will follow the general Right-Hand-Rule, which means rotation
 will be counterclockwise when the axis is pointing towards the observer.
 <p>
 This method will always make sure the provided axis is a unit vector, to
 not modify the length of the vector when rotating. If you are experienced
 with the scaling of a non-unit axis vector, you can use
 {@link Vector#rotateAroundNonUnitAxis(Vector, double)}.

 @param axis the axis to rotate the vector around. If the passed vector is
 not of length 1, it gets copied and normalized before using it for the
 rotation. Please use {@link Vector#normalize()} on the instance before
 passing it to this method
 @param angle the angle to rotate the vector around the axis
 @return the same vector
 @throws IllegalArgumentException if the provided axis vector instance is
 null]]>
      </doc>
    </method>
    <method name="rotateAroundNonUnitAxis" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="axis" type="org.bukkit.util.Vector"/>
      <param name="angle" type="double"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Rotates the vector around a given arbitrary axis in 3 dimensional space.

 <p>
 Rotation will follow the general Right-Hand-Rule, which means rotation
 will be counterclockwise when the axis is pointing towards the observer.
 <p>
 Note that the vector length will change accordingly to the axis vector
 length. If the provided axis is not a unit vector, the rotated vector
 will not have its previous length. The scaled length of the resulting
 vector will be related to the axis vector. If you are not perfectly sure
 about the scaling of the vector, use
 {@link Vector#rotateAroundAxis(Vector, double)}

 @param axis the axis to rotate the vector around.
 @param angle the angle to rotate the vector around the axis
 @return the same vector
 @throws IllegalArgumentException if the provided axis vector instance is
 null]]>
      </doc>
    </method>
    <method name="getX" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the X component.

 @return The X component.]]>
      </doc>
    </method>
    <method name="getBlockX" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the floored value of the X component, indicating the block that
 this vector is contained with.

 @return block X]]>
      </doc>
    </method>
    <method name="getY" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Y component.

 @return The Y component.]]>
      </doc>
    </method>
    <method name="getBlockY" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the floored value of the Y component, indicating the block that
 this vector is contained with.

 @return block y]]>
      </doc>
    </method>
    <method name="getZ" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Z component.

 @return The Z component.]]>
      </doc>
    </method>
    <method name="getBlockZ" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the floored value of the Z component, indicating the block that
 this vector is contained with.

 @return block z]]>
      </doc>
    </method>
    <method name="setX" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Set the X component.

 @param x The new X component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="setX" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Set the X component.

 @param x The new X component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="setX" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="float"/>
      <doc>
      <![CDATA[Set the X component.

 @param x The new X component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="setY" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="y" type="int"/>
      <doc>
      <![CDATA[Set the Y component.

 @param y The new Y component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="setY" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="y" type="double"/>
      <doc>
      <![CDATA[Set the Y component.

 @param y The new Y component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="setY" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="y" type="float"/>
      <doc>
      <![CDATA[Set the Y component.

 @param y The new Y component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="setZ" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="z" type="int"/>
      <doc>
      <![CDATA[Set the Z component.

 @param z The new Z component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="setZ" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Set the Z component.

 @param z The new Z component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="setZ" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="z" type="float"/>
      <doc>
      <![CDATA[Set the Z component.

 @param z The new Z component.
 @return This vector.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Checks to see if two objects are equal.
 <p>
 Only two Vectors can ever return true. This method uses a fuzzy match
 to account for floating point errors. The epsilon can be retrieved
 with epsilon.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code for this vector

 @return hash code]]>
      </doc>
    </method>
    <method name="clone" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a new vector.

 @return vector]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this vector's components as x,y,z.]]>
      </doc>
    </method>
    <method name="toLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <doc>
      <![CDATA[Gets a Location version of this vector with yaw and pitch being 0.

 @param world The world to link the location to.
 @return the location]]>
      </doc>
    </method>
    <method name="toLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="world" type="org.bukkit.World"/>
      <param name="yaw" type="float"/>
      <param name="pitch" type="float"/>
      <doc>
      <![CDATA[Gets a Location version of this vector.

 @param world The world to link the location to.
 @param yaw The desired yaw.
 @param pitch The desired pitch.
 @return the location]]>
      </doc>
    </method>
    <method name="toBlockVector" return="org.bukkit.util.BlockVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the block vector of this vector.

 @return A block vector.]]>
      </doc>
    </method>
    <method name="checkFinite"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Check if each component of this Vector is finite.

 @throws IllegalArgumentException if any component is not finite]]>
      </doc>
    </method>
    <method name="getEpsilon" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the threshold used for equals().

 @return The epsilon.]]>
      </doc>
    </method>
    <method name="getMinimum" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v1" type="org.bukkit.util.Vector"/>
      <param name="v2" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Gets the minimum components of two vectors.

 @param v1 The first vector.
 @param v2 The second vector.
 @return minimum]]>
      </doc>
    </method>
    <method name="getMaximum" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v1" type="org.bukkit.util.Vector"/>
      <param name="v2" type="org.bukkit.util.Vector"/>
      <doc>
      <![CDATA[Gets the maximum components of two vectors.

 @param v1 The first vector.
 @param v2 The second vector.
 @return maximum]]>
      </doc>
    </method>
    <method name="getRandom" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a random vector with components having a random value between 0
 and 1.

 @return A random vector.]]>
      </doc>
    </method>
    <method name="serialize" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="deserialize" return="org.bukkit.util.Vector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <field name="x" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="y" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="z" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents a mutable vector. Because the components of Vectors are mutable,
 storing Vectors long term may be dangerous if passing code modifies the
 Vector later. If you want to keep around a Vector, it may be wise to call
 <code>clone()</code> in order to get a copy.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.Vector -->
</package>
<package name="org.bukkit.util.io">
  <!-- start class org.bukkit.util.io.BukkitObjectInputStream -->
  <class name="BukkitObjectInputStream" extends="java.io.ObjectInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BukkitObjectInputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SecurityException" type="java.lang.SecurityException"/>
      <doc>
      <![CDATA[Constructor provided to mirror super functionality.

 @throws IOException if an I/O error occurs while creating this stream
 @throws SecurityException if a security manager exists and denies
 enabling subclassing
 @see ObjectInputStream#ObjectInputStream()]]>
      </doc>
    </constructor>
    <constructor name="BukkitObjectInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Object input stream decoration constructor.

 @param in the input stream to wrap
 @throws IOException if an I/O error occurs while reading stream header
 @see ObjectInputStream#ObjectInputStream(InputStream)]]>
      </doc>
    </constructor>
    <method name="resolveObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This class is designed to be used in conjunction with the {@link
 ConfigurationSerializable} API. It translates objects back to their
 original implementation after being serialized by {@link
 BukkitObjectInputStream}.
 <p>
 Behavior of implementations extending this class is not guaranteed across
 future versions.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.io.BukkitObjectInputStream -->
  <!-- start class org.bukkit.util.io.BukkitObjectOutputStream -->
  <class name="BukkitObjectOutputStream" extends="java.io.ObjectOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BukkitObjectOutputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SecurityException" type="java.lang.SecurityException"/>
      <doc>
      <![CDATA[Constructor provided to mirror super functionality.

 @throws IOException if an I/O error occurs while creating this stream
 @throws SecurityException if a security manager exists and denies
 enabling subclassing
 @see ObjectOutputStream#ObjectOutputStream()]]>
      </doc>
    </constructor>
    <constructor name="BukkitObjectOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Object output stream decoration constructor.

 @param out the stream to wrap
 @throws IOException if an I/O error occurs while writing stream header
 @see ObjectOutputStream#ObjectOutputStream(OutputStream)]]>
      </doc>
    </constructor>
    <method name="replaceObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This class is designed to be used in conjunction with the {@link
 ConfigurationSerializable} API. It translates objects to an internal
 implementation for later deserialization using {@link
 BukkitObjectInputStream}.
 <p>
 Behavior of implementations extending this class is not guaranteed across
 future versions.]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.io.BukkitObjectOutputStream -->
</package>
<package name="org.bukkit.util.noise">
  <!-- start class org.bukkit.util.noise.NoiseGenerator -->
  <class name="NoiseGenerator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoiseGenerator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="floor" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Speedy floor, faster than (int)Math.floor(x)

 @param x Value to floor
 @return Floored value]]>
      </doc>
    </method>
    <method name="fade" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="x" type="double"/>
    </method>
    <method name="lerp" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
    </method>
    <method name="grad" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="hash" type="int"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 1D noise for the given coordinate in 1D space

 @param x X coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 2D noise for the given coordinates in 2D space

 @param x X coordinate
 @param y Y coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 3D noise for the given coordinates in 3D space

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 1D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <param name="normalized" type="boolean"/>
      <doc>
      <![CDATA[Generates noise for the 1D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @param normalized If true, normalize the value to [-1, 1]
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 2D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <param name="normalized" type="boolean"/>
      <doc>
      <![CDATA[Generates noise for the 2D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @param normalized If true, normalize the value to [-1, 1]
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 3D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param z Z-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <param name="normalized" type="boolean"/>
      <doc>
      <![CDATA[Generates noise for the 3D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param z Z-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @param normalized If true, normalize the value to [-1, 1]
 @return Resulting noise]]>
      </doc>
    </method>
    <field name="perm" type="int[]"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="offsetX" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="offsetY" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="offsetZ" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Base class for all noise generators]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.noise.NoiseGenerator -->
  <!-- start class org.bukkit.util.noise.OctaveGenerator -->
  <class name="OctaveGenerator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OctaveGenerator" type="org.bukkit.util.noise.NoiseGenerator[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="setScale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="double"/>
      <doc>
      <![CDATA[Sets the scale used for all coordinates passed to this generator.
 <p>
 This is the equivalent to setting each coordinate to the specified
 value.

 @param scale New value to scale each coordinate by]]>
      </doc>
    </method>
    <method name="getXScale" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the scale used for each X-coordinates passed

 @return X scale]]>
      </doc>
    </method>
    <method name="setXScale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="double"/>
      <doc>
      <![CDATA[Sets the scale used for each X-coordinates passed

 @param scale New X scale]]>
      </doc>
    </method>
    <method name="getYScale" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the scale used for each Y-coordinates passed

 @return Y scale]]>
      </doc>
    </method>
    <method name="setYScale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="double"/>
      <doc>
      <![CDATA[Sets the scale used for each Y-coordinates passed

 @param scale New Y scale]]>
      </doc>
    </method>
    <method name="getZScale" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the scale used for each Z-coordinates passed

 @return Z scale]]>
      </doc>
    </method>
    <method name="setZScale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="double"/>
      <doc>
      <![CDATA[Sets the scale used for each Z-coordinates passed

 @param scale New Z scale]]>
      </doc>
    </method>
    <method name="getOctaves" return="org.bukkit.util.noise.NoiseGenerator[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a clone of the individual octaves used within this generator

 @return Clone of the individual octaves]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 1D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <param name="normalized" type="boolean"/>
      <doc>
      <![CDATA[Generates noise for the 1D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @param normalized If true, normalize the value to [-1, 1]
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 2D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <param name="normalized" type="boolean"/>
      <doc>
      <![CDATA[Generates noise for the 2D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @param normalized If true, normalize the value to [-1, 1]
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 3D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param z Z-coordinate
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <param name="normalized" type="boolean"/>
      <doc>
      <![CDATA[Generates noise for the 3D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param z Z-coordinate
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @param normalized If true, normalize the value to [-1, 1]
 @return Resulting noise]]>
      </doc>
    </method>
    <field name="octaves" type="org.bukkit.util.noise.NoiseGenerator[]"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="xScale" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="yScale" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="zScale" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Creates noise using unbiased octaves]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.noise.OctaveGenerator -->
  <!-- start class org.bukkit.util.noise.PerlinNoiseGenerator -->
  <class name="PerlinNoiseGenerator" extends="org.bukkit.util.noise.NoiseGenerator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PerlinNoiseGenerator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PerlinNoiseGenerator" type="org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a seeded perlin noise generator for the given world

 @param world World to construct this generator for]]>
      </doc>
    </constructor>
    <constructor name="PerlinNoiseGenerator" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a seeded perlin noise generator for the given seed

 @param seed Seed to construct this generator for]]>
      </doc>
    </constructor>
    <constructor name="PerlinNoiseGenerator" type="java.util.Random"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a seeded perlin noise generator with the given Random

 @param rand Random to construct with]]>
      </doc>
    </constructor>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 1D unseeded perlin noise for the given
 coordinates in 1D space

 @param x X coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 2D unseeded perlin noise for the given
 coordinates in 2D space

 @param x X coordinate
 @param y Y coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 3D unseeded perlin noise for the given
 coordinates in 3D space

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="getInstance" return="org.bukkit.util.noise.PerlinNoiseGenerator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the singleton unseeded instance of this generator

 @return Singleton]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 1D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 2D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="octaves" type="int"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 3D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param z Z-coordinate
 @param octaves Number of octaves to use
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <field name="grad3" type="int[][]"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Generates noise using the "classic" perlin generator

 @see SimplexNoiseGenerator "Improved" and faster version with slightly
     different results]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.noise.PerlinNoiseGenerator -->
  <!-- start class org.bukkit.util.noise.PerlinOctaveGenerator -->
  <class name="PerlinOctaveGenerator" extends="org.bukkit.util.noise.OctaveGenerator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PerlinOctaveGenerator" type="org.bukkit.World, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a perlin octave generator for the given world

 @param world World to construct this generator for
 @param octaves Amount of octaves to create]]>
      </doc>
    </constructor>
    <constructor name="PerlinOctaveGenerator" type="long, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a perlin octave generator for the given world

 @param seed Seed to construct this generator for
 @param octaves Amount of octaves to create]]>
      </doc>
    </constructor>
    <constructor name="PerlinOctaveGenerator" type="java.util.Random, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a perlin octave generator for the given {@link Random}

 @param rand Random object to construct this generator for
 @param octaves Amount of octaves to create]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Creates perlin noise through unbiased octaves]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.noise.PerlinOctaveGenerator -->
  <!-- start class org.bukkit.util.noise.SimplexNoiseGenerator -->
  <class name="SimplexNoiseGenerator" extends="org.bukkit.util.noise.PerlinNoiseGenerator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimplexNoiseGenerator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimplexNoiseGenerator" type="org.bukkit.World"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a seeded simplex noise generator for the given world

 @param world World to construct this generator for]]>
      </doc>
    </constructor>
    <constructor name="SimplexNoiseGenerator" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a seeded simplex noise generator for the given seed

 @param seed Seed to construct this generator for]]>
      </doc>
    </constructor>
    <constructor name="SimplexNoiseGenerator" type="java.util.Random"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a seeded simplex noise generator with the given Random

 @param rand Random to construct with]]>
      </doc>
    </constructor>
    <method name="dot" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="g" type="int[]"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
    </method>
    <method name="dot" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="g" type="int[]"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
    </method>
    <method name="dot" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="g" type="int[]"/>
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="w" type="double"/>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xin" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 1D unseeded simplex noise for the given
 coordinates in 1D space

 @param xin X coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xin" type="double"/>
      <param name="yin" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 2D unseeded simplex noise for the given
 coordinates in 2D space

 @param xin X coordinate
 @param yin Y coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xin" type="double"/>
      <param name="yin" type="double"/>
      <param name="zin" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 3D unseeded simplex noise for the given
 coordinates in 3D space

 @param xin X coordinate
 @param yin Y coordinate
 @param zin Z coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="getNoise" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="w" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 4D simplex noise for the given coordinates in
 4D space

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @param w W coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xin" type="double"/>
      <param name="yin" type="double"/>
      <param name="zin" type="double"/>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xin" type="double"/>
      <param name="yin" type="double"/>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="w" type="double"/>
      <doc>
      <![CDATA[Computes and returns the 4D simplex noise for the given coordinates in
 4D space

 @param x X coordinate
 @param y Y coordinate
 @param z Z coordinate
 @param w W coordinate
 @return Noise at given location, from range -1 to 1]]>
      </doc>
    </method>
    <method name="getInstance" return="org.bukkit.util.noise.SimplexNoiseGenerator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the singleton unseeded instance of this generator

 @return Singleton]]>
      </doc>
    </method>
    <field name="SQRT_3" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="SQRT_5" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="F2" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="G2" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="G22" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="F3" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="G3" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="F4" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="G4" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="G42" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="G43" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="G44" type="double"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="grad4" type="int[][]"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="simplex" type="int[][]"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="offsetW" type="double"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Generates simplex-based noise.
 <p>
 This is a modified version of the freely published version in the paper by
 Stefan Gustavson at
 <a href="http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">
 http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a>]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.noise.SimplexNoiseGenerator -->
  <!-- start class org.bukkit.util.noise.SimplexOctaveGenerator -->
  <class name="SimplexOctaveGenerator" extends="org.bukkit.util.noise.OctaveGenerator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimplexOctaveGenerator" type="org.bukkit.World, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a simplex octave generator for the given world

 @param world World to construct this generator for
 @param octaves Amount of octaves to create]]>
      </doc>
    </constructor>
    <constructor name="SimplexOctaveGenerator" type="long, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a simplex octave generator for the given world

 @param seed Seed to construct this generator for
 @param octaves Amount of octaves to create]]>
      </doc>
    </constructor>
    <constructor name="SimplexOctaveGenerator" type="java.util.Random, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a simplex octave generator for the given {@link Random}

 @param rand Random object to construct this generator for
 @param octaves Amount of octaves to create]]>
      </doc>
    </constructor>
    <method name="setScale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="double"/>
    </method>
    <method name="getWScale" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the scale used for each W-coordinates passed

 @return W scale]]>
      </doc>
    </method>
    <method name="setWScale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="double"/>
      <doc>
      <![CDATA[Sets the scale used for each W-coordinates passed

 @param scale New W scale]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="w" type="double"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <doc>
      <![CDATA[Generates noise for the 3D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param z Z-coordinate
 @param w W-coordinate
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @return Resulting noise]]>
      </doc>
    </method>
    <method name="noise" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <param name="z" type="double"/>
      <param name="w" type="double"/>
      <param name="frequency" type="double"/>
      <param name="amplitude" type="double"/>
      <param name="normalized" type="boolean"/>
      <doc>
      <![CDATA[Generates noise for the 3D coordinates using the specified number of
 octaves and parameters

 @param x X-coordinate
 @param y Y-coordinate
 @param z Z-coordinate
 @param w W-coordinate
 @param frequency How much to alter the frequency by each octave
 @param amplitude How much to alter the amplitude by each octave
 @param normalized If true, normalize the value to [-1, 1]
 @return Resulting noise]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Creates simplex noise through unbiased octaves]]>
    </doc>
  </class>
  <!-- end class org.bukkit.util.noise.SimplexOctaveGenerator -->
</package>
<package name="org.bukkit.util.permissions">
  <!-- start class org.bukkit.util.permissions.BroadcastPermissions -->
  <class name="BroadcastPermissions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="registerPermissions" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="org.bukkit.permissions.Permission"/>
    </method>
  </class>
  <!-- end class org.bukkit.util.permissions.BroadcastPermissions -->
  <!-- start class org.bukkit.util.permissions.CommandPermissions -->
  <class name="CommandPermissions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="registerPermissions" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="org.bukkit.permissions.Permission"/>
    </method>
  </class>
  <!-- end class org.bukkit.util.permissions.CommandPermissions -->
  <!-- start class org.bukkit.util.permissions.DefaultPermissions -->
  <class name="DefaultPermissions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <param name="withLegacy" type="boolean"/>
    </method>
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.bukkit.permissions.Permission"/>
      <param name="parent" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
    </method>
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="parent" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="def" type="org.bukkit.permissions.PermissionDefault"/>
    </method>
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="def" type="org.bukkit.permissions.PermissionDefault"/>
      <param name="parent" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="def" type="org.bukkit.permissions.PermissionDefault"/>
      <param name="children" type="java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;"/>
    </method>
    <method name="registerPermission" return="org.bukkit.permissions.Permission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="def" type="org.bukkit.permissions.PermissionDefault"/>
      <param name="children" type="java.util.Map&lt;java.lang.String, java.lang.Boolean&gt;"/>
      <param name="parent" type="org.bukkit.permissions.Permission"/>
    </method>
    <method name="registerCorePermissions"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.bukkit.util.permissions.DefaultPermissions -->
</package>
<package name="org.spigotmc">
  <!-- start class org.spigotmc.CustomTimingsHandler -->
  <class name="CustomTimingsHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="deprecated, no comment">
    <constructor name="CustomTimingsHandler" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startTiming"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopTiming"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is here for legacy purposes incase any plugin used it.

 If you use this, migrate ASAP as this will be removed in the future!

 @deprecated
 @see co.aikar.timings.Timings#of]]>
    </doc>
  </class>
  <!-- end class org.spigotmc.CustomTimingsHandler -->
</package>
<package name="org.spigotmc.event.entity">
  <!-- start class org.spigotmc.event.entity.EntityDismountEvent -->
  <class name="EntityDismountEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityDismountEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="EntityDismountEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDismounted" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="isCancellable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity stops riding another entity.]]>
    </doc>
  </class>
  <!-- end class org.spigotmc.event.entity.EntityDismountEvent -->
  <!-- start class org.spigotmc.event.entity.EntityMountEvent -->
  <class name="EntityMountEvent" extends="org.bukkit.event.entity.EntityEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.bukkit.event.Cancellable"/>
    <constructor name="EntityMountEvent" type="org.bukkit.entity.Entity, org.bukkit.entity.Entity"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMount" return="org.bukkit.entity.Entity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCancelled"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cancel" type="boolean"/>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when an entity attempts to ride another entity.]]>
    </doc>
  </class>
  <!-- end class org.spigotmc.event.entity.EntityMountEvent -->
</package>
<package name="org.spigotmc.event.player">
  <!-- start class org.spigotmc.event.player.PlayerSpawnLocationEvent -->
  <class name="PlayerSpawnLocationEvent" extends="org.bukkit.event.player.PlayerEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlayerSpawnLocationEvent" type="org.bukkit.entity.Player, org.bukkit.Location"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSpawnLocation" return="org.bukkit.Location"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets player's spawn location.
 If the player {@link Player#hasPlayedBefore()}, it's going to default to the location inside player.dat file.
 For new players, the default spawn location is spawn of the main Bukkit world.

 @return the spawn location]]>
      </doc>
    </method>
    <method name="setSpawnLocation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="org.bukkit.Location"/>
      <doc>
      <![CDATA[Sets player's spawn location.

 @param location the spawn location]]>
      </doc>
    </method>
    <method name="getHandlers" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHandlerList" return="org.bukkit.event.HandlerList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Called when player is about to spawn in a world after joining the server.]]>
    </doc>
  </class>
  <!-- end class org.spigotmc.event.player.PlayerSpawnLocationEvent -->
</package>

</api>
